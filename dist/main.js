/*
* to include js file write: `//= include ./path-to-file`
* */

/*! jQuery v3.6.1 | (c) OpenJS Foundation and other contributors | jquery.org/license */

!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,y=n.hasOwnProperty,a=y.toString,l=a.call(Object),v={},m=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType&&"function"!=typeof e.item},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement("script");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[o.call(e)]||"object":typeof e}var f="3.6.1",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&"length"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}S.fn=S.prototype={jquery:f,constructor:S,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=S.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return S.each(this,e)},map:function(n){return this.pushStack(S.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(S.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(S.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},S.extend=S.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(S.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||S.isPlainObject(n)?n:{},i=!1,a[t]=S.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},S.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==o.call(e))&&(!(t=r(e))||"function"==typeof(n=y.call(t,"constructor")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){b(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(p(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},makeArray:function(e,t){var n=t||[];return null!=e&&(p(Object(e))?S.merge(n,"string"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(p(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:v}),"function"==typeof Symbol&&(S.fn[Symbol.iterator]=t[Symbol.iterator]),S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var d=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,y,s,c,v,S="sizzle"+1*new Date,p=n.document,k=0,r=0,m=ue(),x=ue(),A=ue(),N=ue(),j=function(e,t){return e===t&&(l=!0),0},D={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",I="(?:\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",W="\\["+M+"*("+I+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+I+"))|)"+M+"*\\]",F=":("+I+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+W+")*)|.*)\\)|)",$=new RegExp(M+"+","g"),B=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),_=new RegExp("^"+M+"*,"+M+"*"),z=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp(M+"|>"),X=new RegExp(F),V=new RegExp("^"+I+"$"),G={ID:new RegExp("^#("+I+")"),CLASS:new RegExp("^\\.("+I+")"),TAG:new RegExp("^("+I+"|[*])"),ATTR:new RegExp("^"+W),PSEUDO:new RegExp("^"+F),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+R+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/HTML$/i,Q=/^(?:input|select|textarea|button)$/i,J=/^h\d$/i,K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\([^\\r\\n\\f])","g"),ne=function(e,t){var n="0x"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{H.apply(t=O.call(p.childNodes),p.childNodes),t[p.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&v(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!N[t+" "]&&(!y||!y.test(t))&&(1!==p||"object"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&(U.test(t)||z.test(t))){(f=ee.test(t)&&ve(e.parentNode)||e)===e&&d.scope||((s=e.getAttribute("id"))?s=s.replace(re,ie):e.setAttribute("id",s=S)),o=(l=h(t)).length;while(o--)l[o]=(s?"#"+s:":scope")+" "+xe(l[o]);c=l.join(",")}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){N(t,!0)}finally{s===S&&e.removeAttribute("id")}}}return g(t.replace(B,"$1"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function le(e){return e[S]=!0,e}function ce(e){var t=C.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split("|"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return"input"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return("input"===t||"button"===t)&&e.type===n}}function ge(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function ye(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ve(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e&&e.namespaceURI,n=e&&(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||"HTML")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:p;return r!=C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),p!=C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",oe,!1):n.attachEvent&&n.attachEvent("onunload",oe)),d.scope=ce(function(e){return a.appendChild(e).appendChild(C.createElement("div")),"undefined"!=typeof e.querySelectorAll&&!e.querySelectorAll(":scope fieldset div").length}),d.attributes=ce(function(e){return e.className="i",!e.getAttribute("className")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment("")),!e.getElementsByTagName("*").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=S,!C.getElementsByName||!C.getElementsByName(S).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],y=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){var t;a.appendChild(e).innerHTML="<a id='"+S+"'></a><select id='"+S+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&y.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||y.push("\\["+M+"*(?:value|"+R+")"),e.querySelectorAll("[id~="+S+"-]").length||y.push("~="),(t=C.createElement("input")).setAttribute("name",""),e.appendChild(t),e.querySelectorAll("[name='']").length||y.push("\\["+M+"*name"+M+"*="+M+"*(?:''|\"\")"),e.querySelectorAll(":checked").length||y.push(":checked"),e.querySelectorAll("a#"+S+"+*").length||y.push(".#.+[+~]"),e.querySelectorAll("\\\f"),y.push("[\\r\\n\\f]")}),ce(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=C.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&y.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&y.push(":enabled",":disabled"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&y.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),y.push(",.*:")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,"*"),c.call(e,"[s!='']:x"),s.push("!=",F)}),y=y.length&&new RegExp(y.join("|")),s=s.length&&new RegExp(s.join("|")),t=K.test(a.compareDocumentPosition),v=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},j=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e==C||e.ownerDocument==p&&v(p,e)?-1:t==C||t.ownerDocument==p&&v(p,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e==C?-1:t==C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]==p?-1:s[r]==p?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if(T(e),d.matchesSelector&&E&&!N[t+" "]&&(!s||!s.test(t))&&(!y||!y.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){N(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!=C&&T(e),v(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!=C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&D.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+"").replace(re,ie)},se.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(j),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=m[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&m(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace($," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(h,e,t,g,y){var v="nth"!==h.slice(0,3),m="last"!==h.slice(-4),x="of-type"===e;return 1===g&&0===y?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=v!==m?"nextSibling":"previousSibling",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(v){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l="only"===h&&!u&&"nextSibling"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[k,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[k,d]),a===e))break;return(d-=y)===g||d%g==0&&0<=d/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error("unsupported pseudo: "+e);return a[S]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace(B,"$1"));return s[S]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||"")||se.error("unsupported lang: "+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:ye(function(){return[0]}),last:ye(function(e,t){return[t-1]}),eq:ye(function(e,t,n){return[n<0?n+t:n]}),even:ye(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ye(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ye(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ye(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&"parentNode"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[k,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[S]||(e[S]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===k&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,y,v,e){return y&&!y[S]&&(y=Ce(y)),v&&!v[S]&&(v=Ce(v,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?v||(e?d:l||y)?[]:t:f;if(g&&g(f,p,n,r),y){i=Te(p,u),y(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(v||d){if(v){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);v(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=v?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),v?v(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace(B,"$1"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace(B," ")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,y,v,m,x,r,i=[],o=[],a=A[e+" "];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[S]?i.push(a):o.push(a);(a=A(e,(y=o,m=0<(v=i).length,x=0<y.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=k+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==C||(T(o),n=!E);while(s=y[a++])if(s(o,t||C,n)){r.push(o);break}i&&(k=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=v[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+v.length&&se.uniqueSort(r)}return i&&(k=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ve(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ve(t.parentNode)||t),n},d.sortStable=S.split("").sort(j).join("")===S,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement("fieldset"))}),ce(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||fe("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||fe("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute("disabled")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);S.find=d,S.expr=d.selectors,S.expr[":"]=S.expr.pseudos,S.uniqueSort=S.unique=d.uniqueSort,S.text=d.getText,S.isXMLDoc=d.isXML,S.contains=d.contains,S.escapeSelector=d.escape;var h=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&S(e).is(n))break;r.push(e)}return r},T=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},k=S.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var N=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function j(e,n,r){return m(n)?S.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?S.grep(e,function(e){return e===n!==r}):"string"!=typeof n?S.grep(e,function(e){return-1<i.call(n,e)!==r}):S.filter(n,e,r)}S.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?S.find.matchesSelector(r,e)?[r]:[]:S.find.matches(e,S.grep(t,function(e){return 1===e.nodeType}))},S.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(S(e).filter(function(){for(t=0;t<r;t++)if(S.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)S.find(e,i[t],n);return 1<r?S.uniqueSort(n):n},filter:function(e){return this.pushStack(j(this,e||[],!1))},not:function(e){return this.pushStack(j(this,e||[],!0))},is:function(e){return!!j(this,"string"==typeof e&&k.test(e)?S(e):e||[],!1).length}});var D,q=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(S.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||D,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:q.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof S?t[0]:t,S.merge(this,S.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),N.test(r[1])&&S.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(S):S.makeArray(e,this)}).prototype=S.fn,D=S(E);var L=/^(?:parents|prev(?:Until|All))/,H={children:!0,contents:!0,next:!0,prev:!0};function O(e,t){while((e=e[t])&&1!==e.nodeType);return e}S.fn.extend({has:function(e){var t=S(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(S.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&S(e);if(!k.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&S.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?S.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?i.call(S(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(S.uniqueSort(S.merge(this.get(),S(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),S.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return h(e,"parentNode")},parentsUntil:function(e,t,n){return h(e,"parentNode",n)},next:function(e){return O(e,"nextSibling")},prev:function(e){return O(e,"previousSibling")},nextAll:function(e){return h(e,"nextSibling")},prevAll:function(e){return h(e,"previousSibling")},nextUntil:function(e,t,n){return h(e,"nextSibling",n)},prevUntil:function(e,t,n){return h(e,"previousSibling",n)},siblings:function(e){return T((e.parentNode||{}).firstChild,e)},children:function(e){return T(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(A(e,"template")&&(e=e.content||e),S.merge([],e.childNodes))}},function(r,i){S.fn[r]=function(e,t){var n=S.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=S.filter(t,n)),1<this.length&&(H[r]||S.uniqueSort(n),L.test(r)&&n.reverse()),this.pushStack(n)}});var P=/[^\x20\t\r\n\f]+/g;function R(e){return e}function M(e){throw e}function I(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}S.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},S.each(e.match(P)||[],function(e,t){n[t]=!0}),n):S.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){S.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return S.each(arguments,function(e,t){var n;while(-1<(n=S.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<S.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},S.extend({Deferred:function(e){var o=[["notify","progress",S.Callbacks("memory"),S.Callbacks("memory"),2],["resolve","done",S.Callbacks("once memory"),S.Callbacks("once memory"),0,"resolved"],["reject","fail",S.Callbacks("once memory"),S.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return S.Deferred(function(r){S.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,R,s),l(u,o,M,s)):(u++,t.call(e,l(u,o,R,s),l(u,o,M,s),l(u,o,R,o.notifyWith))):(a!==R&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){S.Deferred.exceptionHook&&S.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==M&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(S.Deferred.getStackHook&&(t.stackTrace=S.Deferred.getStackHook()),C.setTimeout(t))}}return S.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:R,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:R)),o[2][3].add(l(0,e,m(n)?n:M))}).promise()},promise:function(e){return null!=e?S.extend(e,a):a}},s={};return S.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=S.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(I(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)I(i[t],a(t),o.reject);return o.promise()}});var W=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;S.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&W.test(e.name)&&C.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},S.readyException=function(e){C.setTimeout(function(){throw e})};var F=S.Deferred();function $(){E.removeEventListener("DOMContentLoaded",$),C.removeEventListener("load",$),S.ready()}S.fn.ready=function(e){return F.then(e)["catch"](function(e){S.readyException(e)}),this},S.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--S.readyWait:S.isReady)||(S.isReady=!0)!==e&&0<--S.readyWait||F.resolveWith(E,[S])}}),S.ready.then=F.then,"complete"===E.readyState||"loading"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(S.ready):(E.addEventListener("DOMContentLoaded",$),C.addEventListener("load",$));var B=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===w(n))for(s in i=!0,n)B(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(S(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},_=/^-ms-/,z=/-([a-z])/g;function U(e,t){return t.toUpperCase()}function X(e){return e.replace(_,"ms-").replace(z,U)}var V=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function G(){this.expando=S.expando+G.uid++}G.uid=1,G.prototype={cache:function(e){var t=e[this.expando];return t||(t={},V(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[X(t)]=n;else for(r in t)i[X(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][X(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(X):(t=X(t))in r?[t]:t.match(P)||[]).length;while(n--)delete r[t[n]]}(void 0===t||S.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!S.isEmptyObject(t)}};var Y=new G,Q=new G,J=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,K=/[A-Z]/g;function Z(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(K,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:J.test(i)?JSON.parse(i):i)}catch(e){}Q.set(e,t,n)}else n=void 0;return n}S.extend({hasData:function(e){return Q.hasData(e)||Y.hasData(e)},data:function(e,t,n){return Q.access(e,t,n)},removeData:function(e,t){Q.remove(e,t)},_data:function(e,t,n){return Y.access(e,t,n)},_removeData:function(e,t){Y.remove(e,t)}}),S.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=Q.get(o),1===o.nodeType&&!Y.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=X(r.slice(5)),Z(o,r,i[r]));Y.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){Q.set(this,n)}):B(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=Q.get(o,n))?t:void 0!==(t=Z(o,n))?t:void 0;this.each(function(){Q.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){Q.remove(this,e)})}}),S.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=Y.get(e,t),n&&(!r||Array.isArray(n)?r=Y.access(e,t,S.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=S.queue(e,t),r=n.length,i=n.shift(),o=S._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){S.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Y.get(e,n)||Y.access(e,n,{empty:S.Callbacks("once memory").add(function(){Y.remove(e,[t+"queue",n])})})}}),S.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?S.queue(this[0],t):void 0===n?this:this.each(function(){var e=S.queue(this,t,n);S._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&S.dequeue(this,t)})},dequeue:function(e){return this.each(function(){S.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=S.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=Y.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var ee=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,te=new RegExp("^(?:([+-])=|)("+ee+")([a-z%]*)$","i"),ne=["Top","Right","Bottom","Left"],re=E.documentElement,ie=function(e){return S.contains(e.ownerDocument,e)},oe={composed:!0};re.getRootNode&&(ie=function(e){return S.contains(e.ownerDocument,e)||e.getRootNode(oe)===e.ownerDocument});var ae=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&ie(e)&&"none"===S.css(e,"display")};function se(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return S.css(e,t,"")},u=s(),l=n&&n[3]||(S.cssNumber[t]?"":"px"),c=e.nodeType&&(S.cssNumber[t]||"px"!==l&&+u)&&te.exec(S.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)S.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,S.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ue={};function le(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=Y.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&ae(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ue[s])||(o=a.body.appendChild(a.createElement(s)),u=S.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ue[s]=u)))):"none"!==n&&(l[c]="none",Y.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}S.fn.extend({show:function(){return le(this,!0)},hide:function(){return le(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){ae(this)?S(this).show():S(this).hide()})}});var ce,fe,pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,he=/^$|^module$|\/(?:java|ecma)script/i;ce=E.createDocumentFragment().appendChild(E.createElement("div")),(fe=E.createElement("input")).setAttribute("type","radio"),fe.setAttribute("checked","checked"),fe.setAttribute("name","t"),ce.appendChild(fe),v.checkClone=ce.cloneNode(!0).cloneNode(!0).lastChild.checked,ce.innerHTML="<textarea>x</textarea>",v.noCloneChecked=!!ce.cloneNode(!0).lastChild.defaultValue,ce.innerHTML="<option></option>",v.option=!!ce.lastChild;var ge={thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function ye(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&A(e,t)?S.merge([e],n):n}function ve(e,t){for(var n=0,r=e.length;n<r;n++)Y.set(e[n],"globalEval",!t||Y.get(t[n],"globalEval"))}ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td,v.option||(ge.optgroup=ge.option=[1,"<select multiple='multiple'>","</select>"]);var me=/<|&#?\w+;/;function xe(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===w(o))S.merge(p,o.nodeType?[o]:o);else if(me.test(o)){a=a||f.appendChild(t.createElement("div")),s=(de.exec(o)||["",""])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+S.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;S.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<S.inArray(o,r))i&&i.push(o);else if(l=ie(o),a=ye(f.appendChild(o),"script"),l&&ve(a),n){c=0;while(o=a[c++])he.test(o.type||"")&&n.push(o)}return f}var be=/^([^.]*)(?:\.(.+)|)/;function we(){return!0}function Te(){return!1}function Ce(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==("focus"===t)}function Ee(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)Ee(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Te;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return S().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=S.guid++)),e.each(function(){S.event.add(this,t,i,r,n)})}function Se(e,i,o){o?(Y.set(e,i,!1),S.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Y.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(S.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Y.set(this,i,r),t=o(this,i),this[i](),r!==(n=Y.get(this,i))||t?Y.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n&&n.value}else r.length&&(Y.set(this,i,{value:S.event.trigger(S.extend(r[0],S.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Y.get(e,i)&&S.event.add(e,i,we)}S.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,y=Y.get(t);if(V(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&S.find.matchesSelector(re,i),n.guid||(n.guid=S.guid++),(u=y.events)||(u=y.events=Object.create(null)),(a=y.handle)||(a=y.handle=function(e){return"undefined"!=typeof S&&S.event.triggered!==e.type?S.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(P)||[""]).length;while(l--)d=g=(s=be.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=S.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=S.event.special[d]||{},c=S.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&S.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),S.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,y=Y.hasData(e)&&Y.get(e);if(y&&(u=y.events)){l=(t=(t||"").match(P)||[""]).length;while(l--)if(d=g=(s=be.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=S.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,y.handle)||S.removeEvent(e,d,y.handle),delete u[d])}else for(d in u)S.event.remove(e,d+t[l],n,r,!0);S.isEmptyObject(u)&&Y.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=S.event.fix(e),l=(Y.get(this,"events")||Object.create(null))[u.type]||[],c=S.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=S.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((S.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<S(i,this).index(l):S.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(S.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[S.expando]?e:new S.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&Se(t,"click",we),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&Se(t,"click"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,"input")&&Y.get(t,"click")||A(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},S.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},S.Event=function(e,t){if(!(this instanceof S.Event))return new S.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?we:Te,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&S.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[S.expando]=!0},S.Event.prototype={constructor:S.Event,isDefaultPrevented:Te,isPropagationStopped:Te,isImmediatePropagationStopped:Te,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=we,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=we,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=we,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},S.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:!0},S.event.addProp),S.each({focus:"focusin",blur:"focusout"},function(t,e){S.event.special[t]={setup:function(){return Se(this,t,Ce),!1},trigger:function(){return Se(this,t),!0},_default:function(e){return Y.get(e.target,t)},delegateType:e}}),S.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){S.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||S.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),S.fn.extend({on:function(e,t,n,r){return Ee(this,e,t,n,r)},one:function(e,t,n,r){return Ee(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,S(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=Te),this.each(function(){S.event.remove(this,e,n,t)})}});var ke=/<script|<style|<link/i,Ae=/checked\s*(?:[^=]|=\s*.checked.)/i,Ne=/^\s*<!\[CDATA\[|\]\]>\s*$/g;function je(e,t){return A(e,"table")&&A(11!==t.nodeType?t:t.firstChild,"tr")&&S(e).children("tbody")[0]||e}function De(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function qe(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Le(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(Y.hasData(e)&&(s=Y.get(e).events))for(i in Y.remove(t,"handle events"),s)for(n=0,r=s[i].length;n<r;n++)S.event.add(t,i,s[i][n]);Q.hasData(e)&&(o=Q.access(e),a=S.extend({},o),Q.set(t,a))}}function He(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&"string"==typeof d&&!v.checkClone&&Ae.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),He(t,r,i,o)});if(f&&(t=(e=xe(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=S.map(ye(e,"script"),De)).length;c<f;c++)u=e,c!==p&&(u=S.clone(u,!0,!0),s&&S.merge(a,ye(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,S.map(a,qe),c=0;c<s;c++)u=a[c],he.test(u.type||"")&&!Y.access(u,"globalEval")&&S.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?S._evalUrl&&!u.noModule&&S._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")},l):b(u.textContent.replace(Ne,""),u,l))}return n}function Oe(e,t,n){for(var r,i=t?S.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||S.cleanData(ye(r)),r.parentNode&&(n&&ie(r)&&ve(ye(r,"script")),r.parentNode.removeChild(r));return e}S.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=ie(e);if(!(v.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||S.isXMLDoc(e)))for(a=ye(c),r=0,i=(o=ye(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ye(e),a=a||ye(c),r=0,i=o.length;r<i;r++)Le(o[r],a[r]);else Le(e,c);return 0<(a=ye(c,"script")).length&&ve(a,!f&&ye(e,"script")),c},cleanData:function(e){for(var t,n,r,i=S.event.special,o=0;void 0!==(n=e[o]);o++)if(V(n)){if(t=n[Y.expando]){if(t.events)for(r in t.events)i[r]?S.event.remove(n,r):S.removeEvent(n,r,t.handle);n[Y.expando]=void 0}n[Q.expando]&&(n[Q.expando]=void 0)}}}),S.fn.extend({detach:function(e){return Oe(this,e,!0)},remove:function(e){return Oe(this,e)},text:function(e){return B(this,function(e){return void 0===e?S.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return He(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||je(this,e).appendChild(e)})},prepend:function(){return He(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=je(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return He(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return He(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(S.cleanData(ye(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return S.clone(this,e,t)})},html:function(e){return B(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!ke.test(e)&&!ge[(de.exec(e)||["",""])[1].toLowerCase()]){e=S.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(S.cleanData(ye(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return He(this,arguments,function(e){var t=this.parentNode;S.inArray(this,n)<0&&(S.cleanData(ye(this)),t&&t.replaceChild(e,this))},n)}}),S.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){S.fn[e]=function(e){for(var t,n=[],r=S(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),S(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var Pe=new RegExp("^("+ee+")(?!px)[a-z%]+$","i"),Re=/^--/,Me=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},Ie=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},We=new RegExp(ne.join("|"),"i"),Fe="[\\x20\\t\\r\\n\\f]",$e=new RegExp("^"+Fe+"+|((?:^|[^\\\\])(?:\\\\.)*)"+Fe+"+$","g");function Be(e,t,n){var r,i,o,a,s=Re.test(t),u=e.style;return(n=n||Me(e))&&(a=n.getPropertyValue(t)||n[t],s&&(a=a.replace($e,"$1")),""!==a||ie(e)||(a=S.style(e,t)),!v.pixelBoxStyles()&&Pe.test(a)&&We.test(t)&&(r=u.width,i=u.minWidth,o=u.maxWidth,u.minWidth=u.maxWidth=u.width=a,a=n.width,u.width=r,u.minWidth=i,u.maxWidth=o)),void 0!==a?a+"":a}function _e(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",l.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",re.appendChild(u).appendChild(l);var e=C.getComputedStyle(l);n="1%"!==e.top,s=12===t(e.marginLeft),l.style.right="60%",o=36===t(e.right),r=36===t(e.width),l.style.position="absolute",i=12===t(l.offsetWidth/3),re.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=E.createElement("div"),l=E.createElement("div");l.style&&(l.style.backgroundClip="content-box",l.cloneNode(!0).style.backgroundClip="",v.clearCloneStyle="content-box"===l.style.backgroundClip,S.extend(v,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=E.createElement("table"),t=E.createElement("tr"),n=E.createElement("div"),e.style.cssText="position:absolute;left:-11111px;border-collapse:separate",t.style.cssText="border:1px solid",t.style.height="1px",n.style.height="9px",n.style.display="block",re.appendChild(e).appendChild(t).appendChild(n),r=C.getComputedStyle(t),a=parseInt(r.height,10)+parseInt(r.borderTopWidth,10)+parseInt(r.borderBottomWidth,10)===t.offsetHeight,re.removeChild(e)),a}}))}();var ze=["Webkit","Moz","ms"],Ue=E.createElement("div").style,Xe={};function Ve(e){var t=S.cssProps[e]||Xe[e];return t||(e in Ue?e:Xe[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=ze.length;while(n--)if((e=ze[n]+t)in Ue)return e}(e)||e)}var Ge=/^(none|table(?!-c[ea]).+)/,Ye={position:"absolute",visibility:"hidden",display:"block"},Qe={letterSpacing:"0",fontWeight:"400"};function Je(e,t,n){var r=te.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function Ke(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(u+=S.css(e,n+ne[a],!0,i)),r?("content"===n&&(u-=S.css(e,"padding"+ne[a],!0,i)),"margin"!==n&&(u-=S.css(e,"border"+ne[a]+"Width",!0,i))):(u+=S.css(e,"padding"+ne[a],!0,i),"padding"!==n?u+=S.css(e,"border"+ne[a]+"Width",!0,i):s+=S.css(e,"border"+ne[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function Ze(e,t,n){var r=Me(e),i=(!v.boxSizingReliable()||n)&&"border-box"===S.css(e,"boxSizing",!1,r),o=i,a=Be(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if(Pe.test(a)){if(!n)return a;a="auto"}return(!v.boxSizingReliable()&&i||!v.reliableTrDimensions()&&A(e,"tr")||"auto"===a||!parseFloat(a)&&"inline"===S.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===S.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+Ke(e,t,n||(i?"border":"content"),o,r,a)+"px"}function et(e,t,n,r,i){return new et.prototype.init(e,t,n,r,i)}S.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Be(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=X(t),u=Re.test(t),l=e.style;if(u||(t=Ve(s)),a=S.cssHooks[t]||S.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=te.exec(n))&&i[1]&&(n=se(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(S.cssNumber[s]?"":"px")),v.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=X(t);return Re.test(t)||(t=Ve(s)),(a=S.cssHooks[t]||S.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=Be(e,t,r)),"normal"===i&&t in Qe&&(i=Qe[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),S.each(["height","width"],function(e,u){S.cssHooks[u]={get:function(e,t,n){if(t)return!Ge.test(S.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?Ze(e,u,n):Ie(e,Ye,function(){return Ze(e,u,n)})},set:function(e,t,n){var r,i=Me(e),o=!v.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===S.css(e,"boxSizing",!1,i),s=n?Ke(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-Ke(e,u,"border",!1,i)-.5)),s&&(r=te.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=S.css(e,u)),Je(0,t,s)}}}),S.cssHooks.marginLeft=_e(v.reliableMarginLeft,function(e,t){if(t)return(parseFloat(Be(e,"marginLeft"))||e.getBoundingClientRect().left-Ie(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),S.each({margin:"",padding:"",border:"Width"},function(i,o){S.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+ne[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(S.cssHooks[i+o].set=Je)}),S.fn.extend({css:function(e,t){return B(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Me(e),i=t.length;a<i;a++)o[t[a]]=S.css(e,t[a],!1,r);return o}return void 0!==n?S.style(e,t,n):S.css(e,t)},e,t,1<arguments.length)}}),((S.Tween=et).prototype={constructor:et,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||S.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(S.cssNumber[n]?"":"px")},cur:function(){var e=et.propHooks[this.prop];return e&&e.get?e.get(this):et.propHooks._default.get(this)},run:function(e){var t,n=et.propHooks[this.prop];return this.options.duration?this.pos=t=S.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):et.propHooks._default.set(this),this}}).init.prototype=et.prototype,(et.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=S.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){S.fx.step[e.prop]?S.fx.step[e.prop](e):1!==e.elem.nodeType||!S.cssHooks[e.prop]&&null==e.elem.style[Ve(e.prop)]?e.elem[e.prop]=e.now:S.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=et.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},S.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},S.fx=et.prototype.init,S.fx.step={};var tt,nt,rt,it,ot=/^(?:toggle|show|hide)$/,at=/queueHooks$/;function st(){nt&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(st):C.setTimeout(st,S.fx.interval),S.fx.tick())}function ut(){return C.setTimeout(function(){tt=void 0}),tt=Date.now()}function lt(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=ne[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function ct(e,t,n){for(var r,i=(ft.tweeners[t]||[]).concat(ft.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function ft(o,e,t){var n,a,r=0,i=ft.prefilters.length,s=S.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=tt||ut(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:S.extend({},e),opts:S.extend(!0,{specialEasing:{},easing:S.easing._default},t),originalProperties:e,originalOptions:t,startTime:tt||ut(),duration:t.duration,tweens:[],createTween:function(e,t){var n=S.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=X(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=S.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=ft.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(S._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return S.map(c,ct,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),S.fx.timer(S.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}S.Animation=S.extend(ft,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return se(n.elem,e,te.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=["*"]):e=e.match(P);for(var n,r=0,i=e.length;r<i;r++)n=e[r],ft.tweeners[n]=ft.tweeners[n]||[],ft.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&ae(e),y=Y.get(e,"fxshow");for(r in n.queue||(null==(a=S._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,S.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],ot.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!y||void 0===y[r])continue;g=!0}d[r]=y&&y[r]||S.style(e,r)}if((u=!S.isEmptyObject(t))||!S.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=y&&y.display)&&(l=Y.get(e,"display")),"none"===(c=S.css(e,"display"))&&(l?c=l:(le([e],!0),l=e.style.display||l,c=S.css(e,"display"),le([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===S.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(y?"hidden"in y&&(g=y.hidden):y=Y.access(e,"fxshow",{display:l}),o&&(y.hidden=!g),g&&le([e],!0),p.done(function(){for(r in g||le([e]),Y.remove(e,"fxshow"),d)S.style(e,r,d[r])})),u=ct(g?y[r]:0,r,p),r in y||(y[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?ft.prefilters.unshift(e):ft.prefilters.push(e)}}),S.speed=function(e,t,n){var r=e&&"object"==typeof e?S.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return S.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in S.fx.speeds?r.duration=S.fx.speeds[r.duration]:r.duration=S.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&S.dequeue(this,r.queue)},r},S.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ae).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=S.isEmptyObject(t),o=S.speed(e,n,r),a=function(){var e=ft(this,S.extend({},t),o);(i||Y.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=S.timers,r=Y.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&at.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||S.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=Y.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=S.timers,o=n?n.length:0;for(t.finish=!0,S.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),S.each(["toggle","show","hide"],function(e,r){var i=S.fn[r];S.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(lt(r,!0),e,t,n)}}),S.each({slideDown:lt("show"),slideUp:lt("hide"),slideToggle:lt("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){S.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),S.timers=[],S.fx.tick=function(){var e,t=0,n=S.timers;for(tt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||S.fx.stop(),tt=void 0},S.fx.timer=function(e){S.timers.push(e),S.fx.start()},S.fx.interval=13,S.fx.start=function(){nt||(nt=!0,st())},S.fx.stop=function(){nt=null},S.fx.speeds={slow:600,fast:200,_default:400},S.fn.delay=function(r,e){return r=S.fx&&S.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},rt=E.createElement("input"),it=E.createElement("select").appendChild(E.createElement("option")),rt.type="checkbox",v.checkOn=""!==rt.value,v.optSelected=it.selected,(rt=E.createElement("input")).value="t",rt.type="radio",v.radioValue="t"===rt.value;var pt,dt=S.expr.attrHandle;S.fn.extend({attr:function(e,t){return B(this,S.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){S.removeAttr(this,e)})}}),S.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?S.prop(e,t,n):(1===o&&S.isXMLDoc(e)||(i=S.attrHooks[t.toLowerCase()]||(S.expr.match.bool.test(t)?pt:void 0)),void 0!==n?null===n?void S.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=S.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!v.radioValue&&"radio"===t&&A(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(P);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),pt={set:function(e,t,n){return!1===t?S.removeAttr(e,n):e.setAttribute(n,n),n}},S.each(S.expr.match.bool.source.match(/\w+/g),function(e,t){var a=dt[t]||S.find.attr;dt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=dt[o],dt[o]=r,r=null!=a(e,t,n)?o:null,dt[o]=i),r}});var ht=/^(?:input|select|textarea|button)$/i,gt=/^(?:a|area)$/i;function yt(e){return(e.match(P)||[]).join(" ")}function vt(e){return e.getAttribute&&e.getAttribute("class")||""}function mt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(P)||[]}S.fn.extend({prop:function(e,t){return B(this,S.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[S.propFix[e]||e]})}}),S.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&S.isXMLDoc(e)||(t=S.propFix[t]||t,i=S.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=S.find.attr(e,"tabindex");return t?parseInt(t,10):ht.test(e.nodeName)||gt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),v.optSelected||(S.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),S.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){S.propFix[this.toLowerCase()]=this}),S.fn.extend({addClass:function(t){var e,n,r,i,o,a;return m(t)?this.each(function(e){S(this).addClass(t.call(this,e,vt(this)))}):(e=mt(t)).length?this.each(function(){if(r=vt(this),n=1===this.nodeType&&" "+yt(r)+" "){for(o=0;o<e.length;o++)i=e[o],n.indexOf(" "+i+" ")<0&&(n+=i+" ");a=yt(n),r!==a&&this.setAttribute("class",a)}}):this},removeClass:function(t){var e,n,r,i,o,a;return m(t)?this.each(function(e){S(this).removeClass(t.call(this,e,vt(this)))}):arguments.length?(e=mt(t)).length?this.each(function(){if(r=vt(this),n=1===this.nodeType&&" "+yt(r)+" "){for(o=0;o<e.length;o++){i=e[o];while(-1<n.indexOf(" "+i+" "))n=n.replace(" "+i+" "," ")}a=yt(n),r!==a&&this.setAttribute("class",a)}}):this:this.attr("class","")},toggleClass:function(t,n){var e,r,i,o,a=typeof t,s="string"===a||Array.isArray(t);return m(t)?this.each(function(e){S(this).toggleClass(t.call(this,e,vt(this),n),n)}):"boolean"==typeof n&&s?n?this.addClass(t):this.removeClass(t):(e=mt(t),this.each(function(){if(s)for(o=S(this),i=0;i<e.length;i++)r=e[i],o.hasClass(r)?o.removeClass(r):o.addClass(r);else void 0!==t&&"boolean"!==a||((r=vt(this))&&Y.set(this,"__className__",r),this.setAttribute&&this.setAttribute("class",r||!1===t?"":Y.get(this,"__className__")||""))}))},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+yt(vt(n))+" ").indexOf(t))return!0;return!1}});var xt=/\r/g;S.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,S(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=S.map(t,function(e){return null==e?"":e+""})),(r=S.valHooks[this.type]||S.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=S.valHooks[t.type]||S.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(xt,""):null==e?"":e:void 0}}),S.extend({valHooks:{option:{get:function(e){var t=S.find.attr(e,"value");return null!=t?t:yt(S.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,"optgroup"))){if(t=S(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=S.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<S.inArray(S.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),S.each(["radio","checkbox"],function(){S.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<S.inArray(S(e).val(),t)}},v.checkOn||(S.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),v.focusin="onfocusin"in C;var bt=/^(?:focusinfocus|focusoutblur)$/,wt=function(e){e.stopPropagation()};S.extend(S.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=y.call(e,"type")?e.type:e,h=y.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!bt.test(d+S.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[S.expando]?e:new S.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:S.makeArray(t,[e]),c=S.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,bt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Y.get(o,"events")||Object.create(null))[e.type]&&Y.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&V(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!V(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),S.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,wt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,wt),S.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=S.extend(new S.Event,n,{type:e,isSimulated:!0});S.event.trigger(r,null,t)}}),S.fn.extend({trigger:function(e,t){return this.each(function(){S.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return S.event.trigger(e,t,n,!0)}}),v.focusin||S.each({focus:"focusin",blur:"focusout"},function(n,r){var i=function(e){S.event.simulate(r,e.target,S.event.fix(e))};S.event.special[r]={setup:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r);t||e.addEventListener(n,i,!0),Y.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r)-1;t?Y.access(e,r,t):(e.removeEventListener(n,i,!0),Y.remove(e,r))}}});var Tt=C.location,Ct={guid:Date.now()},Et=/\?/;S.parseXML=function(e){var t,n;if(!e||"string"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,"text/xml")}catch(e){}return n=t&&t.getElementsByTagName("parsererror")[0],t&&!n||S.error("Invalid XML: "+(n?S.map(n.childNodes,function(e){return e.textContent}).join("\n"):e)),t};var St=/\[\]$/,kt=/\r?\n/g,At=/^(?:submit|button|image|reset|file)$/i,Nt=/^(?:input|select|textarea|keygen)/i;function jt(n,e,r,i){var t;if(Array.isArray(e))S.each(e,function(e,t){r||St.test(n)?i(n,t):jt(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==w(e))i(n,e);else for(t in e)jt(n+"["+t+"]",e[t],r,i)}S.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!S.isPlainObject(e))S.each(e,function(){i(this.name,this.value)});else for(n in e)jt(n,e[n],t,i);return r.join("&")},S.fn.extend({serialize:function(){return S.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=S.prop(this,"elements");return e?S.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!S(this).is(":disabled")&&Nt.test(this.nodeName)&&!At.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=S(this).val();return null==n?null:Array.isArray(n)?S.map(n,function(e){return{name:t.name,value:e.replace(kt,"\r\n")}}):{name:t.name,value:n.replace(kt,"\r\n")}}).get()}});var Dt=/%20/g,qt=/#.*$/,Lt=/([?&])_=[^&]*/,Ht=/^(.*?):[ \t]*([^\r\n]*)$/gm,Ot=/^(?:GET|HEAD)$/,Pt=/^\/\//,Rt={},Mt={},It="*/".concat("*"),Wt=E.createElement("a");function Ft(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(P)||[];if(m(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function $t(t,i,o,a){var s={},u=t===Mt;function l(e){var r;return s[e]=!0,S.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function Bt(e,t){var n,r,i=S.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&S.extend(!0,e,r),e}Wt.href=Tt.href,S.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Tt.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Tt.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":It,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":S.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?Bt(Bt(e,S.ajaxSettings),t):Bt(S.ajaxSettings,e)},ajaxPrefilter:Ft(Rt),ajaxTransport:Ft(Mt),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,y=S.ajaxSetup({},t),v=y.context||y,m=y.context&&(v.nodeType||v.jquery)?S(v):S.event,x=S.Deferred(),b=S.Callbacks("once memory"),w=y.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Ht.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(y.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),y.url=((e||y.url||Tt.href)+"").replace(Pt,Tt.protocol+"//"),y.type=t.method||t.type||y.method||y.type,y.dataTypes=(y.dataType||"*").toLowerCase().match(P)||[""],null==y.crossDomain){r=E.createElement("a");try{r.href=y.url,r.href=r.href,y.crossDomain=Wt.protocol+"//"+Wt.host!=r.protocol+"//"+r.host}catch(e){y.crossDomain=!0}}if(y.data&&y.processData&&"string"!=typeof y.data&&(y.data=S.param(y.data,y.traditional)),$t(Rt,y,t,T),h)return T;for(i in(g=S.event&&y.global)&&0==S.active++&&S.event.trigger("ajaxStart"),y.type=y.type.toUpperCase(),y.hasContent=!Ot.test(y.type),f=y.url.replace(qt,""),y.hasContent?y.data&&y.processData&&0===(y.contentType||"").indexOf("application/x-www-form-urlencoded")&&(y.data=y.data.replace(Dt,"+")):(o=y.url.slice(f.length),y.data&&(y.processData||"string"==typeof y.data)&&(f+=(Et.test(f)?"&":"?")+y.data,delete y.data),!1===y.cache&&(f=f.replace(Lt,"$1"),o=(Et.test(f)?"&":"?")+"_="+Ct.guid+++o),y.url=f+o),y.ifModified&&(S.lastModified[f]&&T.setRequestHeader("If-Modified-Since",S.lastModified[f]),S.etag[f]&&T.setRequestHeader("If-None-Match",S.etag[f])),(y.data&&y.hasContent&&!1!==y.contentType||t.contentType)&&T.setRequestHeader("Content-Type",y.contentType),T.setRequestHeader("Accept",y.dataTypes[0]&&y.accepts[y.dataTypes[0]]?y.accepts[y.dataTypes[0]]+("*"!==y.dataTypes[0]?", "+It+"; q=0.01":""):y.accepts["*"]),y.headers)T.setRequestHeader(i,y.headers[i]);if(y.beforeSend&&(!1===y.beforeSend.call(v,T,y)||h))return T.abort();if(u="abort",b.add(y.complete),T.done(y.success),T.fail(y.error),c=$t(Mt,y,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,y]),h)return T;y.async&&0<y.timeout&&(d=C.setTimeout(function(){T.abort("timeout")},y.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(y,T,n)),!i&&-1<S.inArray("script",y.dataTypes)&&S.inArray("json",y.dataTypes)<0&&(y.converters["text script"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(y,s,T,i),i?(y.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(S.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(S.etag[f]=u)),204===e||"HEAD"===y.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(v,[o,l,T]):x.rejectWith(v,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,y,i?o:a]),b.fireWith(v,[T,l]),g&&(m.trigger("ajaxComplete",[T,y]),--S.active||S.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return S.get(e,t,n,"json")},getScript:function(e,t){return S.get(e,void 0,t,"script")}}),S.each(["get","post"],function(e,i){S[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),S.ajax(S.extend({url:e,type:i,dataType:r,data:t,success:n},S.isPlainObject(e)&&e))}}),S.ajaxPrefilter(function(e){var t;for(t in e.headers)"content-type"===t.toLowerCase()&&(e.contentType=e.headers[t]||"")}),S._evalUrl=function(e,t,n){return S.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){S.globalEval(e,t,n)}})},S.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=S(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){S(this).wrapInner(n.call(this,e))}):this.each(function(){var e=S(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){S(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){S(this).replaceWith(this.childNodes)}),this}}),S.expr.pseudos.hidden=function(e){return!S.expr.pseudos.visible(e)},S.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},S.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var _t={0:200,1223:204},zt=S.ajaxSettings.xhr();v.cors=!!zt&&"withCredentials"in zt,v.ajax=zt=!!zt,S.ajaxTransport(function(i){var o,a;if(v.cors||zt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(_t[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),S.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),S.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return S.globalEval(e),e}}}),S.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),S.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=S("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var Ut,Xt=[],Vt=/(=)\?(?=&|$)|\?\?/;S.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Xt.pop()||S.expando+"_"+Ct.guid++;return this[e]=!0,e}}),S.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Vt.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Vt.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Vt,"$1"+r):!1!==e.jsonp&&(e.url+=(Et.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||S.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?S(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Xt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),"script"}),v.createHTMLDocument=((Ut=E.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Ut.childNodes.length),S.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(v.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument("")).createElement("base")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=N.exec(e))?[t.createElement(i[1])]:(i=xe([e],t,o),o&&o.length&&S(o).remove(),S.merge([],i.childNodes)));var r,i,o},S.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=yt(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&S.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?S("<div>").append(S.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},S.expr.pseudos.animated=function(t){return S.grep(S.timers,function(e){return t===e.elem}).length},S.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=S.css(e,"position"),c=S(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=S.css(e,"top"),u=S.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,S.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):c.css(f)}},S.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){S.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===S.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===S.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=S(e).offset()).top+=S.css(e,"borderTopWidth",!0),i.left+=S.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-S.css(r,"marginTop",!0),left:t.left-i.left-S.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===S.css(e,"position"))e=e.offsetParent;return e||re})}}),S.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;S.fn[t]=function(e){return B(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),S.each(["top","left"],function(e,n){S.cssHooks[n]=_e(v.pixelPosition,function(e,t){if(t)return t=Be(e,n),Pe.test(t)?S(e).position()[n]+"px":t})}),S.each({Height:"height",Width:"width"},function(a,s){S.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){S.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return B(this,function(e,t,n){var r;return x(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?S.css(e,t,i):S.style(e,t,n,i)},s,n?e:void 0,n)}})}),S.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){S.fn[t]=function(e){return this.on(t,e)}}),S.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){S.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var Gt=/^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;S.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||S.guid++,i},S.holdReady=function(e){e?S.readyWait++:S.ready(!0)},S.isArray=Array.isArray,S.parseJSON=JSON.parse,S.nodeName=A,S.isFunction=m,S.isWindow=x,S.camelCase=X,S.type=w,S.now=Date.now,S.isNumeric=function(e){var t=S.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},S.trim=function(e){return null==e?"":(e+"").replace(Gt,"$1")},"function"==typeof define&&define.amd&&define("jquery",[],function(){return S});var Yt=C.jQuery,Qt=C.$;return S.noConflict=function(e){return C.$===S&&(C.$=Qt),e&&C.jQuery===S&&(C.jQuery=Yt),S},"undefined"==typeof e&&(C.jQuery=C.$=S),S});
/**
 * Swiper 8.4.7
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2023 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: January 30, 2023
 */

!function (e, t) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).Swiper = t()
}(this, (function () {
    "use strict";

    function e(e) {
        return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object
    }

    function t(s, a) {
        void 0 === s && (s = {}), void 0 === a && (a = {}), Object.keys(a).forEach((i => {
            void 0 === s[i] ? s[i] = a[i] : e(a[i]) && e(s[i]) && Object.keys(a[i]).length > 0 && t(s[i], a[i])
        }))
    }

    const s = {
        body: {},
        addEventListener() {
        },
        removeEventListener() {
        },
        activeElement: {
            blur() {
            }, nodeName: ""
        },
        querySelector: () => null,
        querySelectorAll: () => [],
        getElementById: () => null,
        createEvent: () => ({
            initEvent() {
            }
        }),
        createElement: () => ({
            children: [], childNodes: [], style: {}, setAttribute() {
            }, getElementsByTagName: () => []
        }),
        createElementNS: () => ({}),
        importNode: () => null,
        location: {hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: ""}
    };

    function a() {
        const e = "undefined" != typeof document ? document : {};
        return t(e, s), e
    }

    const i = {
        document: s,
        navigator: {userAgent: ""},
        location: {hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: ""},
        history: {
            replaceState() {
            }, pushState() {
            }, go() {
            }, back() {
            }
        },
        CustomEvent: function () {
            return this
        },
        addEventListener() {
        },
        removeEventListener() {
        },
        getComputedStyle: () => ({getPropertyValue: () => ""}),
        Image() {
        },
        Date() {
        },
        screen: {},
        setTimeout() {
        },
        clearTimeout() {
        },
        matchMedia: () => ({}),
        requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0),
        cancelAnimationFrame(e) {
            "undefined" != typeof setTimeout && clearTimeout(e)
        }
    };

    function r() {
        const e = "undefined" != typeof window ? window : {};
        return t(e, i), e
    }

    class n extends Array {
        constructor(e) {
            "number" == typeof e ? super(e) : (super(...e || []), function (e) {
                const t = e.__proto__;
                Object.defineProperty(e, "__proto__", {
                    get: () => t, set(e) {
                        t.__proto__ = e
                    }
                })
            }(this))
        }
    }

    function l(e) {
        void 0 === e && (e = []);
        const t = [];
        return e.forEach((e => {
            Array.isArray(e) ? t.push(...l(e)) : t.push(e)
        })), t
    }

    function o(e, t) {
        return Array.prototype.filter.call(e, t)
    }

    function d(e, t) {
        const s = r(), i = a();
        let l = [];
        if (!t && e instanceof n) return e;
        if (!e) return new n(l);
        if ("string" == typeof e) {
            const s = e.trim();
            if (s.indexOf("<") >= 0 && s.indexOf(">") >= 0) {
                let e = "div";
                0 === s.indexOf("<li") && (e = "ul"), 0 === s.indexOf("<tr") && (e = "tbody"), 0 !== s.indexOf("<td") && 0 !== s.indexOf("<th") || (e = "tr"), 0 === s.indexOf("<tbody") && (e = "table"), 0 === s.indexOf("<option") && (e = "select");
                const t = i.createElement(e);
                t.innerHTML = s;
                for (let e = 0; e < t.childNodes.length; e += 1) l.push(t.childNodes[e])
            } else l = function (e, t) {
                if ("string" != typeof e) return [e];
                const s = [], a = t.querySelectorAll(e);
                for (let e = 0; e < a.length; e += 1) s.push(a[e]);
                return s
            }(e.trim(), t || i)
        } else if (e.nodeType || e === s || e === i) l.push(e); else if (Array.isArray(e)) {
            if (e instanceof n) return e;
            l = e
        }
        return new n(function (e) {
            const t = [];
            for (let s = 0; s < e.length; s += 1) -1 === t.indexOf(e[s]) && t.push(e[s]);
            return t
        }(l))
    }

    d.fn = n.prototype;
    const c = {
        addClass: function () {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];
            const a = l(t.map((e => e.split(" "))));
            return this.forEach((e => {
                e.classList.add(...a)
            })), this
        }, removeClass: function () {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];
            const a = l(t.map((e => e.split(" "))));
            return this.forEach((e => {
                e.classList.remove(...a)
            })), this
        }, hasClass: function () {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];
            const a = l(t.map((e => e.split(" "))));
            return o(this, (e => a.filter((t => e.classList.contains(t))).length > 0)).length > 0
        }, toggleClass: function () {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];
            const a = l(t.map((e => e.split(" "))));
            this.forEach((e => {
                a.forEach((t => {
                    e.classList.toggle(t)
                }))
            }))
        }, attr: function (e, t) {
            if (1 === arguments.length && "string" == typeof e) return this[0] ? this[0].getAttribute(e) : void 0;
            for (let s = 0; s < this.length; s += 1) if (2 === arguments.length) this[s].setAttribute(e, t); else for (const t in e) this[s][t] = e[t], this[s].setAttribute(t, e[t]);
            return this
        }, removeAttr: function (e) {
            for (let t = 0; t < this.length; t += 1) this[t].removeAttribute(e);
            return this
        }, transform: function (e) {
            for (let t = 0; t < this.length; t += 1) this[t].style.transform = e;
            return this
        }, transition: function (e) {
            for (let t = 0; t < this.length; t += 1) this[t].style.transitionDuration = "string" != typeof e ? `${e}ms` : e;
            return this
        }, on: function () {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];
            let [a, i, r, n] = t;

            function l(e) {
                const t = e.target;
                if (!t) return;
                const s = e.target.dom7EventData || [];
                if (s.indexOf(e) < 0 && s.unshift(e), d(t).is(i)) r.apply(t, s); else {
                    const e = d(t).parents();
                    for (let t = 0; t < e.length; t += 1) d(e[t]).is(i) && r.apply(e[t], s)
                }
            }

            function o(e) {
                const t = e && e.target && e.target.dom7EventData || [];
                t.indexOf(e) < 0 && t.unshift(e), r.apply(this, t)
            }

            "function" == typeof t[1] && ([a, r, n] = t, i = void 0), n || (n = !1);
            const c = a.split(" ");
            let p;
            for (let e = 0; e < this.length; e += 1) {
                const t = this[e];
                if (i) for (p = 0; p < c.length; p += 1) {
                    const e = c[p];
                    t.dom7LiveListeners || (t.dom7LiveListeners = {}), t.dom7LiveListeners[e] || (t.dom7LiveListeners[e] = []), t.dom7LiveListeners[e].push({
                        listener: r,
                        proxyListener: l
                    }), t.addEventListener(e, l, n)
                } else for (p = 0; p < c.length; p += 1) {
                    const e = c[p];
                    t.dom7Listeners || (t.dom7Listeners = {}), t.dom7Listeners[e] || (t.dom7Listeners[e] = []), t.dom7Listeners[e].push({
                        listener: r,
                        proxyListener: o
                    }), t.addEventListener(e, o, n)
                }
            }
            return this
        }, off: function () {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];
            let [a, i, r, n] = t;
            "function" == typeof t[1] && ([a, r, n] = t, i = void 0), n || (n = !1);
            const l = a.split(" ");
            for (let e = 0; e < l.length; e += 1) {
                const t = l[e];
                for (let e = 0; e < this.length; e += 1) {
                    const s = this[e];
                    let a;
                    if (!i && s.dom7Listeners ? a = s.dom7Listeners[t] : i && s.dom7LiveListeners && (a = s.dom7LiveListeners[t]), a && a.length) for (let e = a.length - 1; e >= 0; e -= 1) {
                        const i = a[e];
                        r && i.listener === r || r && i.listener && i.listener.dom7proxy && i.listener.dom7proxy === r ? (s.removeEventListener(t, i.proxyListener, n), a.splice(e, 1)) : r || (s.removeEventListener(t, i.proxyListener, n), a.splice(e, 1))
                    }
                }
            }
            return this
        }, trigger: function () {
            const e = r();
            for (var t = arguments.length, s = new Array(t), a = 0; a < t; a++) s[a] = arguments[a];
            const i = s[0].split(" "), n = s[1];
            for (let t = 0; t < i.length; t += 1) {
                const a = i[t];
                for (let t = 0; t < this.length; t += 1) {
                    const i = this[t];
                    if (e.CustomEvent) {
                        const t = new e.CustomEvent(a, {detail: n, bubbles: !0, cancelable: !0});
                        i.dom7EventData = s.filter(((e, t) => t > 0)), i.dispatchEvent(t), i.dom7EventData = [], delete i.dom7EventData
                    }
                }
            }
            return this
        }, transitionEnd: function (e) {
            const t = this;
            return e && t.on("transitionend", (function s(a) {
                a.target === this && (e.call(this, a), t.off("transitionend", s))
            })), this
        }, outerWidth: function (e) {
            if (this.length > 0) {
                if (e) {
                    const e = this.styles();
                    return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left"))
                }
                return this[0].offsetWidth
            }
            return null
        }, outerHeight: function (e) {
            if (this.length > 0) {
                if (e) {
                    const e = this.styles();
                    return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom"))
                }
                return this[0].offsetHeight
            }
            return null
        }, styles: function () {
            const e = r();
            return this[0] ? e.getComputedStyle(this[0], null) : {}
        }, offset: function () {
            if (this.length > 0) {
                const e = r(), t = a(), s = this[0], i = s.getBoundingClientRect(), n = t.body,
                    l = s.clientTop || n.clientTop || 0, o = s.clientLeft || n.clientLeft || 0,
                    d = s === e ? e.scrollY : s.scrollTop, c = s === e ? e.scrollX : s.scrollLeft;
                return {top: i.top + d - l, left: i.left + c - o}
            }
            return null
        }, css: function (e, t) {
            const s = r();
            let a;
            if (1 === arguments.length) {
                if ("string" != typeof e) {
                    for (a = 0; a < this.length; a += 1) for (const t in e) this[a].style[t] = e[t];
                    return this
                }
                if (this[0]) return s.getComputedStyle(this[0], null).getPropertyValue(e)
            }
            if (2 === arguments.length && "string" == typeof e) {
                for (a = 0; a < this.length; a += 1) this[a].style[e] = t;
                return this
            }
            return this
        }, each: function (e) {
            return e ? (this.forEach(((t, s) => {
                e.apply(t, [t, s])
            })), this) : this
        }, html: function (e) {
            if (void 0 === e) return this[0] ? this[0].innerHTML : null;
            for (let t = 0; t < this.length; t += 1) this[t].innerHTML = e;
            return this
        }, text: function (e) {
            if (void 0 === e) return this[0] ? this[0].textContent.trim() : null;
            for (let t = 0; t < this.length; t += 1) this[t].textContent = e;
            return this
        }, is: function (e) {
            const t = r(), s = a(), i = this[0];
            let l, o;
            if (!i || void 0 === e) return !1;
            if ("string" == typeof e) {
                if (i.matches) return i.matches(e);
                if (i.webkitMatchesSelector) return i.webkitMatchesSelector(e);
                if (i.msMatchesSelector) return i.msMatchesSelector(e);
                for (l = d(e), o = 0; o < l.length; o += 1) if (l[o] === i) return !0;
                return !1
            }
            if (e === s) return i === s;
            if (e === t) return i === t;
            if (e.nodeType || e instanceof n) {
                for (l = e.nodeType ? [e] : e, o = 0; o < l.length; o += 1) if (l[o] === i) return !0;
                return !1
            }
            return !1
        }, index: function () {
            let e, t = this[0];
            if (t) {
                for (e = 0; null !== (t = t.previousSibling);) 1 === t.nodeType && (e += 1);
                return e
            }
        }, eq: function (e) {
            if (void 0 === e) return this;
            const t = this.length;
            if (e > t - 1) return d([]);
            if (e < 0) {
                const s = t + e;
                return d(s < 0 ? [] : [this[s]])
            }
            return d([this[e]])
        }, append: function () {
            let e;
            const t = a();
            for (let s = 0; s < arguments.length; s += 1) {
                e = s < 0 || arguments.length <= s ? void 0 : arguments[s];
                for (let s = 0; s < this.length; s += 1) if ("string" == typeof e) {
                    const a = t.createElement("div");
                    for (a.innerHTML = e; a.firstChild;) this[s].appendChild(a.firstChild)
                } else if (e instanceof n) for (let t = 0; t < e.length; t += 1) this[s].appendChild(e[t]); else this[s].appendChild(e)
            }
            return this
        }, prepend: function (e) {
            const t = a();
            let s, i;
            for (s = 0; s < this.length; s += 1) if ("string" == typeof e) {
                const a = t.createElement("div");
                for (a.innerHTML = e, i = a.childNodes.length - 1; i >= 0; i -= 1) this[s].insertBefore(a.childNodes[i], this[s].childNodes[0])
            } else if (e instanceof n) for (i = 0; i < e.length; i += 1) this[s].insertBefore(e[i], this[s].childNodes[0]); else this[s].insertBefore(e, this[s].childNodes[0]);
            return this
        }, next: function (e) {
            return this.length > 0 ? e ? this[0].nextElementSibling && d(this[0].nextElementSibling).is(e) ? d([this[0].nextElementSibling]) : d([]) : this[0].nextElementSibling ? d([this[0].nextElementSibling]) : d([]) : d([])
        }, nextAll: function (e) {
            const t = [];
            let s = this[0];
            if (!s) return d([]);
            for (; s.nextElementSibling;) {
                const a = s.nextElementSibling;
                e ? d(a).is(e) && t.push(a) : t.push(a), s = a
            }
            return d(t)
        }, prev: function (e) {
            if (this.length > 0) {
                const t = this[0];
                return e ? t.previousElementSibling && d(t.previousElementSibling).is(e) ? d([t.previousElementSibling]) : d([]) : t.previousElementSibling ? d([t.previousElementSibling]) : d([])
            }
            return d([])
        }, prevAll: function (e) {
            const t = [];
            let s = this[0];
            if (!s) return d([]);
            for (; s.previousElementSibling;) {
                const a = s.previousElementSibling;
                e ? d(a).is(e) && t.push(a) : t.push(a), s = a
            }
            return d(t)
        }, parent: function (e) {
            const t = [];
            for (let s = 0; s < this.length; s += 1) null !== this[s].parentNode && (e ? d(this[s].parentNode).is(e) && t.push(this[s].parentNode) : t.push(this[s].parentNode));
            return d(t)
        }, parents: function (e) {
            const t = [];
            for (let s = 0; s < this.length; s += 1) {
                let a = this[s].parentNode;
                for (; a;) e ? d(a).is(e) && t.push(a) : t.push(a), a = a.parentNode
            }
            return d(t)
        }, closest: function (e) {
            let t = this;
            return void 0 === e ? d([]) : (t.is(e) || (t = t.parents(e).eq(0)), t)
        }, find: function (e) {
            const t = [];
            for (let s = 0; s < this.length; s += 1) {
                const a = this[s].querySelectorAll(e);
                for (let e = 0; e < a.length; e += 1) t.push(a[e])
            }
            return d(t)
        }, children: function (e) {
            const t = [];
            for (let s = 0; s < this.length; s += 1) {
                const a = this[s].children;
                for (let s = 0; s < a.length; s += 1) e && !d(a[s]).is(e) || t.push(a[s])
            }
            return d(t)
        }, filter: function (e) {
            return d(o(this, e))
        }, remove: function () {
            for (let e = 0; e < this.length; e += 1) this[e].parentNode && this[e].parentNode.removeChild(this[e]);
            return this
        }
    };

    function p(e, t) {
        return void 0 === t && (t = 0), setTimeout(e, t)
    }

    function u() {
        return Date.now()
    }

    function h(e, t) {
        void 0 === t && (t = "x");
        const s = r();
        let a, i, n;
        const l = function (e) {
            const t = r();
            let s;
            return t.getComputedStyle && (s = t.getComputedStyle(e, null)), !s && e.currentStyle && (s = e.currentStyle), s || (s = e.style), s
        }(e);
        return s.WebKitCSSMatrix ? (i = l.transform || l.webkitTransform, i.split(",").length > 6 && (i = i.split(", ").map((e => e.replace(",", "."))).join(", ")), n = new s.WebKitCSSMatrix("none" === i ? "" : i)) : (n = l.MozTransform || l.OTransform || l.MsTransform || l.msTransform || l.transform || l.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), a = n.toString().split(",")), "x" === t && (i = s.WebKitCSSMatrix ? n.m41 : 16 === a.length ? parseFloat(a[12]) : parseFloat(a[4])), "y" === t && (i = s.WebKitCSSMatrix ? n.m42 : 16 === a.length ? parseFloat(a[13]) : parseFloat(a[5])), i || 0
    }

    function m(e) {
        return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1)
    }

    function f(e) {
        return "undefined" != typeof window && void 0 !== window.HTMLElement ? e instanceof HTMLElement : e && (1 === e.nodeType || 11 === e.nodeType)
    }

    function g() {
        const e = Object(arguments.length <= 0 ? void 0 : arguments[0]), t = ["__proto__", "constructor", "prototype"];
        for (let s = 1; s < arguments.length; s += 1) {
            const a = s < 0 || arguments.length <= s ? void 0 : arguments[s];
            if (null != a && !f(a)) {
                const s = Object.keys(Object(a)).filter((e => t.indexOf(e) < 0));
                for (let t = 0, i = s.length; t < i; t += 1) {
                    const i = s[t], r = Object.getOwnPropertyDescriptor(a, i);
                    void 0 !== r && r.enumerable && (m(e[i]) && m(a[i]) ? a[i].__swiper__ ? e[i] = a[i] : g(e[i], a[i]) : !m(e[i]) && m(a[i]) ? (e[i] = {}, a[i].__swiper__ ? e[i] = a[i] : g(e[i], a[i])) : e[i] = a[i])
                }
            }
        }
        return e
    }

    function v(e, t, s) {
        e.style.setProperty(t, s)
    }

    function w(e) {
        let {swiper: t, targetPosition: s, side: a} = e;
        const i = r(), n = -t.translate;
        let l, o = null;
        const d = t.params.speed;
        t.wrapperEl.style.scrollSnapType = "none", i.cancelAnimationFrame(t.cssModeFrameID);
        const c = s > n ? "next" : "prev", p = (e, t) => "next" === c && e >= t || "prev" === c && e <= t, u = () => {
            l = (new Date).getTime(), null === o && (o = l);
            const e = Math.max(Math.min((l - o) / d, 1), 0), r = .5 - Math.cos(e * Math.PI) / 2;
            let c = n + r * (s - n);
            if (p(c, s) && (c = s), t.wrapperEl.scrollTo({[a]: c}), p(c, s)) return t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout((() => {
                t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({[a]: c})
            })), void i.cancelAnimationFrame(t.cssModeFrameID);
            t.cssModeFrameID = i.requestAnimationFrame(u)
        };
        u()
    }

    let b, x, y;

    function E() {
        return b || (b = function () {
            const e = r(), t = a();
            return {
                smoothScroll: t.documentElement && "scrollBehavior" in t.documentElement.style,
                touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch),
                passiveListener: function () {
                    let t = !1;
                    try {
                        const s = Object.defineProperty({}, "passive", {
                            get() {
                                t = !0
                            }
                        });
                        e.addEventListener("testPassiveListener", null, s)
                    } catch (e) {
                    }
                    return t
                }(),
                gestures: "ongesturestart" in e
            }
        }()), b
    }

    function C(e) {
        return void 0 === e && (e = {}), x || (x = function (e) {
            let {userAgent: t} = void 0 === e ? {} : e;
            const s = E(), a = r(), i = a.navigator.platform, n = t || a.navigator.userAgent,
                l = {ios: !1, android: !1}, o = a.screen.width, d = a.screen.height,
                c = n.match(/(Android);?[\s\/]+([\d.]+)?/);
            let p = n.match(/(iPad).*OS\s([\d_]+)/);
            const u = n.match(/(iPod)(.*OS\s([\d_]+))?/), h = !p && n.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
                m = "Win32" === i;
            let f = "MacIntel" === i;
            return !p && f && s.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${o}x${d}`) >= 0 && (p = n.match(/(Version)\/([\d.]+)/), p || (p = [0, 1, "13_0_0"]), f = !1), c && !m && (l.os = "android", l.android = !0), (p || h || u) && (l.os = "ios", l.ios = !0), l
        }(e)), x
    }

    function T() {
        return y || (y = function () {
            const e = r();
            return {
                isSafari: function () {
                    const t = e.navigator.userAgent.toLowerCase();
                    return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0
                }(), isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent)
            }
        }()), y
    }

    Object.keys(c).forEach((e => {
        Object.defineProperty(d.fn, e, {value: c[e], writable: !0})
    }));
    var $ = {
        on(e, t, s) {
            const a = this;
            if (!a.eventsListeners || a.destroyed) return a;
            if ("function" != typeof t) return a;
            const i = s ? "unshift" : "push";
            return e.split(" ").forEach((e => {
                a.eventsListeners[e] || (a.eventsListeners[e] = []), a.eventsListeners[e][i](t)
            })), a
        }, once(e, t, s) {
            const a = this;
            if (!a.eventsListeners || a.destroyed) return a;
            if ("function" != typeof t) return a;

            function i() {
                a.off(e, i), i.__emitterProxy && delete i.__emitterProxy;
                for (var s = arguments.length, r = new Array(s), n = 0; n < s; n++) r[n] = arguments[n];
                t.apply(a, r)
            }

            return i.__emitterProxy = t, a.on(e, i, s)
        }, onAny(e, t) {
            const s = this;
            if (!s.eventsListeners || s.destroyed) return s;
            if ("function" != typeof e) return s;
            const a = t ? "unshift" : "push";
            return s.eventsAnyListeners.indexOf(e) < 0 && s.eventsAnyListeners[a](e), s
        }, offAny(e) {
            const t = this;
            if (!t.eventsListeners || t.destroyed) return t;
            if (!t.eventsAnyListeners) return t;
            const s = t.eventsAnyListeners.indexOf(e);
            return s >= 0 && t.eventsAnyListeners.splice(s, 1), t
        }, off(e, t) {
            const s = this;
            return !s.eventsListeners || s.destroyed ? s : s.eventsListeners ? (e.split(" ").forEach((e => {
                void 0 === t ? s.eventsListeners[e] = [] : s.eventsListeners[e] && s.eventsListeners[e].forEach(((a, i) => {
                    (a === t || a.__emitterProxy && a.__emitterProxy === t) && s.eventsListeners[e].splice(i, 1)
                }))
            })), s) : s
        }, emit() {
            const e = this;
            if (!e.eventsListeners || e.destroyed) return e;
            if (!e.eventsListeners) return e;
            let t, s, a;
            for (var i = arguments.length, r = new Array(i), n = 0; n < i; n++) r[n] = arguments[n];
            "string" == typeof r[0] || Array.isArray(r[0]) ? (t = r[0], s = r.slice(1, r.length), a = e) : (t = r[0].events, s = r[0].data, a = r[0].context || e), s.unshift(a);
            return (Array.isArray(t) ? t : t.split(" ")).forEach((t => {
                e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach((e => {
                    e.apply(a, [t, ...s])
                })), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach((e => {
                    e.apply(a, s)
                }))
            })), e
        }
    };
    var S = {
        updateSize: function () {
            const e = this;
            let t, s;
            const a = e.$el;
            t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : a[0].clientWidth, s = void 0 !== e.params.height && null !== e.params.height ? e.params.height : a[0].clientHeight, 0 === t && e.isHorizontal() || 0 === s && e.isVertical() || (t = t - parseInt(a.css("padding-left") || 0, 10) - parseInt(a.css("padding-right") || 0, 10), s = s - parseInt(a.css("padding-top") || 0, 10) - parseInt(a.css("padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(s) && (s = 0), Object.assign(e, {
                width: t,
                height: s,
                size: e.isHorizontal() ? t : s
            }))
        }, updateSlides: function () {
            const e = this;

            function t(t) {
                return e.isHorizontal() ? t : {
                    width: "height",
                    "margin-top": "margin-left",
                    "margin-bottom ": "margin-right",
                    "margin-left": "margin-top",
                    "margin-right": "margin-bottom",
                    "padding-left": "padding-top",
                    "padding-right": "padding-bottom",
                    marginRight: "marginBottom"
                }[t]
            }

            function s(e, s) {
                return parseFloat(e.getPropertyValue(t(s)) || 0)
            }

            const a = e.params, {$wrapperEl: i, size: r, rtlTranslate: n, wrongRTL: l} = e,
                o = e.virtual && a.virtual.enabled, d = o ? e.virtual.slides.length : e.slides.length,
                c = i.children(`.${e.params.slideClass}`), p = o ? e.virtual.slides.length : c.length;
            let u = [];
            const h = [], m = [];
            let f = a.slidesOffsetBefore;
            "function" == typeof f && (f = a.slidesOffsetBefore.call(e));
            let g = a.slidesOffsetAfter;
            "function" == typeof g && (g = a.slidesOffsetAfter.call(e));
            const w = e.snapGrid.length, b = e.slidesGrid.length;
            let x = a.spaceBetween, y = -f, E = 0, C = 0;
            if (void 0 === r) return;
            "string" == typeof x && x.indexOf("%") >= 0 && (x = parseFloat(x.replace("%", "")) / 100 * r), e.virtualSize = -x, n ? c.css({
                marginLeft: "",
                marginBottom: "",
                marginTop: ""
            }) : c.css({
                marginRight: "",
                marginBottom: "",
                marginTop: ""
            }), a.centeredSlides && a.cssMode && (v(e.wrapperEl, "--swiper-centered-offset-before", ""), v(e.wrapperEl, "--swiper-centered-offset-after", ""));
            const T = a.grid && a.grid.rows > 1 && e.grid;
            let $;
            T && e.grid.initSlides(p);
            const S = "auto" === a.slidesPerView && a.breakpoints && Object.keys(a.breakpoints).filter((e => void 0 !== a.breakpoints[e].slidesPerView)).length > 0;
            for (let i = 0; i < p; i += 1) {
                $ = 0;
                const n = c.eq(i);
                if (T && e.grid.updateSlide(i, n, p, t), "none" !== n.css("display")) {
                    if ("auto" === a.slidesPerView) {
                        S && (c[i].style[t("width")] = "");
                        const r = getComputedStyle(n[0]), l = n[0].style.transform, o = n[0].style.webkitTransform;
                        if (l && (n[0].style.transform = "none"), o && (n[0].style.webkitTransform = "none"), a.roundLengths) $ = e.isHorizontal() ? n.outerWidth(!0) : n.outerHeight(!0); else {
                            const e = s(r, "width"), t = s(r, "padding-left"), a = s(r, "padding-right"),
                                i = s(r, "margin-left"), l = s(r, "margin-right"), o = r.getPropertyValue("box-sizing");
                            if (o && "border-box" === o) $ = e + i + l; else {
                                const {clientWidth: s, offsetWidth: r} = n[0];
                                $ = e + t + a + i + l + (r - s)
                            }
                        }
                        l && (n[0].style.transform = l), o && (n[0].style.webkitTransform = o), a.roundLengths && ($ = Math.floor($))
                    } else $ = (r - (a.slidesPerView - 1) * x) / a.slidesPerView, a.roundLengths && ($ = Math.floor($)), c[i] && (c[i].style[t("width")] = `${$}px`);
                    c[i] && (c[i].swiperSlideSize = $), m.push($), a.centeredSlides ? (y = y + $ / 2 + E / 2 + x, 0 === E && 0 !== i && (y = y - r / 2 - x), 0 === i && (y = y - r / 2 - x), Math.abs(y) < .001 && (y = 0), a.roundLengths && (y = Math.floor(y)), C % a.slidesPerGroup == 0 && u.push(y), h.push(y)) : (a.roundLengths && (y = Math.floor(y)), (C - Math.min(e.params.slidesPerGroupSkip, C)) % e.params.slidesPerGroup == 0 && u.push(y), h.push(y), y = y + $ + x), e.virtualSize += $ + x, E = $, C += 1
                }
            }
            if (e.virtualSize = Math.max(e.virtualSize, r) + g, n && l && ("slide" === a.effect || "coverflow" === a.effect) && i.css({width: `${e.virtualSize + a.spaceBetween}px`}), a.setWrapperSize && i.css({[t("width")]: `${e.virtualSize + a.spaceBetween}px`}), T && e.grid.updateWrapperSize($, u, t), !a.centeredSlides) {
                const t = [];
                for (let s = 0; s < u.length; s += 1) {
                    let i = u[s];
                    a.roundLengths && (i = Math.floor(i)), u[s] <= e.virtualSize - r && t.push(i)
                }
                u = t, Math.floor(e.virtualSize - r) - Math.floor(u[u.length - 1]) > 1 && u.push(e.virtualSize - r)
            }
            if (0 === u.length && (u = [0]), 0 !== a.spaceBetween) {
                const s = e.isHorizontal() && n ? "marginLeft" : t("marginRight");
                c.filter(((e, t) => !a.cssMode || t !== c.length - 1)).css({[s]: `${x}px`})
            }
            if (a.centeredSlides && a.centeredSlidesBounds) {
                let e = 0;
                m.forEach((t => {
                    e += t + (a.spaceBetween ? a.spaceBetween : 0)
                })), e -= a.spaceBetween;
                const t = e - r;
                u = u.map((e => e < 0 ? -f : e > t ? t + g : e))
            }
            if (a.centerInsufficientSlides) {
                let e = 0;
                if (m.forEach((t => {
                    e += t + (a.spaceBetween ? a.spaceBetween : 0)
                })), e -= a.spaceBetween, e < r) {
                    const t = (r - e) / 2;
                    u.forEach(((e, s) => {
                        u[s] = e - t
                    })), h.forEach(((e, s) => {
                        h[s] = e + t
                    }))
                }
            }
            if (Object.assign(e, {
                slides: c,
                snapGrid: u,
                slidesGrid: h,
                slidesSizesGrid: m
            }), a.centeredSlides && a.cssMode && !a.centeredSlidesBounds) {
                v(e.wrapperEl, "--swiper-centered-offset-before", -u[0] + "px"), v(e.wrapperEl, "--swiper-centered-offset-after", e.size / 2 - m[m.length - 1] / 2 + "px");
                const t = -e.snapGrid[0], s = -e.slidesGrid[0];
                e.snapGrid = e.snapGrid.map((e => e + t)), e.slidesGrid = e.slidesGrid.map((e => e + s))
            }
            if (p !== d && e.emit("slidesLengthChange"), u.length !== w && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), h.length !== b && e.emit("slidesGridLengthChange"), a.watchSlidesProgress && e.updateSlidesOffset(), !(o || a.cssMode || "slide" !== a.effect && "fade" !== a.effect)) {
                const t = `${a.containerModifierClass}backface-hidden`, s = e.$el.hasClass(t);
                p <= a.maxBackfaceHiddenSlides ? s || e.$el.addClass(t) : s && e.$el.removeClass(t)
            }
        }, updateAutoHeight: function (e) {
            const t = this, s = [], a = t.virtual && t.params.virtual.enabled;
            let i, r = 0;
            "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed);
            const n = e => a ? t.slides.filter((t => parseInt(t.getAttribute("data-swiper-slide-index"), 10) === e))[0] : t.slides.eq(e)[0];
            if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1) if (t.params.centeredSlides) (t.visibleSlides || d([])).each((e => {
                s.push(e)
            })); else for (i = 0; i < Math.ceil(t.params.slidesPerView); i += 1) {
                const e = t.activeIndex + i;
                if (e > t.slides.length && !a) break;
                s.push(n(e))
            } else s.push(n(t.activeIndex));
            for (i = 0; i < s.length; i += 1) if (void 0 !== s[i]) {
                const e = s[i].offsetHeight;
                r = e > r ? e : r
            }
            (r || 0 === r) && t.$wrapperEl.css("height", `${r}px`)
        }, updateSlidesOffset: function () {
            const e = this, t = e.slides;
            for (let s = 0; s < t.length; s += 1) t[s].swiperSlideOffset = e.isHorizontal() ? t[s].offsetLeft : t[s].offsetTop
        }, updateSlidesProgress: function (e) {
            void 0 === e && (e = this && this.translate || 0);
            const t = this, s = t.params, {slides: a, rtlTranslate: i, snapGrid: r} = t;
            if (0 === a.length) return;
            void 0 === a[0].swiperSlideOffset && t.updateSlidesOffset();
            let n = -e;
            i && (n = e), a.removeClass(s.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = [];
            for (let e = 0; e < a.length; e += 1) {
                const l = a[e];
                let o = l.swiperSlideOffset;
                s.cssMode && s.centeredSlides && (o -= a[0].swiperSlideOffset);
                const d = (n + (s.centeredSlides ? t.minTranslate() : 0) - o) / (l.swiperSlideSize + s.spaceBetween),
                    c = (n - r[0] + (s.centeredSlides ? t.minTranslate() : 0) - o) / (l.swiperSlideSize + s.spaceBetween),
                    p = -(n - o), u = p + t.slidesSizesGrid[e];
                (p >= 0 && p < t.size - 1 || u > 1 && u <= t.size || p <= 0 && u >= t.size) && (t.visibleSlides.push(l), t.visibleSlidesIndexes.push(e), a.eq(e).addClass(s.slideVisibleClass)), l.progress = i ? -d : d, l.originalProgress = i ? -c : c
            }
            t.visibleSlides = d(t.visibleSlides)
        }, updateProgress: function (e) {
            const t = this;
            if (void 0 === e) {
                const s = t.rtlTranslate ? -1 : 1;
                e = t && t.translate && t.translate * s || 0
            }
            const s = t.params, a = t.maxTranslate() - t.minTranslate();
            let {progress: i, isBeginning: r, isEnd: n} = t;
            const l = r, o = n;
            0 === a ? (i = 0, r = !0, n = !0) : (i = (e - t.minTranslate()) / a, r = i <= 0, n = i >= 1), Object.assign(t, {
                progress: i,
                isBeginning: r,
                isEnd: n
            }), (s.watchSlidesProgress || s.centeredSlides && s.autoHeight) && t.updateSlidesProgress(e), r && !l && t.emit("reachBeginning toEdge"), n && !o && t.emit("reachEnd toEdge"), (l && !r || o && !n) && t.emit("fromEdge"), t.emit("progress", i)
        }, updateSlidesClasses: function () {
            const e = this, {slides: t, params: s, $wrapperEl: a, activeIndex: i, realIndex: r} = e,
                n = e.virtual && s.virtual.enabled;
            let l;
            t.removeClass(`${s.slideActiveClass} ${s.slideNextClass} ${s.slidePrevClass} ${s.slideDuplicateActiveClass} ${s.slideDuplicateNextClass} ${s.slideDuplicatePrevClass}`), l = n ? e.$wrapperEl.find(`.${s.slideClass}[data-swiper-slide-index="${i}"]`) : t.eq(i), l.addClass(s.slideActiveClass), s.loop && (l.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${r}"]`).addClass(s.slideDuplicateActiveClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${r}"]`).addClass(s.slideDuplicateActiveClass));
            let o = l.nextAll(`.${s.slideClass}`).eq(0).addClass(s.slideNextClass);
            s.loop && 0 === o.length && (o = t.eq(0), o.addClass(s.slideNextClass));
            let d = l.prevAll(`.${s.slideClass}`).eq(0).addClass(s.slidePrevClass);
            s.loop && 0 === d.length && (d = t.eq(-1), d.addClass(s.slidePrevClass)), s.loop && (o.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${o.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicateNextClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${o.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicateNextClass), d.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${d.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicatePrevClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${d.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicatePrevClass)), e.emitSlidesClasses()
        }, updateActiveIndex: function (e) {
            const t = this, s = t.rtlTranslate ? t.translate : -t.translate, {
                slidesGrid: a,
                snapGrid: i,
                params: r,
                activeIndex: n,
                realIndex: l,
                snapIndex: o
            } = t;
            let d, c = e;
            if (void 0 === c) {
                for (let e = 0; e < a.length; e += 1) void 0 !== a[e + 1] ? s >= a[e] && s < a[e + 1] - (a[e + 1] - a[e]) / 2 ? c = e : s >= a[e] && s < a[e + 1] && (c = e + 1) : s >= a[e] && (c = e);
                r.normalizeSlideIndex && (c < 0 || void 0 === c) && (c = 0)
            }
            if (i.indexOf(s) >= 0) d = i.indexOf(s); else {
                const e = Math.min(r.slidesPerGroupSkip, c);
                d = e + Math.floor((c - e) / r.slidesPerGroup)
            }
            if (d >= i.length && (d = i.length - 1), c === n) return void (d !== o && (t.snapIndex = d, t.emit("snapIndexChange")));
            const p = parseInt(t.slides.eq(c).attr("data-swiper-slide-index") || c, 10);
            Object.assign(t, {
                snapIndex: d,
                realIndex: p,
                previousIndex: n,
                activeIndex: c
            }), t.emit("activeIndexChange"), t.emit("snapIndexChange"), l !== p && t.emit("realIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange")
        }, updateClickedSlide: function (e) {
            const t = this, s = t.params, a = d(e).closest(`.${s.slideClass}`)[0];
            let i, r = !1;
            if (a) for (let e = 0; e < t.slides.length; e += 1) if (t.slides[e] === a) {
                r = !0, i = e;
                break
            }
            if (!a || !r) return t.clickedSlide = void 0, void (t.clickedIndex = void 0);
            t.clickedSlide = a, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(d(a).attr("data-swiper-slide-index"), 10) : t.clickedIndex = i, s.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide()
        }
    };
    var M = {
        getTranslate: function (e) {
            void 0 === e && (e = this.isHorizontal() ? "x" : "y");
            const {params: t, rtlTranslate: s, translate: a, $wrapperEl: i} = this;
            if (t.virtualTranslate) return s ? -a : a;
            if (t.cssMode) return a;
            let r = h(i[0], e);
            return s && (r = -r), r || 0
        }, setTranslate: function (e, t) {
            const s = this, {rtlTranslate: a, params: i, $wrapperEl: r, wrapperEl: n, progress: l} = s;
            let o, d = 0, c = 0;
            s.isHorizontal() ? d = a ? -e : e : c = e, i.roundLengths && (d = Math.floor(d), c = Math.floor(c)), i.cssMode ? n[s.isHorizontal() ? "scrollLeft" : "scrollTop"] = s.isHorizontal() ? -d : -c : i.virtualTranslate || r.transform(`translate3d(${d}px, ${c}px, 0px)`), s.previousTranslate = s.translate, s.translate = s.isHorizontal() ? d : c;
            const p = s.maxTranslate() - s.minTranslate();
            o = 0 === p ? 0 : (e - s.minTranslate()) / p, o !== l && s.updateProgress(e), s.emit("setTranslate", s.translate, t)
        }, minTranslate: function () {
            return -this.snapGrid[0]
        }, maxTranslate: function () {
            return -this.snapGrid[this.snapGrid.length - 1]
        }, translateTo: function (e, t, s, a, i) {
            void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), void 0 === a && (a = !0);
            const r = this, {params: n, wrapperEl: l} = r;
            if (r.animating && n.preventInteractionOnTransition) return !1;
            const o = r.minTranslate(), d = r.maxTranslate();
            let c;
            if (c = a && e > o ? o : a && e < d ? d : e, r.updateProgress(c), n.cssMode) {
                const e = r.isHorizontal();
                if (0 === t) l[e ? "scrollLeft" : "scrollTop"] = -c; else {
                    if (!r.support.smoothScroll) return w({
                        swiper: r,
                        targetPosition: -c,
                        side: e ? "left" : "top"
                    }), !0;
                    l.scrollTo({[e ? "left" : "top"]: -c, behavior: "smooth"})
                }
                return !0
            }
            return 0 === t ? (r.setTransition(0), r.setTranslate(c), s && (r.emit("beforeTransitionStart", t, i), r.emit("transitionEnd"))) : (r.setTransition(t), r.setTranslate(c), s && (r.emit("beforeTransitionStart", t, i), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function (e) {
                r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, s && r.emit("transitionEnd"))
            }), r.$wrapperEl[0].addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd))), !0
        }
    };

    function P(e) {
        let {swiper: t, runCallbacks: s, direction: a, step: i} = e;
        const {activeIndex: r, previousIndex: n} = t;
        let l = a;
        if (l || (l = r > n ? "next" : r < n ? "prev" : "reset"), t.emit(`transition${i}`), s && r !== n) {
            if ("reset" === l) return void t.emit(`slideResetTransition${i}`);
            t.emit(`slideChangeTransition${i}`), "next" === l ? t.emit(`slideNextTransition${i}`) : t.emit(`slidePrevTransition${i}`)
        }
    }

    var k = {
        slideTo: function (e, t, s, a, i) {
            if (void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), "number" != typeof e && "string" != typeof e) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof e}] given.`);
            if ("string" == typeof e) {
                const t = parseInt(e, 10);
                if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`);
                e = t
            }
            const r = this;
            let n = e;
            n < 0 && (n = 0);
            const {
                params: l,
                snapGrid: o,
                slidesGrid: d,
                previousIndex: c,
                activeIndex: p,
                rtlTranslate: u,
                wrapperEl: h,
                enabled: m
            } = r;
            if (r.animating && l.preventInteractionOnTransition || !m && !a && !i) return !1;
            const f = Math.min(r.params.slidesPerGroupSkip, n);
            let g = f + Math.floor((n - f) / r.params.slidesPerGroup);
            g >= o.length && (g = o.length - 1);
            const v = -o[g];
            if (l.normalizeSlideIndex) for (let e = 0; e < d.length; e += 1) {
                const t = -Math.floor(100 * v), s = Math.floor(100 * d[e]), a = Math.floor(100 * d[e + 1]);
                void 0 !== d[e + 1] ? t >= s && t < a - (a - s) / 2 ? n = e : t >= s && t < a && (n = e + 1) : t >= s && (n = e)
            }
            if (r.initialized && n !== p) {
                if (!r.allowSlideNext && v < r.translate && v < r.minTranslate()) return !1;
                if (!r.allowSlidePrev && v > r.translate && v > r.maxTranslate() && (p || 0) !== n) return !1
            }
            let b;
            if (n !== (c || 0) && s && r.emit("beforeSlideChangeStart"), r.updateProgress(v), b = n > p ? "next" : n < p ? "prev" : "reset", u && -v === r.translate || !u && v === r.translate) return r.updateActiveIndex(n), l.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), "slide" !== l.effect && r.setTranslate(v), "reset" !== b && (r.transitionStart(s, b), r.transitionEnd(s, b)), !1;
            if (l.cssMode) {
                const e = r.isHorizontal(), s = u ? v : -v;
                if (0 === t) {
                    const t = r.virtual && r.params.virtual.enabled;
                    t && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), h[e ? "scrollLeft" : "scrollTop"] = s, t && requestAnimationFrame((() => {
                        r.wrapperEl.style.scrollSnapType = "", r._swiperImmediateVirtual = !1
                    }))
                } else {
                    if (!r.support.smoothScroll) return w({swiper: r, targetPosition: s, side: e ? "left" : "top"}), !0;
                    h.scrollTo({[e ? "left" : "top"]: s, behavior: "smooth"})
                }
                return !0
            }
            return r.setTransition(t), r.setTranslate(v), r.updateActiveIndex(n), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, a), r.transitionStart(s, b), 0 === t ? r.transitionEnd(s, b) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function (e) {
                r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(s, b))
            }), r.$wrapperEl[0].addEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd)), !0
        }, slideToLoop: function (e, t, s, a) {
            if (void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), "string" == typeof e) {
                const t = parseInt(e, 10);
                if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`);
                e = t
            }
            const i = this;
            let r = e;
            return i.params.loop && (r += i.loopedSlides), i.slideTo(r, t, s, a)
        }, slideNext: function (e, t, s) {
            void 0 === e && (e = this.params.speed), void 0 === t && (t = !0);
            const a = this, {animating: i, enabled: r, params: n} = a;
            if (!r) return a;
            let l = n.slidesPerGroup;
            "auto" === n.slidesPerView && 1 === n.slidesPerGroup && n.slidesPerGroupAuto && (l = Math.max(a.slidesPerViewDynamic("current", !0), 1));
            const o = a.activeIndex < n.slidesPerGroupSkip ? 1 : l;
            if (n.loop) {
                if (i && n.loopPreventsSlide) return !1;
                a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft
            }
            return n.rewind && a.isEnd ? a.slideTo(0, e, t, s) : a.slideTo(a.activeIndex + o, e, t, s)
        }, slidePrev: function (e, t, s) {
            void 0 === e && (e = this.params.speed), void 0 === t && (t = !0);
            const a = this, {params: i, animating: r, snapGrid: n, slidesGrid: l, rtlTranslate: o, enabled: d} = a;
            if (!d) return a;
            if (i.loop) {
                if (r && i.loopPreventsSlide) return !1;
                a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft
            }

            function c(e) {
                return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e)
            }

            const p = c(o ? a.translate : -a.translate), u = n.map((e => c(e)));
            let h = n[u.indexOf(p) - 1];
            if (void 0 === h && i.cssMode) {
                let e;
                n.forEach(((t, s) => {
                    p >= t && (e = s)
                })), void 0 !== e && (h = n[e > 0 ? e - 1 : e])
            }
            let m = 0;
            if (void 0 !== h && (m = l.indexOf(h), m < 0 && (m = a.activeIndex - 1), "auto" === i.slidesPerView && 1 === i.slidesPerGroup && i.slidesPerGroupAuto && (m = m - a.slidesPerViewDynamic("previous", !0) + 1, m = Math.max(m, 0))), i.rewind && a.isBeginning) {
                const i = a.params.virtual && a.params.virtual.enabled && a.virtual ? a.virtual.slides.length - 1 : a.slides.length - 1;
                return a.slideTo(i, e, t, s)
            }
            return a.slideTo(m, e, t, s)
        }, slideReset: function (e, t, s) {
            return void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), this.slideTo(this.activeIndex, e, t, s)
        }, slideToClosest: function (e, t, s, a) {
            void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), void 0 === a && (a = .5);
            const i = this;
            let r = i.activeIndex;
            const n = Math.min(i.params.slidesPerGroupSkip, r), l = n + Math.floor((r - n) / i.params.slidesPerGroup),
                o = i.rtlTranslate ? i.translate : -i.translate;
            if (o >= i.snapGrid[l]) {
                const e = i.snapGrid[l];
                o - e > (i.snapGrid[l + 1] - e) * a && (r += i.params.slidesPerGroup)
            } else {
                const e = i.snapGrid[l - 1];
                o - e <= (i.snapGrid[l] - e) * a && (r -= i.params.slidesPerGroup)
            }
            return r = Math.max(r, 0), r = Math.min(r, i.slidesGrid.length - 1), i.slideTo(r, e, t, s)
        }, slideToClickedSlide: function () {
            const e = this, {params: t, $wrapperEl: s} = e,
                a = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView;
            let i, r = e.clickedIndex;
            if (t.loop) {
                if (e.animating) return;
                i = parseInt(d(e.clickedSlide).attr("data-swiper-slide-index"), 10), t.centeredSlides ? r < e.loopedSlides - a / 2 || r > e.slides.length - e.loopedSlides + a / 2 ? (e.loopFix(), r = s.children(`.${t.slideClass}[data-swiper-slide-index="${i}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), p((() => {
                    e.slideTo(r)
                }))) : e.slideTo(r) : r > e.slides.length - a ? (e.loopFix(), r = s.children(`.${t.slideClass}[data-swiper-slide-index="${i}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), p((() => {
                    e.slideTo(r)
                }))) : e.slideTo(r)
            } else e.slideTo(r)
        }
    };
    var z = {
        loopCreate: function () {
            const e = this, t = a(), {params: s, $wrapperEl: i} = e,
                r = i.children().length > 0 ? d(i.children()[0].parentNode) : i;
            r.children(`.${s.slideClass}.${s.slideDuplicateClass}`).remove();
            let n = r.children(`.${s.slideClass}`);
            if (s.loopFillGroupWithBlank) {
                const e = s.slidesPerGroup - n.length % s.slidesPerGroup;
                if (e !== s.slidesPerGroup) {
                    for (let a = 0; a < e; a += 1) {
                        const e = d(t.createElement("div")).addClass(`${s.slideClass} ${s.slideBlankClass}`);
                        r.append(e)
                    }
                    n = r.children(`.${s.slideClass}`)
                }
            }
            "auto" !== s.slidesPerView || s.loopedSlides || (s.loopedSlides = n.length), e.loopedSlides = Math.ceil(parseFloat(s.loopedSlides || s.slidesPerView, 10)), e.loopedSlides += s.loopAdditionalSlides, e.loopedSlides > n.length && e.params.loopedSlidesLimit && (e.loopedSlides = n.length);
            const l = [], o = [];
            n.each(((e, t) => {
                d(e).attr("data-swiper-slide-index", t)
            }));
            for (let t = 0; t < e.loopedSlides; t += 1) {
                const e = t - Math.floor(t / n.length) * n.length;
                o.push(n.eq(e)[0]), l.unshift(n.eq(n.length - e - 1)[0])
            }
            for (let e = 0; e < o.length; e += 1) r.append(d(o[e].cloneNode(!0)).addClass(s.slideDuplicateClass));
            for (let e = l.length - 1; e >= 0; e -= 1) r.prepend(d(l[e].cloneNode(!0)).addClass(s.slideDuplicateClass))
        }, loopFix: function () {
            const e = this;
            e.emit("beforeLoopFix");
            const {
                activeIndex: t,
                slides: s,
                loopedSlides: a,
                allowSlidePrev: i,
                allowSlideNext: r,
                snapGrid: n,
                rtlTranslate: l
            } = e;
            let o;
            e.allowSlidePrev = !0, e.allowSlideNext = !0;
            const d = -n[t] - e.getTranslate();
            if (t < a) {
                o = s.length - 3 * a + t, o += a;
                e.slideTo(o, 0, !1, !0) && 0 !== d && e.setTranslate((l ? -e.translate : e.translate) - d)
            } else if (t >= s.length - a) {
                o = -s.length + t + a, o += a;
                e.slideTo(o, 0, !1, !0) && 0 !== d && e.setTranslate((l ? -e.translate : e.translate) - d)
            }
            e.allowSlidePrev = i, e.allowSlideNext = r, e.emit("loopFix")
        }, loopDestroy: function () {
            const {$wrapperEl: e, params: t, slides: s} = this;
            e.children(`.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`).remove(), s.removeAttr("data-swiper-slide-index")
        }
    };

    function L(e) {
        const t = this, s = a(), i = r(), n = t.touchEventsData, {params: l, touches: o, enabled: c} = t;
        if (!c) return;
        if (t.animating && l.preventInteractionOnTransition) return;
        !t.animating && l.cssMode && l.loop && t.loopFix();
        let p = e;
        p.originalEvent && (p = p.originalEvent);
        let h = d(p.target);
        if ("wrapper" === l.touchEventsTarget && !h.closest(t.wrapperEl).length) return;
        if (n.isTouchEvent = "touchstart" === p.type, !n.isTouchEvent && "which" in p && 3 === p.which) return;
        if (!n.isTouchEvent && "button" in p && p.button > 0) return;
        if (n.isTouched && n.isMoved) return;
        const m = !!l.noSwipingClass && "" !== l.noSwipingClass, f = e.composedPath ? e.composedPath() : e.path;
        m && p.target && p.target.shadowRoot && f && (h = d(f[0]));
        const g = l.noSwipingSelector ? l.noSwipingSelector : `.${l.noSwipingClass}`,
            v = !(!p.target || !p.target.shadowRoot);
        if (l.noSwiping && (v ? function (e, t) {
            return void 0 === t && (t = this), function t(s) {
                if (!s || s === a() || s === r()) return null;
                s.assignedSlot && (s = s.assignedSlot);
                const i = s.closest(e);
                return i || s.getRootNode ? i || t(s.getRootNode().host) : null
            }(t)
        }(g, h[0]) : h.closest(g)[0])) return void (t.allowClick = !0);
        if (l.swipeHandler && !h.closest(l.swipeHandler)[0]) return;
        o.currentX = "touchstart" === p.type ? p.targetTouches[0].pageX : p.pageX, o.currentY = "touchstart" === p.type ? p.targetTouches[0].pageY : p.pageY;
        const w = o.currentX, b = o.currentY, x = l.edgeSwipeDetection || l.iOSEdgeSwipeDetection,
            y = l.edgeSwipeThreshold || l.iOSEdgeSwipeThreshold;
        if (x && (w <= y || w >= i.innerWidth - y)) {
            if ("prevent" !== x) return;
            e.preventDefault()
        }
        if (Object.assign(n, {
            isTouched: !0,
            isMoved: !1,
            allowTouchCallbacks: !0,
            isScrolling: void 0,
            startMoving: void 0
        }), o.startX = w, o.startY = b, n.touchStartTime = u(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, l.threshold > 0 && (n.allowThresholdMove = !1), "touchstart" !== p.type) {
            let e = !0;
            h.is(n.focusableElements) && (e = !1, "SELECT" === h[0].nodeName && (n.isTouched = !1)), s.activeElement && d(s.activeElement).is(n.focusableElements) && s.activeElement !== h[0] && s.activeElement.blur();
            const a = e && t.allowTouchMove && l.touchStartPreventDefault;
            !l.touchStartForcePreventDefault && !a || h[0].isContentEditable || p.preventDefault()
        }
        t.params.freeMode && t.params.freeMode.enabled && t.freeMode && t.animating && !l.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", p)
    }

    function O(e) {
        const t = a(), s = this, i = s.touchEventsData, {params: r, touches: n, rtlTranslate: l, enabled: o} = s;
        if (!o) return;
        let c = e;
        if (c.originalEvent && (c = c.originalEvent), !i.isTouched) return void (i.startMoving && i.isScrolling && s.emit("touchMoveOpposite", c));
        if (i.isTouchEvent && "touchmove" !== c.type) return;
        const p = "touchmove" === c.type && c.targetTouches && (c.targetTouches[0] || c.changedTouches[0]),
            h = "touchmove" === c.type ? p.pageX : c.pageX, m = "touchmove" === c.type ? p.pageY : c.pageY;
        if (c.preventedByNestedSwiper) return n.startX = h, void (n.startY = m);
        if (!s.allowTouchMove) return d(c.target).is(i.focusableElements) || (s.allowClick = !1), void (i.isTouched && (Object.assign(n, {
            startX: h,
            startY: m,
            currentX: h,
            currentY: m
        }), i.touchStartTime = u()));
        if (i.isTouchEvent && r.touchReleaseOnEdges && !r.loop) if (s.isVertical()) {
            if (m < n.startY && s.translate <= s.maxTranslate() || m > n.startY && s.translate >= s.minTranslate()) return i.isTouched = !1, void (i.isMoved = !1)
        } else if (h < n.startX && s.translate <= s.maxTranslate() || h > n.startX && s.translate >= s.minTranslate()) return;
        if (i.isTouchEvent && t.activeElement && c.target === t.activeElement && d(c.target).is(i.focusableElements)) return i.isMoved = !0, void (s.allowClick = !1);
        if (i.allowTouchCallbacks && s.emit("touchMove", c), c.targetTouches && c.targetTouches.length > 1) return;
        n.currentX = h, n.currentY = m;
        const f = n.currentX - n.startX, g = n.currentY - n.startY;
        if (s.params.threshold && Math.sqrt(f ** 2 + g ** 2) < s.params.threshold) return;
        if (void 0 === i.isScrolling) {
            let e;
            s.isHorizontal() && n.currentY === n.startY || s.isVertical() && n.currentX === n.startX ? i.isScrolling = !1 : f * f + g * g >= 25 && (e = 180 * Math.atan2(Math.abs(g), Math.abs(f)) / Math.PI, i.isScrolling = s.isHorizontal() ? e > r.touchAngle : 90 - e > r.touchAngle)
        }
        if (i.isScrolling && s.emit("touchMoveOpposite", c), void 0 === i.startMoving && (n.currentX === n.startX && n.currentY === n.startY || (i.startMoving = !0)), i.isScrolling) return void (i.isTouched = !1);
        if (!i.startMoving) return;
        s.allowClick = !1, !r.cssMode && c.cancelable && c.preventDefault(), r.touchMoveStopPropagation && !r.nested && c.stopPropagation(), i.isMoved || (r.loop && !r.cssMode && s.loopFix(), i.startTranslate = s.getTranslate(), s.setTransition(0), s.animating && s.$wrapperEl.trigger("webkitTransitionEnd transitionend"), i.allowMomentumBounce = !1, !r.grabCursor || !0 !== s.allowSlideNext && !0 !== s.allowSlidePrev || s.setGrabCursor(!0), s.emit("sliderFirstMove", c)), s.emit("sliderMove", c), i.isMoved = !0;
        let v = s.isHorizontal() ? f : g;
        n.diff = v, v *= r.touchRatio, l && (v = -v), s.swipeDirection = v > 0 ? "prev" : "next", i.currentTranslate = v + i.startTranslate;
        let w = !0, b = r.resistanceRatio;
        if (r.touchReleaseOnEdges && (b = 0), v > 0 && i.currentTranslate > s.minTranslate() ? (w = !1, r.resistance && (i.currentTranslate = s.minTranslate() - 1 + (-s.minTranslate() + i.startTranslate + v) ** b)) : v < 0 && i.currentTranslate < s.maxTranslate() && (w = !1, r.resistance && (i.currentTranslate = s.maxTranslate() + 1 - (s.maxTranslate() - i.startTranslate - v) ** b)), w && (c.preventedByNestedSwiper = !0), !s.allowSlideNext && "next" === s.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !s.allowSlidePrev && "prev" === s.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), s.allowSlidePrev || s.allowSlideNext || (i.currentTranslate = i.startTranslate), r.threshold > 0) {
            if (!(Math.abs(v) > r.threshold || i.allowThresholdMove)) return void (i.currentTranslate = i.startTranslate);
            if (!i.allowThresholdMove) return i.allowThresholdMove = !0, n.startX = n.currentX, n.startY = n.currentY, i.currentTranslate = i.startTranslate, void (n.diff = s.isHorizontal() ? n.currentX - n.startX : n.currentY - n.startY)
        }
        r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && s.freeMode || r.watchSlidesProgress) && (s.updateActiveIndex(), s.updateSlidesClasses()), s.params.freeMode && r.freeMode.enabled && s.freeMode && s.freeMode.onTouchMove(), s.updateProgress(i.currentTranslate), s.setTranslate(i.currentTranslate))
    }

    function I(e) {
        const t = this, s = t.touchEventsData, {params: a, touches: i, rtlTranslate: r, slidesGrid: n, enabled: l} = t;
        if (!l) return;
        let o = e;
        if (o.originalEvent && (o = o.originalEvent), s.allowTouchCallbacks && t.emit("touchEnd", o), s.allowTouchCallbacks = !1, !s.isTouched) return s.isMoved && a.grabCursor && t.setGrabCursor(!1), s.isMoved = !1, void (s.startMoving = !1);
        a.grabCursor && s.isMoved && s.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1);
        const d = u(), c = d - s.touchStartTime;
        if (t.allowClick) {
            const e = o.path || o.composedPath && o.composedPath();
            t.updateClickedSlide(e && e[0] || o.target), t.emit("tap click", o), c < 300 && d - s.lastClickTime < 300 && t.emit("doubleTap doubleClick", o)
        }
        if (s.lastClickTime = u(), p((() => {
            t.destroyed || (t.allowClick = !0)
        })), !s.isTouched || !s.isMoved || !t.swipeDirection || 0 === i.diff || s.currentTranslate === s.startTranslate) return s.isTouched = !1, s.isMoved = !1, void (s.startMoving = !1);
        let h;
        if (s.isTouched = !1, s.isMoved = !1, s.startMoving = !1, h = a.followFinger ? r ? t.translate : -t.translate : -s.currentTranslate, a.cssMode) return;
        if (t.params.freeMode && a.freeMode.enabled) return void t.freeMode.onTouchEnd({currentPos: h});
        let m = 0, f = t.slidesSizesGrid[0];
        for (let e = 0; e < n.length; e += e < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup) {
            const t = e < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
            void 0 !== n[e + t] ? h >= n[e] && h < n[e + t] && (m = e, f = n[e + t] - n[e]) : h >= n[e] && (m = e, f = n[n.length - 1] - n[n.length - 2])
        }
        let g = null, v = null;
        a.rewind && (t.isBeginning ? v = t.params.virtual && t.params.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (g = 0));
        const w = (h - n[m]) / f, b = m < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
        if (c > a.longSwipesMs) {
            if (!a.longSwipes) return void t.slideTo(t.activeIndex);
            "next" === t.swipeDirection && (w >= a.longSwipesRatio ? t.slideTo(a.rewind && t.isEnd ? g : m + b) : t.slideTo(m)), "prev" === t.swipeDirection && (w > 1 - a.longSwipesRatio ? t.slideTo(m + b) : null !== v && w < 0 && Math.abs(w) > a.longSwipesRatio ? t.slideTo(v) : t.slideTo(m))
        } else {
            if (!a.shortSwipes) return void t.slideTo(t.activeIndex);
            t.navigation && (o.target === t.navigation.nextEl || o.target === t.navigation.prevEl) ? o.target === t.navigation.nextEl ? t.slideTo(m + b) : t.slideTo(m) : ("next" === t.swipeDirection && t.slideTo(null !== g ? g : m + b), "prev" === t.swipeDirection && t.slideTo(null !== v ? v : m))
        }
    }

    function A() {
        const e = this, {params: t, el: s} = e;
        if (s && 0 === s.offsetWidth) return;
        t.breakpoints && e.setBreakpoint();
        const {allowSlideNext: a, allowSlidePrev: i, snapGrid: r} = e;
        e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), ("auto" === t.slidesPerView || t.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = i, e.allowSlideNext = a, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow()
    }

    function D(e) {
        const t = this;
        t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation())))
    }

    function G() {
        const e = this, {wrapperEl: t, rtlTranslate: s, enabled: a} = e;
        if (!a) return;
        let i;
        e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses();
        const r = e.maxTranslate() - e.minTranslate();
        i = 0 === r ? 0 : (e.translate - e.minTranslate()) / r, i !== e.progress && e.updateProgress(s ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1)
    }

    let N = !1;

    function B() {
    }

    const H = (e, t) => {
        const s = a(), {params: i, touchEvents: r, el: n, wrapperEl: l, device: o, support: d} = e, c = !!i.nested,
            p = "on" === t ? "addEventListener" : "removeEventListener", u = t;
        if (d.touch) {
            const t = !("touchstart" !== r.start || !d.passiveListener || !i.passiveListeners) && {
                passive: !0,
                capture: !1
            };
            n[p](r.start, e.onTouchStart, t), n[p](r.move, e.onTouchMove, d.passiveListener ? {
                passive: !1,
                capture: c
            } : c), n[p](r.end, e.onTouchEnd, t), r.cancel && n[p](r.cancel, e.onTouchEnd, t)
        } else n[p](r.start, e.onTouchStart, !1), s[p](r.move, e.onTouchMove, c), s[p](r.end, e.onTouchEnd, !1);
        (i.preventClicks || i.preventClicksPropagation) && n[p]("click", e.onClick, !0), i.cssMode && l[p]("scroll", e.onScroll), i.updateOnWindowResize ? e[u](o.ios || o.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", A, !0) : e[u]("observerUpdate", A, !0)
    };
    var X = {
        attachEvents: function () {
            const e = this, t = a(), {params: s, support: i} = e;
            e.onTouchStart = L.bind(e), e.onTouchMove = O.bind(e), e.onTouchEnd = I.bind(e), s.cssMode && (e.onScroll = G.bind(e)), e.onClick = D.bind(e), i.touch && !N && (t.addEventListener("touchstart", B), N = !0), H(e, "on")
        }, detachEvents: function () {
            H(this, "off")
        }
    };
    const Y = (e, t) => e.grid && t.grid && t.grid.rows > 1;
    var R = {
        addClasses: function () {
            const e = this, {classNames: t, params: s, rtl: a, $el: i, device: r, support: n} = e, l = function (e, t) {
                const s = [];
                return e.forEach((e => {
                    "object" == typeof e ? Object.keys(e).forEach((a => {
                        e[a] && s.push(t + a)
                    })) : "string" == typeof e && s.push(t + e)
                })), s
            }(["initialized", s.direction, {"pointer-events": !n.touch}, {"free-mode": e.params.freeMode && s.freeMode.enabled}, {autoheight: s.autoHeight}, {rtl: a}, {grid: s.grid && s.grid.rows > 1}, {"grid-column": s.grid && s.grid.rows > 1 && "column" === s.grid.fill}, {android: r.android}, {ios: r.ios}, {"css-mode": s.cssMode}, {centered: s.cssMode && s.centeredSlides}, {"watch-progress": s.watchSlidesProgress}], s.containerModifierClass);
            t.push(...l), i.addClass([...t].join(" ")), e.emitContainerClasses()
        }, removeClasses: function () {
            const {$el: e, classNames: t} = this;
            e.removeClass(t.join(" ")), this.emitContainerClasses()
        }
    };
    var W = {
        init: !0,
        direction: "horizontal",
        touchEventsTarget: "wrapper",
        initialSlide: 0,
        speed: 300,
        cssMode: !1,
        updateOnWindowResize: !0,
        resizeObserver: !0,
        nested: !1,
        createElements: !1,
        enabled: !0,
        focusableElements: "input, select, option, textarea, button, video, label",
        width: null,
        height: null,
        preventInteractionOnTransition: !1,
        userAgent: null,
        url: null,
        edgeSwipeDetection: !1,
        edgeSwipeThreshold: 20,
        autoHeight: !1,
        setWrapperSize: !1,
        virtualTranslate: !1,
        effect: "slide",
        breakpoints: void 0,
        breakpointsBase: "window",
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: !1,
        centeredSlides: !1,
        centeredSlidesBounds: !1,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: !0,
        centerInsufficientSlides: !1,
        watchOverflow: !0,
        roundLengths: !1,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: !0,
        shortSwipes: !0,
        longSwipes: !0,
        longSwipesRatio: .5,
        longSwipesMs: 300,
        followFinger: !0,
        allowTouchMove: !0,
        threshold: 0,
        touchMoveStopPropagation: !1,
        touchStartPreventDefault: !0,
        touchStartForcePreventDefault: !1,
        touchReleaseOnEdges: !1,
        uniqueNavElements: !0,
        resistance: !0,
        resistanceRatio: .85,
        watchSlidesProgress: !1,
        grabCursor: !1,
        preventClicks: !0,
        preventClicksPropagation: !0,
        slideToClickedSlide: !1,
        preloadImages: !0,
        updateOnImagesReady: !0,
        loop: !1,
        loopAdditionalSlides: 0,
        loopedSlides: null,
        loopedSlidesLimit: !0,
        loopFillGroupWithBlank: !1,
        loopPreventsSlide: !0,
        rewind: !1,
        allowSlidePrev: !0,
        allowSlideNext: !0,
        swipeHandler: null,
        noSwiping: !0,
        noSwipingClass: "swiper-no-swiping",
        noSwipingSelector: null,
        passiveListeners: !0,
        maxBackfaceHiddenSlides: 10,
        containerModifierClass: "swiper-",
        slideClass: "swiper-slide",
        slideBlankClass: "swiper-slide-invisible-blank",
        slideActiveClass: "swiper-slide-active",
        slideDuplicateActiveClass: "swiper-slide-duplicate-active",
        slideVisibleClass: "swiper-slide-visible",
        slideDuplicateClass: "swiper-slide-duplicate",
        slideNextClass: "swiper-slide-next",
        slideDuplicateNextClass: "swiper-slide-duplicate-next",
        slidePrevClass: "swiper-slide-prev",
        slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
        wrapperClass: "swiper-wrapper",
        runCallbacksOnInit: !0,
        _emitClasses: !1
    };

    function q(e, t) {
        return function (s) {
            void 0 === s && (s = {});
            const a = Object.keys(s)[0], i = s[a];
            "object" == typeof i && null !== i ? (["navigation", "pagination", "scrollbar"].indexOf(a) >= 0 && !0 === e[a] && (e[a] = {auto: !0}), a in e && "enabled" in i ? (!0 === e[a] && (e[a] = {enabled: !0}), "object" != typeof e[a] || "enabled" in e[a] || (e[a].enabled = !0), e[a] || (e[a] = {enabled: !1}), g(t, s)) : g(t, s)) : g(t, s)
        }
    }

    const j = {
        eventsEmitter: $, update: S, translate: M, transition: {
            setTransition: function (e, t) {
                const s = this;
                s.params.cssMode || s.$wrapperEl.transition(e), s.emit("setTransition", e, t)
            }, transitionStart: function (e, t) {
                void 0 === e && (e = !0);
                const s = this, {params: a} = s;
                a.cssMode || (a.autoHeight && s.updateAutoHeight(), P({
                    swiper: s,
                    runCallbacks: e,
                    direction: t,
                    step: "Start"
                }))
            }, transitionEnd: function (e, t) {
                void 0 === e && (e = !0);
                const s = this, {params: a} = s;
                s.animating = !1, a.cssMode || (s.setTransition(0), P({
                    swiper: s,
                    runCallbacks: e,
                    direction: t,
                    step: "End"
                }))
            }
        }, slide: k, loop: z, grabCursor: {
            setGrabCursor: function (e) {
                const t = this;
                if (t.support.touch || !t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return;
                const s = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl;
                s.style.cursor = "move", s.style.cursor = e ? "grabbing" : "grab"
            }, unsetGrabCursor: function () {
                const e = this;
                e.support.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "")
            }
        }, events: X, breakpoints: {
            setBreakpoint: function () {
                const e = this, {activeIndex: t, initialized: s, loopedSlides: a = 0, params: i, $el: r} = e,
                    n = i.breakpoints;
                if (!n || n && 0 === Object.keys(n).length) return;
                const l = e.getBreakpoint(n, e.params.breakpointsBase, e.el);
                if (!l || e.currentBreakpoint === l) return;
                const o = (l in n ? n[l] : void 0) || e.originalParams, d = Y(e, i), c = Y(e, o), p = i.enabled;
                d && !c ? (r.removeClass(`${i.containerModifierClass}grid ${i.containerModifierClass}grid-column`), e.emitContainerClasses()) : !d && c && (r.addClass(`${i.containerModifierClass}grid`), (o.grid.fill && "column" === o.grid.fill || !o.grid.fill && "column" === i.grid.fill) && r.addClass(`${i.containerModifierClass}grid-column`), e.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach((t => {
                    const s = i[t] && i[t].enabled, a = o[t] && o[t].enabled;
                    s && !a && e[t].disable(), !s && a && e[t].enable()
                }));
                const u = o.direction && o.direction !== i.direction,
                    h = i.loop && (o.slidesPerView !== i.slidesPerView || u);
                u && s && e.changeDirection(), g(e.params, o);
                const m = e.params.enabled;
                Object.assign(e, {
                    allowTouchMove: e.params.allowTouchMove,
                    allowSlideNext: e.params.allowSlideNext,
                    allowSlidePrev: e.params.allowSlidePrev
                }), p && !m ? e.disable() : !p && m && e.enable(), e.currentBreakpoint = l, e.emit("_beforeBreakpoint", o), h && s && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - a + e.loopedSlides, 0, !1)), e.emit("breakpoint", o)
            }, getBreakpoint: function (e, t, s) {
                if (void 0 === t && (t = "window"), !e || "container" === t && !s) return;
                let a = !1;
                const i = r(), n = "window" === t ? i.innerHeight : s.clientHeight, l = Object.keys(e).map((e => {
                    if ("string" == typeof e && 0 === e.indexOf("@")) {
                        const t = parseFloat(e.substr(1));
                        return {value: n * t, point: e}
                    }
                    return {value: e, point: e}
                }));
                l.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10)));
                for (let e = 0; e < l.length; e += 1) {
                    const {point: r, value: n} = l[e];
                    "window" === t ? i.matchMedia(`(min-width: ${n}px)`).matches && (a = r) : n <= s.clientWidth && (a = r)
                }
                return a || "max"
            }
        }, checkOverflow: {
            checkOverflow: function () {
                const e = this, {isLocked: t, params: s} = e, {slidesOffsetBefore: a} = s;
                if (a) {
                    const t = e.slides.length - 1, s = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * a;
                    e.isLocked = e.size > s
                } else e.isLocked = 1 === e.snapGrid.length;
                !0 === s.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === s.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock")
            }
        }, classes: R, images: {
            loadImage: function (e, t, s, a, i, n) {
                const l = r();
                let o;

                function c() {
                    n && n()
                }

                d(e).parent("picture")[0] || e.complete && i ? c() : t ? (o = new l.Image, o.onload = c, o.onerror = c, a && (o.sizes = a), s && (o.srcset = s), t && (o.src = t)) : c()
            }, preloadImages: function () {
                const e = this;

                function t() {
                    null != e && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit("imagesReady")))
                }

                e.imagesToLoad = e.$el.find("img");
                for (let s = 0; s < e.imagesToLoad.length; s += 1) {
                    const a = e.imagesToLoad[s];
                    e.loadImage(a, a.currentSrc || a.getAttribute("src"), a.srcset || a.getAttribute("srcset"), a.sizes || a.getAttribute("sizes"), !0, t)
                }
            }
        }
    }, _ = {};

    class V {
        constructor() {
            let e, t;
            for (var s = arguments.length, a = new Array(s), i = 0; i < s; i++) a[i] = arguments[i];
            if (1 === a.length && a[0].constructor && "Object" === Object.prototype.toString.call(a[0]).slice(8, -1) ? t = a[0] : [e, t] = a, t || (t = {}), t = g({}, t), e && !t.el && (t.el = e), t.el && d(t.el).length > 1) {
                const e = [];
                return d(t.el).each((s => {
                    const a = g({}, t, {el: s});
                    e.push(new V(a))
                })), e
            }
            const r = this;
            r.__swiper__ = !0, r.support = E(), r.device = C({userAgent: t.userAgent}), r.browser = T(), r.eventsListeners = {}, r.eventsAnyListeners = [], r.modules = [...r.__modules__], t.modules && Array.isArray(t.modules) && r.modules.push(...t.modules);
            const n = {};
            r.modules.forEach((e => {
                e({
                    swiper: r,
                    extendParams: q(t, n),
                    on: r.on.bind(r),
                    once: r.once.bind(r),
                    off: r.off.bind(r),
                    emit: r.emit.bind(r)
                })
            }));
            const l = g({}, W, n);
            return r.params = g({}, l, _, t), r.originalParams = g({}, r.params), r.passedParams = g({}, t), r.params && r.params.on && Object.keys(r.params.on).forEach((e => {
                r.on(e, r.params.on[e])
            })), r.params && r.params.onAny && r.onAny(r.params.onAny), r.$ = d, Object.assign(r, {
                enabled: r.params.enabled,
                el: e,
                classNames: [],
                slides: d(),
                slidesGrid: [],
                snapGrid: [],
                slidesSizesGrid: [],
                isHorizontal: () => "horizontal" === r.params.direction,
                isVertical: () => "vertical" === r.params.direction,
                activeIndex: 0,
                realIndex: 0,
                isBeginning: !0,
                isEnd: !1,
                translate: 0,
                previousTranslate: 0,
                progress: 0,
                velocity: 0,
                animating: !1,
                allowSlideNext: r.params.allowSlideNext,
                allowSlidePrev: r.params.allowSlidePrev,
                touchEvents: function () {
                    const e = ["touchstart", "touchmove", "touchend", "touchcancel"],
                        t = ["pointerdown", "pointermove", "pointerup"];
                    return r.touchEventsTouch = {
                        start: e[0],
                        move: e[1],
                        end: e[2],
                        cancel: e[3]
                    }, r.touchEventsDesktop = {
                        start: t[0],
                        move: t[1],
                        end: t[2]
                    }, r.support.touch || !r.params.simulateTouch ? r.touchEventsTouch : r.touchEventsDesktop
                }(),
                touchEventsData: {
                    isTouched: void 0,
                    isMoved: void 0,
                    allowTouchCallbacks: void 0,
                    touchStartTime: void 0,
                    isScrolling: void 0,
                    currentTranslate: void 0,
                    startTranslate: void 0,
                    allowThresholdMove: void 0,
                    focusableElements: r.params.focusableElements,
                    lastClickTime: u(),
                    clickTimeout: void 0,
                    velocities: [],
                    allowMomentumBounce: void 0,
                    isTouchEvent: void 0,
                    startMoving: void 0
                },
                allowClick: !0,
                allowTouchMove: r.params.allowTouchMove,
                touches: {startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0},
                imagesToLoad: [],
                imagesLoaded: 0
            }), r.emit("_swiper"), r.params.init && r.init(), r
        }

        enable() {
            const e = this;
            e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable"))
        }

        disable() {
            const e = this;
            e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable"))
        }

        setProgress(e, t) {
            const s = this;
            e = Math.min(Math.max(e, 0), 1);
            const a = s.minTranslate(), i = (s.maxTranslate() - a) * e + a;
            s.translateTo(i, void 0 === t ? 0 : t), s.updateActiveIndex(), s.updateSlidesClasses()
        }

        emitContainerClasses() {
            const e = this;
            if (!e.params._emitClasses || !e.el) return;
            const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass)));
            e.emit("_containerClasses", t.join(" "))
        }

        getSlideClasses(e) {
            const t = this;
            return t.destroyed ? "" : e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ")
        }

        emitSlidesClasses() {
            const e = this;
            if (!e.params._emitClasses || !e.el) return;
            const t = [];
            e.slides.each((s => {
                const a = e.getSlideClasses(s);
                t.push({slideEl: s, classNames: a}), e.emit("_slideClass", s, a)
            })), e.emit("_slideClasses", t)
        }

        slidesPerViewDynamic(e, t) {
            void 0 === e && (e = "current"), void 0 === t && (t = !1);
            const {params: s, slides: a, slidesGrid: i, slidesSizesGrid: r, size: n, activeIndex: l} = this;
            let o = 1;
            if (s.centeredSlides) {
                let e, t = a[l].swiperSlideSize;
                for (let s = l + 1; s < a.length; s += 1) a[s] && !e && (t += a[s].swiperSlideSize, o += 1, t > n && (e = !0));
                for (let s = l - 1; s >= 0; s -= 1) a[s] && !e && (t += a[s].swiperSlideSize, o += 1, t > n && (e = !0))
            } else if ("current" === e) for (let e = l + 1; e < a.length; e += 1) {
                (t ? i[e] + r[e] - i[l] < n : i[e] - i[l] < n) && (o += 1)
            } else for (let e = l - 1; e >= 0; e -= 1) {
                i[l] - i[e] < n && (o += 1)
            }
            return o
        }

        update() {
            const e = this;
            if (!e || e.destroyed) return;
            const {snapGrid: t, params: s} = e;

            function a() {
                const t = e.rtlTranslate ? -1 * e.translate : e.translate,
                    s = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
                e.setTranslate(s), e.updateActiveIndex(), e.updateSlidesClasses()
            }

            let i;
            s.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode && e.params.freeMode.enabled ? (a(), e.params.autoHeight && e.updateAutoHeight()) : (i = ("auto" === e.params.slidesPerView || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), i || a()), s.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update")
        }

        changeDirection(e, t) {
            void 0 === t && (t = !0);
            const s = this, a = s.params.direction;
            return e || (e = "horizontal" === a ? "vertical" : "horizontal"), e === a || "horizontal" !== e && "vertical" !== e || (s.$el.removeClass(`${s.params.containerModifierClass}${a}`).addClass(`${s.params.containerModifierClass}${e}`), s.emitContainerClasses(), s.params.direction = e, s.slides.each((t => {
                "vertical" === e ? t.style.width = "" : t.style.height = ""
            })), s.emit("changeDirection"), t && s.update()), s
        }

        changeLanguageDirection(e) {
            const t = this;
            t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e, t.rtlTranslate = "horizontal" === t.params.direction && t.rtl, t.rtl ? (t.$el.addClass(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.$el.removeClass(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update())
        }

        mount(e) {
            const t = this;
            if (t.mounted) return !0;
            const s = d(e || t.params.el);
            if (!(e = s[0])) return !1;
            e.swiper = t;
            const i = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`;
            let r = (() => {
                if (e && e.shadowRoot && e.shadowRoot.querySelector) {
                    const t = d(e.shadowRoot.querySelector(i()));
                    return t.children = e => s.children(e), t
                }
                return s.children ? s.children(i()) : d(s).children(i())
            })();
            if (0 === r.length && t.params.createElements) {
                const e = a().createElement("div");
                r = d(e), e.className = t.params.wrapperClass, s.append(e), s.children(`.${t.params.slideClass}`).each((e => {
                    r.append(e)
                }))
            }
            return Object.assign(t, {
                $el: s,
                el: e,
                $wrapperEl: r,
                wrapperEl: r[0],
                mounted: !0,
                rtl: "rtl" === e.dir.toLowerCase() || "rtl" === s.css("direction"),
                rtlTranslate: "horizontal" === t.params.direction && ("rtl" === e.dir.toLowerCase() || "rtl" === s.css("direction")),
                wrongRTL: "-webkit-box" === r.css("display")
            }), !0
        }

        init(e) {
            const t = this;
            if (t.initialized) return t;
            return !1 === t.mount(e) || (t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.params.loop && t.loopCreate(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.preloadImages && t.preloadImages(), t.params.loop ? t.slideTo(t.params.initialSlide + t.loopedSlides, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.attachEvents(), t.initialized = !0, t.emit("init"), t.emit("afterInit")), t
        }

        destroy(e, t) {
            void 0 === e && (e = !0), void 0 === t && (t = !0);
            const s = this, {params: a, $el: i, $wrapperEl: r, slides: n} = s;
            return void 0 === s.params || s.destroyed || (s.emit("beforeDestroy"), s.initialized = !1, s.detachEvents(), a.loop && s.loopDestroy(), t && (s.removeClasses(), i.removeAttr("style"), r.removeAttr("style"), n && n.length && n.removeClass([a.slideVisibleClass, a.slideActiveClass, a.slideNextClass, a.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), s.emit("destroy"), Object.keys(s.eventsListeners).forEach((e => {
                s.off(e)
            })), !1 !== e && (s.$el[0].swiper = null, function (e) {
                const t = e;
                Object.keys(t).forEach((e => {
                    try {
                        t[e] = null
                    } catch (e) {
                    }
                    try {
                        delete t[e]
                    } catch (e) {
                    }
                }))
            }(s)), s.destroyed = !0), null
        }

        static extendDefaults(e) {
            g(_, e)
        }

        static get extendedDefaults() {
            return _
        }

        static get defaults() {
            return W
        }

        static installModule(e) {
            V.prototype.__modules__ || (V.prototype.__modules__ = []);
            const t = V.prototype.__modules__;
            "function" == typeof e && t.indexOf(e) < 0 && t.push(e)
        }

        static use(e) {
            return Array.isArray(e) ? (e.forEach((e => V.installModule(e))), V) : (V.installModule(e), V)
        }
    }

    function F(e, t, s, i) {
        const r = a();
        return e.params.createElements && Object.keys(i).forEach((a => {
            if (!s[a] && !0 === s.auto) {
                let n = e.$el.children(`.${i[a]}`)[0];
                n || (n = r.createElement("div"), n.className = i[a], e.$el.append(n)), s[a] = n, t[a] = n
            }
        })), s
    }

    function U(e) {
        return void 0 === e && (e = ""), `.${e.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}`
    }

    function K(e) {
        const t = this, {$wrapperEl: s, params: a} = t;
        if (a.loop && t.loopDestroy(), "object" == typeof e && "length" in e) for (let t = 0; t < e.length; t += 1) e[t] && s.append(e[t]); else s.append(e);
        a.loop && t.loopCreate(), a.observer || t.update()
    }

    function Z(e) {
        const t = this, {params: s, $wrapperEl: a, activeIndex: i} = t;
        s.loop && t.loopDestroy();
        let r = i + 1;
        if ("object" == typeof e && "length" in e) {
            for (let t = 0; t < e.length; t += 1) e[t] && a.prepend(e[t]);
            r = i + e.length
        } else a.prepend(e);
        s.loop && t.loopCreate(), s.observer || t.update(), t.slideTo(r, 0, !1)
    }

    function Q(e, t) {
        const s = this, {$wrapperEl: a, params: i, activeIndex: r} = s;
        let n = r;
        i.loop && (n -= s.loopedSlides, s.loopDestroy(), s.slides = a.children(`.${i.slideClass}`));
        const l = s.slides.length;
        if (e <= 0) return void s.prependSlide(t);
        if (e >= l) return void s.appendSlide(t);
        let o = n > e ? n + 1 : n;
        const d = [];
        for (let t = l - 1; t >= e; t -= 1) {
            const e = s.slides.eq(t);
            e.remove(), d.unshift(e)
        }
        if ("object" == typeof t && "length" in t) {
            for (let e = 0; e < t.length; e += 1) t[e] && a.append(t[e]);
            o = n > e ? n + t.length : n
        } else a.append(t);
        for (let e = 0; e < d.length; e += 1) a.append(d[e]);
        i.loop && s.loopCreate(), i.observer || s.update(), i.loop ? s.slideTo(o + s.loopedSlides, 0, !1) : s.slideTo(o, 0, !1)
    }

    function J(e) {
        const t = this, {params: s, $wrapperEl: a, activeIndex: i} = t;
        let r = i;
        s.loop && (r -= t.loopedSlides, t.loopDestroy(), t.slides = a.children(`.${s.slideClass}`));
        let n, l = r;
        if ("object" == typeof e && "length" in e) {
            for (let s = 0; s < e.length; s += 1) n = e[s], t.slides[n] && t.slides.eq(n).remove(), n < l && (l -= 1);
            l = Math.max(l, 0)
        } else n = e, t.slides[n] && t.slides.eq(n).remove(), n < l && (l -= 1), l = Math.max(l, 0);
        s.loop && t.loopCreate(), s.observer || t.update(), s.loop ? t.slideTo(l + t.loopedSlides, 0, !1) : t.slideTo(l, 0, !1)
    }

    function ee() {
        const e = this, t = [];
        for (let s = 0; s < e.slides.length; s += 1) t.push(s);
        e.removeSlide(t)
    }

    function te(e) {
        const {
            effect: t,
            swiper: s,
            on: a,
            setTranslate: i,
            setTransition: r,
            overwriteParams: n,
            perspective: l,
            recreateShadows: o,
            getEffectParams: d
        } = e;
        let c;
        a("beforeInit", (() => {
            if (s.params.effect !== t) return;
            s.classNames.push(`${s.params.containerModifierClass}${t}`), l && l() && s.classNames.push(`${s.params.containerModifierClass}3d`);
            const e = n ? n() : {};
            Object.assign(s.params, e), Object.assign(s.originalParams, e)
        })), a("setTranslate", (() => {
            s.params.effect === t && i()
        })), a("setTransition", ((e, a) => {
            s.params.effect === t && r(a)
        })), a("transitionEnd", (() => {
            if (s.params.effect === t && o) {
                if (!d || !d().slideShadows) return;
                s.slides.each((e => {
                    s.$(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").remove()
                })), o()
            }
        })), a("virtualUpdate", (() => {
            s.params.effect === t && (s.slides.length || (c = !0), requestAnimationFrame((() => {
                c && s.slides && s.slides.length && (i(), c = !1)
            })))
        }))
    }

    function se(e, t) {
        return e.transformEl ? t.find(e.transformEl).css({
            "backface-visibility": "hidden",
            "-webkit-backface-visibility": "hidden"
        }) : t
    }

    function ae(e) {
        let {swiper: t, duration: s, transformEl: a, allSlides: i} = e;
        const {slides: r, activeIndex: n, $wrapperEl: l} = t;
        if (t.params.virtualTranslate && 0 !== s) {
            let e, s = !1;
            e = i ? a ? r.find(a) : r : a ? r.eq(n).find(a) : r.eq(n), e.transitionEnd((() => {
                if (s) return;
                if (!t || t.destroyed) return;
                s = !0, t.animating = !1;
                const e = ["webkitTransitionEnd", "transitionend"];
                for (let t = 0; t < e.length; t += 1) l.trigger(e[t])
            }))
        }
    }

    function ie(e, t, s) {
        const a = "swiper-slide-shadow" + (s ? `-${s}` : ""), i = e.transformEl ? t.find(e.transformEl) : t;
        let r = i.children(`.${a}`);
        return r.length || (r = d(`<div class="swiper-slide-shadow${s ? `-${s}` : ""}"></div>`), i.append(r)), r
    }

    Object.keys(j).forEach((e => {
        Object.keys(j[e]).forEach((t => {
            V.prototype[t] = j[e][t]
        }))
    })), V.use([function (e) {
        let {swiper: t, on: s, emit: a} = e;
        const i = r();
        let n = null, l = null;
        const o = () => {
            t && !t.destroyed && t.initialized && (a("beforeResize"), a("resize"))
        }, d = () => {
            t && !t.destroyed && t.initialized && a("orientationchange")
        };
        s("init", (() => {
            t.params.resizeObserver && void 0 !== i.ResizeObserver ? t && !t.destroyed && t.initialized && (n = new ResizeObserver((e => {
                l = i.requestAnimationFrame((() => {
                    const {width: s, height: a} = t;
                    let i = s, r = a;
                    e.forEach((e => {
                        let {contentBoxSize: s, contentRect: a, target: n} = e;
                        n && n !== t.el || (i = a ? a.width : (s[0] || s).inlineSize, r = a ? a.height : (s[0] || s).blockSize)
                    })), i === s && r === a || o()
                }))
            })), n.observe(t.el)) : (i.addEventListener("resize", o), i.addEventListener("orientationchange", d))
        })), s("destroy", (() => {
            l && i.cancelAnimationFrame(l), n && n.unobserve && t.el && (n.unobserve(t.el), n = null), i.removeEventListener("resize", o), i.removeEventListener("orientationchange", d)
        }))
    }, function (e) {
        let {swiper: t, extendParams: s, on: a, emit: i} = e;
        const n = [], l = r(), o = function (e, t) {
            void 0 === t && (t = {});
            const s = new (l.MutationObserver || l.WebkitMutationObserver)((e => {
                if (1 === e.length) return void i("observerUpdate", e[0]);
                const t = function () {
                    i("observerUpdate", e[0])
                };
                l.requestAnimationFrame ? l.requestAnimationFrame(t) : l.setTimeout(t, 0)
            }));
            s.observe(e, {
                attributes: void 0 === t.attributes || t.attributes,
                childList: void 0 === t.childList || t.childList,
                characterData: void 0 === t.characterData || t.characterData
            }), n.push(s)
        };
        s({observer: !1, observeParents: !1, observeSlideChildren: !1}), a("init", (() => {
            if (t.params.observer) {
                if (t.params.observeParents) {
                    const e = t.$el.parents();
                    for (let t = 0; t < e.length; t += 1) o(e[t])
                }
                o(t.$el[0], {childList: t.params.observeSlideChildren}), o(t.$wrapperEl[0], {attributes: !1})
            }
        })), a("destroy", (() => {
            n.forEach((e => {
                e.disconnect()
            })), n.splice(0, n.length)
        }))
    }]);
    const re = [function (e) {
        let t, {swiper: s, extendParams: a, on: i, emit: r} = e;

        function n(e, t) {
            const a = s.params.virtual;
            if (a.cache && s.virtual.cache[t]) return s.virtual.cache[t];
            const i = a.renderSlide ? d(a.renderSlide.call(s, e, t)) : d(`<div class="${s.params.slideClass}" data-swiper-slide-index="${t}">${e}</div>`);
            return i.attr("data-swiper-slide-index") || i.attr("data-swiper-slide-index", t), a.cache && (s.virtual.cache[t] = i), i
        }

        function l(e) {
            const {slidesPerView: t, slidesPerGroup: a, centeredSlides: i} = s.params, {
                addSlidesBefore: l,
                addSlidesAfter: o
            } = s.params.virtual, {from: d, to: c, slides: p, slidesGrid: u, offset: h} = s.virtual;
            s.params.cssMode || s.updateActiveIndex();
            const m = s.activeIndex || 0;
            let f, g, v;
            f = s.rtlTranslate ? "right" : s.isHorizontal() ? "left" : "top", i ? (g = Math.floor(t / 2) + a + o, v = Math.floor(t / 2) + a + l) : (g = t + (a - 1) + o, v = a + l);
            const w = Math.max((m || 0) - v, 0), b = Math.min((m || 0) + g, p.length - 1),
                x = (s.slidesGrid[w] || 0) - (s.slidesGrid[0] || 0);

            function y() {
                s.updateSlides(), s.updateProgress(), s.updateSlidesClasses(), s.lazy && s.params.lazy.enabled && s.lazy.load(), r("virtualUpdate")
            }

            if (Object.assign(s.virtual, {
                from: w,
                to: b,
                offset: x,
                slidesGrid: s.slidesGrid
            }), d === w && c === b && !e) return s.slidesGrid !== u && x !== h && s.slides.css(f, `${x}px`), s.updateProgress(), void r("virtualUpdate");
            if (s.params.virtual.renderExternal) return s.params.virtual.renderExternal.call(s, {
                offset: x,
                from: w,
                to: b,
                slides: function () {
                    const e = [];
                    for (let t = w; t <= b; t += 1) e.push(p[t]);
                    return e
                }()
            }), void (s.params.virtual.renderExternalUpdate ? y() : r("virtualUpdate"));
            const E = [], C = [];
            if (e) s.$wrapperEl.find(`.${s.params.slideClass}`).remove(); else for (let e = d; e <= c; e += 1) (e < w || e > b) && s.$wrapperEl.find(`.${s.params.slideClass}[data-swiper-slide-index="${e}"]`).remove();
            for (let t = 0; t < p.length; t += 1) t >= w && t <= b && (void 0 === c || e ? C.push(t) : (t > c && C.push(t), t < d && E.push(t)));
            C.forEach((e => {
                s.$wrapperEl.append(n(p[e], e))
            })), E.sort(((e, t) => t - e)).forEach((e => {
                s.$wrapperEl.prepend(n(p[e], e))
            })), s.$wrapperEl.children(".swiper-slide").css(f, `${x}px`), y()
        }

        a({
            virtual: {
                enabled: !1,
                slides: [],
                cache: !0,
                renderSlide: null,
                renderExternal: null,
                renderExternalUpdate: !0,
                addSlidesBefore: 0,
                addSlidesAfter: 0
            }
        }), s.virtual = {
            cache: {},
            from: void 0,
            to: void 0,
            slides: [],
            offset: 0,
            slidesGrid: []
        }, i("beforeInit", (() => {
            s.params.virtual.enabled && (s.virtual.slides = s.params.virtual.slides, s.classNames.push(`${s.params.containerModifierClass}virtual`), s.params.watchSlidesProgress = !0, s.originalParams.watchSlidesProgress = !0, s.params.initialSlide || l())
        })), i("setTranslate", (() => {
            s.params.virtual.enabled && (s.params.cssMode && !s._immediateVirtual ? (clearTimeout(t), t = setTimeout((() => {
                l()
            }), 100)) : l())
        })), i("init update resize", (() => {
            s.params.virtual.enabled && s.params.cssMode && v(s.wrapperEl, "--swiper-virtual-size", `${s.virtualSize}px`)
        })), Object.assign(s.virtual, {
            appendSlide: function (e) {
                if ("object" == typeof e && "length" in e) for (let t = 0; t < e.length; t += 1) e[t] && s.virtual.slides.push(e[t]); else s.virtual.slides.push(e);
                l(!0)
            }, prependSlide: function (e) {
                const t = s.activeIndex;
                let a = t + 1, i = 1;
                if (Array.isArray(e)) {
                    for (let t = 0; t < e.length; t += 1) e[t] && s.virtual.slides.unshift(e[t]);
                    a = t + e.length, i = e.length
                } else s.virtual.slides.unshift(e);
                if (s.params.virtual.cache) {
                    const e = s.virtual.cache, t = {};
                    Object.keys(e).forEach((s => {
                        const a = e[s], r = a.attr("data-swiper-slide-index");
                        r && a.attr("data-swiper-slide-index", parseInt(r, 10) + i), t[parseInt(s, 10) + i] = a
                    })), s.virtual.cache = t
                }
                l(!0), s.slideTo(a, 0)
            }, removeSlide: function (e) {
                if (null == e) return;
                let t = s.activeIndex;
                if (Array.isArray(e)) for (let a = e.length - 1; a >= 0; a -= 1) s.virtual.slides.splice(e[a], 1), s.params.virtual.cache && delete s.virtual.cache[e[a]], e[a] < t && (t -= 1), t = Math.max(t, 0); else s.virtual.slides.splice(e, 1), s.params.virtual.cache && delete s.virtual.cache[e], e < t && (t -= 1), t = Math.max(t, 0);
                l(!0), s.slideTo(t, 0)
            }, removeAllSlides: function () {
                s.virtual.slides = [], s.params.virtual.cache && (s.virtual.cache = {}), l(!0), s.slideTo(0, 0)
            }, update: l
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: i, emit: n} = e;
        const l = a(), o = r();

        function c(e) {
            if (!t.enabled) return;
            const {rtlTranslate: s} = t;
            let a = e;
            a.originalEvent && (a = a.originalEvent);
            const i = a.keyCode || a.charCode, r = t.params.keyboard.pageUpDown, d = r && 33 === i, c = r && 34 === i,
                p = 37 === i, u = 39 === i, h = 38 === i, m = 40 === i;
            if (!t.allowSlideNext && (t.isHorizontal() && u || t.isVertical() && m || c)) return !1;
            if (!t.allowSlidePrev && (t.isHorizontal() && p || t.isVertical() && h || d)) return !1;
            if (!(a.shiftKey || a.altKey || a.ctrlKey || a.metaKey || l.activeElement && l.activeElement.nodeName && ("input" === l.activeElement.nodeName.toLowerCase() || "textarea" === l.activeElement.nodeName.toLowerCase()))) {
                if (t.params.keyboard.onlyInViewport && (d || c || p || u || h || m)) {
                    let e = !1;
                    if (t.$el.parents(`.${t.params.slideClass}`).length > 0 && 0 === t.$el.parents(`.${t.params.slideActiveClass}`).length) return;
                    const a = t.$el, i = a[0].clientWidth, r = a[0].clientHeight, n = o.innerWidth, l = o.innerHeight,
                        d = t.$el.offset();
                    s && (d.left -= t.$el[0].scrollLeft);
                    const c = [[d.left, d.top], [d.left + i, d.top], [d.left, d.top + r], [d.left + i, d.top + r]];
                    for (let t = 0; t < c.length; t += 1) {
                        const s = c[t];
                        if (s[0] >= 0 && s[0] <= n && s[1] >= 0 && s[1] <= l) {
                            if (0 === s[0] && 0 === s[1]) continue;
                            e = !0
                        }
                    }
                    if (!e) return
                }
                t.isHorizontal() ? ((d || c || p || u) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), ((c || u) && !s || (d || p) && s) && t.slideNext(), ((d || p) && !s || (c || u) && s) && t.slidePrev()) : ((d || c || h || m) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), (c || m) && t.slideNext(), (d || h) && t.slidePrev()), n("keyPress", i)
            }
        }

        function p() {
            t.keyboard.enabled || (d(l).on("keydown", c), t.keyboard.enabled = !0)
        }

        function u() {
            t.keyboard.enabled && (d(l).off("keydown", c), t.keyboard.enabled = !1)
        }

        t.keyboard = {enabled: !1}, s({keyboard: {enabled: !1, onlyInViewport: !0, pageUpDown: !0}}), i("init", (() => {
            t.params.keyboard.enabled && p()
        })), i("destroy", (() => {
            t.keyboard.enabled && u()
        })), Object.assign(t.keyboard, {enable: p, disable: u})
    }, function (e) {
        let {swiper: t, extendParams: s, on: a, emit: i} = e;
        const n = r();
        let l;
        s({
            mousewheel: {
                enabled: !1,
                releaseOnEdges: !1,
                invert: !1,
                forceToAxis: !1,
                sensitivity: 1,
                eventsTarget: "container",
                thresholdDelta: null,
                thresholdTime: null
            }
        }), t.mousewheel = {enabled: !1};
        let o, c = u();
        const h = [];

        function m() {
            t.enabled && (t.mouseEntered = !0)
        }

        function f() {
            t.enabled && (t.mouseEntered = !1)
        }

        function g(e) {
            return !(t.params.mousewheel.thresholdDelta && e.delta < t.params.mousewheel.thresholdDelta) && (!(t.params.mousewheel.thresholdTime && u() - c < t.params.mousewheel.thresholdTime) && (e.delta >= 6 && u() - c < 60 || (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(), i("scroll", e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(), i("scroll", e.raw)), c = (new n.Date).getTime(), !1)))
        }

        function v(e) {
            let s = e, a = !0;
            if (!t.enabled) return;
            const r = t.params.mousewheel;
            t.params.cssMode && s.preventDefault();
            let n = t.$el;
            if ("container" !== t.params.mousewheel.eventsTarget && (n = d(t.params.mousewheel.eventsTarget)), !t.mouseEntered && !n[0].contains(s.target) && !r.releaseOnEdges) return !0;
            s.originalEvent && (s = s.originalEvent);
            let c = 0;
            const m = t.rtlTranslate ? -1 : 1, f = function (e) {
                let t = 0, s = 0, a = 0, i = 0;
                return "detail" in e && (s = e.detail), "wheelDelta" in e && (s = -e.wheelDelta / 120), "wheelDeltaY" in e && (s = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = s, s = 0), a = 10 * t, i = 10 * s, "deltaY" in e && (i = e.deltaY), "deltaX" in e && (a = e.deltaX), e.shiftKey && !a && (a = i, i = 0), (a || i) && e.deltaMode && (1 === e.deltaMode ? (a *= 40, i *= 40) : (a *= 800, i *= 800)), a && !t && (t = a < 1 ? -1 : 1), i && !s && (s = i < 1 ? -1 : 1), {
                    spinX: t,
                    spinY: s,
                    pixelX: a,
                    pixelY: i
                }
            }(s);
            if (r.forceToAxis) if (t.isHorizontal()) {
                if (!(Math.abs(f.pixelX) > Math.abs(f.pixelY))) return !0;
                c = -f.pixelX * m
            } else {
                if (!(Math.abs(f.pixelY) > Math.abs(f.pixelX))) return !0;
                c = -f.pixelY
            } else c = Math.abs(f.pixelX) > Math.abs(f.pixelY) ? -f.pixelX * m : -f.pixelY;
            if (0 === c) return !0;
            r.invert && (c = -c);
            let v = t.getTranslate() + c * r.sensitivity;
            if (v >= t.minTranslate() && (v = t.minTranslate()), v <= t.maxTranslate() && (v = t.maxTranslate()), a = !!t.params.loop || !(v === t.minTranslate() || v === t.maxTranslate()), a && t.params.nested && s.stopPropagation(), t.params.freeMode && t.params.freeMode.enabled) {
                const e = {time: u(), delta: Math.abs(c), direction: Math.sign(c)},
                    a = o && e.time < o.time + 500 && e.delta <= o.delta && e.direction === o.direction;
                if (!a) {
                    o = void 0, t.params.loop && t.loopFix();
                    let n = t.getTranslate() + c * r.sensitivity;
                    const d = t.isBeginning, u = t.isEnd;
                    if (n >= t.minTranslate() && (n = t.minTranslate()), n <= t.maxTranslate() && (n = t.maxTranslate()), t.setTransition(0), t.setTranslate(n), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses(), (!d && t.isBeginning || !u && t.isEnd) && t.updateSlidesClasses(), t.params.freeMode.sticky) {
                        clearTimeout(l), l = void 0, h.length >= 15 && h.shift();
                        const s = h.length ? h[h.length - 1] : void 0, a = h[0];
                        if (h.push(e), s && (e.delta > s.delta || e.direction !== s.direction)) h.splice(0); else if (h.length >= 15 && e.time - a.time < 500 && a.delta - e.delta >= 1 && e.delta <= 6) {
                            const s = c > 0 ? .8 : .2;
                            o = e, h.splice(0), l = p((() => {
                                t.slideToClosest(t.params.speed, !0, void 0, s)
                            }), 0)
                        }
                        l || (l = p((() => {
                            o = e, h.splice(0), t.slideToClosest(t.params.speed, !0, void 0, .5)
                        }), 500))
                    }
                    if (a || i("scroll", s), t.params.autoplay && t.params.autoplayDisableOnInteraction && t.autoplay.stop(), n === t.minTranslate() || n === t.maxTranslate()) return !0
                }
            } else {
                const s = {time: u(), delta: Math.abs(c), direction: Math.sign(c), raw: e};
                h.length >= 2 && h.shift();
                const a = h.length ? h[h.length - 1] : void 0;
                if (h.push(s), a ? (s.direction !== a.direction || s.delta > a.delta || s.time > a.time + 150) && g(s) : g(s), function (e) {
                    const s = t.params.mousewheel;
                    if (e.direction < 0) {
                        if (t.isEnd && !t.params.loop && s.releaseOnEdges) return !0
                    } else if (t.isBeginning && !t.params.loop && s.releaseOnEdges) return !0;
                    return !1
                }(s)) return !0
            }
            return s.preventDefault ? s.preventDefault() : s.returnValue = !1, !1
        }

        function w(e) {
            let s = t.$el;
            "container" !== t.params.mousewheel.eventsTarget && (s = d(t.params.mousewheel.eventsTarget)), s[e]("mouseenter", m), s[e]("mouseleave", f), s[e]("wheel", v)
        }

        function b() {
            return t.params.cssMode ? (t.wrapperEl.removeEventListener("wheel", v), !0) : !t.mousewheel.enabled && (w("on"), t.mousewheel.enabled = !0, !0)
        }

        function x() {
            return t.params.cssMode ? (t.wrapperEl.addEventListener(event, v), !0) : !!t.mousewheel.enabled && (w("off"), t.mousewheel.enabled = !1, !0)
        }

        a("init", (() => {
            !t.params.mousewheel.enabled && t.params.cssMode && x(), t.params.mousewheel.enabled && b()
        })), a("destroy", (() => {
            t.params.cssMode && b(), t.mousewheel.enabled && x()
        })), Object.assign(t.mousewheel, {enable: b, disable: x})
    }, function (e) {
        let {swiper: t, extendParams: s, on: a, emit: i} = e;

        function r(e) {
            let s;
            return e && (s = d(e), t.params.uniqueNavElements && "string" == typeof e && s.length > 1 && 1 === t.$el.find(e).length && (s = t.$el.find(e))), s
        }

        function n(e, s) {
            const a = t.params.navigation;
            e && e.length > 0 && (e[s ? "addClass" : "removeClass"](a.disabledClass), e[0] && "BUTTON" === e[0].tagName && (e[0].disabled = s), t.params.watchOverflow && t.enabled && e[t.isLocked ? "addClass" : "removeClass"](a.lockClass))
        }

        function l() {
            if (t.params.loop) return;
            const {$nextEl: e, $prevEl: s} = t.navigation;
            n(s, t.isBeginning && !t.params.rewind), n(e, t.isEnd && !t.params.rewind)
        }

        function o(e) {
            e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(), i("navigationPrev"))
        }

        function c(e) {
            e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(), i("navigationNext"))
        }

        function p() {
            const e = t.params.navigation;
            if (t.params.navigation = F(t, t.originalParams.navigation, t.params.navigation, {
                nextEl: "swiper-button-next",
                prevEl: "swiper-button-prev"
            }), !e.nextEl && !e.prevEl) return;
            const s = r(e.nextEl), a = r(e.prevEl);
            s && s.length > 0 && s.on("click", c), a && a.length > 0 && a.on("click", o), Object.assign(t.navigation, {
                $nextEl: s,
                nextEl: s && s[0],
                $prevEl: a,
                prevEl: a && a[0]
            }), t.enabled || (s && s.addClass(e.lockClass), a && a.addClass(e.lockClass))
        }

        function u() {
            const {$nextEl: e, $prevEl: s} = t.navigation;
            e && e.length && (e.off("click", c), e.removeClass(t.params.navigation.disabledClass)), s && s.length && (s.off("click", o), s.removeClass(t.params.navigation.disabledClass))
        }

        s({
            navigation: {
                nextEl: null,
                prevEl: null,
                hideOnClick: !1,
                disabledClass: "swiper-button-disabled",
                hiddenClass: "swiper-button-hidden",
                lockClass: "swiper-button-lock",
                navigationDisabledClass: "swiper-navigation-disabled"
            }
        }), t.navigation = {nextEl: null, $nextEl: null, prevEl: null, $prevEl: null}, a("init", (() => {
            !1 === t.params.navigation.enabled ? h() : (p(), l())
        })), a("toEdge fromEdge lock unlock", (() => {
            l()
        })), a("destroy", (() => {
            u()
        })), a("enable disable", (() => {
            const {$nextEl: e, $prevEl: s} = t.navigation;
            e && e[t.enabled ? "removeClass" : "addClass"](t.params.navigation.lockClass), s && s[t.enabled ? "removeClass" : "addClass"](t.params.navigation.lockClass)
        })), a("click", ((e, s) => {
            const {$nextEl: a, $prevEl: r} = t.navigation, n = s.target;
            if (t.params.navigation.hideOnClick && !d(n).is(r) && !d(n).is(a)) {
                if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === n || t.pagination.el.contains(n))) return;
                let e;
                a ? e = a.hasClass(t.params.navigation.hiddenClass) : r && (e = r.hasClass(t.params.navigation.hiddenClass)), i(!0 === e ? "navigationShow" : "navigationHide"), a && a.toggleClass(t.params.navigation.hiddenClass), r && r.toggleClass(t.params.navigation.hiddenClass)
            }
        }));
        const h = () => {
            t.$el.addClass(t.params.navigation.navigationDisabledClass), u()
        };
        Object.assign(t.navigation, {
            enable: () => {
                t.$el.removeClass(t.params.navigation.navigationDisabledClass), p(), l()
            }, disable: h, update: l, init: p, destroy: u
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: a, emit: i} = e;
        const r = "swiper-pagination";
        let n;
        s({
            pagination: {
                el: null,
                bulletElement: "span",
                clickable: !1,
                hideOnClick: !1,
                renderBullet: null,
                renderProgressbar: null,
                renderFraction: null,
                renderCustom: null,
                progressbarOpposite: !1,
                type: "bullets",
                dynamicBullets: !1,
                dynamicMainBullets: 1,
                formatFractionCurrent: e => e,
                formatFractionTotal: e => e,
                bulletClass: `${r}-bullet`,
                bulletActiveClass: `${r}-bullet-active`,
                modifierClass: `${r}-`,
                currentClass: `${r}-current`,
                totalClass: `${r}-total`,
                hiddenClass: `${r}-hidden`,
                progressbarFillClass: `${r}-progressbar-fill`,
                progressbarOppositeClass: `${r}-progressbar-opposite`,
                clickableClass: `${r}-clickable`,
                lockClass: `${r}-lock`,
                horizontalClass: `${r}-horizontal`,
                verticalClass: `${r}-vertical`,
                paginationDisabledClass: `${r}-disabled`
            }
        }), t.pagination = {el: null, $el: null, bullets: []};
        let l = 0;

        function o() {
            return !t.params.pagination.el || !t.pagination.el || !t.pagination.$el || 0 === t.pagination.$el.length
        }

        function c(e, s) {
            const {bulletActiveClass: a} = t.params.pagination;
            e[s]().addClass(`${a}-${s}`)[s]().addClass(`${a}-${s}-${s}`)
        }

        function p() {
            const e = t.rtl, s = t.params.pagination;
            if (o()) return;
            const a = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length,
                r = t.pagination.$el;
            let p;
            const u = t.params.loop ? Math.ceil((a - 2 * t.loopedSlides) / t.params.slidesPerGroup) : t.snapGrid.length;
            if (t.params.loop ? (p = Math.ceil((t.activeIndex - t.loopedSlides) / t.params.slidesPerGroup), p > a - 1 - 2 * t.loopedSlides && (p -= a - 2 * t.loopedSlides), p > u - 1 && (p -= u), p < 0 && "bullets" !== t.params.paginationType && (p = u + p)) : p = void 0 !== t.snapIndex ? t.snapIndex : t.activeIndex || 0, "bullets" === s.type && t.pagination.bullets && t.pagination.bullets.length > 0) {
                const a = t.pagination.bullets;
                let i, o, u;
                if (s.dynamicBullets && (n = a.eq(0)[t.isHorizontal() ? "outerWidth" : "outerHeight"](!0), r.css(t.isHorizontal() ? "width" : "height", n * (s.dynamicMainBullets + 4) + "px"), s.dynamicMainBullets > 1 && void 0 !== t.previousIndex && (l += p - (t.previousIndex - t.loopedSlides || 0), l > s.dynamicMainBullets - 1 ? l = s.dynamicMainBullets - 1 : l < 0 && (l = 0)), i = Math.max(p - l, 0), o = i + (Math.min(a.length, s.dynamicMainBullets) - 1), u = (o + i) / 2), a.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((e => `${s.bulletActiveClass}${e}`)).join(" ")), r.length > 1) a.each((e => {
                    const t = d(e), a = t.index();
                    a === p && t.addClass(s.bulletActiveClass), s.dynamicBullets && (a >= i && a <= o && t.addClass(`${s.bulletActiveClass}-main`), a === i && c(t, "prev"), a === o && c(t, "next"))
                })); else {
                    const e = a.eq(p), r = e.index();
                    if (e.addClass(s.bulletActiveClass), s.dynamicBullets) {
                        const e = a.eq(i), n = a.eq(o);
                        for (let e = i; e <= o; e += 1) a.eq(e).addClass(`${s.bulletActiveClass}-main`);
                        if (t.params.loop) if (r >= a.length) {
                            for (let e = s.dynamicMainBullets; e >= 0; e -= 1) a.eq(a.length - e).addClass(`${s.bulletActiveClass}-main`);
                            a.eq(a.length - s.dynamicMainBullets - 1).addClass(`${s.bulletActiveClass}-prev`)
                        } else c(e, "prev"), c(n, "next"); else c(e, "prev"), c(n, "next")
                    }
                }
                if (s.dynamicBullets) {
                    const i = Math.min(a.length, s.dynamicMainBullets + 4), r = (n * i - n) / 2 - u * n,
                        l = e ? "right" : "left";
                    a.css(t.isHorizontal() ? l : "top", `${r}px`)
                }
            }
            if ("fraction" === s.type && (r.find(U(s.currentClass)).text(s.formatFractionCurrent(p + 1)), r.find(U(s.totalClass)).text(s.formatFractionTotal(u))), "progressbar" === s.type) {
                let e;
                e = s.progressbarOpposite ? t.isHorizontal() ? "vertical" : "horizontal" : t.isHorizontal() ? "horizontal" : "vertical";
                const a = (p + 1) / u;
                let i = 1, n = 1;
                "horizontal" === e ? i = a : n = a, r.find(U(s.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${i}) scaleY(${n})`).transition(t.params.speed)
            }
            "custom" === s.type && s.renderCustom ? (r.html(s.renderCustom(t, p + 1, u)), i("paginationRender", r[0])) : i("paginationUpdate", r[0]), t.params.watchOverflow && t.enabled && r[t.isLocked ? "addClass" : "removeClass"](s.lockClass)
        }

        function u() {
            const e = t.params.pagination;
            if (o()) return;
            const s = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length,
                a = t.pagination.$el;
            let r = "";
            if ("bullets" === e.type) {
                let i = t.params.loop ? Math.ceil((s - 2 * t.loopedSlides) / t.params.slidesPerGroup) : t.snapGrid.length;
                t.params.freeMode && t.params.freeMode.enabled && !t.params.loop && i > s && (i = s);
                for (let s = 0; s < i; s += 1) e.renderBullet ? r += e.renderBullet.call(t, s, e.bulletClass) : r += `<${e.bulletElement} class="${e.bulletClass}"></${e.bulletElement}>`;
                a.html(r), t.pagination.bullets = a.find(U(e.bulletClass))
            }
            "fraction" === e.type && (r = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`, a.html(r)), "progressbar" === e.type && (r = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`, a.html(r)), "custom" !== e.type && i("paginationRender", t.pagination.$el[0])
        }

        function h() {
            t.params.pagination = F(t, t.originalParams.pagination, t.params.pagination, {el: "swiper-pagination"});
            const e = t.params.pagination;
            if (!e.el) return;
            let s = d(e.el);
            0 !== s.length && (t.params.uniqueNavElements && "string" == typeof e.el && s.length > 1 && (s = t.$el.find(e.el), s.length > 1 && (s = s.filter((e => d(e).parents(".swiper")[0] === t.el)))), "bullets" === e.type && e.clickable && s.addClass(e.clickableClass), s.addClass(e.modifierClass + e.type), s.addClass(t.isHorizontal() ? e.horizontalClass : e.verticalClass), "bullets" === e.type && e.dynamicBullets && (s.addClass(`${e.modifierClass}${e.type}-dynamic`), l = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), "progressbar" === e.type && e.progressbarOpposite && s.addClass(e.progressbarOppositeClass), e.clickable && s.on("click", U(e.bulletClass), (function (e) {
                e.preventDefault();
                let s = d(this).index() * t.params.slidesPerGroup;
                t.params.loop && (s += t.loopedSlides), t.slideTo(s)
            })), Object.assign(t.pagination, {$el: s, el: s[0]}), t.enabled || s.addClass(e.lockClass))
        }

        function m() {
            const e = t.params.pagination;
            if (o()) return;
            const s = t.pagination.$el;
            s.removeClass(e.hiddenClass), s.removeClass(e.modifierClass + e.type), s.removeClass(t.isHorizontal() ? e.horizontalClass : e.verticalClass), t.pagination.bullets && t.pagination.bullets.removeClass && t.pagination.bullets.removeClass(e.bulletActiveClass), e.clickable && s.off("click", U(e.bulletClass))
        }

        a("init", (() => {
            !1 === t.params.pagination.enabled ? f() : (h(), u(), p())
        })), a("activeIndexChange", (() => {
            (t.params.loop || void 0 === t.snapIndex) && p()
        })), a("snapIndexChange", (() => {
            t.params.loop || p()
        })), a("slidesLengthChange", (() => {
            t.params.loop && (u(), p())
        })), a("snapGridLengthChange", (() => {
            t.params.loop || (u(), p())
        })), a("destroy", (() => {
            m()
        })), a("enable disable", (() => {
            const {$el: e} = t.pagination;
            e && e[t.enabled ? "removeClass" : "addClass"](t.params.pagination.lockClass)
        })), a("lock unlock", (() => {
            p()
        })), a("click", ((e, s) => {
            const a = s.target, {$el: r} = t.pagination;
            if (t.params.pagination.el && t.params.pagination.hideOnClick && r && r.length > 0 && !d(a).hasClass(t.params.pagination.bulletClass)) {
                if (t.navigation && (t.navigation.nextEl && a === t.navigation.nextEl || t.navigation.prevEl && a === t.navigation.prevEl)) return;
                const e = r.hasClass(t.params.pagination.hiddenClass);
                i(!0 === e ? "paginationShow" : "paginationHide"), r.toggleClass(t.params.pagination.hiddenClass)
            }
        }));
        const f = () => {
            t.$el.addClass(t.params.pagination.paginationDisabledClass), t.pagination.$el && t.pagination.$el.addClass(t.params.pagination.paginationDisabledClass), m()
        };
        Object.assign(t.pagination, {
            enable: () => {
                t.$el.removeClass(t.params.pagination.paginationDisabledClass), t.pagination.$el && t.pagination.$el.removeClass(t.params.pagination.paginationDisabledClass), h(), u(), p()
            }, disable: f, render: u, update: p, init: h, destroy: m
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: i, emit: r} = e;
        const n = a();
        let l, o, c, u, h = !1, m = null, f = null;

        function g() {
            if (!t.params.scrollbar.el || !t.scrollbar.el) return;
            const {scrollbar: e, rtlTranslate: s, progress: a} = t, {$dragEl: i, $el: r} = e, n = t.params.scrollbar;
            let l = o, d = (c - o) * a;
            s ? (d = -d, d > 0 ? (l = o - d, d = 0) : -d + o > c && (l = c + d)) : d < 0 ? (l = o + d, d = 0) : d + o > c && (l = c - d), t.isHorizontal() ? (i.transform(`translate3d(${d}px, 0, 0)`), i[0].style.width = `${l}px`) : (i.transform(`translate3d(0px, ${d}px, 0)`), i[0].style.height = `${l}px`), n.hide && (clearTimeout(m), r[0].style.opacity = 1, m = setTimeout((() => {
                r[0].style.opacity = 0, r.transition(400)
            }), 1e3))
        }

        function v() {
            if (!t.params.scrollbar.el || !t.scrollbar.el) return;
            const {scrollbar: e} = t, {$dragEl: s, $el: a} = e;
            s[0].style.width = "", s[0].style.height = "", c = t.isHorizontal() ? a[0].offsetWidth : a[0].offsetHeight, u = t.size / (t.virtualSize + t.params.slidesOffsetBefore - (t.params.centeredSlides ? t.snapGrid[0] : 0)), o = "auto" === t.params.scrollbar.dragSize ? c * u : parseInt(t.params.scrollbar.dragSize, 10), t.isHorizontal() ? s[0].style.width = `${o}px` : s[0].style.height = `${o}px`, a[0].style.display = u >= 1 ? "none" : "", t.params.scrollbar.hide && (a[0].style.opacity = 0), t.params.watchOverflow && t.enabled && e.$el[t.isLocked ? "addClass" : "removeClass"](t.params.scrollbar.lockClass)
        }

        function w(e) {
            return t.isHorizontal() ? "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].clientX : e.clientX : "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].clientY : e.clientY
        }

        function b(e) {
            const {scrollbar: s, rtlTranslate: a} = t, {$el: i} = s;
            let r;
            r = (w(e) - i.offset()[t.isHorizontal() ? "left" : "top"] - (null !== l ? l : o / 2)) / (c - o), r = Math.max(Math.min(r, 1), 0), a && (r = 1 - r);
            const n = t.minTranslate() + (t.maxTranslate() - t.minTranslate()) * r;
            t.updateProgress(n), t.setTranslate(n), t.updateActiveIndex(), t.updateSlidesClasses()
        }

        function x(e) {
            const s = t.params.scrollbar, {scrollbar: a, $wrapperEl: i} = t, {$el: n, $dragEl: o} = a;
            h = !0, l = e.target === o[0] || e.target === o ? w(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? "left" : "top"] : null, e.preventDefault(), e.stopPropagation(), i.transition(100), o.transition(100), b(e), clearTimeout(f), n.transition(0), s.hide && n.css("opacity", 1), t.params.cssMode && t.$wrapperEl.css("scroll-snap-type", "none"), r("scrollbarDragStart", e)
        }

        function y(e) {
            const {scrollbar: s, $wrapperEl: a} = t, {$el: i, $dragEl: n} = s;
            h && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, b(e), a.transition(0), i.transition(0), n.transition(0), r("scrollbarDragMove", e))
        }

        function E(e) {
            const s = t.params.scrollbar, {scrollbar: a, $wrapperEl: i} = t, {$el: n} = a;
            h && (h = !1, t.params.cssMode && (t.$wrapperEl.css("scroll-snap-type", ""), i.transition("")), s.hide && (clearTimeout(f), f = p((() => {
                n.css("opacity", 0), n.transition(400)
            }), 1e3)), r("scrollbarDragEnd", e), s.snapOnRelease && t.slideToClosest())
        }

        function C(e) {
            const {scrollbar: s, touchEventsTouch: a, touchEventsDesktop: i, params: r, support: l} = t, o = s.$el;
            if (!o) return;
            const d = o[0], c = !(!l.passiveListener || !r.passiveListeners) && {passive: !1, capture: !1},
                p = !(!l.passiveListener || !r.passiveListeners) && {passive: !0, capture: !1};
            if (!d) return;
            const u = "on" === e ? "addEventListener" : "removeEventListener";
            l.touch ? (d[u](a.start, x, c), d[u](a.move, y, c), d[u](a.end, E, p)) : (d[u](i.start, x, c), n[u](i.move, y, c), n[u](i.end, E, p))
        }

        function T() {
            const {scrollbar: e, $el: s} = t;
            t.params.scrollbar = F(t, t.originalParams.scrollbar, t.params.scrollbar, {el: "swiper-scrollbar"});
            const a = t.params.scrollbar;
            if (!a.el) return;
            let i = d(a.el);
            t.params.uniqueNavElements && "string" == typeof a.el && i.length > 1 && 1 === s.find(a.el).length && (i = s.find(a.el)), i.addClass(t.isHorizontal() ? a.horizontalClass : a.verticalClass);
            let r = i.find(`.${t.params.scrollbar.dragClass}`);
            0 === r.length && (r = d(`<div class="${t.params.scrollbar.dragClass}"></div>`), i.append(r)), Object.assign(e, {
                $el: i,
                el: i[0],
                $dragEl: r,
                dragEl: r[0]
            }), a.draggable && t.params.scrollbar.el && t.scrollbar.el && C("on"), i && i[t.enabled ? "removeClass" : "addClass"](t.params.scrollbar.lockClass)
        }

        function $() {
            const e = t.params.scrollbar, s = t.scrollbar.$el;
            s && s.removeClass(t.isHorizontal() ? e.horizontalClass : e.verticalClass), t.params.scrollbar.el && t.scrollbar.el && C("off")
        }

        s({
            scrollbar: {
                el: null,
                dragSize: "auto",
                hide: !1,
                draggable: !1,
                snapOnRelease: !0,
                lockClass: "swiper-scrollbar-lock",
                dragClass: "swiper-scrollbar-drag",
                scrollbarDisabledClass: "swiper-scrollbar-disabled",
                horizontalClass: "swiper-scrollbar-horizontal",
                verticalClass: "swiper-scrollbar-vertical"
            }
        }), t.scrollbar = {el: null, dragEl: null, $el: null, $dragEl: null}, i("init", (() => {
            !1 === t.params.scrollbar.enabled ? S() : (T(), v(), g())
        })), i("update resize observerUpdate lock unlock", (() => {
            v()
        })), i("setTranslate", (() => {
            g()
        })), i("setTransition", ((e, s) => {
            !function (e) {
                t.params.scrollbar.el && t.scrollbar.el && t.scrollbar.$dragEl.transition(e)
            }(s)
        })), i("enable disable", (() => {
            const {$el: e} = t.scrollbar;
            e && e[t.enabled ? "removeClass" : "addClass"](t.params.scrollbar.lockClass)
        })), i("destroy", (() => {
            $()
        }));
        const S = () => {
            t.$el.addClass(t.params.scrollbar.scrollbarDisabledClass), t.scrollbar.$el && t.scrollbar.$el.addClass(t.params.scrollbar.scrollbarDisabledClass), $()
        };
        Object.assign(t.scrollbar, {
            enable: () => {
                t.$el.removeClass(t.params.scrollbar.scrollbarDisabledClass), t.scrollbar.$el && t.scrollbar.$el.removeClass(t.params.scrollbar.scrollbarDisabledClass), T(), v(), g()
            }, disable: S, updateSize: v, setTranslate: g, init: T, destroy: $
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({parallax: {enabled: !1}});
        const i = (e, s) => {
            const {rtl: a} = t, i = d(e), r = a ? -1 : 1, n = i.attr("data-swiper-parallax") || "0";
            let l = i.attr("data-swiper-parallax-x"), o = i.attr("data-swiper-parallax-y");
            const c = i.attr("data-swiper-parallax-scale"), p = i.attr("data-swiper-parallax-opacity");
            if (l || o ? (l = l || "0", o = o || "0") : t.isHorizontal() ? (l = n, o = "0") : (o = n, l = "0"), l = l.indexOf("%") >= 0 ? parseInt(l, 10) * s * r + "%" : l * s * r + "px", o = o.indexOf("%") >= 0 ? parseInt(o, 10) * s + "%" : o * s + "px", null != p) {
                const e = p - (p - 1) * (1 - Math.abs(s));
                i[0].style.opacity = e
            }
            if (null == c) i.transform(`translate3d(${l}, ${o}, 0px)`); else {
                const e = c - (c - 1) * (1 - Math.abs(s));
                i.transform(`translate3d(${l}, ${o}, 0px) scale(${e})`)
            }
        }, r = () => {
            const {$el: e, slides: s, progress: a, snapGrid: r} = t;
            e.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((e => {
                i(e, a)
            })), s.each(((e, s) => {
                let n = e.progress;
                t.params.slidesPerGroup > 1 && "auto" !== t.params.slidesPerView && (n += Math.ceil(s / 2) - a * (r.length - 1)), n = Math.min(Math.max(n, -1), 1), d(e).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((e => {
                    i(e, n)
                }))
            }))
        };
        a("beforeInit", (() => {
            t.params.parallax.enabled && (t.params.watchSlidesProgress = !0, t.originalParams.watchSlidesProgress = !0)
        })), a("init", (() => {
            t.params.parallax.enabled && r()
        })), a("setTranslate", (() => {
            t.params.parallax.enabled && r()
        })), a("setTransition", ((e, s) => {
            t.params.parallax.enabled && function (e) {
                void 0 === e && (e = t.params.speed);
                const {$el: s} = t;
                s.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((t => {
                    const s = d(t);
                    let a = parseInt(s.attr("data-swiper-parallax-duration"), 10) || e;
                    0 === e && (a = 0), s.transition(a)
                }))
            }(s)
        }))
    }, function (e) {
        let {swiper: t, extendParams: s, on: a, emit: i} = e;
        const n = r();
        s({
            zoom: {
                enabled: !1,
                maxRatio: 3,
                minRatio: 1,
                toggle: !0,
                containerClass: "swiper-zoom-container",
                zoomedSlideClass: "swiper-slide-zoomed"
            }
        }), t.zoom = {enabled: !1};
        let l, o, c, p = 1, u = !1;
        const m = {
            $slideEl: void 0,
            slideWidth: void 0,
            slideHeight: void 0,
            $imageEl: void 0,
            $imageWrapEl: void 0,
            maxRatio: 3
        }, f = {
            isTouched: void 0,
            isMoved: void 0,
            currentX: void 0,
            currentY: void 0,
            minX: void 0,
            minY: void 0,
            maxX: void 0,
            maxY: void 0,
            width: void 0,
            height: void 0,
            startX: void 0,
            startY: void 0,
            touchesStart: {},
            touchesCurrent: {}
        }, g = {x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0};
        let v = 1;

        function w(e) {
            if (e.targetTouches.length < 2) return 1;
            const t = e.targetTouches[0].pageX, s = e.targetTouches[0].pageY, a = e.targetTouches[1].pageX,
                i = e.targetTouches[1].pageY;
            return Math.sqrt((a - t) ** 2 + (i - s) ** 2)
        }

        function b(e) {
            const s = t.support, a = t.params.zoom;
            if (o = !1, c = !1, !s.gestures) {
                if ("touchstart" !== e.type || "touchstart" === e.type && e.targetTouches.length < 2) return;
                o = !0, m.scaleStart = w(e)
            }
            m.$slideEl && m.$slideEl.length || (m.$slideEl = d(e.target).closest(`.${t.params.slideClass}`), 0 === m.$slideEl.length && (m.$slideEl = t.slides.eq(t.activeIndex)), m.$imageEl = m.$slideEl.find(`.${a.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), m.$imageWrapEl = m.$imageEl.parent(`.${a.containerClass}`), m.maxRatio = m.$imageWrapEl.attr("data-swiper-zoom") || a.maxRatio, 0 !== m.$imageWrapEl.length) ? (m.$imageEl && m.$imageEl.transition(0), u = !0) : m.$imageEl = void 0
        }

        function x(e) {
            const s = t.support, a = t.params.zoom, i = t.zoom;
            if (!s.gestures) {
                if ("touchmove" !== e.type || "touchmove" === e.type && e.targetTouches.length < 2) return;
                c = !0, m.scaleMove = w(e)
            }
            m.$imageEl && 0 !== m.$imageEl.length ? (s.gestures ? i.scale = e.scale * p : i.scale = m.scaleMove / m.scaleStart * p, i.scale > m.maxRatio && (i.scale = m.maxRatio - 1 + (i.scale - m.maxRatio + 1) ** .5), i.scale < a.minRatio && (i.scale = a.minRatio + 1 - (a.minRatio - i.scale + 1) ** .5), m.$imageEl.transform(`translate3d(0,0,0) scale(${i.scale})`)) : "gesturechange" === e.type && b(e)
        }

        function y(e) {
            const s = t.device, a = t.support, i = t.params.zoom, r = t.zoom;
            if (!a.gestures) {
                if (!o || !c) return;
                if ("touchend" !== e.type || "touchend" === e.type && e.changedTouches.length < 2 && !s.android) return;
                o = !1, c = !1
            }
            m.$imageEl && 0 !== m.$imageEl.length && (r.scale = Math.max(Math.min(r.scale, m.maxRatio), i.minRatio), m.$imageEl.transition(t.params.speed).transform(`translate3d(0,0,0) scale(${r.scale})`), p = r.scale, u = !1, 1 === r.scale && (m.$slideEl = void 0))
        }

        function E(e) {
            const s = t.zoom;
            if (!m.$imageEl || 0 === m.$imageEl.length) return;
            if (t.allowClick = !1, !f.isTouched || !m.$slideEl) return;
            f.isMoved || (f.width = m.$imageEl[0].offsetWidth, f.height = m.$imageEl[0].offsetHeight, f.startX = h(m.$imageWrapEl[0], "x") || 0, f.startY = h(m.$imageWrapEl[0], "y") || 0, m.slideWidth = m.$slideEl[0].offsetWidth, m.slideHeight = m.$slideEl[0].offsetHeight, m.$imageWrapEl.transition(0));
            const a = f.width * s.scale, i = f.height * s.scale;
            if (!(a < m.slideWidth && i < m.slideHeight)) {
                if (f.minX = Math.min(m.slideWidth / 2 - a / 2, 0), f.maxX = -f.minX, f.minY = Math.min(m.slideHeight / 2 - i / 2, 0), f.maxY = -f.minY, f.touchesCurrent.x = "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX, f.touchesCurrent.y = "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY, !f.isMoved && !u) {
                    if (t.isHorizontal() && (Math.floor(f.minX) === Math.floor(f.startX) && f.touchesCurrent.x < f.touchesStart.x || Math.floor(f.maxX) === Math.floor(f.startX) && f.touchesCurrent.x > f.touchesStart.x)) return void (f.isTouched = !1);
                    if (!t.isHorizontal() && (Math.floor(f.minY) === Math.floor(f.startY) && f.touchesCurrent.y < f.touchesStart.y || Math.floor(f.maxY) === Math.floor(f.startY) && f.touchesCurrent.y > f.touchesStart.y)) return void (f.isTouched = !1)
                }
                e.cancelable && e.preventDefault(), e.stopPropagation(), f.isMoved = !0, f.currentX = f.touchesCurrent.x - f.touchesStart.x + f.startX, f.currentY = f.touchesCurrent.y - f.touchesStart.y + f.startY, f.currentX < f.minX && (f.currentX = f.minX + 1 - (f.minX - f.currentX + 1) ** .8), f.currentX > f.maxX && (f.currentX = f.maxX - 1 + (f.currentX - f.maxX + 1) ** .8), f.currentY < f.minY && (f.currentY = f.minY + 1 - (f.minY - f.currentY + 1) ** .8), f.currentY > f.maxY && (f.currentY = f.maxY - 1 + (f.currentY - f.maxY + 1) ** .8), g.prevPositionX || (g.prevPositionX = f.touchesCurrent.x), g.prevPositionY || (g.prevPositionY = f.touchesCurrent.y), g.prevTime || (g.prevTime = Date.now()), g.x = (f.touchesCurrent.x - g.prevPositionX) / (Date.now() - g.prevTime) / 2, g.y = (f.touchesCurrent.y - g.prevPositionY) / (Date.now() - g.prevTime) / 2, Math.abs(f.touchesCurrent.x - g.prevPositionX) < 2 && (g.x = 0), Math.abs(f.touchesCurrent.y - g.prevPositionY) < 2 && (g.y = 0), g.prevPositionX = f.touchesCurrent.x, g.prevPositionY = f.touchesCurrent.y, g.prevTime = Date.now(), m.$imageWrapEl.transform(`translate3d(${f.currentX}px, ${f.currentY}px,0)`)
            }
        }

        function C() {
            const e = t.zoom;
            m.$slideEl && t.previousIndex !== t.activeIndex && (m.$imageEl && m.$imageEl.transform("translate3d(0,0,0) scale(1)"), m.$imageWrapEl && m.$imageWrapEl.transform("translate3d(0,0,0)"), e.scale = 1, p = 1, m.$slideEl = void 0, m.$imageEl = void 0, m.$imageWrapEl = void 0)
        }

        function T(e) {
            const s = t.zoom, a = t.params.zoom;
            if (m.$slideEl || (e && e.target && (m.$slideEl = d(e.target).closest(`.${t.params.slideClass}`)), m.$slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? m.$slideEl = t.$wrapperEl.children(`.${t.params.slideActiveClass}`) : m.$slideEl = t.slides.eq(t.activeIndex)), m.$imageEl = m.$slideEl.find(`.${a.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), m.$imageWrapEl = m.$imageEl.parent(`.${a.containerClass}`)), !m.$imageEl || 0 === m.$imageEl.length || !m.$imageWrapEl || 0 === m.$imageWrapEl.length) return;
            let i, r, l, o, c, u, h, g, v, w, b, x, y, E, C, T, $, S;
            t.params.cssMode && (t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.touchAction = "none"), m.$slideEl.addClass(`${a.zoomedSlideClass}`), void 0 === f.touchesStart.x && e ? (i = "touchend" === e.type ? e.changedTouches[0].pageX : e.pageX, r = "touchend" === e.type ? e.changedTouches[0].pageY : e.pageY) : (i = f.touchesStart.x, r = f.touchesStart.y), s.scale = m.$imageWrapEl.attr("data-swiper-zoom") || a.maxRatio, p = m.$imageWrapEl.attr("data-swiper-zoom") || a.maxRatio, e ? ($ = m.$slideEl[0].offsetWidth, S = m.$slideEl[0].offsetHeight, l = m.$slideEl.offset().left + n.scrollX, o = m.$slideEl.offset().top + n.scrollY, c = l + $ / 2 - i, u = o + S / 2 - r, v = m.$imageEl[0].offsetWidth, w = m.$imageEl[0].offsetHeight, b = v * s.scale, x = w * s.scale, y = Math.min($ / 2 - b / 2, 0), E = Math.min(S / 2 - x / 2, 0), C = -y, T = -E, h = c * s.scale, g = u * s.scale, h < y && (h = y), h > C && (h = C), g < E && (g = E), g > T && (g = T)) : (h = 0, g = 0), m.$imageWrapEl.transition(300).transform(`translate3d(${h}px, ${g}px,0)`), m.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${s.scale})`)
        }

        function $() {
            const e = t.zoom, s = t.params.zoom;
            m.$slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? m.$slideEl = t.$wrapperEl.children(`.${t.params.slideActiveClass}`) : m.$slideEl = t.slides.eq(t.activeIndex), m.$imageEl = m.$slideEl.find(`.${s.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), m.$imageWrapEl = m.$imageEl.parent(`.${s.containerClass}`)), m.$imageEl && 0 !== m.$imageEl.length && m.$imageWrapEl && 0 !== m.$imageWrapEl.length && (t.params.cssMode && (t.wrapperEl.style.overflow = "", t.wrapperEl.style.touchAction = ""), e.scale = 1, p = 1, m.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"), m.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"), m.$slideEl.removeClass(`${s.zoomedSlideClass}`), m.$slideEl = void 0)
        }

        function S(e) {
            const s = t.zoom;
            s.scale && 1 !== s.scale ? $() : T(e)
        }

        function M() {
            const e = t.support;
            return {
                passiveListener: !("touchstart" !== t.touchEvents.start || !e.passiveListener || !t.params.passiveListeners) && {
                    passive: !0,
                    capture: !1
                }, activeListenerWithCapture: !e.passiveListener || {passive: !1, capture: !0}
            }
        }

        function P() {
            return `.${t.params.slideClass}`
        }

        function k(e) {
            const {passiveListener: s} = M(), a = P();
            t.$wrapperEl[e]("gesturestart", a, b, s), t.$wrapperEl[e]("gesturechange", a, x, s), t.$wrapperEl[e]("gestureend", a, y, s)
        }

        function z() {
            l || (l = !0, k("on"))
        }

        function L() {
            l && (l = !1, k("off"))
        }

        function O() {
            const e = t.zoom;
            if (e.enabled) return;
            e.enabled = !0;
            const s = t.support, {passiveListener: a, activeListenerWithCapture: i} = M(), r = P();
            s.gestures ? (t.$wrapperEl.on(t.touchEvents.start, z, a), t.$wrapperEl.on(t.touchEvents.end, L, a)) : "touchstart" === t.touchEvents.start && (t.$wrapperEl.on(t.touchEvents.start, r, b, a), t.$wrapperEl.on(t.touchEvents.move, r, x, i), t.$wrapperEl.on(t.touchEvents.end, r, y, a), t.touchEvents.cancel && t.$wrapperEl.on(t.touchEvents.cancel, r, y, a)), t.$wrapperEl.on(t.touchEvents.move, `.${t.params.zoom.containerClass}`, E, i)
        }

        function I() {
            const e = t.zoom;
            if (!e.enabled) return;
            const s = t.support;
            e.enabled = !1;
            const {passiveListener: a, activeListenerWithCapture: i} = M(), r = P();
            s.gestures ? (t.$wrapperEl.off(t.touchEvents.start, z, a), t.$wrapperEl.off(t.touchEvents.end, L, a)) : "touchstart" === t.touchEvents.start && (t.$wrapperEl.off(t.touchEvents.start, r, b, a), t.$wrapperEl.off(t.touchEvents.move, r, x, i), t.$wrapperEl.off(t.touchEvents.end, r, y, a), t.touchEvents.cancel && t.$wrapperEl.off(t.touchEvents.cancel, r, y, a)), t.$wrapperEl.off(t.touchEvents.move, `.${t.params.zoom.containerClass}`, E, i)
        }

        Object.defineProperty(t.zoom, "scale", {
            get: () => v, set(e) {
                if (v !== e) {
                    const t = m.$imageEl ? m.$imageEl[0] : void 0, s = m.$slideEl ? m.$slideEl[0] : void 0;
                    i("zoomChange", e, t, s)
                }
                v = e
            }
        }), a("init", (() => {
            t.params.zoom.enabled && O()
        })), a("destroy", (() => {
            I()
        })), a("touchStart", ((e, s) => {
            t.zoom.enabled && function (e) {
                const s = t.device;
                m.$imageEl && 0 !== m.$imageEl.length && (f.isTouched || (s.android && e.cancelable && e.preventDefault(), f.isTouched = !0, f.touchesStart.x = "touchstart" === e.type ? e.targetTouches[0].pageX : e.pageX, f.touchesStart.y = "touchstart" === e.type ? e.targetTouches[0].pageY : e.pageY))
            }(s)
        })), a("touchEnd", ((e, s) => {
            t.zoom.enabled && function () {
                const e = t.zoom;
                if (!m.$imageEl || 0 === m.$imageEl.length) return;
                if (!f.isTouched || !f.isMoved) return f.isTouched = !1, void (f.isMoved = !1);
                f.isTouched = !1, f.isMoved = !1;
                let s = 300, a = 300;
                const i = g.x * s, r = f.currentX + i, n = g.y * a, l = f.currentY + n;
                0 !== g.x && (s = Math.abs((r - f.currentX) / g.x)), 0 !== g.y && (a = Math.abs((l - f.currentY) / g.y));
                const o = Math.max(s, a);
                f.currentX = r, f.currentY = l;
                const d = f.width * e.scale, c = f.height * e.scale;
                f.minX = Math.min(m.slideWidth / 2 - d / 2, 0), f.maxX = -f.minX, f.minY = Math.min(m.slideHeight / 2 - c / 2, 0), f.maxY = -f.minY, f.currentX = Math.max(Math.min(f.currentX, f.maxX), f.minX), f.currentY = Math.max(Math.min(f.currentY, f.maxY), f.minY), m.$imageWrapEl.transition(o).transform(`translate3d(${f.currentX}px, ${f.currentY}px,0)`)
            }()
        })), a("doubleTap", ((e, s) => {
            !t.animating && t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && S(s)
        })), a("transitionEnd", (() => {
            t.zoom.enabled && t.params.zoom.enabled && C()
        })), a("slideChange", (() => {
            t.zoom.enabled && t.params.zoom.enabled && t.params.cssMode && C()
        })), Object.assign(t.zoom, {enable: O, disable: I, in: T, out: $, toggle: S})
    }, function (e) {
        let {swiper: t, extendParams: s, on: a, emit: i} = e;
        s({
            lazy: {
                checkInView: !1,
                enabled: !1,
                loadPrevNext: !1,
                loadPrevNextAmount: 1,
                loadOnTransitionStart: !1,
                scrollingElement: "",
                elementClass: "swiper-lazy",
                loadingClass: "swiper-lazy-loading",
                loadedClass: "swiper-lazy-loaded",
                preloaderClass: "swiper-lazy-preloader"
            }
        }), t.lazy = {};
        let n = !1, l = !1;

        function o(e, s) {
            void 0 === s && (s = !0);
            const a = t.params.lazy;
            if (void 0 === e) return;
            if (0 === t.slides.length) return;
            const r = t.virtual && t.params.virtual.enabled ? t.$wrapperEl.children(`.${t.params.slideClass}[data-swiper-slide-index="${e}"]`) : t.slides.eq(e),
                n = r.find(`.${a.elementClass}:not(.${a.loadedClass}):not(.${a.loadingClass})`);
            !r.hasClass(a.elementClass) || r.hasClass(a.loadedClass) || r.hasClass(a.loadingClass) || n.push(r[0]), 0 !== n.length && n.each((e => {
                const n = d(e);
                n.addClass(a.loadingClass);
                const l = n.attr("data-background"), c = n.attr("data-src"), p = n.attr("data-srcset"),
                    u = n.attr("data-sizes"), h = n.parent("picture");
                t.loadImage(n[0], c || l, p, u, !1, (() => {
                    if (null != t && t && (!t || t.params) && !t.destroyed) {
                        if (l ? (n.css("background-image", `url("${l}")`), n.removeAttr("data-background")) : (p && (n.attr("srcset", p), n.removeAttr("data-srcset")), u && (n.attr("sizes", u), n.removeAttr("data-sizes")), h.length && h.children("source").each((e => {
                            const t = d(e);
                            t.attr("data-srcset") && (t.attr("srcset", t.attr("data-srcset")), t.removeAttr("data-srcset"))
                        })), c && (n.attr("src", c), n.removeAttr("data-src"))), n.addClass(a.loadedClass).removeClass(a.loadingClass), r.find(`.${a.preloaderClass}`).remove(), t.params.loop && s) {
                            const e = r.attr("data-swiper-slide-index");
                            if (r.hasClass(t.params.slideDuplicateClass)) {
                                o(t.$wrapperEl.children(`[data-swiper-slide-index="${e}"]:not(.${t.params.slideDuplicateClass})`).index(), !1)
                            } else {
                                o(t.$wrapperEl.children(`.${t.params.slideDuplicateClass}[data-swiper-slide-index="${e}"]`).index(), !1)
                            }
                        }
                        i("lazyImageReady", r[0], n[0]), t.params.autoHeight && t.updateAutoHeight()
                    }
                })), i("lazyImageLoad", r[0], n[0])
            }))
        }

        function c() {
            const {$wrapperEl: e, params: s, slides: a, activeIndex: i} = t, r = t.virtual && s.virtual.enabled,
                n = s.lazy;
            let c = s.slidesPerView;

            function p(t) {
                if (r) {
                    if (e.children(`.${s.slideClass}[data-swiper-slide-index="${t}"]`).length) return !0
                } else if (a[t]) return !0;
                return !1
            }

            function u(e) {
                return r ? d(e).attr("data-swiper-slide-index") : d(e).index()
            }

            if ("auto" === c && (c = 0), l || (l = !0), t.params.watchSlidesProgress) e.children(`.${s.slideVisibleClass}`).each((e => {
                o(r ? d(e).attr("data-swiper-slide-index") : d(e).index())
            })); else if (c > 1) for (let e = i; e < i + c; e += 1) p(e) && o(e); else o(i);
            if (n.loadPrevNext) if (c > 1 || n.loadPrevNextAmount && n.loadPrevNextAmount > 1) {
                const e = n.loadPrevNextAmount, t = Math.ceil(c), s = Math.min(i + t + Math.max(e, t), a.length),
                    r = Math.max(i - Math.max(t, e), 0);
                for (let e = i + t; e < s; e += 1) p(e) && o(e);
                for (let e = r; e < i; e += 1) p(e) && o(e)
            } else {
                const t = e.children(`.${s.slideNextClass}`);
                t.length > 0 && o(u(t));
                const a = e.children(`.${s.slidePrevClass}`);
                a.length > 0 && o(u(a))
            }
        }

        function p() {
            const e = r();
            if (!t || t.destroyed) return;
            const s = t.params.lazy.scrollingElement ? d(t.params.lazy.scrollingElement) : d(e), a = s[0] === e,
                i = a ? e.innerWidth : s[0].offsetWidth, l = a ? e.innerHeight : s[0].offsetHeight,
                o = t.$el.offset(), {rtlTranslate: u} = t;
            let h = !1;
            u && (o.left -= t.$el[0].scrollLeft);
            const m = [[o.left, o.top], [o.left + t.width, o.top], [o.left, o.top + t.height], [o.left + t.width, o.top + t.height]];
            for (let e = 0; e < m.length; e += 1) {
                const t = m[e];
                if (t[0] >= 0 && t[0] <= i && t[1] >= 0 && t[1] <= l) {
                    if (0 === t[0] && 0 === t[1]) continue;
                    h = !0
                }
            }
            const f = !("touchstart" !== t.touchEvents.start || !t.support.passiveListener || !t.params.passiveListeners) && {
                passive: !0,
                capture: !1
            };
            h ? (c(), s.off("scroll", p, f)) : n || (n = !0, s.on("scroll", p, f))
        }

        a("beforeInit", (() => {
            t.params.lazy.enabled && t.params.preloadImages && (t.params.preloadImages = !1)
        })), a("init", (() => {
            t.params.lazy.enabled && (t.params.lazy.checkInView ? p() : c())
        })), a("scroll", (() => {
            t.params.freeMode && t.params.freeMode.enabled && !t.params.freeMode.sticky && c()
        })), a("scrollbarDragMove resize _freeModeNoMomentumRelease", (() => {
            t.params.lazy.enabled && (t.params.lazy.checkInView ? p() : c())
        })), a("transitionStart", (() => {
            t.params.lazy.enabled && (t.params.lazy.loadOnTransitionStart || !t.params.lazy.loadOnTransitionStart && !l) && (t.params.lazy.checkInView ? p() : c())
        })), a("transitionEnd", (() => {
            t.params.lazy.enabled && !t.params.lazy.loadOnTransitionStart && (t.params.lazy.checkInView ? p() : c())
        })), a("slideChange", (() => {
            const {lazy: e, cssMode: s, watchSlidesProgress: a, touchReleaseOnEdges: i, resistanceRatio: r} = t.params;
            e.enabled && (s || a && (i || 0 === r)) && c()
        })), a("destroy", (() => {
            t.$el && t.$el.find(`.${t.params.lazy.loadingClass}`).removeClass(t.params.lazy.loadingClass)
        })), Object.assign(t.lazy, {load: c, loadInSlide: o})
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;

        function i(e, t) {
            const s = function () {
                let e, t, s;
                return (a, i) => {
                    for (t = -1, e = a.length; e - t > 1;) s = e + t >> 1, a[s] <= i ? t = s : e = s;
                    return e
                }
            }();
            let a, i;
            return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) {
                return e ? (i = s(this.x, e), a = i - 1, (e - this.x[a]) * (this.y[i] - this.y[a]) / (this.x[i] - this.x[a]) + this.y[a]) : 0
            }, this
        }

        function r() {
            t.controller.control && t.controller.spline && (t.controller.spline = void 0, delete t.controller.spline)
        }

        s({
            controller: {
                control: void 0,
                inverse: !1,
                by: "slide"
            }
        }), t.controller = {control: void 0}, a("beforeInit", (() => {
            t.controller.control = t.params.controller.control
        })), a("update", (() => {
            r()
        })), a("resize", (() => {
            r()
        })), a("observerUpdate", (() => {
            r()
        })), a("setTranslate", ((e, s, a) => {
            t.controller.control && t.controller.setTranslate(s, a)
        })), a("setTransition", ((e, s, a) => {
            t.controller.control && t.controller.setTransition(s, a)
        })), Object.assign(t.controller, {
            setTranslate: function (e, s) {
                const a = t.controller.control;
                let r, n;
                const l = t.constructor;

                function o(e) {
                    const s = t.rtlTranslate ? -t.translate : t.translate;
                    "slide" === t.params.controller.by && (!function (e) {
                        t.controller.spline || (t.controller.spline = t.params.loop ? new i(t.slidesGrid, e.slidesGrid) : new i(t.snapGrid, e.snapGrid))
                    }(e), n = -t.controller.spline.interpolate(-s)), n && "container" !== t.params.controller.by || (r = (e.maxTranslate() - e.minTranslate()) / (t.maxTranslate() - t.minTranslate()), n = (s - t.minTranslate()) * r + e.minTranslate()), t.params.controller.inverse && (n = e.maxTranslate() - n), e.updateProgress(n), e.setTranslate(n, t), e.updateActiveIndex(), e.updateSlidesClasses()
                }

                if (Array.isArray(a)) for (let e = 0; e < a.length; e += 1) a[e] !== s && a[e] instanceof l && o(a[e]); else a instanceof l && s !== a && o(a)
            }, setTransition: function (e, s) {
                const a = t.constructor, i = t.controller.control;
                let r;

                function n(s) {
                    s.setTransition(e, t), 0 !== e && (s.transitionStart(), s.params.autoHeight && p((() => {
                        s.updateAutoHeight()
                    })), s.$wrapperEl.transitionEnd((() => {
                        i && (s.params.loop && "slide" === t.params.controller.by && s.loopFix(), s.transitionEnd())
                    })))
                }

                if (Array.isArray(i)) for (r = 0; r < i.length; r += 1) i[r] !== s && i[r] instanceof a && n(i[r]); else i instanceof a && s !== i && n(i)
            }
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({
            a11y: {
                enabled: !0,
                notificationClass: "swiper-notification",
                prevSlideMessage: "Previous slide",
                nextSlideMessage: "Next slide",
                firstSlideMessage: "This is the first slide",
                lastSlideMessage: "This is the last slide",
                paginationBulletMessage: "Go to slide {{index}}",
                slideLabelMessage: "{{index}} / {{slidesLength}}",
                containerMessage: null,
                containerRoleDescriptionMessage: null,
                itemRoleDescriptionMessage: null,
                slideRole: "group",
                id: null
            }
        }), t.a11y = {clicked: !1};
        let i = null;

        function r(e) {
            const t = i;
            0 !== t.length && (t.html(""), t.html(e))
        }

        function n(e) {
            e.attr("tabIndex", "0")
        }

        function l(e) {
            e.attr("tabIndex", "-1")
        }

        function o(e, t) {
            e.attr("role", t)
        }

        function c(e, t) {
            e.attr("aria-roledescription", t)
        }

        function p(e, t) {
            e.attr("aria-label", t)
        }

        function u(e) {
            e.attr("aria-disabled", !0)
        }

        function h(e) {
            e.attr("aria-disabled", !1)
        }

        function m(e) {
            if (13 !== e.keyCode && 32 !== e.keyCode) return;
            const s = t.params.a11y, a = d(e.target);
            t.navigation && t.navigation.$nextEl && a.is(t.navigation.$nextEl) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? r(s.lastSlideMessage) : r(s.nextSlideMessage)), t.navigation && t.navigation.$prevEl && a.is(t.navigation.$prevEl) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? r(s.firstSlideMessage) : r(s.prevSlideMessage)), t.pagination && a.is(U(t.params.pagination.bulletClass)) && a[0].click()
        }

        function f() {
            return t.pagination && t.pagination.bullets && t.pagination.bullets.length
        }

        function g() {
            return f() && t.params.pagination.clickable
        }

        const v = (e, t, s) => {
            n(e), "BUTTON" !== e[0].tagName && (o(e, "button"), e.on("keydown", m)), p(e, s), function (e, t) {
                e.attr("aria-controls", t)
            }(e, t)
        }, w = () => {
            t.a11y.clicked = !0
        }, b = () => {
            requestAnimationFrame((() => {
                requestAnimationFrame((() => {
                    t.destroyed || (t.a11y.clicked = !1)
                }))
            }))
        }, x = e => {
            if (t.a11y.clicked) return;
            const s = e.target.closest(`.${t.params.slideClass}`);
            if (!s || !t.slides.includes(s)) return;
            const a = t.slides.indexOf(s) === t.activeIndex,
                i = t.params.watchSlidesProgress && t.visibleSlides && t.visibleSlides.includes(s);
            a || i || e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents || (t.isHorizontal() ? t.el.scrollLeft = 0 : t.el.scrollTop = 0, t.slideTo(t.slides.indexOf(s), 0))
        }, y = () => {
            const e = t.params.a11y;
            e.itemRoleDescriptionMessage && c(d(t.slides), e.itemRoleDescriptionMessage), e.slideRole && o(d(t.slides), e.slideRole);
            const s = t.params.loop ? t.slides.filter((e => !e.classList.contains(t.params.slideDuplicateClass))).length : t.slides.length;
            e.slideLabelMessage && t.slides.each(((a, i) => {
                const r = d(a), n = t.params.loop ? parseInt(r.attr("data-swiper-slide-index"), 10) : i;
                p(r, e.slideLabelMessage.replace(/\{\{index\}\}/, n + 1).replace(/\{\{slidesLength\}\}/, s))
            }))
        }, E = () => {
            const e = t.params.a11y;
            t.$el.append(i);
            const s = t.$el;
            e.containerRoleDescriptionMessage && c(s, e.containerRoleDescriptionMessage), e.containerMessage && p(s, e.containerMessage);
            const a = t.$wrapperEl,
                r = e.id || a.attr("id") || `swiper-wrapper-${n = 16, void 0 === n && (n = 16), "x".repeat(n).replace(/x/g, (() => Math.round(16 * Math.random()).toString(16)))}`;
            var n;
            const l = t.params.autoplay && t.params.autoplay.enabled ? "off" : "polite";
            var o;
            let d, u;
            o = r, a.attr("id", o), function (e, t) {
                e.attr("aria-live", t)
            }(a, l), y(), t.navigation && t.navigation.$nextEl && (d = t.navigation.$nextEl), t.navigation && t.navigation.$prevEl && (u = t.navigation.$prevEl), d && d.length && v(d, r, e.nextSlideMessage), u && u.length && v(u, r, e.prevSlideMessage), g() && t.pagination.$el.on("keydown", U(t.params.pagination.bulletClass), m), t.$el.on("focus", x, !0), t.$el.on("pointerdown", w, !0), t.$el.on("pointerup", b, !0)
        };
        a("beforeInit", (() => {
            i = d(`<span class="${t.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`)
        })), a("afterInit", (() => {
            t.params.a11y.enabled && E()
        })), a("slidesLengthChange snapGridLengthChange slidesGridLengthChange", (() => {
            t.params.a11y.enabled && y()
        })), a("fromEdge toEdge afterInit lock unlock", (() => {
            t.params.a11y.enabled && function () {
                if (t.params.loop || t.params.rewind || !t.navigation) return;
                const {$nextEl: e, $prevEl: s} = t.navigation;
                s && s.length > 0 && (t.isBeginning ? (u(s), l(s)) : (h(s), n(s))), e && e.length > 0 && (t.isEnd ? (u(e), l(e)) : (h(e), n(e)))
            }()
        })), a("paginationUpdate", (() => {
            t.params.a11y.enabled && function () {
                const e = t.params.a11y;
                f() && t.pagination.bullets.each((s => {
                    const a = d(s);
                    t.params.pagination.clickable && (n(a), t.params.pagination.renderBullet || (o(a, "button"), p(a, e.paginationBulletMessage.replace(/\{\{index\}\}/, a.index() + 1)))), a.is(`.${t.params.pagination.bulletActiveClass}`) ? a.attr("aria-current", "true") : a.removeAttr("aria-current")
                }))
            }()
        })), a("destroy", (() => {
            t.params.a11y.enabled && function () {
                let e, s;
                i && i.length > 0 && i.remove(), t.navigation && t.navigation.$nextEl && (e = t.navigation.$nextEl), t.navigation && t.navigation.$prevEl && (s = t.navigation.$prevEl), e && e.off("keydown", m), s && s.off("keydown", m), g() && t.pagination.$el.off("keydown", U(t.params.pagination.bulletClass), m), t.$el.off("focus", x, !0), t.$el.off("pointerdown", w, !0), t.$el.off("pointerup", b, !0)
            }()
        }))
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({history: {enabled: !1, root: "", replaceState: !1, key: "slides", keepQuery: !1}});
        let i = !1, n = {};
        const l = e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""),
            o = e => {
                const t = r();
                let s;
                s = e ? new URL(e) : t.location;
                const a = s.pathname.slice(1).split("/").filter((e => "" !== e)), i = a.length;
                return {key: a[i - 2], value: a[i - 1]}
            }, d = (e, s) => {
                const a = r();
                if (!i || !t.params.history.enabled) return;
                let n;
                n = t.params.url ? new URL(t.params.url) : a.location;
                const o = t.slides.eq(s);
                let d = l(o.attr("data-history"));
                if (t.params.history.root.length > 0) {
                    let s = t.params.history.root;
                    "/" === s[s.length - 1] && (s = s.slice(0, s.length - 1)), d = `${s}/${e}/${d}`
                } else n.pathname.includes(e) || (d = `${e}/${d}`);
                t.params.history.keepQuery && (d += n.search);
                const c = a.history.state;
                c && c.value === d || (t.params.history.replaceState ? a.history.replaceState({value: d}, null, d) : a.history.pushState({value: d}, null, d))
            }, c = (e, s, a) => {
                if (s) for (let i = 0, r = t.slides.length; i < r; i += 1) {
                    const r = t.slides.eq(i);
                    if (l(r.attr("data-history")) === s && !r.hasClass(t.params.slideDuplicateClass)) {
                        const s = r.index();
                        t.slideTo(s, e, a)
                    }
                } else t.slideTo(0, e, a)
            }, p = () => {
                n = o(t.params.url), c(t.params.speed, n.value, !1)
            };
        a("init", (() => {
            t.params.history.enabled && (() => {
                const e = r();
                if (t.params.history) {
                    if (!e.history || !e.history.pushState) return t.params.history.enabled = !1, void (t.params.hashNavigation.enabled = !0);
                    i = !0, n = o(t.params.url), (n.key || n.value) && (c(0, n.value, t.params.runCallbacksOnInit), t.params.history.replaceState || e.addEventListener("popstate", p))
                }
            })()
        })), a("destroy", (() => {
            t.params.history.enabled && (() => {
                const e = r();
                t.params.history.replaceState || e.removeEventListener("popstate", p)
            })()
        })), a("transitionEnd _freeModeNoMomentumRelease", (() => {
            i && d(t.params.history.key, t.activeIndex)
        })), a("slideChange", (() => {
            i && t.params.cssMode && d(t.params.history.key, t.activeIndex)
        }))
    }, function (e) {
        let {swiper: t, extendParams: s, emit: i, on: n} = e, l = !1;
        const o = a(), c = r();
        s({hashNavigation: {enabled: !1, replaceState: !1, watchState: !1}});
        const p = () => {
            i("hashChange");
            const e = o.location.hash.replace("#", "");
            if (e !== t.slides.eq(t.activeIndex).attr("data-hash")) {
                const s = t.$wrapperEl.children(`.${t.params.slideClass}[data-hash="${e}"]`).index();
                if (void 0 === s) return;
                t.slideTo(s)
            }
        }, u = () => {
            if (l && t.params.hashNavigation.enabled) if (t.params.hashNavigation.replaceState && c.history && c.history.replaceState) c.history.replaceState(null, null, `#${t.slides.eq(t.activeIndex).attr("data-hash")}` || ""), i("hashSet"); else {
                const e = t.slides.eq(t.activeIndex), s = e.attr("data-hash") || e.attr("data-history");
                o.location.hash = s || "", i("hashSet")
            }
        };
        n("init", (() => {
            t.params.hashNavigation.enabled && (() => {
                if (!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled) return;
                l = !0;
                const e = o.location.hash.replace("#", "");
                if (e) {
                    const s = 0;
                    for (let a = 0, i = t.slides.length; a < i; a += 1) {
                        const i = t.slides.eq(a);
                        if ((i.attr("data-hash") || i.attr("data-history")) === e && !i.hasClass(t.params.slideDuplicateClass)) {
                            const e = i.index();
                            t.slideTo(e, s, t.params.runCallbacksOnInit, !0)
                        }
                    }
                }
                t.params.hashNavigation.watchState && d(c).on("hashchange", p)
            })()
        })), n("destroy", (() => {
            t.params.hashNavigation.enabled && t.params.hashNavigation.watchState && d(c).off("hashchange", p)
        })), n("transitionEnd _freeModeNoMomentumRelease", (() => {
            l && u()
        })), n("slideChange", (() => {
            l && t.params.cssMode && u()
        }))
    }, function (e) {
        let t, {swiper: s, extendParams: i, on: r, emit: n} = e;

        function l() {
            if (!s.size) return s.autoplay.running = !1, void (s.autoplay.paused = !1);
            const e = s.slides.eq(s.activeIndex);
            let a = s.params.autoplay.delay;
            e.attr("data-swiper-autoplay") && (a = e.attr("data-swiper-autoplay") || s.params.autoplay.delay), clearTimeout(t), t = p((() => {
                let e;
                s.params.autoplay.reverseDirection ? s.params.loop ? (s.loopFix(), e = s.slidePrev(s.params.speed, !0, !0), n("autoplay")) : s.isBeginning ? s.params.autoplay.stopOnLastSlide ? d() : (e = s.slideTo(s.slides.length - 1, s.params.speed, !0, !0), n("autoplay")) : (e = s.slidePrev(s.params.speed, !0, !0), n("autoplay")) : s.params.loop ? (s.loopFix(), e = s.slideNext(s.params.speed, !0, !0), n("autoplay")) : s.isEnd ? s.params.autoplay.stopOnLastSlide ? d() : (e = s.slideTo(0, s.params.speed, !0, !0), n("autoplay")) : (e = s.slideNext(s.params.speed, !0, !0), n("autoplay")), (s.params.cssMode && s.autoplay.running || !1 === e) && l()
            }), a)
        }

        function o() {
            return void 0 === t && (!s.autoplay.running && (s.autoplay.running = !0, n("autoplayStart"), l(), !0))
        }

        function d() {
            return !!s.autoplay.running && (void 0 !== t && (t && (clearTimeout(t), t = void 0), s.autoplay.running = !1, n("autoplayStop"), !0))
        }

        function c(e) {
            s.autoplay.running && (s.autoplay.paused || (t && clearTimeout(t), s.autoplay.paused = !0, 0 !== e && s.params.autoplay.waitForTransition ? ["transitionend", "webkitTransitionEnd"].forEach((e => {
                s.$wrapperEl[0].addEventListener(e, h)
            })) : (s.autoplay.paused = !1, l())))
        }

        function u() {
            const e = a();
            "hidden" === e.visibilityState && s.autoplay.running && c(), "visible" === e.visibilityState && s.autoplay.paused && (l(), s.autoplay.paused = !1)
        }

        function h(e) {
            s && !s.destroyed && s.$wrapperEl && e.target === s.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach((e => {
                s.$wrapperEl[0].removeEventListener(e, h)
            })), s.autoplay.paused = !1, s.autoplay.running ? l() : d())
        }

        function m() {
            s.params.autoplay.disableOnInteraction ? d() : (n("autoplayPause"), c()), ["transitionend", "webkitTransitionEnd"].forEach((e => {
                s.$wrapperEl[0].removeEventListener(e, h)
            }))
        }

        function f() {
            s.params.autoplay.disableOnInteraction || (s.autoplay.paused = !1, n("autoplayResume"), l())
        }

        s.autoplay = {running: !1, paused: !1}, i({
            autoplay: {
                enabled: !1,
                delay: 3e3,
                waitForTransition: !0,
                disableOnInteraction: !0,
                stopOnLastSlide: !1,
                reverseDirection: !1,
                pauseOnMouseEnter: !1
            }
        }), r("init", (() => {
            if (s.params.autoplay.enabled) {
                o();
                a().addEventListener("visibilitychange", u), s.params.autoplay.pauseOnMouseEnter && (s.$el.on("mouseenter", m), s.$el.on("mouseleave", f))
            }
        })), r("beforeTransitionStart", ((e, t, a) => {
            s.autoplay.running && (a || !s.params.autoplay.disableOnInteraction ? s.autoplay.pause(t) : d())
        })), r("sliderFirstMove", (() => {
            s.autoplay.running && (s.params.autoplay.disableOnInteraction ? d() : c())
        })), r("touchEnd", (() => {
            s.params.cssMode && s.autoplay.paused && !s.params.autoplay.disableOnInteraction && l()
        })), r("destroy", (() => {
            s.$el.off("mouseenter", m), s.$el.off("mouseleave", f), s.autoplay.running && d();
            a().removeEventListener("visibilitychange", u)
        })), Object.assign(s.autoplay, {pause: c, run: l, start: o, stop: d})
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({
            thumbs: {
                swiper: null,
                multipleActiveThumbs: !0,
                autoScrollOffset: 0,
                slideThumbActiveClass: "swiper-slide-thumb-active",
                thumbsContainerClass: "swiper-thumbs"
            }
        });
        let i = !1, r = !1;

        function n() {
            const e = t.thumbs.swiper;
            if (!e || e.destroyed) return;
            const s = e.clickedIndex, a = e.clickedSlide;
            if (a && d(a).hasClass(t.params.thumbs.slideThumbActiveClass)) return;
            if (null == s) return;
            let i;
            if (i = e.params.loop ? parseInt(d(e.clickedSlide).attr("data-swiper-slide-index"), 10) : s, t.params.loop) {
                let e = t.activeIndex;
                t.slides.eq(e).hasClass(t.params.slideDuplicateClass) && (t.loopFix(), t._clientLeft = t.$wrapperEl[0].clientLeft, e = t.activeIndex);
                const s = t.slides.eq(e).prevAll(`[data-swiper-slide-index="${i}"]`).eq(0).index(),
                    a = t.slides.eq(e).nextAll(`[data-swiper-slide-index="${i}"]`).eq(0).index();
                i = void 0 === s ? a : void 0 === a ? s : a - e < e - s ? a : s
            }
            t.slideTo(i)
        }

        function l() {
            const {thumbs: e} = t.params;
            if (i) return !1;
            i = !0;
            const s = t.constructor;
            if (e.swiper instanceof s) t.thumbs.swiper = e.swiper, Object.assign(t.thumbs.swiper.originalParams, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1
            }), Object.assign(t.thumbs.swiper.params, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1
            }); else if (m(e.swiper)) {
                const a = Object.assign({}, e.swiper);
                Object.assign(a, {watchSlidesProgress: !0, slideToClickedSlide: !1}), t.thumbs.swiper = new s(a), r = !0
            }
            return t.thumbs.swiper.$el.addClass(t.params.thumbs.thumbsContainerClass), t.thumbs.swiper.on("tap", n), !0
        }

        function o(e) {
            const s = t.thumbs.swiper;
            if (!s || s.destroyed) return;
            const a = "auto" === s.params.slidesPerView ? s.slidesPerViewDynamic() : s.params.slidesPerView;
            let i = 1;
            const r = t.params.thumbs.slideThumbActiveClass;
            if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (i = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (i = 1), i = Math.floor(i), s.slides.removeClass(r), s.params.loop || s.params.virtual && s.params.virtual.enabled) for (let e = 0; e < i; e += 1) s.$wrapperEl.children(`[data-swiper-slide-index="${t.realIndex + e}"]`).addClass(r); else for (let e = 0; e < i; e += 1) s.slides.eq(t.realIndex + e).addClass(r);
            const n = t.params.thumbs.autoScrollOffset, l = n && !s.params.loop;
            if (t.realIndex !== s.realIndex || l) {
                let i, r, o = s.activeIndex;
                if (s.params.loop) {
                    s.slides.eq(o).hasClass(s.params.slideDuplicateClass) && (s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft, o = s.activeIndex);
                    const e = s.slides.eq(o).prevAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index(),
                        a = s.slides.eq(o).nextAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index();
                    i = void 0 === e ? a : void 0 === a ? e : a - o == o - e ? s.params.slidesPerGroup > 1 ? a : o : a - o < o - e ? a : e, r = t.activeIndex > t.previousIndex ? "next" : "prev"
                } else i = t.realIndex, r = i > t.previousIndex ? "next" : "prev";
                l && (i += "next" === r ? n : -1 * n), s.visibleSlidesIndexes && s.visibleSlidesIndexes.indexOf(i) < 0 && (s.params.centeredSlides ? i = i > o ? i - Math.floor(a / 2) + 1 : i + Math.floor(a / 2) - 1 : i > o && s.params.slidesPerGroup, s.slideTo(i, e ? 0 : void 0))
            }
        }

        t.thumbs = {swiper: null}, a("beforeInit", (() => {
            const {thumbs: e} = t.params;
            e && e.swiper && (l(), o(!0))
        })), a("slideChange update resize observerUpdate", (() => {
            o()
        })), a("setTransition", ((e, s) => {
            const a = t.thumbs.swiper;
            a && !a.destroyed && a.setTransition(s)
        })), a("beforeDestroy", (() => {
            const e = t.thumbs.swiper;
            e && !e.destroyed && r && e.destroy()
        })), Object.assign(t.thumbs, {init: l, update: o})
    }, function (e) {
        let {swiper: t, extendParams: s, emit: a, once: i} = e;
        s({
            freeMode: {
                enabled: !1,
                momentum: !0,
                momentumRatio: 1,
                momentumBounce: !0,
                momentumBounceRatio: 1,
                momentumVelocityRatio: 1,
                sticky: !1,
                minimumVelocity: .02
            }
        }), Object.assign(t, {
            freeMode: {
                onTouchStart: function () {
                    const e = t.getTranslate();
                    t.setTranslate(e), t.setTransition(0), t.touchEventsData.velocities.length = 0, t.freeMode.onTouchEnd({currentPos: t.rtl ? t.translate : -t.translate})
                }, onTouchMove: function () {
                    const {touchEventsData: e, touches: s} = t;
                    0 === e.velocities.length && e.velocities.push({
                        position: s[t.isHorizontal() ? "startX" : "startY"],
                        time: e.touchStartTime
                    }), e.velocities.push({position: s[t.isHorizontal() ? "currentX" : "currentY"], time: u()})
                }, onTouchEnd: function (e) {
                    let {currentPos: s} = e;
                    const {params: r, $wrapperEl: n, rtlTranslate: l, snapGrid: o, touchEventsData: d} = t,
                        c = u() - d.touchStartTime;
                    if (s < -t.minTranslate()) t.slideTo(t.activeIndex); else if (s > -t.maxTranslate()) t.slides.length < o.length ? t.slideTo(o.length - 1) : t.slideTo(t.slides.length - 1); else {
                        if (r.freeMode.momentum) {
                            if (d.velocities.length > 1) {
                                const e = d.velocities.pop(), s = d.velocities.pop(), a = e.position - s.position,
                                    i = e.time - s.time;
                                t.velocity = a / i, t.velocity /= 2, Math.abs(t.velocity) < r.freeMode.minimumVelocity && (t.velocity = 0), (i > 150 || u() - e.time > 300) && (t.velocity = 0)
                            } else t.velocity = 0;
                            t.velocity *= r.freeMode.momentumVelocityRatio, d.velocities.length = 0;
                            let e = 1e3 * r.freeMode.momentumRatio;
                            const s = t.velocity * e;
                            let c = t.translate + s;
                            l && (c = -c);
                            let p, h = !1;
                            const m = 20 * Math.abs(t.velocity) * r.freeMode.momentumBounceRatio;
                            let f;
                            if (c < t.maxTranslate()) r.freeMode.momentumBounce ? (c + t.maxTranslate() < -m && (c = t.maxTranslate() - m), p = t.maxTranslate(), h = !0, d.allowMomentumBounce = !0) : c = t.maxTranslate(), r.loop && r.centeredSlides && (f = !0); else if (c > t.minTranslate()) r.freeMode.momentumBounce ? (c - t.minTranslate() > m && (c = t.minTranslate() + m), p = t.minTranslate(), h = !0, d.allowMomentumBounce = !0) : c = t.minTranslate(), r.loop && r.centeredSlides && (f = !0); else if (r.freeMode.sticky) {
                                let e;
                                for (let t = 0; t < o.length; t += 1) if (o[t] > -c) {
                                    e = t;
                                    break
                                }
                                c = Math.abs(o[e] - c) < Math.abs(o[e - 1] - c) || "next" === t.swipeDirection ? o[e] : o[e - 1], c = -c
                            }
                            if (f && i("transitionEnd", (() => {
                                t.loopFix()
                            })), 0 !== t.velocity) {
                                if (e = l ? Math.abs((-c - t.translate) / t.velocity) : Math.abs((c - t.translate) / t.velocity), r.freeMode.sticky) {
                                    const s = Math.abs((l ? -c : c) - t.translate),
                                        a = t.slidesSizesGrid[t.activeIndex];
                                    e = s < a ? r.speed : s < 2 * a ? 1.5 * r.speed : 2.5 * r.speed
                                }
                            } else if (r.freeMode.sticky) return void t.slideToClosest();
                            r.freeMode.momentumBounce && h ? (t.updateProgress(p), t.setTransition(e), t.setTranslate(c), t.transitionStart(!0, t.swipeDirection), t.animating = !0, n.transitionEnd((() => {
                                t && !t.destroyed && d.allowMomentumBounce && (a("momentumBounce"), t.setTransition(r.speed), setTimeout((() => {
                                    t.setTranslate(p), n.transitionEnd((() => {
                                        t && !t.destroyed && t.transitionEnd()
                                    }))
                                }), 0))
                            }))) : t.velocity ? (a("_freeModeNoMomentumRelease"), t.updateProgress(c), t.setTransition(e), t.setTranslate(c), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, n.transitionEnd((() => {
                                t && !t.destroyed && t.transitionEnd()
                            })))) : t.updateProgress(c), t.updateActiveIndex(), t.updateSlidesClasses()
                        } else {
                            if (r.freeMode.sticky) return void t.slideToClosest();
                            r.freeMode && a("_freeModeNoMomentumRelease")
                        }
                        (!r.freeMode.momentum || c >= r.longSwipesMs) && (t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses())
                    }
                }
            }
        })
    }, function (e) {
        let t, s, a, {swiper: i, extendParams: r} = e;
        r({grid: {rows: 1, fill: "column"}}), i.grid = {
            initSlides: e => {
                const {slidesPerView: r} = i.params, {rows: n, fill: l} = i.params.grid;
                s = t / n, a = Math.floor(e / n), t = Math.floor(e / n) === e / n ? e : Math.ceil(e / n) * n, "auto" !== r && "row" === l && (t = Math.max(t, r * n))
            }, updateSlide: (e, r, n, l) => {
                const {slidesPerGroup: o, spaceBetween: d} = i.params, {rows: c, fill: p} = i.params.grid;
                let u, h, m;
                if ("row" === p && o > 1) {
                    const s = Math.floor(e / (o * c)), a = e - c * o * s,
                        i = 0 === s ? o : Math.min(Math.ceil((n - s * c * o) / c), o);
                    m = Math.floor(a / i), h = a - m * i + s * o, u = h + m * t / c, r.css({
                        "-webkit-order": u,
                        order: u
                    })
                } else "column" === p ? (h = Math.floor(e / c), m = e - h * c, (h > a || h === a && m === c - 1) && (m += 1, m >= c && (m = 0, h += 1))) : (m = Math.floor(e / s), h = e - m * s);
                r.css(l("margin-top"), 0 !== m ? d && `${d}px` : "")
            }, updateWrapperSize: (e, s, a) => {
                const {spaceBetween: r, centeredSlides: n, roundLengths: l} = i.params, {rows: o} = i.params.grid;
                if (i.virtualSize = (e + r) * t, i.virtualSize = Math.ceil(i.virtualSize / o) - r, i.$wrapperEl.css({[a("width")]: `${i.virtualSize + r}px`}), n) {
                    s.splice(0, s.length);
                    const e = [];
                    for (let t = 0; t < s.length; t += 1) {
                        let a = s[t];
                        l && (a = Math.floor(a)), s[t] < i.virtualSize + s[0] && e.push(a)
                    }
                    s.push(...e)
                }
            }
        }
    }, function (e) {
        let {swiper: t} = e;
        Object.assign(t, {
            appendSlide: K.bind(t),
            prependSlide: Z.bind(t),
            addSlide: Q.bind(t),
            removeSlide: J.bind(t),
            removeAllSlides: ee.bind(t)
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({fadeEffect: {crossFade: !1, transformEl: null}}), te({
            effect: "fade",
            swiper: t,
            on: a,
            setTranslate: () => {
                const {slides: e} = t, s = t.params.fadeEffect;
                for (let a = 0; a < e.length; a += 1) {
                    const e = t.slides.eq(a);
                    let i = -e[0].swiperSlideOffset;
                    t.params.virtualTranslate || (i -= t.translate);
                    let r = 0;
                    t.isHorizontal() || (r = i, i = 0);
                    const n = t.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(e[0].progress), 0) : 1 + Math.min(Math.max(e[0].progress, -1), 0);
                    se(s, e).css({opacity: n}).transform(`translate3d(${i}px, ${r}px, 0px)`)
                }
            },
            setTransition: e => {
                const {transformEl: s} = t.params.fadeEffect;
                (s ? t.slides.find(s) : t.slides).transition(e), ae({
                    swiper: t,
                    duration: e,
                    transformEl: s,
                    allSlides: !0
                })
            },
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: !0,
                spaceBetween: 0,
                virtualTranslate: !t.params.cssMode
            })
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({cubeEffect: {slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: .94}});
        const i = (e, t, s) => {
            let a = s ? e.find(".swiper-slide-shadow-left") : e.find(".swiper-slide-shadow-top"),
                i = s ? e.find(".swiper-slide-shadow-right") : e.find(".swiper-slide-shadow-bottom");
            0 === a.length && (a = d(`<div class="swiper-slide-shadow-${s ? "left" : "top"}"></div>`), e.append(a)), 0 === i.length && (i = d(`<div class="swiper-slide-shadow-${s ? "right" : "bottom"}"></div>`), e.append(i)), a.length && (a[0].style.opacity = Math.max(-t, 0)), i.length && (i[0].style.opacity = Math.max(t, 0))
        };
        te({
            effect: "cube",
            swiper: t,
            on: a,
            setTranslate: () => {
                const {$el: e, $wrapperEl: s, slides: a, width: r, height: n, rtlTranslate: l, size: o, browser: c} = t,
                    p = t.params.cubeEffect, u = t.isHorizontal(), h = t.virtual && t.params.virtual.enabled;
                let m, f = 0;
                p.shadow && (u ? (m = s.find(".swiper-cube-shadow"), 0 === m.length && (m = d('<div class="swiper-cube-shadow"></div>'), s.append(m)), m.css({height: `${r}px`})) : (m = e.find(".swiper-cube-shadow"), 0 === m.length && (m = d('<div class="swiper-cube-shadow"></div>'), e.append(m))));
                for (let e = 0; e < a.length; e += 1) {
                    const t = a.eq(e);
                    let s = e;
                    h && (s = parseInt(t.attr("data-swiper-slide-index"), 10));
                    let r = 90 * s, n = Math.floor(r / 360);
                    l && (r = -r, n = Math.floor(-r / 360));
                    const d = Math.max(Math.min(t[0].progress, 1), -1);
                    let c = 0, m = 0, g = 0;
                    s % 4 == 0 ? (c = 4 * -n * o, g = 0) : (s - 1) % 4 == 0 ? (c = 0, g = 4 * -n * o) : (s - 2) % 4 == 0 ? (c = o + 4 * n * o, g = o) : (s - 3) % 4 == 0 && (c = -o, g = 3 * o + 4 * o * n), l && (c = -c), u || (m = c, c = 0);
                    const v = `rotateX(${u ? 0 : -r}deg) rotateY(${u ? r : 0}deg) translate3d(${c}px, ${m}px, ${g}px)`;
                    d <= 1 && d > -1 && (f = 90 * s + 90 * d, l && (f = 90 * -s - 90 * d)), t.transform(v), p.slideShadows && i(t, d, u)
                }
                if (s.css({
                    "-webkit-transform-origin": `50% 50% -${o / 2}px`,
                    "transform-origin": `50% 50% -${o / 2}px`
                }), p.shadow) if (u) m.transform(`translate3d(0px, ${r / 2 + p.shadowOffset}px, ${-r / 2}px) rotateX(90deg) rotateZ(0deg) scale(${p.shadowScale})`); else {
                    const e = Math.abs(f) - 90 * Math.floor(Math.abs(f) / 90),
                        t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2),
                        s = p.shadowScale, a = p.shadowScale / t, i = p.shadowOffset;
                    m.transform(`scale3d(${s}, 1, ${a}) translate3d(0px, ${n / 2 + i}px, ${-n / 2 / a}px) rotateX(-90deg)`)
                }
                const g = c.isSafari || c.isWebView ? -o / 2 : 0;
                s.transform(`translate3d(0px,0,${g}px) rotateX(${t.isHorizontal() ? 0 : f}deg) rotateY(${t.isHorizontal() ? -f : 0}deg)`), s[0].style.setProperty("--swiper-cube-translate-z", `${g}px`)
            },
            setTransition: e => {
                const {$el: s, slides: a} = t;
                a.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), t.params.cubeEffect.shadow && !t.isHorizontal() && s.find(".swiper-cube-shadow").transition(e)
            },
            recreateShadows: () => {
                const e = t.isHorizontal();
                t.slides.each((t => {
                    const s = Math.max(Math.min(t.progress, 1), -1);
                    i(d(t), s, e)
                }))
            },
            getEffectParams: () => t.params.cubeEffect,
            perspective: () => !0,
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: !0,
                resistanceRatio: 0,
                spaceBetween: 0,
                centeredSlides: !1,
                virtualTranslate: !0
            })
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({flipEffect: {slideShadows: !0, limitRotation: !0, transformEl: null}});
        const i = (e, s, a) => {
            let i = t.isHorizontal() ? e.find(".swiper-slide-shadow-left") : e.find(".swiper-slide-shadow-top"),
                r = t.isHorizontal() ? e.find(".swiper-slide-shadow-right") : e.find(".swiper-slide-shadow-bottom");
            0 === i.length && (i = ie(a, e, t.isHorizontal() ? "left" : "top")), 0 === r.length && (r = ie(a, e, t.isHorizontal() ? "right" : "bottom")), i.length && (i[0].style.opacity = Math.max(-s, 0)), r.length && (r[0].style.opacity = Math.max(s, 0))
        };
        te({
            effect: "flip",
            swiper: t,
            on: a,
            setTranslate: () => {
                const {slides: e, rtlTranslate: s} = t, a = t.params.flipEffect;
                for (let r = 0; r < e.length; r += 1) {
                    const n = e.eq(r);
                    let l = n[0].progress;
                    t.params.flipEffect.limitRotation && (l = Math.max(Math.min(n[0].progress, 1), -1));
                    const o = n[0].swiperSlideOffset;
                    let d = -180 * l, c = 0, p = t.params.cssMode ? -o - t.translate : -o, u = 0;
                    t.isHorizontal() ? s && (d = -d) : (u = p, p = 0, c = -d, d = 0), n[0].style.zIndex = -Math.abs(Math.round(l)) + e.length, a.slideShadows && i(n, l, a);
                    const h = `translate3d(${p}px, ${u}px, 0px) rotateX(${c}deg) rotateY(${d}deg)`;
                    se(a, n).transform(h)
                }
            },
            setTransition: e => {
                const {transformEl: s} = t.params.flipEffect;
                (s ? t.slides.find(s) : t.slides).transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), ae({
                    swiper: t,
                    duration: e,
                    transformEl: s
                })
            },
            recreateShadows: () => {
                const e = t.params.flipEffect;
                t.slides.each((s => {
                    const a = d(s);
                    let r = a[0].progress;
                    t.params.flipEffect.limitRotation && (r = Math.max(Math.min(s.progress, 1), -1)), i(a, r, e)
                }))
            },
            getEffectParams: () => t.params.flipEffect,
            perspective: () => !0,
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: !0,
                spaceBetween: 0,
                virtualTranslate: !t.params.cssMode
            })
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({
            coverflowEffect: {
                rotate: 50,
                stretch: 0,
                depth: 100,
                scale: 1,
                modifier: 1,
                slideShadows: !0,
                transformEl: null
            }
        }), te({
            effect: "coverflow", swiper: t, on: a, setTranslate: () => {
                const {width: e, height: s, slides: a, slidesSizesGrid: i} = t, r = t.params.coverflowEffect,
                    n = t.isHorizontal(), l = t.translate, o = n ? e / 2 - l : s / 2 - l, d = n ? r.rotate : -r.rotate,
                    c = r.depth;
                for (let e = 0, t = a.length; e < t; e += 1) {
                    const t = a.eq(e), s = i[e], l = (o - t[0].swiperSlideOffset - s / 2) / s,
                        p = "function" == typeof r.modifier ? r.modifier(l) : l * r.modifier;
                    let u = n ? d * p : 0, h = n ? 0 : d * p, m = -c * Math.abs(p), f = r.stretch;
                    "string" == typeof f && -1 !== f.indexOf("%") && (f = parseFloat(r.stretch) / 100 * s);
                    let g = n ? 0 : f * p, v = n ? f * p : 0, w = 1 - (1 - r.scale) * Math.abs(p);
                    Math.abs(v) < .001 && (v = 0), Math.abs(g) < .001 && (g = 0), Math.abs(m) < .001 && (m = 0), Math.abs(u) < .001 && (u = 0), Math.abs(h) < .001 && (h = 0), Math.abs(w) < .001 && (w = 0);
                    const b = `translate3d(${v}px,${g}px,${m}px)  rotateX(${h}deg) rotateY(${u}deg) scale(${w})`;
                    if (se(r, t).transform(b), t[0].style.zIndex = 1 - Math.abs(Math.round(p)), r.slideShadows) {
                        let e = n ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"),
                            s = n ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom");
                        0 === e.length && (e = ie(r, t, n ? "left" : "top")), 0 === s.length && (s = ie(r, t, n ? "right" : "bottom")), e.length && (e[0].style.opacity = p > 0 ? p : 0), s.length && (s[0].style.opacity = -p > 0 ? -p : 0)
                    }
                }
            }, setTransition: e => {
                const {transformEl: s} = t.params.coverflowEffect;
                (s ? t.slides.find(s) : t.slides).transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e)
            }, perspective: () => !0, overwriteParams: () => ({watchSlidesProgress: !0})
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({
            creativeEffect: {
                transformEl: null,
                limitProgress: 1,
                shadowPerProgress: !1,
                progressMultiplier: 1,
                perspective: !0,
                prev: {translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1},
                next: {translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1}
            }
        });
        const i = e => "string" == typeof e ? e : `${e}px`;
        te({
            effect: "creative",
            swiper: t,
            on: a,
            setTranslate: () => {
                const {slides: e, $wrapperEl: s, slidesSizesGrid: a} = t,
                    r = t.params.creativeEffect, {progressMultiplier: n} = r, l = t.params.centeredSlides;
                if (l) {
                    const e = a[0] / 2 - t.params.slidesOffsetBefore || 0;
                    s.transform(`translateX(calc(50% - ${e}px))`)
                }
                for (let s = 0; s < e.length; s += 1) {
                    const a = e.eq(s), o = a[0].progress,
                        d = Math.min(Math.max(a[0].progress, -r.limitProgress), r.limitProgress);
                    let c = d;
                    l || (c = Math.min(Math.max(a[0].originalProgress, -r.limitProgress), r.limitProgress));
                    const p = a[0].swiperSlideOffset, u = [t.params.cssMode ? -p - t.translate : -p, 0, 0],
                        h = [0, 0, 0];
                    let m = !1;
                    t.isHorizontal() || (u[1] = u[0], u[0] = 0);
                    let f = {translate: [0, 0, 0], rotate: [0, 0, 0], scale: 1, opacity: 1};
                    d < 0 ? (f = r.next, m = !0) : d > 0 && (f = r.prev, m = !0), u.forEach(((e, t) => {
                        u[t] = `calc(${e}px + (${i(f.translate[t])} * ${Math.abs(d * n)}))`
                    })), h.forEach(((e, t) => {
                        h[t] = f.rotate[t] * Math.abs(d * n)
                    })), a[0].style.zIndex = -Math.abs(Math.round(o)) + e.length;
                    const g = u.join(", "), v = `rotateX(${h[0]}deg) rotateY(${h[1]}deg) rotateZ(${h[2]}deg)`,
                        w = c < 0 ? `scale(${1 + (1 - f.scale) * c * n})` : `scale(${1 - (1 - f.scale) * c * n})`,
                        b = c < 0 ? 1 + (1 - f.opacity) * c * n : 1 - (1 - f.opacity) * c * n,
                        x = `translate3d(${g}) ${v} ${w}`;
                    if (m && f.shadow || !m) {
                        let e = a.children(".swiper-slide-shadow");
                        if (0 === e.length && f.shadow && (e = ie(r, a)), e.length) {
                            const t = r.shadowPerProgress ? d * (1 / r.limitProgress) : d;
                            e[0].style.opacity = Math.min(Math.max(Math.abs(t), 0), 1)
                        }
                    }
                    const y = se(r, a);
                    y.transform(x).css({opacity: b}), f.origin && y.css("transform-origin", f.origin)
                }
            },
            setTransition: e => {
                const {transformEl: s} = t.params.creativeEffect;
                (s ? t.slides.find(s) : t.slides).transition(e).find(".swiper-slide-shadow").transition(e), ae({
                    swiper: t,
                    duration: e,
                    transformEl: s,
                    allSlides: !0
                })
            },
            perspective: () => t.params.creativeEffect.perspective,
            overwriteParams: () => ({watchSlidesProgress: !0, virtualTranslate: !t.params.cssMode})
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({cardsEffect: {slideShadows: !0, transformEl: null, rotate: !0, perSlideRotate: 2, perSlideOffset: 8}}), te({
            effect: "cards",
            swiper: t,
            on: a,
            setTranslate: () => {
                const {slides: e, activeIndex: s} = t, a = t.params.cardsEffect, {
                    startTranslate: i,
                    isTouched: r
                } = t.touchEventsData, n = t.translate;
                for (let l = 0; l < e.length; l += 1) {
                    const o = e.eq(l), d = o[0].progress, c = Math.min(Math.max(d, -4), 4);
                    let p = o[0].swiperSlideOffset;
                    t.params.centeredSlides && !t.params.cssMode && t.$wrapperEl.transform(`translateX(${t.minTranslate()}px)`), t.params.centeredSlides && t.params.cssMode && (p -= e[0].swiperSlideOffset);
                    let u = t.params.cssMode ? -p - t.translate : -p, h = 0;
                    const m = -100 * Math.abs(c);
                    let f = 1, g = -a.perSlideRotate * c, v = a.perSlideOffset - .75 * Math.abs(c);
                    const w = t.virtual && t.params.virtual.enabled ? t.virtual.from + l : l,
                        b = (w === s || w === s - 1) && c > 0 && c < 1 && (r || t.params.cssMode) && n < i,
                        x = (w === s || w === s + 1) && c < 0 && c > -1 && (r || t.params.cssMode) && n > i;
                    if (b || x) {
                        const e = (1 - Math.abs((Math.abs(c) - .5) / .5)) ** .5;
                        g += -28 * c * e, f += -.5 * e, v += 96 * e, h = -25 * e * Math.abs(c) + "%"
                    }
                    if (u = c < 0 ? `calc(${u}px + (${v * Math.abs(c)}%))` : c > 0 ? `calc(${u}px + (-${v * Math.abs(c)}%))` : `${u}px`, !t.isHorizontal()) {
                        const e = h;
                        h = u, u = e
                    }
                    const y = c < 0 ? "" + (1 + (1 - f) * c) : "" + (1 - (1 - f) * c),
                        E = `\n        translate3d(${u}, ${h}, ${m}px)\n        rotateZ(${a.rotate ? g : 0}deg)\n        scale(${y})\n      `;
                    if (a.slideShadows) {
                        let e = o.find(".swiper-slide-shadow");
                        0 === e.length && (e = ie(a, o)), e.length && (e[0].style.opacity = Math.min(Math.max((Math.abs(c) - .5) / .5, 0), 1))
                    }
                    o[0].style.zIndex = -Math.abs(Math.round(d)) + e.length;
                    se(a, o).transform(E)
                }
            },
            setTransition: e => {
                const {transformEl: s} = t.params.cardsEffect;
                (s ? t.slides.find(s) : t.slides).transition(e).find(".swiper-slide-shadow").transition(e), ae({
                    swiper: t,
                    duration: e,
                    transformEl: s
                })
            },
            perspective: () => !0,
            overwriteParams: () => ({watchSlidesProgress: !0, virtualTranslate: !t.params.cssMode})
        })
    }];
    return V.use(re), V
}));
//# sourceMappingURL=swiper-bundle.min.js.map
/*!
 * baguetteBox.js
 * @author  feimosi
 * @version 1.11.1
 * @url https://github.com/feimosi/baguetteBox.js
 */
!function(e,t){"use strict";"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.baguetteBox=t()}(this,function(){"use strict";var r,l,u,c,d,f='<svg width="44" height="60"><polyline points="30 10 10 30 30 50" stroke="rgba(255,255,255,0.5)" stroke-width="4"stroke-linecap="butt" fill="none" stroke-linejoin="round"/></svg>',g='<svg width="44" height="60"><polyline points="14 10 34 30 14 50" stroke="rgba(255,255,255,0.5)" stroke-width="4"stroke-linecap="butt" fill="none" stroke-linejoin="round"/></svg>',p='<svg width="30" height="30"><g stroke="rgb(160,160,160)" stroke-width="4"><line x1="5" y1="5" x2="25" y2="25"/><line x1="5" y1="25" x2="25" y2="5"/></g></svg>',b={},v={captions:!0,buttons:"auto",fullScreen:!1,noScrollbars:!1,bodyClass:"baguetteBox-open",titleTag:!1,async:!1,preload:2,animation:"slideIn",afterShow:null,afterHide:null,onChange:null,overlayBackgroundColor:"rgba(0,0,0,.8)"},m={},h=[],o=0,n=!1,i={},a=!1,y=/.+\.(gif|jpe?g|png|webp)/i,w={},k=[],s=null,x=function(e){-1!==e.target.id.indexOf("baguette-img")&&j()},E=function(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0,D()},C=function(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0,X()},B=function(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0,j()},T=function(e){i.count++,1<i.count&&(i.multitouch=!0),i.startX=e.changedTouches[0].pageX,i.startY=e.changedTouches[0].pageY},N=function(e){if(!a&&!i.multitouch){e.preventDefault?e.preventDefault():e.returnValue=!1;var t=e.touches[0]||e.changedTouches[0];40<t.pageX-i.startX?(a=!0,D()):t.pageX-i.startX<-40?(a=!0,X()):100<i.startY-t.pageY&&j()}},L=function(){i.count--,i.count<=0&&(i.multitouch=!1),a=!1},A=function(){L()},P=function(e){"block"===r.style.display&&r.contains&&!r.contains(e.target)&&(e.stopPropagation(),Y())};function S(e){if(w.hasOwnProperty(e)){var t=w[e].galleries;[].forEach.call(t,function(e){[].forEach.call(e,function(e){W(e.imageElement,"click",e.eventHandler)}),h===e&&(h=[])}),delete w[e]}}function F(e){switch(e.keyCode){case 37:D();break;case 39:X();break;case 27:j();break;case 36:!function t(e){e&&e.preventDefault();return M(0)}(e);break;case 35:!function n(e){e&&e.preventDefault();return M(h.length-1)}(e)}}function H(e,t){if(h!==e){for(h=e,function s(e){e=e||{};for(var t in v)b[t]=v[t],"undefined"!=typeof e[t]&&(b[t]=e[t]);l.style.transition=l.style.webkitTransition="fadeIn"===b.animation?"opacity .4s ease":"slideIn"===b.animation?"":"none","auto"===b.buttons&&("ontouchstart"in window||1===h.length)&&(b.buttons=!1);u.style.display=c.style.display=b.buttons?"":"none";try{r.style.backgroundColor=b.overlayBackgroundColor}catch(n){}}(t);l.firstChild;)l.removeChild(l.firstChild);for(var n,o=[],i=[],a=k.length=0;a<e.length;a++)(n=J("div")).className="full-image",n.id="baguette-img-"+a,k.push(n),o.push("baguetteBox-figure-"+a),i.push("baguetteBox-figcaption-"+a),l.appendChild(k[a]);r.setAttribute("aria-labelledby",o.join(" ")),r.setAttribute("aria-describedby",i.join(" "))}}function I(e){b.noScrollbars&&(document.documentElement.style.overflowY="hidden",document.body.style.overflowY="scroll"),"block"!==r.style.display&&(U(document,"keydown",F),i={count:0,startX:null,startY:null},q(o=e,function(){z(o),V(o)}),R(),r.style.display="block",b.fullScreen&&function t(){r.requestFullscreen?r.requestFullscreen():r.webkitRequestFullscreen?r.webkitRequestFullscreen():r.mozRequestFullScreen&&r.mozRequestFullScreen()}(),setTimeout(function(){r.className="visible",b.bodyClass&&document.body.classList&&document.body.classList.add(b.bodyClass),b.afterShow&&b.afterShow()},50),b.onChange&&b.onChange(o,k.length),s=document.activeElement,Y(),n=!0)}function Y(){b.buttons?u.focus():d.focus()}function j(){b.noScrollbars&&(document.documentElement.style.overflowY="auto",document.body.style.overflowY="auto"),"none"!==r.style.display&&(W(document,"keydown",F),r.className="",setTimeout(function(){r.style.display="none",document.fullscreen&&function e(){document.exitFullscreen?document.exitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitExitFullscreen&&document.webkitExitFullscreen()}(),b.bodyClass&&document.body.classList&&document.body.classList.remove(b.bodyClass),b.afterHide&&b.afterHide(),s&&s.focus(),n=!1},500))}function q(t,n){var e=k[t],o=h[t];if(void 0!==e&&void 0!==o)if(e.getElementsByTagName("img")[0])n&&n();else{var i=o.imageElement,a=i.getElementsByTagName("img")[0],s="function"==typeof b.captions?b.captions.call(h,i):i.getAttribute("data-caption")||i.title,r=function d(e){var t=e.href;if(e.dataset){var n=[];for(var o in e.dataset)"at-"!==o.substring(0,3)||isNaN(o.substring(3))||(n[o.replace("at-","")]=e.dataset[o]);for(var i=Object.keys(n).sort(function(e,t){return parseInt(e,10)<parseInt(t,10)?-1:1}),a=window.innerWidth*window.devicePixelRatio,s=0;s<i.length-1&&i[s]<a;)s++;t=n[i[s]]||t}return t}(i),l=J("figure");if(l.id="baguetteBox-figure-"+t,l.innerHTML='<div class="baguetteBox-spinner"><div class="baguetteBox-double-bounce1"></div><div class="baguetteBox-double-bounce2"></div></div>',b.captions&&s){var u=J("figcaption");u.id="baguetteBox-figcaption-"+t,u.innerHTML=s,l.appendChild(u)}e.appendChild(l);var c=J("img");c.onload=function(){var e=document.querySelector("#baguette-img-"+t+" .baguetteBox-spinner");l.removeChild(e),!b.async&&n&&n()},c.setAttribute("src",r),c.alt=a&&a.alt||"",b.titleTag&&s&&(c.title=s),l.appendChild(c),b.async&&n&&n()}}function X(){return M(o+1)}function D(){return M(o-1)}function M(e,t){return!n&&0<=e&&e<t.length?(H(t,b),I(e),!0):e<0?(b.animation&&O("left"),!1):e>=k.length?(b.animation&&O("right"),!1):(q(o=e,function(){z(o),V(o)}),R(),b.onChange&&b.onChange(o,k.length),!0)}function O(e){l.className="bounce-from-"+e,setTimeout(function(){l.className=""},400)}function R(){var e=100*-o+"%";"fadeIn"===b.animation?(l.style.opacity=0,setTimeout(function(){m.transforms?l.style.transform=l.style.webkitTransform="translate3d("+e+",0,0)":l.style.left=e,l.style.opacity=1},400)):m.transforms?l.style.transform=l.style.webkitTransform="translate3d("+e+",0,0)":l.style.left=e}function z(e){e-o>=b.preload||q(e+1,function(){z(e+1)})}function V(e){o-e>=b.preload||q(e-1,function(){V(e-1)})}function U(e,t,n,o){e.addEventListener?e.addEventListener(t,n,o):e.attachEvent("on"+t,function(e){(e=e||window.event).target=e.target||e.srcElement,n(e)})}function W(e,t,n,o){e.removeEventListener?e.removeEventListener(t,n,o):e.detachEvent("on"+t,n)}function G(e){return document.getElementById(e)}function J(e){return document.createElement(e)}return[].forEach||(Array.prototype.forEach=function(e,t){for(var n=0;n<this.length;n++)e.call(t,this[n],n,this)}),[].filter||(Array.prototype.filter=function(e,t,n,o,i){for(n=this,o=[],i=0;i<n.length;i++)e.call(t,n[i],i,n)&&o.push(n[i]);return o}),{run:function K(e,t){return m.transforms=function n(){var e=J("div");return"undefined"!=typeof e.style.perspective||"undefined"!=typeof e.style.webkitPerspective}(),m.svg=function o(){var e=J("div");return e.innerHTML="<svg/>","http://www.w3.org/2000/svg"===(e.firstChild&&e.firstChild.namespaceURI)}(),m.passiveEvents=function i(){var e=!1;try{var t=Object.defineProperty({},"passive",{get:function(){e=!0}});window.addEventListener("test",null,t)}catch(n){}return e}(),function a(){if(r=G("baguetteBox-overlay"))return l=G("baguetteBox-slider"),u=G("previous-button"),c=G("next-button"),void(d=G("close-button"));(r=J("div")).setAttribute("role","dialog"),r.id="baguetteBox-overlay",document.getElementsByTagName("body")[0].appendChild(r),(l=J("div")).id="baguetteBox-slider",r.appendChild(l),(u=J("button")).setAttribute("type","button"),u.id="previous-button",u.setAttribute("aria-label","Previous"),u.innerHTML=m.svg?f:"&lt;",r.appendChild(u),(c=J("button")).setAttribute("type","button"),c.id="next-button",c.setAttribute("aria-label","Next"),c.innerHTML=m.svg?g:"&gt;",r.appendChild(c),(d=J("button")).setAttribute("type","button"),d.id="close-button",d.setAttribute("aria-label","Close"),d.innerHTML=m.svg?p:"&times;",r.appendChild(d),u.className=c.className=d.className="baguetteBox-button",function n(){var e=m.passiveEvents?{passive:!1}:null,t=m.passiveEvents?{passive:!0}:null;U(r,"click",x),U(u,"click",E),U(c,"click",C),U(d,"click",B),U(l,"contextmenu",A),U(r,"touchstart",T,t),U(r,"touchmove",N,e),U(r,"touchend",L),U(document,"focus",P,!0)}()}(),S(e),function s(e,a){var t=document.querySelectorAll(e),n={galleries:[],nodeList:t};return w[e]=n,[].forEach.call(t,function(e){a&&a.filter&&(y=a.filter);var t=[];if(t="A"===e.tagName?[e]:e.getElementsByTagName("a"),0!==(t=[].filter.call(t,function(e){if(-1===e.className.indexOf(a&&a.ignoreClass))return y.test(e.href)})).length){var i=[];[].forEach.call(t,function(e,t){var n=function(e){e.preventDefault?e.preventDefault():e.returnValue=!1,H(i,a),I(t)},o={eventHandler:n,imageElement:e};U(e,"click",n),i.push(o)}),n.galleries.push(i)}}),n.galleries}(e,t)},show:M,showNext:X,showPrevious:D,hide:j,destroy:function e(){!function n(){var e=m.passiveEvents?{passive:!1}:null,t=m.passiveEvents?{passive:!0}:null;W(r,"click",x),W(u,"click",E),W(c,"click",C),W(d,"click",B),W(l,"contextmenu",A),W(r,"touchstart",T,t),W(r,"touchmove",N,e),W(r,"touchend",L),W(document,"focus",P,!0)}(),function t(){for(var e in w)w.hasOwnProperty(e)&&S(e)}(),W(document,"keydown",F),document.getElementsByTagName("body")[0].removeChild(document.getElementById("baguetteBox-overlay")),w={},h=[],o=0}}});

// CUSTOM SCRIPTS


$(document).ready(function () {
    function destroySwiper(sliderInstance) {
        if (sliderInstance instanceof Swiper && sliderInstance.initialized) {
            sliderInstance.destroy(true, true);
            console.log('destroy')
        }
    }

    // MOBILE MENU
    const nav = $('.header__nav');

    $('.btn-burger').click(function (e) {
        e.preventDefault();
        nav.toggleClass('open');
        $(this).toggleClass('open');
        jQuery('.backdrop').fadeToggle();
        $('body').toggleClass('modal_open');
    });

    $('.menu__link, .backdrop').click(function (e) {
        $('.btn-burger').removeClass('open');
        nav.removeClass('open');
        $('.sub-menu__toggle').removeClass('sub-menu__toggle_active')
        jQuery('.backdrop').fadeOut();
        $('body').removeClass('modal_open');
    });

    $('.sub-menu__toggle').click(function (e) {
        $(this).toggleClass('sub-menu__toggle_active')
    });

    //SLIDER NEWS
    var sliderNews = new Swiper(".slider-news", {
        breakpoints: {
            320: {
                slidesPerView: 1,
                spaceBetween: 24,
            },

            640: {
                slidesPerView: 2,
                spaceBetween: 24,
            }
        },
        navigation: {
            nextEl: ".swiper-button-next",
            prevEl: ".swiper-button-prev",
        },
        pagination: {
            el: ".swiper-pagination",
        },
    });

    var sliderGallery = new Swiper(".slider-gallery", {
        breakpoints: {
            320: {
                slidesPerView: 1,
                spaceBetween: 24,
            },

            640: {
                slidesPerView: 2,
                spaceBetween: 24,
            }
        },
        navigation: {
            nextEl: ".swiper-button-next",
            prevEl: ".swiper-button-prev",
        },
        pagination: {
            el: ".swiper-pagination",
        },
    });

    var sliderAboutHelps = new Swiper(".about-helps", {
        breakpoints: {
            320: {
                slidesPerView: 1,
                spaceBetween: 24,
            },
            640: {
                slidesPerView: 3,
                spaceBetween: 24,
            }
        },
        navigation: {
            nextEl: ".swiper-button-next",
            prevEl: ".swiper-button-prev",
        },
        pagination: {
            el: ".swiper-pagination",
        },
    });

    var sliderPartners = new Swiper(".slider-partners", {
        navigation: {
            nextEl: ".swiper-button-next",
            prevEl: ".swiper-button-prev",
        },
        pagination: {
            el: ".swiper-pagination",
        },
    });

    //SLIDERS
    let valuablesSlider;
    let advantagesSlider;

    function handleResponsive() {

        // DESTROY SLIDER INSTANCES

        if ($(window).outerWidth() <= 767) {
            if (!valuablesSlider) {
                valuablesSlider = new Swiper('.valuables', {
                    breakpoints: {
                        320: {
                            slidesPerView: 1,
                        },

                        540: {
                            slidesPerView: 2,
                        }
                    },
                    pagination: {
                        el: ".swiper-pagination",
                    },
                });
            }
        } else {
            console.log(valuablesSlider)
            destroySwiper(valuablesSlider);
            valuablesSlider = null;
        }

        if ($(window).outerWidth() <= 767) {
            if (!advantagesSlider) {
                valuablesSlider = new Swiper('.advantages', {
                    breakpoints: {
                        320: {
                            slidesPerView: 1,
                        },

                        540: {
                            slidesPerView: 2,
                        }
                    },
                    pagination: {
                        el: ".swiper-pagination",
                    },
                });
            }
        } else {
            destroySwiper(advantagesSlider);
            advantagesSlider = null;
        }
    }

    let resizeId;


    handleResponsive();

    window.addEventListener('resize', function () {
        clearTimeout(resizeId);
        resizeId = setTimeout(handleResponsive, 500);
    });


    //BAGUETTE BOX
    $('.awards-list a').click(function (e) {
        e.preventDefault();
    });

    baguetteBox.run('.awards-list', {
        buttons: 'auto', // arrows navigation
        noScrollbars: false,
        bodyClass: 'baguetteBox-open',
        titleTag: false,
        async: false,
        preload: 2,
        animation: 'fadeIn',
        overlayBackgroundColor: 'rgba (1,1,1, .25)'
    });

// VIDEO YOUTUBE
    const videos = document.querySelectorAll('.video');
    let generateUrl = function(id) {
        let query = '?rel=0&showinfo=0&autoplay=1';

        return 'https://www.youtube.com/embed/' + id + query;
    };
    let createIframe = function(id) {
        let iframe = document.createElement('iframe');

        iframe.setAttribute('allowfullscreen', '');
        iframe.setAttribute('allow', 'autoplay; encrypted-media');
        iframe.setAttribute('src', generateUrl(id));

        return iframe;
    };

    videos.forEach((el) => {
        let videoHref = el.getAttribute('data-video');

        let deletedLength = 'https://youtu.be/'.length;

        let videoId = videoHref.substring(deletedLength, videoHref.length);

        let img = el.querySelector('img');
        let youtubeImgSrc = 'https://i.ytimg.com/vi/' + videoId + '/maxresdefault.jpg';
        img.setAttribute('src', youtubeImgSrc);

        el.addEventListener('click', (e) => {
            e.preventDefault();

            let iframe = createIframe(videoId);
            el.querySelector('.video__poster').remove();
            el.appendChild(iframe);
            el.querySelector('.btn_play').remove();
        });
    });


});




//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1haW4uanMiLCIuLi9saWIvanF1ZXJ5Lm1pbi5qcyIsIi4uL2xpYi9zd2lwZXIvc3dpcGVyLWJ1bmRsZS5taW4uanMiLCIuLi9saWIvYmFndWV0dGVCb3gubWluLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQ0xBO0VBQ0E7RUFDQTtBREtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUVYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBRjcxT0E7QUdiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBSFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Im1haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4qIHRvIGluY2x1ZGUganMgZmlsZSB3cml0ZTogYC8vPSBpbmNsdWRlIC4vcGF0aC10by1maWxlYFxyXG4qICovXHJcblxyXG4vLz0gaW5jbHVkZSAuLi9saWIvanF1ZXJ5Lm1pbi5qcyA7XHJcbi8vPSBpbmNsdWRlIC4uL2xpYi9zd2lwZXIvc3dpcGVyLWJ1bmRsZS5taW4uanNcclxuLy89IGluY2x1ZGUgLi4vbGliL2JhZ3VldHRlQm94Lm1pbi5qc1xyXG5cclxuLy8gQ1VTVE9NIFNDUklQVFNcclxuXHJcblxyXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBkZXN0cm95U3dpcGVyKHNsaWRlckluc3RhbmNlKSB7XHJcbiAgICAgICAgaWYgKHNsaWRlckluc3RhbmNlIGluc3RhbmNlb2YgU3dpcGVyICYmIHNsaWRlckluc3RhbmNlLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHNsaWRlckluc3RhbmNlLmRlc3Ryb3kodHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdkZXN0cm95JylcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTU9CSUxFIE1FTlVcclxuICAgIGNvbnN0IG5hdiA9ICQoJy5oZWFkZXJfX25hdicpO1xyXG5cclxuICAgICQoJy5idG4tYnVyZ2VyJykuY2xpY2soZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgbmF2LnRvZ2dsZUNsYXNzKCdvcGVuJyk7XHJcbiAgICAgICAgJCh0aGlzKS50b2dnbGVDbGFzcygnb3BlbicpO1xyXG4gICAgICAgIGpRdWVyeSgnLmJhY2tkcm9wJykuZmFkZVRvZ2dsZSgpO1xyXG4gICAgICAgICQoJ2JvZHknKS50b2dnbGVDbGFzcygnbW9kYWxfb3BlbicpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgJCgnLm1lbnVfX2xpbmssIC5iYWNrZHJvcCcpLmNsaWNrKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgJCgnLmJ0bi1idXJnZXInKS5yZW1vdmVDbGFzcygnb3BlbicpO1xyXG4gICAgICAgIG5hdi5yZW1vdmVDbGFzcygnb3BlbicpO1xyXG4gICAgICAgICQoJy5zdWItbWVudV9fdG9nZ2xlJykucmVtb3ZlQ2xhc3MoJ3N1Yi1tZW51X190b2dnbGVfYWN0aXZlJylcclxuICAgICAgICBqUXVlcnkoJy5iYWNrZHJvcCcpLmZhZGVPdXQoKTtcclxuICAgICAgICAkKCdib2R5JykucmVtb3ZlQ2xhc3MoJ21vZGFsX29wZW4nKTtcclxuICAgIH0pO1xyXG5cclxuICAgICQoJy5zdWItbWVudV9fdG9nZ2xlJykuY2xpY2soZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAkKHRoaXMpLnRvZ2dsZUNsYXNzKCdzdWItbWVudV9fdG9nZ2xlX2FjdGl2ZScpXHJcbiAgICB9KTtcclxuXHJcbiAgICAvL1NMSURFUiBORVdTXHJcbiAgICB2YXIgc2xpZGVyTmV3cyA9IG5ldyBTd2lwZXIoXCIuc2xpZGVyLW5ld3NcIiwge1xyXG4gICAgICAgIGJyZWFrcG9pbnRzOiB7XHJcbiAgICAgICAgICAgIDMyMDoge1xyXG4gICAgICAgICAgICAgICAgc2xpZGVzUGVyVmlldzogMSxcclxuICAgICAgICAgICAgICAgIHNwYWNlQmV0d2VlbjogMjQsXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICA2NDA6IHtcclxuICAgICAgICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDIsXHJcbiAgICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDI0LFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuYXZpZ2F0aW9uOiB7XHJcbiAgICAgICAgICAgIG5leHRFbDogXCIuc3dpcGVyLWJ1dHRvbi1uZXh0XCIsXHJcbiAgICAgICAgICAgIHByZXZFbDogXCIuc3dpcGVyLWJ1dHRvbi1wcmV2XCIsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwYWdpbmF0aW9uOiB7XHJcbiAgICAgICAgICAgIGVsOiBcIi5zd2lwZXItcGFnaW5hdGlvblwiLFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgc2xpZGVyR2FsbGVyeSA9IG5ldyBTd2lwZXIoXCIuc2xpZGVyLWdhbGxlcnlcIiwge1xyXG4gICAgICAgIGJyZWFrcG9pbnRzOiB7XHJcbiAgICAgICAgICAgIDMyMDoge1xyXG4gICAgICAgICAgICAgICAgc2xpZGVzUGVyVmlldzogMSxcclxuICAgICAgICAgICAgICAgIHNwYWNlQmV0d2VlbjogMjQsXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICA2NDA6IHtcclxuICAgICAgICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDIsXHJcbiAgICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDI0LFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuYXZpZ2F0aW9uOiB7XHJcbiAgICAgICAgICAgIG5leHRFbDogXCIuc3dpcGVyLWJ1dHRvbi1uZXh0XCIsXHJcbiAgICAgICAgICAgIHByZXZFbDogXCIuc3dpcGVyLWJ1dHRvbi1wcmV2XCIsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwYWdpbmF0aW9uOiB7XHJcbiAgICAgICAgICAgIGVsOiBcIi5zd2lwZXItcGFnaW5hdGlvblwiLFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgc2xpZGVyQWJvdXRIZWxwcyA9IG5ldyBTd2lwZXIoXCIuYWJvdXQtaGVscHNcIiwge1xyXG4gICAgICAgIGJyZWFrcG9pbnRzOiB7XHJcbiAgICAgICAgICAgIDMyMDoge1xyXG4gICAgICAgICAgICAgICAgc2xpZGVzUGVyVmlldzogMSxcclxuICAgICAgICAgICAgICAgIHNwYWNlQmV0d2VlbjogMjQsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIDY0MDoge1xyXG4gICAgICAgICAgICAgICAgc2xpZGVzUGVyVmlldzogMyxcclxuICAgICAgICAgICAgICAgIHNwYWNlQmV0d2VlbjogMjQsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG5hdmlnYXRpb246IHtcclxuICAgICAgICAgICAgbmV4dEVsOiBcIi5zd2lwZXItYnV0dG9uLW5leHRcIixcclxuICAgICAgICAgICAgcHJldkVsOiBcIi5zd2lwZXItYnV0dG9uLXByZXZcIixcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhZ2luYXRpb246IHtcclxuICAgICAgICAgICAgZWw6IFwiLnN3aXBlci1wYWdpbmF0aW9uXCIsXHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBzbGlkZXJQYXJ0bmVycyA9IG5ldyBTd2lwZXIoXCIuc2xpZGVyLXBhcnRuZXJzXCIsIHtcclxuICAgICAgICBuYXZpZ2F0aW9uOiB7XHJcbiAgICAgICAgICAgIG5leHRFbDogXCIuc3dpcGVyLWJ1dHRvbi1uZXh0XCIsXHJcbiAgICAgICAgICAgIHByZXZFbDogXCIuc3dpcGVyLWJ1dHRvbi1wcmV2XCIsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwYWdpbmF0aW9uOiB7XHJcbiAgICAgICAgICAgIGVsOiBcIi5zd2lwZXItcGFnaW5hdGlvblwiLFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICAvL1NMSURFUlNcclxuICAgIGxldCB2YWx1YWJsZXNTbGlkZXI7XHJcbiAgICBsZXQgYWR2YW50YWdlc1NsaWRlcjtcclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVSZXNwb25zaXZlKCkge1xyXG5cclxuICAgICAgICAvLyBERVNUUk9ZIFNMSURFUiBJTlNUQU5DRVNcclxuXHJcbiAgICAgICAgaWYgKCQod2luZG93KS5vdXRlcldpZHRoKCkgPD0gNzY3KSB7XHJcbiAgICAgICAgICAgIGlmICghdmFsdWFibGVzU2xpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1YWJsZXNTbGlkZXIgPSBuZXcgU3dpcGVyKCcudmFsdWFibGVzJywge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrcG9pbnRzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDMyMDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVzUGVyVmlldzogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDU0MDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVzUGVyVmlldzogMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcGFnaW5hdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbDogXCIuc3dpcGVyLXBhZ2luYXRpb25cIixcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh2YWx1YWJsZXNTbGlkZXIpXHJcbiAgICAgICAgICAgIGRlc3Ryb3lTd2lwZXIodmFsdWFibGVzU2xpZGVyKTtcclxuICAgICAgICAgICAgdmFsdWFibGVzU2xpZGVyID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgkKHdpbmRvdykub3V0ZXJXaWR0aCgpIDw9IDc2Nykge1xyXG4gICAgICAgICAgICBpZiAoIWFkdmFudGFnZXNTbGlkZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVhYmxlc1NsaWRlciA9IG5ldyBTd2lwZXIoJy5hZHZhbnRhZ2VzJywge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrcG9pbnRzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDMyMDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVzUGVyVmlldzogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDU0MDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVzUGVyVmlldzogMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcGFnaW5hdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbDogXCIuc3dpcGVyLXBhZ2luYXRpb25cIixcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkZXN0cm95U3dpcGVyKGFkdmFudGFnZXNTbGlkZXIpO1xyXG4gICAgICAgICAgICBhZHZhbnRhZ2VzU2xpZGVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHJlc2l6ZUlkO1xyXG5cclxuXHJcbiAgICBoYW5kbGVSZXNwb25zaXZlKCk7XHJcblxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQocmVzaXplSWQpO1xyXG4gICAgICAgIHJlc2l6ZUlkID0gc2V0VGltZW91dChoYW5kbGVSZXNwb25zaXZlLCA1MDApO1xyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIC8vQkFHVUVUVEUgQk9YXHJcbiAgICAkKCcuYXdhcmRzLWxpc3QgYScpLmNsaWNrKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYmFndWV0dGVCb3gucnVuKCcuYXdhcmRzLWxpc3QnLCB7XHJcbiAgICAgICAgYnV0dG9uczogJ2F1dG8nLCAvLyBhcnJvd3MgbmF2aWdhdGlvblxyXG4gICAgICAgIG5vU2Nyb2xsYmFyczogZmFsc2UsXHJcbiAgICAgICAgYm9keUNsYXNzOiAnYmFndWV0dGVCb3gtb3BlbicsXHJcbiAgICAgICAgdGl0bGVUYWc6IGZhbHNlLFxyXG4gICAgICAgIGFzeW5jOiBmYWxzZSxcclxuICAgICAgICBwcmVsb2FkOiAyLFxyXG4gICAgICAgIGFuaW1hdGlvbjogJ2ZhZGVJbicsXHJcbiAgICAgICAgb3ZlcmxheUJhY2tncm91bmRDb2xvcjogJ3JnYmEgKDEsMSwxLCAuMjUpJ1xyXG4gICAgfSk7XHJcblxyXG4vLyBWSURFTyBZT1VUVUJFXHJcbiAgICBjb25zdCB2aWRlb3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudmlkZW8nKTtcclxuICAgIGxldCBnZW5lcmF0ZVVybCA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgICAgbGV0IHF1ZXJ5ID0gJz9yZWw9MCZzaG93aW5mbz0wJmF1dG9wbGF5PTEnO1xyXG5cclxuICAgICAgICByZXR1cm4gJ2h0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2VtYmVkLycgKyBpZCArIHF1ZXJ5O1xyXG4gICAgfTtcclxuICAgIGxldCBjcmVhdGVJZnJhbWUgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgICAgIGxldCBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcclxuXHJcbiAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnYWxsb3dmdWxsc2NyZWVuJywgJycpO1xyXG4gICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FsbG93JywgJ2F1dG9wbGF5OyBlbmNyeXB0ZWQtbWVkaWEnKTtcclxuICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdzcmMnLCBnZW5lcmF0ZVVybChpZCkpO1xyXG5cclxuICAgICAgICByZXR1cm4gaWZyYW1lO1xyXG4gICAgfTtcclxuXHJcbiAgICB2aWRlb3MuZm9yRWFjaCgoZWwpID0+IHtcclxuICAgICAgICBsZXQgdmlkZW9IcmVmID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXZpZGVvJyk7XHJcblxyXG4gICAgICAgIGxldCBkZWxldGVkTGVuZ3RoID0gJ2h0dHBzOi8veW91dHUuYmUvJy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGxldCB2aWRlb0lkID0gdmlkZW9IcmVmLnN1YnN0cmluZyhkZWxldGVkTGVuZ3RoLCB2aWRlb0hyZWYubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgbGV0IGltZyA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xyXG4gICAgICAgIGxldCB5b3V0dWJlSW1nU3JjID0gJ2h0dHBzOi8vaS55dGltZy5jb20vdmkvJyArIHZpZGVvSWQgKyAnL21heHJlc2RlZmF1bHQuanBnJztcclxuICAgICAgICBpbWcuc2V0QXR0cmlidXRlKCdzcmMnLCB5b3V0dWJlSW1nU3JjKTtcclxuXHJcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgaWZyYW1lID0gY3JlYXRlSWZyYW1lKHZpZGVvSWQpO1xyXG4gICAgICAgICAgICBlbC5xdWVyeVNlbGVjdG9yKCcudmlkZW9fX3Bvc3RlcicpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChpZnJhbWUpO1xyXG4gICAgICAgICAgICBlbC5xdWVyeVNlbGVjdG9yKCcuYnRuX3BsYXknKS5yZW1vdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuXHJcbn0pO1xyXG5cclxuXHJcblxyXG4iLCIvKiEgalF1ZXJ5IHYzLjYuMSB8IChjKSBPcGVuSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIHwganF1ZXJ5Lm9yZy9saWNlbnNlICovXHJcbiFmdW5jdGlvbihlLHQpe1widXNlIHN0cmljdFwiO1wib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGUmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGUuZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1lLmRvY3VtZW50P3QoZSwhMCk6ZnVuY3Rpb24oZSl7aWYoIWUuZG9jdW1lbnQpdGhyb3cgbmV3IEVycm9yKFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiKTtyZXR1cm4gdChlKX06dChlKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6dGhpcyxmdW5jdGlvbihDLGUpe1widXNlIHN0cmljdFwiO3ZhciB0PVtdLHI9T2JqZWN0LmdldFByb3RvdHlwZU9mLHM9dC5zbGljZSxnPXQuZmxhdD9mdW5jdGlvbihlKXtyZXR1cm4gdC5mbGF0LmNhbGwoZSl9OmZ1bmN0aW9uKGUpe3JldHVybiB0LmNvbmNhdC5hcHBseShbXSxlKX0sdT10LnB1c2gsaT10LmluZGV4T2Ysbj17fSxvPW4udG9TdHJpbmcseT1uLmhhc093blByb3BlcnR5LGE9eS50b1N0cmluZyxsPWEuY2FsbChPYmplY3QpLHY9e30sbT1mdW5jdGlvbihlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZcIm51bWJlclwiIT10eXBlb2YgZS5ub2RlVHlwZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZS5pdGVtfSx4PWZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT1lJiZlPT09ZS53aW5kb3d9LEU9Qy5kb2N1bWVudCxjPXt0eXBlOiEwLHNyYzohMCxub25jZTohMCxub01vZHVsZTohMH07ZnVuY3Rpb24gYihlLHQsbil7dmFyIHIsaSxvPShuPW58fEUpLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7aWYoby50ZXh0PWUsdClmb3IociBpbiBjKShpPXRbcl18fHQuZ2V0QXR0cmlidXRlJiZ0LmdldEF0dHJpYnV0ZShyKSkmJm8uc2V0QXR0cmlidXRlKHIsaSk7bi5oZWFkLmFwcGVuZENoaWxkKG8pLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobyl9ZnVuY3Rpb24gdyhlKXtyZXR1cm4gbnVsbD09ZT9lK1wiXCI6XCJvYmplY3RcIj09dHlwZW9mIGV8fFwiZnVuY3Rpb25cIj09dHlwZW9mIGU/bltvLmNhbGwoZSldfHxcIm9iamVjdFwiOnR5cGVvZiBlfXZhciBmPVwiMy42LjFcIixTPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBTLmZuLmluaXQoZSx0KX07ZnVuY3Rpb24gcChlKXt2YXIgdD0hIWUmJlwibGVuZ3RoXCJpbiBlJiZlLmxlbmd0aCxuPXcoZSk7cmV0dXJuIW0oZSkmJiF4KGUpJiYoXCJhcnJheVwiPT09bnx8MD09PXR8fFwibnVtYmVyXCI9PXR5cGVvZiB0JiYwPHQmJnQtMSBpbiBlKX1TLmZuPVMucHJvdG90eXBlPXtqcXVlcnk6Zixjb25zdHJ1Y3RvcjpTLGxlbmd0aDowLHRvQXJyYXk6ZnVuY3Rpb24oKXtyZXR1cm4gcy5jYWxsKHRoaXMpfSxnZXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWU/cy5jYWxsKHRoaXMpOmU8MD90aGlzW2UrdGhpcy5sZW5ndGhdOnRoaXNbZV19LHB1c2hTdGFjazpmdW5jdGlvbihlKXt2YXIgdD1TLm1lcmdlKHRoaXMuY29uc3RydWN0b3IoKSxlKTtyZXR1cm4gdC5wcmV2T2JqZWN0PXRoaXMsdH0sZWFjaDpmdW5jdGlvbihlKXtyZXR1cm4gUy5lYWNoKHRoaXMsZSl9LG1hcDpmdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soUy5tYXAodGhpcyxmdW5jdGlvbihlLHQpe3JldHVybiBuLmNhbGwoZSx0LGUpfSkpfSxzbGljZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB1c2hTdGFjayhzLmFwcGx5KHRoaXMsYXJndW1lbnRzKSl9LGZpcnN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXEoMCl9LGxhc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lcSgtMSl9LGV2ZW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soUy5ncmVwKHRoaXMsZnVuY3Rpb24oZSx0KXtyZXR1cm4odCsxKSUyfSkpfSxvZGQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soUy5ncmVwKHRoaXMsZnVuY3Rpb24oZSx0KXtyZXR1cm4gdCUyfSkpfSxlcTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLmxlbmd0aCxuPStlKyhlPDA/dDowKTtyZXR1cm4gdGhpcy5wdXNoU3RhY2soMDw9biYmbjx0P1t0aGlzW25dXTpbXSl9LGVuZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnByZXZPYmplY3R8fHRoaXMuY29uc3RydWN0b3IoKX0scHVzaDp1LHNvcnQ6dC5zb3J0LHNwbGljZTp0LnNwbGljZX0sUy5leHRlbmQ9Uy5mbi5leHRlbmQ9ZnVuY3Rpb24oKXt2YXIgZSx0LG4scixpLG8sYT1hcmd1bWVudHNbMF18fHt9LHM9MSx1PWFyZ3VtZW50cy5sZW5ndGgsbD0hMTtmb3IoXCJib29sZWFuXCI9PXR5cGVvZiBhJiYobD1hLGE9YXJndW1lbnRzW3NdfHx7fSxzKyspLFwib2JqZWN0XCI9PXR5cGVvZiBhfHxtKGEpfHwoYT17fSkscz09PXUmJihhPXRoaXMscy0tKTtzPHU7cysrKWlmKG51bGwhPShlPWFyZ3VtZW50c1tzXSkpZm9yKHQgaW4gZSlyPWVbdF0sXCJfX3Byb3RvX19cIiE9PXQmJmEhPT1yJiYobCYmciYmKFMuaXNQbGFpbk9iamVjdChyKXx8KGk9QXJyYXkuaXNBcnJheShyKSkpPyhuPWFbdF0sbz1pJiYhQXJyYXkuaXNBcnJheShuKT9bXTppfHxTLmlzUGxhaW5PYmplY3Qobik/bjp7fSxpPSExLGFbdF09Uy5leHRlbmQobCxvLHIpKTp2b2lkIDAhPT1yJiYoYVt0XT1yKSk7cmV0dXJuIGF9LFMuZXh0ZW5kKHtleHBhbmRvOlwialF1ZXJ5XCIrKGYrTWF0aC5yYW5kb20oKSkucmVwbGFjZSgvXFxEL2csXCJcIiksaXNSZWFkeTohMCxlcnJvcjpmdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoZSl9LG5vb3A6ZnVuY3Rpb24oKXt9LGlzUGxhaW5PYmplY3Q6ZnVuY3Rpb24oZSl7dmFyIHQsbjtyZXR1cm4hKCFlfHxcIltvYmplY3QgT2JqZWN0XVwiIT09by5jYWxsKGUpKSYmKCEodD1yKGUpKXx8XCJmdW5jdGlvblwiPT10eXBlb2Yobj15LmNhbGwodCxcImNvbnN0cnVjdG9yXCIpJiZ0LmNvbnN0cnVjdG9yKSYmYS5jYWxsKG4pPT09bCl9LGlzRW1wdHlPYmplY3Q6ZnVuY3Rpb24oZSl7dmFyIHQ7Zm9yKHQgaW4gZSlyZXR1cm4hMTtyZXR1cm4hMH0sZ2xvYmFsRXZhbDpmdW5jdGlvbihlLHQsbil7YihlLHtub25jZTp0JiZ0Lm5vbmNlfSxuKX0sZWFjaDpmdW5jdGlvbihlLHQpe3ZhciBuLHI9MDtpZihwKGUpKXtmb3Iobj1lLmxlbmd0aDtyPG47cisrKWlmKCExPT09dC5jYWxsKGVbcl0scixlW3JdKSlicmVha31lbHNlIGZvcihyIGluIGUpaWYoITE9PT10LmNhbGwoZVtyXSxyLGVbcl0pKWJyZWFrO3JldHVybiBlfSxtYWtlQXJyYXk6ZnVuY3Rpb24oZSx0KXt2YXIgbj10fHxbXTtyZXR1cm4gbnVsbCE9ZSYmKHAoT2JqZWN0KGUpKT9TLm1lcmdlKG4sXCJzdHJpbmdcIj09dHlwZW9mIGU/W2VdOmUpOnUuY2FsbChuLGUpKSxufSxpbkFycmF5OmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gbnVsbD09dD8tMTppLmNhbGwodCxlLG4pfSxtZXJnZTpmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0rdC5sZW5ndGgscj0wLGk9ZS5sZW5ndGg7cjxuO3IrKyllW2krK109dFtyXTtyZXR1cm4gZS5sZW5ndGg9aSxlfSxncmVwOmZ1bmN0aW9uKGUsdCxuKXtmb3IodmFyIHI9W10saT0wLG89ZS5sZW5ndGgsYT0hbjtpPG87aSsrKSF0KGVbaV0saSkhPT1hJiZyLnB1c2goZVtpXSk7cmV0dXJuIHJ9LG1hcDpmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvPTAsYT1bXTtpZihwKGUpKWZvcihyPWUubGVuZ3RoO288cjtvKyspbnVsbCE9KGk9dChlW29dLG8sbikpJiZhLnB1c2goaSk7ZWxzZSBmb3IobyBpbiBlKW51bGwhPShpPXQoZVtvXSxvLG4pKSYmYS5wdXNoKGkpO3JldHVybiBnKGEpfSxndWlkOjEsc3VwcG9ydDp2fSksXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYoUy5mbltTeW1ib2wuaXRlcmF0b3JdPXRbU3ltYm9sLml0ZXJhdG9yXSksUy5lYWNoKFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdChcIiBcIiksZnVuY3Rpb24oZSx0KXtuW1wiW29iamVjdCBcIit0K1wiXVwiXT10LnRvTG93ZXJDYXNlKCl9KTt2YXIgZD1mdW5jdGlvbihuKXt2YXIgZSxkLGIsbyxpLGgsZixnLHcsdSxsLFQsQyxhLEUseSxzLGMsdixTPVwic2l6emxlXCIrMSpuZXcgRGF0ZSxwPW4uZG9jdW1lbnQsaz0wLHI9MCxtPXVlKCkseD11ZSgpLEE9dWUoKSxOPXVlKCksaj1mdW5jdGlvbihlLHQpe3JldHVybiBlPT09dCYmKGw9ITApLDB9LEQ9e30uaGFzT3duUHJvcGVydHksdD1bXSxxPXQucG9wLEw9dC5wdXNoLEg9dC5wdXNoLE89dC5zbGljZSxQPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPTAscj1lLmxlbmd0aDtuPHI7bisrKWlmKGVbbl09PT10KXJldHVybiBuO3JldHVybi0xfSxSPVwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixNPVwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixJPVwiKD86XFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIitNK1wiP3xcXFxcXFxcXFteXFxcXHJcXFxcblxcXFxmXXxbXFxcXHctXXxbXlxcMC1cXFxceDdmXSkrXCIsVz1cIlxcXFxbXCIrTStcIiooXCIrSStcIikoPzpcIitNK1wiKihbKl4kfCF+XT89KVwiK00rXCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIitJK1wiKSl8KVwiK00rXCIqXFxcXF1cIixGPVwiOihcIitJK1wiKSg/OlxcXFwoKCgnKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIitXK1wiKSopfC4qKVxcXFwpfClcIiwkPW5ldyBSZWdFeHAoTStcIitcIixcImdcIiksQj1uZXcgUmVnRXhwKFwiXlwiK00rXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiK00rXCIrJFwiLFwiZ1wiKSxfPW5ldyBSZWdFeHAoXCJeXCIrTStcIiosXCIrTStcIipcIiksej1uZXcgUmVnRXhwKFwiXlwiK00rXCIqKFs+K35dfFwiK00rXCIpXCIrTStcIipcIiksVT1uZXcgUmVnRXhwKE0rXCJ8PlwiKSxYPW5ldyBSZWdFeHAoRiksVj1uZXcgUmVnRXhwKFwiXlwiK0krXCIkXCIpLEc9e0lEOm5ldyBSZWdFeHAoXCJeIyhcIitJK1wiKVwiKSxDTEFTUzpuZXcgUmVnRXhwKFwiXlxcXFwuKFwiK0krXCIpXCIpLFRBRzpuZXcgUmVnRXhwKFwiXihcIitJK1wifFsqXSlcIiksQVRUUjpuZXcgUmVnRXhwKFwiXlwiK1cpLFBTRVVETzpuZXcgUmVnRXhwKFwiXlwiK0YpLENISUxEOm5ldyBSZWdFeHAoXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiK00rXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIitNK1wiKig/OihbKy1dfClcIitNK1wiKihcXFxcZCspfCkpXCIrTStcIipcXFxcKXwpXCIsXCJpXCIpLGJvb2w6bmV3IFJlZ0V4cChcIl4oPzpcIitSK1wiKSRcIixcImlcIiksbmVlZHNDb250ZXh0Om5ldyBSZWdFeHAoXCJeXCIrTStcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIrTStcIiooKD86LVxcXFxkKT9cXFxcZCopXCIrTStcIipcXFxcKXwpKD89W14tXXwkKVwiLFwiaVwiKX0sWT0vSFRNTCQvaSxRPS9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksSj0vXmhcXGQkL2ksSz0vXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFo9L14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sZWU9L1srfl0vLHRlPW5ldyBSZWdFeHAoXCJcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiK00rXCI/fFxcXFxcXFxcKFteXFxcXHJcXFxcblxcXFxmXSlcIixcImdcIiksbmU9ZnVuY3Rpb24oZSx0KXt2YXIgbj1cIjB4XCIrZS5zbGljZSgxKS02NTUzNjtyZXR1cm4gdHx8KG48MD9TdHJpbmcuZnJvbUNoYXJDb2RlKG4rNjU1MzYpOlN0cmluZy5mcm9tQ2hhckNvZGUobj4+MTB8NTUyOTYsMTAyMyZufDU2MzIwKSl9LHJlPS8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLGllPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQ/XCJcXDBcIj09PWU/XCJcXHVmZmZkXCI6ZS5zbGljZSgwLC0xKStcIlxcXFxcIitlLmNoYXJDb2RlQXQoZS5sZW5ndGgtMSkudG9TdHJpbmcoMTYpK1wiIFwiOlwiXFxcXFwiK2V9LG9lPWZ1bmN0aW9uKCl7VCgpfSxhZT1iZShmdW5jdGlvbihlKXtyZXR1cm4hMD09PWUuZGlzYWJsZWQmJlwiZmllbGRzZXRcIj09PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKX0se2RpcjpcInBhcmVudE5vZGVcIixuZXh0OlwibGVnZW5kXCJ9KTt0cnl7SC5hcHBseSh0PU8uY2FsbChwLmNoaWxkTm9kZXMpLHAuY2hpbGROb2RlcyksdFtwLmNoaWxkTm9kZXMubGVuZ3RoXS5ub2RlVHlwZX1jYXRjaChlKXtIPXthcHBseTp0Lmxlbmd0aD9mdW5jdGlvbihlLHQpe0wuYXBwbHkoZSxPLmNhbGwodCkpfTpmdW5jdGlvbihlLHQpe3ZhciBuPWUubGVuZ3RoLHI9MDt3aGlsZShlW24rK109dFtyKytdKTtlLmxlbmd0aD1uLTF9fX1mdW5jdGlvbiBzZSh0LGUsbixyKXt2YXIgaSxvLGEscyx1LGwsYyxmPWUmJmUub3duZXJEb2N1bWVudCxwPWU/ZS5ub2RlVHlwZTo5O2lmKG49bnx8W10sXCJzdHJpbmdcIiE9dHlwZW9mIHR8fCF0fHwxIT09cCYmOSE9PXAmJjExIT09cClyZXR1cm4gbjtpZighciYmKFQoZSksZT1lfHxDLEUpKXtpZigxMSE9PXAmJih1PVouZXhlYyh0KSkpaWYoaT11WzFdKXtpZig5PT09cCl7aWYoIShhPWUuZ2V0RWxlbWVudEJ5SWQoaSkpKXJldHVybiBuO2lmKGEuaWQ9PT1pKXJldHVybiBuLnB1c2goYSksbn1lbHNlIGlmKGYmJihhPWYuZ2V0RWxlbWVudEJ5SWQoaSkpJiZ2KGUsYSkmJmEuaWQ9PT1pKXJldHVybiBuLnB1c2goYSksbn1lbHNle2lmKHVbMl0pcmV0dXJuIEguYXBwbHkobixlLmdldEVsZW1lbnRzQnlUYWdOYW1lKHQpKSxuO2lmKChpPXVbM10pJiZkLmdldEVsZW1lbnRzQnlDbGFzc05hbWUmJmUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSlyZXR1cm4gSC5hcHBseShuLGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShpKSksbn1pZihkLnFzYSYmIU5bdCtcIiBcIl0mJigheXx8IXkudGVzdCh0KSkmJigxIT09cHx8XCJvYmplY3RcIiE9PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkpe2lmKGM9dCxmPWUsMT09PXAmJihVLnRlc3QodCl8fHoudGVzdCh0KSkpeyhmPWVlLnRlc3QodCkmJnZlKGUucGFyZW50Tm9kZSl8fGUpPT09ZSYmZC5zY29wZXx8KChzPWUuZ2V0QXR0cmlidXRlKFwiaWRcIikpP3M9cy5yZXBsYWNlKHJlLGllKTplLnNldEF0dHJpYnV0ZShcImlkXCIscz1TKSksbz0obD1oKHQpKS5sZW5ndGg7d2hpbGUoby0tKWxbb109KHM/XCIjXCIrczpcIjpzY29wZVwiKStcIiBcIit4ZShsW29dKTtjPWwuam9pbihcIixcIil9dHJ5e3JldHVybiBILmFwcGx5KG4sZi5xdWVyeVNlbGVjdG9yQWxsKGMpKSxufWNhdGNoKGUpe04odCwhMCl9ZmluYWxseXtzPT09UyYmZS5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKX19fXJldHVybiBnKHQucmVwbGFjZShCLFwiJDFcIiksZSxuLHIpfWZ1bmN0aW9uIHVlKCl7dmFyIHI9W107cmV0dXJuIGZ1bmN0aW9uIGUodCxuKXtyZXR1cm4gci5wdXNoKHQrXCIgXCIpPmIuY2FjaGVMZW5ndGgmJmRlbGV0ZSBlW3Iuc2hpZnQoKV0sZVt0K1wiIFwiXT1ufX1mdW5jdGlvbiBsZShlKXtyZXR1cm4gZVtTXT0hMCxlfWZ1bmN0aW9uIGNlKGUpe3ZhciB0PUMuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpO3RyeXtyZXR1cm4hIWUodCl9Y2F0Y2goZSl7cmV0dXJuITF9ZmluYWxseXt0LnBhcmVudE5vZGUmJnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KSx0PW51bGx9fWZ1bmN0aW9uIGZlKGUsdCl7dmFyIG49ZS5zcGxpdChcInxcIikscj1uLmxlbmd0aDt3aGlsZShyLS0pYi5hdHRySGFuZGxlW25bcl1dPXR9ZnVuY3Rpb24gcGUoZSx0KXt2YXIgbj10JiZlLHI9biYmMT09PWUubm9kZVR5cGUmJjE9PT10Lm5vZGVUeXBlJiZlLnNvdXJjZUluZGV4LXQuc291cmNlSW5kZXg7aWYocilyZXR1cm4gcjtpZihuKXdoaWxlKG49bi5uZXh0U2libGluZylpZihuPT09dClyZXR1cm4tMTtyZXR1cm4gZT8xOi0xfWZ1bmN0aW9uIGRlKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm5cImlucHV0XCI9PT1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkmJmUudHlwZT09PXR9fWZ1bmN0aW9uIGhlKG4pe3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuKFwiaW5wdXRcIj09PXR8fFwiYnV0dG9uXCI9PT10KSYmZS50eXBlPT09bn19ZnVuY3Rpb24gZ2UodCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVyblwiZm9ybVwiaW4gZT9lLnBhcmVudE5vZGUmJiExPT09ZS5kaXNhYmxlZD9cImxhYmVsXCJpbiBlP1wibGFiZWxcImluIGUucGFyZW50Tm9kZT9lLnBhcmVudE5vZGUuZGlzYWJsZWQ9PT10OmUuZGlzYWJsZWQ9PT10OmUuaXNEaXNhYmxlZD09PXR8fGUuaXNEaXNhYmxlZCE9PSF0JiZhZShlKT09PXQ6ZS5kaXNhYmxlZD09PXQ6XCJsYWJlbFwiaW4gZSYmZS5kaXNhYmxlZD09PXR9fWZ1bmN0aW9uIHllKGEpe3JldHVybiBsZShmdW5jdGlvbihvKXtyZXR1cm4gbz0rbyxsZShmdW5jdGlvbihlLHQpe3ZhciBuLHI9YShbXSxlLmxlbmd0aCxvKSxpPXIubGVuZ3RoO3doaWxlKGktLSllW249cltpXV0mJihlW25dPSEodFtuXT1lW25dKSl9KX0pfWZ1bmN0aW9uIHZlKGUpe3JldHVybiBlJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgZS5nZXRFbGVtZW50c0J5VGFnTmFtZSYmZX1mb3IoZSBpbiBkPXNlLnN1cHBvcnQ9e30saT1zZS5pc1hNTD1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLm5hbWVzcGFjZVVSSSxuPWUmJihlLm93bmVyRG9jdW1lbnR8fGUpLmRvY3VtZW50RWxlbWVudDtyZXR1cm4hWS50ZXN0KHR8fG4mJm4ubm9kZU5hbWV8fFwiSFRNTFwiKX0sVD1zZS5zZXREb2N1bWVudD1mdW5jdGlvbihlKXt2YXIgdCxuLHI9ZT9lLm93bmVyRG9jdW1lbnR8fGU6cDtyZXR1cm4gciE9QyYmOT09PXIubm9kZVR5cGUmJnIuZG9jdW1lbnRFbGVtZW50JiYoYT0oQz1yKS5kb2N1bWVudEVsZW1lbnQsRT0haShDKSxwIT1DJiYobj1DLmRlZmF1bHRWaWV3KSYmbi50b3AhPT1uJiYobi5hZGRFdmVudExpc3RlbmVyP24uYWRkRXZlbnRMaXN0ZW5lcihcInVubG9hZFwiLG9lLCExKTpuLmF0dGFjaEV2ZW50JiZuLmF0dGFjaEV2ZW50KFwib251bmxvYWRcIixvZSkpLGQuc2NvcGU9Y2UoZnVuY3Rpb24oZSl7cmV0dXJuIGEuYXBwZW5kQ2hpbGQoZSkuYXBwZW5kQ2hpbGQoQy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSxcInVuZGVmaW5lZFwiIT10eXBlb2YgZS5xdWVyeVNlbGVjdG9yQWxsJiYhZS5xdWVyeVNlbGVjdG9yQWxsKFwiOnNjb3BlIGZpZWxkc2V0IGRpdlwiKS5sZW5ndGh9KSxkLmF0dHJpYnV0ZXM9Y2UoZnVuY3Rpb24oZSl7cmV0dXJuIGUuY2xhc3NOYW1lPVwiaVwiLCFlLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKX0pLGQuZ2V0RWxlbWVudHNCeVRhZ05hbWU9Y2UoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYXBwZW5kQ2hpbGQoQy5jcmVhdGVDb21tZW50KFwiXCIpKSwhZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RofSksZC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lPUsudGVzdChDLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpLGQuZ2V0QnlJZD1jZShmdW5jdGlvbihlKXtyZXR1cm4gYS5hcHBlbmRDaGlsZChlKS5pZD1TLCFDLmdldEVsZW1lbnRzQnlOYW1lfHwhQy5nZXRFbGVtZW50c0J5TmFtZShTKS5sZW5ndGh9KSxkLmdldEJ5SWQ/KGIuZmlsdGVyLklEPWZ1bmN0aW9uKGUpe3ZhciB0PWUucmVwbGFjZSh0ZSxuZSk7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBlLmdldEF0dHJpYnV0ZShcImlkXCIpPT09dH19LGIuZmluZC5JRD1mdW5jdGlvbihlLHQpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB0LmdldEVsZW1lbnRCeUlkJiZFKXt2YXIgbj10LmdldEVsZW1lbnRCeUlkKGUpO3JldHVybiBuP1tuXTpbXX19KTooYi5maWx0ZXIuSUQ9ZnVuY3Rpb24oZSl7dmFyIG49ZS5yZXBsYWNlKHRlLG5lKTtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGUuZ2V0QXR0cmlidXRlTm9kZSYmZS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7cmV0dXJuIHQmJnQudmFsdWU9PT1ufX0sYi5maW5kLklEPWZ1bmN0aW9uKGUsdCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHQuZ2V0RWxlbWVudEJ5SWQmJkUpe3ZhciBuLHIsaSxvPXQuZ2V0RWxlbWVudEJ5SWQoZSk7aWYobyl7aWYoKG49by5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIikpJiZuLnZhbHVlPT09ZSlyZXR1cm5bb107aT10LmdldEVsZW1lbnRzQnlOYW1lKGUpLHI9MDt3aGlsZShvPWlbcisrXSlpZigobj1vLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKSkmJm4udmFsdWU9PT1lKXJldHVybltvXX1yZXR1cm5bXX19KSxiLmZpbmQuVEFHPWQuZ2V0RWxlbWVudHNCeVRhZ05hbWU/ZnVuY3Rpb24oZSx0KXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgdC5nZXRFbGVtZW50c0J5VGFnTmFtZT90LmdldEVsZW1lbnRzQnlUYWdOYW1lKGUpOmQucXNhP3QucXVlcnlTZWxlY3RvckFsbChlKTp2b2lkIDB9OmZ1bmN0aW9uKGUsdCl7dmFyIG4scj1bXSxpPTAsbz10LmdldEVsZW1lbnRzQnlUYWdOYW1lKGUpO2lmKFwiKlwiPT09ZSl7d2hpbGUobj1vW2krK10pMT09PW4ubm9kZVR5cGUmJnIucHVzaChuKTtyZXR1cm4gcn1yZXR1cm4gb30sYi5maW5kLkNMQVNTPWQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSYmZnVuY3Rpb24oZSx0KXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgdC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lJiZFKXJldHVybiB0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoZSl9LHM9W10seT1bXSwoZC5xc2E9Sy50ZXN0KEMucXVlcnlTZWxlY3RvckFsbCkpJiYoY2UoZnVuY3Rpb24oZSl7dmFyIHQ7YS5hcHBlbmRDaGlsZChlKS5pbm5lckhUTUw9XCI8YSBpZD0nXCIrUytcIic+PC9hPjxzZWxlY3QgaWQ9J1wiK1MrXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+PG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIixlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGgmJnkucHVzaChcIlsqXiRdPVwiK00rXCIqKD86Jyd8XFxcIlxcXCIpXCIpLGUucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RofHx5LnB1c2goXCJcXFxcW1wiK00rXCIqKD86dmFsdWV8XCIrUitcIilcIiksZS5xdWVyeVNlbGVjdG9yQWxsKFwiW2lkfj1cIitTK1wiLV1cIikubGVuZ3RofHx5LnB1c2goXCJ+PVwiKSwodD1DLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSkuc2V0QXR0cmlidXRlKFwibmFtZVwiLFwiXCIpLGUuYXBwZW5kQ2hpbGQodCksZS5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9JyddXCIpLmxlbmd0aHx8eS5wdXNoKFwiXFxcXFtcIitNK1wiKm5hbWVcIitNK1wiKj1cIitNK1wiKig/OicnfFxcXCJcXFwiKVwiKSxlLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGh8fHkucHVzaChcIjpjaGVja2VkXCIpLGUucXVlcnlTZWxlY3RvckFsbChcImEjXCIrUytcIisqXCIpLmxlbmd0aHx8eS5wdXNoKFwiLiMuK1srfl1cIiksZS5xdWVyeVNlbGVjdG9yQWxsKFwiXFxcXFxcZlwiKSx5LnB1c2goXCJbXFxcXHJcXFxcblxcXFxmXVwiKX0pLGNlKGZ1bmN0aW9uKGUpe2UuaW5uZXJIVE1MPVwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT48c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7dmFyIHQ9Qy5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7dC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJoaWRkZW5cIiksZS5hcHBlbmRDaGlsZCh0KS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsXCJEXCIpLGUucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCYmeS5wdXNoKFwibmFtZVwiK00rXCIqWypeJHwhfl0/PVwiKSwyIT09ZS5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoJiZ5LnB1c2goXCI6ZW5hYmxlZFwiLFwiOmRpc2FibGVkXCIpLGEuYXBwZW5kQ2hpbGQoZSkuZGlzYWJsZWQ9ITAsMiE9PWUucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGgmJnkucHVzaChcIjplbmFibGVkXCIsXCI6ZGlzYWJsZWRcIiksZS5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKSx5LnB1c2goXCIsLio6XCIpfSkpLChkLm1hdGNoZXNTZWxlY3Rvcj1LLnRlc3QoYz1hLm1hdGNoZXN8fGEud2Via2l0TWF0Y2hlc1NlbGVjdG9yfHxhLm1vek1hdGNoZXNTZWxlY3Rvcnx8YS5vTWF0Y2hlc1NlbGVjdG9yfHxhLm1zTWF0Y2hlc1NlbGVjdG9yKSkmJmNlKGZ1bmN0aW9uKGUpe2QuZGlzY29ubmVjdGVkTWF0Y2g9Yy5jYWxsKGUsXCIqXCIpLGMuY2FsbChlLFwiW3MhPScnXTp4XCIpLHMucHVzaChcIiE9XCIsRil9KSx5PXkubGVuZ3RoJiZuZXcgUmVnRXhwKHkuam9pbihcInxcIikpLHM9cy5sZW5ndGgmJm5ldyBSZWdFeHAocy5qb2luKFwifFwiKSksdD1LLnRlc3QoYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiksdj10fHxLLnRlc3QoYS5jb250YWlucyk/ZnVuY3Rpb24oZSx0KXt2YXIgbj05PT09ZS5ub2RlVHlwZT9lLmRvY3VtZW50RWxlbWVudDplLHI9dCYmdC5wYXJlbnROb2RlO3JldHVybiBlPT09cnx8ISghcnx8MSE9PXIubm9kZVR5cGV8fCEobi5jb250YWlucz9uLmNvbnRhaW5zKHIpOmUuY29tcGFyZURvY3VtZW50UG9zaXRpb24mJjE2JmUuY29tcGFyZURvY3VtZW50UG9zaXRpb24ocikpKX06ZnVuY3Rpb24oZSx0KXtpZih0KXdoaWxlKHQ9dC5wYXJlbnROb2RlKWlmKHQ9PT1lKXJldHVybiEwO3JldHVybiExfSxqPXQ/ZnVuY3Rpb24oZSx0KXtpZihlPT09dClyZXR1cm4gbD0hMCwwO3ZhciBuPSFlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uLSF0LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO3JldHVybiBufHwoMSYobj0oZS5vd25lckRvY3VtZW50fHxlKT09KHQub3duZXJEb2N1bWVudHx8dCk/ZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0KToxKXx8IWQuc29ydERldGFjaGVkJiZ0LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGUpPT09bj9lPT1DfHxlLm93bmVyRG9jdW1lbnQ9PXAmJnYocCxlKT8tMTp0PT1DfHx0Lm93bmVyRG9jdW1lbnQ9PXAmJnYocCx0KT8xOnU/UCh1LGUpLVAodSx0KTowOjQmbj8tMToxKX06ZnVuY3Rpb24oZSx0KXtpZihlPT09dClyZXR1cm4gbD0hMCwwO3ZhciBuLHI9MCxpPWUucGFyZW50Tm9kZSxvPXQucGFyZW50Tm9kZSxhPVtlXSxzPVt0XTtpZighaXx8IW8pcmV0dXJuIGU9PUM/LTE6dD09Qz8xOmk/LTE6bz8xOnU/UCh1LGUpLVAodSx0KTowO2lmKGk9PT1vKXJldHVybiBwZShlLHQpO249ZTt3aGlsZShuPW4ucGFyZW50Tm9kZSlhLnVuc2hpZnQobik7bj10O3doaWxlKG49bi5wYXJlbnROb2RlKXMudW5zaGlmdChuKTt3aGlsZShhW3JdPT09c1tyXSlyKys7cmV0dXJuIHI/cGUoYVtyXSxzW3JdKTphW3JdPT1wPy0xOnNbcl09PXA/MTowfSksQ30sc2UubWF0Y2hlcz1mdW5jdGlvbihlLHQpe3JldHVybiBzZShlLG51bGwsbnVsbCx0KX0sc2UubWF0Y2hlc1NlbGVjdG9yPWZ1bmN0aW9uKGUsdCl7aWYoVChlKSxkLm1hdGNoZXNTZWxlY3RvciYmRSYmIU5bdCtcIiBcIl0mJighc3x8IXMudGVzdCh0KSkmJigheXx8IXkudGVzdCh0KSkpdHJ5e3ZhciBuPWMuY2FsbChlLHQpO2lmKG58fGQuZGlzY29ubmVjdGVkTWF0Y2h8fGUuZG9jdW1lbnQmJjExIT09ZS5kb2N1bWVudC5ub2RlVHlwZSlyZXR1cm4gbn1jYXRjaChlKXtOKHQsITApfXJldHVybiAwPHNlKHQsQyxudWxsLFtlXSkubGVuZ3RofSxzZS5jb250YWlucz1mdW5jdGlvbihlLHQpe3JldHVybihlLm93bmVyRG9jdW1lbnR8fGUpIT1DJiZUKGUpLHYoZSx0KX0sc2UuYXR0cj1mdW5jdGlvbihlLHQpeyhlLm93bmVyRG9jdW1lbnR8fGUpIT1DJiZUKGUpO3ZhciBuPWIuYXR0ckhhbmRsZVt0LnRvTG93ZXJDYXNlKCldLHI9biYmRC5jYWxsKGIuYXR0ckhhbmRsZSx0LnRvTG93ZXJDYXNlKCkpP24oZSx0LCFFKTp2b2lkIDA7cmV0dXJuIHZvaWQgMCE9PXI/cjpkLmF0dHJpYnV0ZXN8fCFFP2UuZ2V0QXR0cmlidXRlKHQpOihyPWUuZ2V0QXR0cmlidXRlTm9kZSh0KSkmJnIuc3BlY2lmaWVkP3IudmFsdWU6bnVsbH0sc2UuZXNjYXBlPWZ1bmN0aW9uKGUpe3JldHVybihlK1wiXCIpLnJlcGxhY2UocmUsaWUpfSxzZS5lcnJvcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIitlKX0sc2UudW5pcXVlU29ydD1mdW5jdGlvbihlKXt2YXIgdCxuPVtdLHI9MCxpPTA7aWYobD0hZC5kZXRlY3REdXBsaWNhdGVzLHU9IWQuc29ydFN0YWJsZSYmZS5zbGljZSgwKSxlLnNvcnQoaiksbCl7d2hpbGUodD1lW2krK10pdD09PWVbaV0mJihyPW4ucHVzaChpKSk7d2hpbGUoci0tKWUuc3BsaWNlKG5bcl0sMSl9cmV0dXJuIHU9bnVsbCxlfSxvPXNlLmdldFRleHQ9ZnVuY3Rpb24oZSl7dmFyIHQsbj1cIlwiLHI9MCxpPWUubm9kZVR5cGU7aWYoaSl7aWYoMT09PWl8fDk9PT1pfHwxMT09PWkpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlLnRleHRDb250ZW50KXJldHVybiBlLnRleHRDb250ZW50O2ZvcihlPWUuZmlyc3RDaGlsZDtlO2U9ZS5uZXh0U2libGluZyluKz1vKGUpfWVsc2UgaWYoMz09PWl8fDQ9PT1pKXJldHVybiBlLm5vZGVWYWx1ZX1lbHNlIHdoaWxlKHQ9ZVtyKytdKW4rPW8odCk7cmV0dXJuIG59LChiPXNlLnNlbGVjdG9ycz17Y2FjaGVMZW5ndGg6NTAsY3JlYXRlUHNldWRvOmxlLG1hdGNoOkcsYXR0ckhhbmRsZTp7fSxmaW5kOnt9LHJlbGF0aXZlOntcIj5cIjp7ZGlyOlwicGFyZW50Tm9kZVwiLGZpcnN0OiEwfSxcIiBcIjp7ZGlyOlwicGFyZW50Tm9kZVwifSxcIitcIjp7ZGlyOlwicHJldmlvdXNTaWJsaW5nXCIsZmlyc3Q6ITB9LFwiflwiOntkaXI6XCJwcmV2aW91c1NpYmxpbmdcIn19LHByZUZpbHRlcjp7QVRUUjpmdW5jdGlvbihlKXtyZXR1cm4gZVsxXT1lWzFdLnJlcGxhY2UodGUsbmUpLGVbM109KGVbM118fGVbNF18fGVbNV18fFwiXCIpLnJlcGxhY2UodGUsbmUpLFwifj1cIj09PWVbMl0mJihlWzNdPVwiIFwiK2VbM10rXCIgXCIpLGUuc2xpY2UoMCw0KX0sQ0hJTEQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGVbMV09ZVsxXS50b0xvd2VyQ2FzZSgpLFwibnRoXCI9PT1lWzFdLnNsaWNlKDAsMyk/KGVbM118fHNlLmVycm9yKGVbMF0pLGVbNF09KyhlWzRdP2VbNV0rKGVbNl18fDEpOjIqKFwiZXZlblwiPT09ZVszXXx8XCJvZGRcIj09PWVbM10pKSxlWzVdPSsoZVs3XStlWzhdfHxcIm9kZFwiPT09ZVszXSkpOmVbM10mJnNlLmVycm9yKGVbMF0pLGV9LFBTRVVETzpmdW5jdGlvbihlKXt2YXIgdCxuPSFlWzZdJiZlWzJdO3JldHVybiBHLkNISUxELnRlc3QoZVswXSk/bnVsbDooZVszXT9lWzJdPWVbNF18fGVbNV18fFwiXCI6biYmWC50ZXN0KG4pJiYodD1oKG4sITApKSYmKHQ9bi5pbmRleE9mKFwiKVwiLG4ubGVuZ3RoLXQpLW4ubGVuZ3RoKSYmKGVbMF09ZVswXS5zbGljZSgwLHQpLGVbMl09bi5zbGljZSgwLHQpKSxlLnNsaWNlKDAsMykpfX0sZmlsdGVyOntUQUc6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5yZXBsYWNlKHRlLG5lKS50b0xvd2VyQ2FzZSgpO3JldHVyblwiKlwiPT09ZT9mdW5jdGlvbigpe3JldHVybiEwfTpmdW5jdGlvbihlKXtyZXR1cm4gZS5ub2RlTmFtZSYmZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09dH19LENMQVNTOmZ1bmN0aW9uKGUpe3ZhciB0PW1bZStcIiBcIl07cmV0dXJuIHR8fCh0PW5ldyBSZWdFeHAoXCIoXnxcIitNK1wiKVwiK2UrXCIoXCIrTStcInwkKVwiKSkmJm0oZSxmdW5jdGlvbihlKXtyZXR1cm4gdC50ZXN0KFwic3RyaW5nXCI9PXR5cGVvZiBlLmNsYXNzTmFtZSYmZS5jbGFzc05hbWV8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBlLmdldEF0dHJpYnV0ZSYmZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKXx8XCJcIil9KX0sQVRUUjpmdW5jdGlvbihuLHIsaSl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PXNlLmF0dHIoZSxuKTtyZXR1cm4gbnVsbD09dD9cIiE9XCI9PT1yOiFyfHwodCs9XCJcIixcIj1cIj09PXI/dD09PWk6XCIhPVwiPT09cj90IT09aTpcIl49XCI9PT1yP2kmJjA9PT10LmluZGV4T2YoaSk6XCIqPVwiPT09cj9pJiYtMTx0LmluZGV4T2YoaSk6XCIkPVwiPT09cj9pJiZ0LnNsaWNlKC1pLmxlbmd0aCk9PT1pOlwifj1cIj09PXI/LTE8KFwiIFwiK3QucmVwbGFjZSgkLFwiIFwiKStcIiBcIikuaW5kZXhPZihpKTpcInw9XCI9PT1yJiYodD09PWl8fHQuc2xpY2UoMCxpLmxlbmd0aCsxKT09PWkrXCItXCIpKX19LENISUxEOmZ1bmN0aW9uKGgsZSx0LGcseSl7dmFyIHY9XCJudGhcIiE9PWguc2xpY2UoMCwzKSxtPVwibGFzdFwiIT09aC5zbGljZSgtNCkseD1cIm9mLXR5cGVcIj09PWU7cmV0dXJuIDE9PT1nJiYwPT09eT9mdW5jdGlvbihlKXtyZXR1cm4hIWUucGFyZW50Tm9kZX06ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbyxhLHMsdSxsPXYhPT1tP1wibmV4dFNpYmxpbmdcIjpcInByZXZpb3VzU2libGluZ1wiLGM9ZS5wYXJlbnROb2RlLGY9eCYmZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLHA9IW4mJiF4LGQ9ITE7aWYoYyl7aWYodil7d2hpbGUobCl7YT1lO3doaWxlKGE9YVtsXSlpZih4P2Eubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09PWY6MT09PWEubm9kZVR5cGUpcmV0dXJuITE7dT1sPVwib25seVwiPT09aCYmIXUmJlwibmV4dFNpYmxpbmdcIn1yZXR1cm4hMH1pZih1PVttP2MuZmlyc3RDaGlsZDpjLmxhc3RDaGlsZF0sbSYmcCl7ZD0ocz0ocj0oaT0obz0oYT1jKVtTXXx8KGFbU109e30pKVthLnVuaXF1ZUlEXXx8KG9bYS51bmlxdWVJRF09e30pKVtoXXx8W10pWzBdPT09ayYmclsxXSkmJnJbMl0sYT1zJiZjLmNoaWxkTm9kZXNbc107d2hpbGUoYT0rK3MmJmEmJmFbbF18fChkPXM9MCl8fHUucG9wKCkpaWYoMT09PWEubm9kZVR5cGUmJisrZCYmYT09PWUpe2lbaF09W2sscyxkXTticmVha319ZWxzZSBpZihwJiYoZD1zPShyPShpPShvPShhPWUpW1NdfHwoYVtTXT17fSkpW2EudW5pcXVlSURdfHwob1thLnVuaXF1ZUlEXT17fSkpW2hdfHxbXSlbMF09PT1rJiZyWzFdKSwhMT09PWQpd2hpbGUoYT0rK3MmJmEmJmFbbF18fChkPXM9MCl8fHUucG9wKCkpaWYoKHg/YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09ZjoxPT09YS5ub2RlVHlwZSkmJisrZCYmKHAmJigoaT0obz1hW1NdfHwoYVtTXT17fSkpW2EudW5pcXVlSURdfHwob1thLnVuaXF1ZUlEXT17fSkpW2hdPVtrLGRdKSxhPT09ZSkpYnJlYWs7cmV0dXJuKGQtPXkpPT09Z3x8ZCVnPT0wJiYwPD1kL2d9fX0sUFNFVURPOmZ1bmN0aW9uKGUsbyl7dmFyIHQsYT1iLnBzZXVkb3NbZV18fGIuc2V0RmlsdGVyc1tlLnRvTG93ZXJDYXNlKCldfHxzZS5lcnJvcihcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIrZSk7cmV0dXJuIGFbU10/YShvKToxPGEubGVuZ3RoPyh0PVtlLGUsXCJcIixvXSxiLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoZS50b0xvd2VyQ2FzZSgpKT9sZShmdW5jdGlvbihlLHQpe3ZhciBuLHI9YShlLG8pLGk9ci5sZW5ndGg7d2hpbGUoaS0tKWVbbj1QKGUscltpXSldPSEodFtuXT1yW2ldKX0pOmZ1bmN0aW9uKGUpe3JldHVybiBhKGUsMCx0KX0pOmF9fSxwc2V1ZG9zOntub3Q6bGUoZnVuY3Rpb24oZSl7dmFyIHI9W10saT1bXSxzPWYoZS5yZXBsYWNlKEIsXCIkMVwiKSk7cmV0dXJuIHNbU10/bGUoZnVuY3Rpb24oZSx0LG4scil7dmFyIGksbz1zKGUsbnVsbCxyLFtdKSxhPWUubGVuZ3RoO3doaWxlKGEtLSkoaT1vW2FdKSYmKGVbYV09ISh0W2FdPWkpKX0pOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gclswXT1lLHMocixudWxsLG4saSksclswXT1udWxsLCFpLnBvcCgpfX0pLGhhczpsZShmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIDA8c2UodCxlKS5sZW5ndGh9fSksY29udGFpbnM6bGUoZnVuY3Rpb24odCl7cmV0dXJuIHQ9dC5yZXBsYWNlKHRlLG5lKSxmdW5jdGlvbihlKXtyZXR1cm4tMTwoZS50ZXh0Q29udGVudHx8byhlKSkuaW5kZXhPZih0KX19KSxsYW5nOmxlKGZ1bmN0aW9uKG4pe3JldHVybiBWLnRlc3Qobnx8XCJcIil8fHNlLmVycm9yKFwidW5zdXBwb3J0ZWQgbGFuZzogXCIrbiksbj1uLnJlcGxhY2UodGUsbmUpLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oZSl7dmFyIHQ7ZG97aWYodD1FP2UubGFuZzplLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpfHxlLmdldEF0dHJpYnV0ZShcImxhbmdcIikpcmV0dXJuKHQ9dC50b0xvd2VyQ2FzZSgpKT09PW58fDA9PT10LmluZGV4T2YobitcIi1cIil9d2hpbGUoKGU9ZS5wYXJlbnROb2RlKSYmMT09PWUubm9kZVR5cGUpO3JldHVybiExfX0pLHRhcmdldDpmdW5jdGlvbihlKXt2YXIgdD1uLmxvY2F0aW9uJiZuLmxvY2F0aW9uLmhhc2g7cmV0dXJuIHQmJnQuc2xpY2UoMSk9PT1lLmlkfSxyb290OmZ1bmN0aW9uKGUpe3JldHVybiBlPT09YX0sZm9jdXM6ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT1DLmFjdGl2ZUVsZW1lbnQmJighQy5oYXNGb2N1c3x8Qy5oYXNGb2N1cygpKSYmISEoZS50eXBlfHxlLmhyZWZ8fH5lLnRhYkluZGV4KX0sZW5hYmxlZDpnZSghMSksZGlzYWJsZWQ6Z2UoITApLGNoZWNrZWQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVyblwiaW5wdXRcIj09PXQmJiEhZS5jaGVja2VkfHxcIm9wdGlvblwiPT09dCYmISFlLnNlbGVjdGVkfSxzZWxlY3RlZDpmdW5jdGlvbihlKXtyZXR1cm4gZS5wYXJlbnROb2RlJiZlLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCwhMD09PWUuc2VsZWN0ZWR9LGVtcHR5OmZ1bmN0aW9uKGUpe2ZvcihlPWUuZmlyc3RDaGlsZDtlO2U9ZS5uZXh0U2libGluZylpZihlLm5vZGVUeXBlPDYpcmV0dXJuITE7cmV0dXJuITB9LHBhcmVudDpmdW5jdGlvbihlKXtyZXR1cm4hYi5wc2V1ZG9zLmVtcHR5KGUpfSxoZWFkZXI6ZnVuY3Rpb24oZSl7cmV0dXJuIEoudGVzdChlLm5vZGVOYW1lKX0saW5wdXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIFEudGVzdChlLm5vZGVOYW1lKX0sYnV0dG9uOmZ1bmN0aW9uKGUpe3ZhciB0PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm5cImlucHV0XCI9PT10JiZcImJ1dHRvblwiPT09ZS50eXBlfHxcImJ1dHRvblwiPT09dH0sdGV4dDpmdW5jdGlvbihlKXt2YXIgdDtyZXR1cm5cImlucHV0XCI9PT1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkmJlwidGV4dFwiPT09ZS50eXBlJiYobnVsbD09KHQ9ZS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKXx8XCJ0ZXh0XCI9PT10LnRvTG93ZXJDYXNlKCkpfSxmaXJzdDp5ZShmdW5jdGlvbigpe3JldHVyblswXX0pLGxhc3Q6eWUoZnVuY3Rpb24oZSx0KXtyZXR1cm5bdC0xXX0pLGVxOnllKGZ1bmN0aW9uKGUsdCxuKXtyZXR1cm5bbjwwP24rdDpuXX0pLGV2ZW46eWUoZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49MDtuPHQ7bis9MillLnB1c2gobik7cmV0dXJuIGV9KSxvZGQ6eWUoZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49MTtuPHQ7bis9MillLnB1c2gobik7cmV0dXJuIGV9KSxsdDp5ZShmdW5jdGlvbihlLHQsbil7Zm9yKHZhciByPW48MD9uK3Q6dDxuP3Q6bjswPD0tLXI7KWUucHVzaChyKTtyZXR1cm4gZX0pLGd0OnllKGZ1bmN0aW9uKGUsdCxuKXtmb3IodmFyIHI9bjwwP24rdDpuOysrcjx0OyllLnB1c2gocik7cmV0dXJuIGV9KX19KS5wc2V1ZG9zLm50aD1iLnBzZXVkb3MuZXEse3JhZGlvOiEwLGNoZWNrYm94OiEwLGZpbGU6ITAscGFzc3dvcmQ6ITAsaW1hZ2U6ITB9KWIucHNldWRvc1tlXT1kZShlKTtmb3IoZSBpbntzdWJtaXQ6ITAscmVzZXQ6ITB9KWIucHNldWRvc1tlXT1oZShlKTtmdW5jdGlvbiBtZSgpe31mdW5jdGlvbiB4ZShlKXtmb3IodmFyIHQ9MCxuPWUubGVuZ3RoLHI9XCJcIjt0PG47dCsrKXIrPWVbdF0udmFsdWU7cmV0dXJuIHJ9ZnVuY3Rpb24gYmUocyxlLHQpe3ZhciB1PWUuZGlyLGw9ZS5uZXh0LGM9bHx8dSxmPXQmJlwicGFyZW50Tm9kZVwiPT09YyxwPXIrKztyZXR1cm4gZS5maXJzdD9mdW5jdGlvbihlLHQsbil7d2hpbGUoZT1lW3VdKWlmKDE9PT1lLm5vZGVUeXBlfHxmKXJldHVybiBzKGUsdCxuKTtyZXR1cm4hMX06ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbyxhPVtrLHBdO2lmKG4pe3doaWxlKGU9ZVt1XSlpZigoMT09PWUubm9kZVR5cGV8fGYpJiZzKGUsdCxuKSlyZXR1cm4hMH1lbHNlIHdoaWxlKGU9ZVt1XSlpZigxPT09ZS5ub2RlVHlwZXx8ZilpZihpPShvPWVbU118fChlW1NdPXt9KSlbZS51bmlxdWVJRF18fChvW2UudW5pcXVlSURdPXt9KSxsJiZsPT09ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKWU9ZVt1XXx8ZTtlbHNle2lmKChyPWlbY10pJiZyWzBdPT09ayYmclsxXT09PXApcmV0dXJuIGFbMl09clsyXTtpZigoaVtjXT1hKVsyXT1zKGUsdCxuKSlyZXR1cm4hMH1yZXR1cm4hMX19ZnVuY3Rpb24gd2UoaSl7cmV0dXJuIDE8aS5sZW5ndGg/ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWkubGVuZ3RoO3doaWxlKHItLSlpZighaVtyXShlLHQsbikpcmV0dXJuITE7cmV0dXJuITB9OmlbMF19ZnVuY3Rpb24gVGUoZSx0LG4scixpKXtmb3IodmFyIG8sYT1bXSxzPTAsdT1lLmxlbmd0aCxsPW51bGwhPXQ7czx1O3MrKykobz1lW3NdKSYmKG4mJiFuKG8scixpKXx8KGEucHVzaChvKSxsJiZ0LnB1c2gocykpKTtyZXR1cm4gYX1mdW5jdGlvbiBDZShkLGgsZyx5LHYsZSl7cmV0dXJuIHkmJiF5W1NdJiYoeT1DZSh5KSksdiYmIXZbU10mJih2PUNlKHYsZSkpLGxlKGZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpLG8sYSxzPVtdLHU9W10sbD10Lmxlbmd0aCxjPWV8fGZ1bmN0aW9uKGUsdCxuKXtmb3IodmFyIHI9MCxpPXQubGVuZ3RoO3I8aTtyKyspc2UoZSx0W3JdLG4pO3JldHVybiBufShofHxcIipcIixuLm5vZGVUeXBlP1tuXTpuLFtdKSxmPSFkfHwhZSYmaD9jOlRlKGMscyxkLG4scikscD1nP3Z8fChlP2Q6bHx8eSk/W106dDpmO2lmKGcmJmcoZixwLG4scikseSl7aT1UZShwLHUpLHkoaSxbXSxuLHIpLG89aS5sZW5ndGg7d2hpbGUoby0tKShhPWlbb10pJiYocFt1W29dXT0hKGZbdVtvXV09YSkpfWlmKGUpe2lmKHZ8fGQpe2lmKHYpe2k9W10sbz1wLmxlbmd0aDt3aGlsZShvLS0pKGE9cFtvXSkmJmkucHVzaChmW29dPWEpO3YobnVsbCxwPVtdLGkscil9bz1wLmxlbmd0aDt3aGlsZShvLS0pKGE9cFtvXSkmJi0xPChpPXY/UChlLGEpOnNbb10pJiYoZVtpXT0hKHRbaV09YSkpfX1lbHNlIHA9VGUocD09PXQ/cC5zcGxpY2UobCxwLmxlbmd0aCk6cCksdj92KG51bGwsdCxwLHIpOkguYXBwbHkodCxwKX0pfWZ1bmN0aW9uIEVlKGUpe2Zvcih2YXIgaSx0LG4scj1lLmxlbmd0aCxvPWIucmVsYXRpdmVbZVswXS50eXBlXSxhPW98fGIucmVsYXRpdmVbXCIgXCJdLHM9bz8xOjAsdT1iZShmdW5jdGlvbihlKXtyZXR1cm4gZT09PWl9LGEsITApLGw9YmUoZnVuY3Rpb24oZSl7cmV0dXJuLTE8UChpLGUpfSxhLCEwKSxjPVtmdW5jdGlvbihlLHQsbil7dmFyIHI9IW8mJihufHx0IT09dyl8fCgoaT10KS5ub2RlVHlwZT91KGUsdCxuKTpsKGUsdCxuKSk7cmV0dXJuIGk9bnVsbCxyfV07czxyO3MrKylpZih0PWIucmVsYXRpdmVbZVtzXS50eXBlXSljPVtiZSh3ZShjKSx0KV07ZWxzZXtpZigodD1iLmZpbHRlcltlW3NdLnR5cGVdLmFwcGx5KG51bGwsZVtzXS5tYXRjaGVzKSlbU10pe2ZvcihuPSsrcztuPHI7bisrKWlmKGIucmVsYXRpdmVbZVtuXS50eXBlXSlicmVhaztyZXR1cm4gQ2UoMTxzJiZ3ZShjKSwxPHMmJnhlKGUuc2xpY2UoMCxzLTEpLmNvbmNhdCh7dmFsdWU6XCIgXCI9PT1lW3MtMl0udHlwZT9cIipcIjpcIlwifSkpLnJlcGxhY2UoQixcIiQxXCIpLHQsczxuJiZFZShlLnNsaWNlKHMsbikpLG48ciYmRWUoZT1lLnNsaWNlKG4pKSxuPHImJnhlKGUpKX1jLnB1c2godCl9cmV0dXJuIHdlKGMpfXJldHVybiBtZS5wcm90b3R5cGU9Yi5maWx0ZXJzPWIucHNldWRvcyxiLnNldEZpbHRlcnM9bmV3IG1lLGg9c2UudG9rZW5pemU9ZnVuY3Rpb24oZSx0KXt2YXIgbixyLGksbyxhLHMsdSxsPXhbZStcIiBcIl07aWYobClyZXR1cm4gdD8wOmwuc2xpY2UoMCk7YT1lLHM9W10sdT1iLnByZUZpbHRlcjt3aGlsZShhKXtmb3IobyBpbiBuJiYhKHI9Xy5leGVjKGEpKXx8KHImJihhPWEuc2xpY2UoclswXS5sZW5ndGgpfHxhKSxzLnB1c2goaT1bXSkpLG49ITEsKHI9ei5leGVjKGEpKSYmKG49ci5zaGlmdCgpLGkucHVzaCh7dmFsdWU6bix0eXBlOnJbMF0ucmVwbGFjZShCLFwiIFwiKX0pLGE9YS5zbGljZShuLmxlbmd0aCkpLGIuZmlsdGVyKSEocj1HW29dLmV4ZWMoYSkpfHx1W29dJiYhKHI9dVtvXShyKSl8fChuPXIuc2hpZnQoKSxpLnB1c2goe3ZhbHVlOm4sdHlwZTpvLG1hdGNoZXM6cn0pLGE9YS5zbGljZShuLmxlbmd0aCkpO2lmKCFuKWJyZWFrfXJldHVybiB0P2EubGVuZ3RoOmE/c2UuZXJyb3IoZSk6eChlLHMpLnNsaWNlKDApfSxmPXNlLmNvbXBpbGU9ZnVuY3Rpb24oZSx0KXt2YXIgbix5LHYsbSx4LHIsaT1bXSxvPVtdLGE9QVtlK1wiIFwiXTtpZighYSl7dHx8KHQ9aChlKSksbj10Lmxlbmd0aDt3aGlsZShuLS0pKGE9RWUodFtuXSkpW1NdP2kucHVzaChhKTpvLnB1c2goYSk7KGE9QShlLCh5PW8sbT0wPCh2PWkpLmxlbmd0aCx4PTA8eS5sZW5ndGgscj1mdW5jdGlvbihlLHQsbixyLGkpe3ZhciBvLGEscyx1PTAsbD1cIjBcIixjPWUmJltdLGY9W10scD13LGQ9ZXx8eCYmYi5maW5kLlRBRyhcIipcIixpKSxoPWsrPW51bGw9PXA/MTpNYXRoLnJhbmRvbSgpfHwuMSxnPWQubGVuZ3RoO2ZvcihpJiYodz10PT1DfHx0fHxpKTtsIT09ZyYmbnVsbCE9KG89ZFtsXSk7bCsrKXtpZih4JiZvKXthPTAsdHx8by5vd25lckRvY3VtZW50PT1DfHwoVChvKSxuPSFFKTt3aGlsZShzPXlbYSsrXSlpZihzKG8sdHx8QyxuKSl7ci5wdXNoKG8pO2JyZWFrfWkmJihrPWgpfW0mJigobz0hcyYmbykmJnUtLSxlJiZjLnB1c2gobykpfWlmKHUrPWwsbSYmbCE9PXUpe2E9MDt3aGlsZShzPXZbYSsrXSlzKGMsZix0LG4pO2lmKGUpe2lmKDA8dSl3aGlsZShsLS0pY1tsXXx8ZltsXXx8KGZbbF09cS5jYWxsKHIpKTtmPVRlKGYpfUguYXBwbHkocixmKSxpJiYhZSYmMDxmLmxlbmd0aCYmMTx1K3YubGVuZ3RoJiZzZS51bmlxdWVTb3J0KHIpfXJldHVybiBpJiYoaz1oLHc9cCksY30sbT9sZShyKTpyKSkpLnNlbGVjdG9yPWV9cmV0dXJuIGF9LGc9c2Uuc2VsZWN0PWZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpLG8sYSxzLHUsbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZlLGM9IXImJmgoZT1sLnNlbGVjdG9yfHxlKTtpZihuPW58fFtdLDE9PT1jLmxlbmd0aCl7aWYoMjwobz1jWzBdPWNbMF0uc2xpY2UoMCkpLmxlbmd0aCYmXCJJRFwiPT09KGE9b1swXSkudHlwZSYmOT09PXQubm9kZVR5cGUmJkUmJmIucmVsYXRpdmVbb1sxXS50eXBlXSl7aWYoISh0PShiLmZpbmQuSUQoYS5tYXRjaGVzWzBdLnJlcGxhY2UodGUsbmUpLHQpfHxbXSlbMF0pKXJldHVybiBuO2wmJih0PXQucGFyZW50Tm9kZSksZT1lLnNsaWNlKG8uc2hpZnQoKS52YWx1ZS5sZW5ndGgpfWk9Ry5uZWVkc0NvbnRleHQudGVzdChlKT8wOm8ubGVuZ3RoO3doaWxlKGktLSl7aWYoYT1vW2ldLGIucmVsYXRpdmVbcz1hLnR5cGVdKWJyZWFrO2lmKCh1PWIuZmluZFtzXSkmJihyPXUoYS5tYXRjaGVzWzBdLnJlcGxhY2UodGUsbmUpLGVlLnRlc3Qob1swXS50eXBlKSYmdmUodC5wYXJlbnROb2RlKXx8dCkpKXtpZihvLnNwbGljZShpLDEpLCEoZT1yLmxlbmd0aCYmeGUobykpKXJldHVybiBILmFwcGx5KG4sciksbjticmVha319fXJldHVybihsfHxmKGUsYykpKHIsdCwhRSxuLCF0fHxlZS50ZXN0KGUpJiZ2ZSh0LnBhcmVudE5vZGUpfHx0KSxufSxkLnNvcnRTdGFibGU9Uy5zcGxpdChcIlwiKS5zb3J0KGopLmpvaW4oXCJcIik9PT1TLGQuZGV0ZWN0RHVwbGljYXRlcz0hIWwsVCgpLGQuc29ydERldGFjaGVkPWNlKGZ1bmN0aW9uKGUpe3JldHVybiAxJmUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oQy5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikpfSksY2UoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaW5uZXJIVE1MPVwiPGEgaHJlZj0nIyc+PC9hPlwiLFwiI1wiPT09ZS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIil9KXx8ZmUoXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsZnVuY3Rpb24oZSx0LG4pe2lmKCFuKXJldHVybiBlLmdldEF0dHJpYnV0ZSh0LFwidHlwZVwiPT09dC50b0xvd2VyQ2FzZSgpPzE6Mil9KSxkLmF0dHJpYnV0ZXMmJmNlKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlubmVySFRNTD1cIjxpbnB1dC8+XCIsZS5maXJzdENoaWxkLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsXCJcIiksXCJcIj09PWUuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKX0pfHxmZShcInZhbHVlXCIsZnVuY3Rpb24oZSx0LG4pe2lmKCFuJiZcImlucHV0XCI9PT1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpcmV0dXJuIGUuZGVmYXVsdFZhbHVlfSksY2UoZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWUuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIil9KXx8ZmUoUixmdW5jdGlvbihlLHQsbil7dmFyIHI7aWYoIW4pcmV0dXJuITA9PT1lW3RdP3QudG9Mb3dlckNhc2UoKToocj1lLmdldEF0dHJpYnV0ZU5vZGUodCkpJiZyLnNwZWNpZmllZD9yLnZhbHVlOm51bGx9KSxzZX0oQyk7Uy5maW5kPWQsUy5leHByPWQuc2VsZWN0b3JzLFMuZXhwcltcIjpcIl09Uy5leHByLnBzZXVkb3MsUy51bmlxdWVTb3J0PVMudW5pcXVlPWQudW5pcXVlU29ydCxTLnRleHQ9ZC5nZXRUZXh0LFMuaXNYTUxEb2M9ZC5pc1hNTCxTLmNvbnRhaW5zPWQuY29udGFpbnMsUy5lc2NhcGVTZWxlY3Rvcj1kLmVzY2FwZTt2YXIgaD1mdW5jdGlvbihlLHQsbil7dmFyIHI9W10saT12b2lkIDAhPT1uO3doaWxlKChlPWVbdF0pJiY5IT09ZS5ub2RlVHlwZSlpZigxPT09ZS5ub2RlVHlwZSl7aWYoaSYmUyhlKS5pcyhuKSlicmVhaztyLnB1c2goZSl9cmV0dXJuIHJ9LFQ9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49W107ZTtlPWUubmV4dFNpYmxpbmcpMT09PWUubm9kZVR5cGUmJmUhPT10JiZuLnB1c2goZSk7cmV0dXJuIG59LGs9Uy5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtmdW5jdGlvbiBBKGUsdCl7cmV0dXJuIGUubm9kZU5hbWUmJmUubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09PXQudG9Mb3dlckNhc2UoKX12YXIgTj0vXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaTtmdW5jdGlvbiBqKGUsbixyKXtyZXR1cm4gbShuKT9TLmdyZXAoZSxmdW5jdGlvbihlLHQpe3JldHVybiEhbi5jYWxsKGUsdCxlKSE9PXJ9KTpuLm5vZGVUeXBlP1MuZ3JlcChlLGZ1bmN0aW9uKGUpe3JldHVybiBlPT09biE9PXJ9KTpcInN0cmluZ1wiIT10eXBlb2Ygbj9TLmdyZXAoZSxmdW5jdGlvbihlKXtyZXR1cm4tMTxpLmNhbGwobixlKSE9PXJ9KTpTLmZpbHRlcihuLGUscil9Uy5maWx0ZXI9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRbMF07cmV0dXJuIG4mJihlPVwiOm5vdChcIitlK1wiKVwiKSwxPT09dC5sZW5ndGgmJjE9PT1yLm5vZGVUeXBlP1MuZmluZC5tYXRjaGVzU2VsZWN0b3IocixlKT9bcl06W106Uy5maW5kLm1hdGNoZXMoZSxTLmdyZXAodCxmdW5jdGlvbihlKXtyZXR1cm4gMT09PWUubm9kZVR5cGV9KSl9LFMuZm4uZXh0ZW5kKHtmaW5kOmZ1bmN0aW9uKGUpe3ZhciB0LG4scj10aGlzLmxlbmd0aCxpPXRoaXM7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGUpcmV0dXJuIHRoaXMucHVzaFN0YWNrKFMoZSkuZmlsdGVyKGZ1bmN0aW9uKCl7Zm9yKHQ9MDt0PHI7dCsrKWlmKFMuY29udGFpbnMoaVt0XSx0aGlzKSlyZXR1cm4hMH0pKTtmb3Iobj10aGlzLnB1c2hTdGFjayhbXSksdD0wO3Q8cjt0KyspUy5maW5kKGUsaVt0XSxuKTtyZXR1cm4gMTxyP1MudW5pcXVlU29ydChuKTpufSxmaWx0ZXI6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGoodGhpcyxlfHxbXSwhMSkpfSxub3Q6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGoodGhpcyxlfHxbXSwhMCkpfSxpczpmdW5jdGlvbihlKXtyZXR1cm4hIWoodGhpcyxcInN0cmluZ1wiPT10eXBlb2YgZSYmay50ZXN0KGUpP1MoZSk6ZXx8W10sITEpLmxlbmd0aH19KTt2YXIgRCxxPS9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvOyhTLmZuLmluaXQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGk7aWYoIWUpcmV0dXJuIHRoaXM7aWYobj1ufHxELFwic3RyaW5nXCI9PXR5cGVvZiBlKXtpZighKHI9XCI8XCI9PT1lWzBdJiZcIj5cIj09PWVbZS5sZW5ndGgtMV0mJjM8PWUubGVuZ3RoP1tudWxsLGUsbnVsbF06cS5leGVjKGUpKXx8IXJbMV0mJnQpcmV0dXJuIXR8fHQuanF1ZXJ5Pyh0fHxuKS5maW5kKGUpOnRoaXMuY29uc3RydWN0b3IodCkuZmluZChlKTtpZihyWzFdKXtpZih0PXQgaW5zdGFuY2VvZiBTP3RbMF06dCxTLm1lcmdlKHRoaXMsUy5wYXJzZUhUTUwoclsxXSx0JiZ0Lm5vZGVUeXBlP3Qub3duZXJEb2N1bWVudHx8dDpFLCEwKSksTi50ZXN0KHJbMV0pJiZTLmlzUGxhaW5PYmplY3QodCkpZm9yKHIgaW4gdCltKHRoaXNbcl0pP3RoaXNbcl0odFtyXSk6dGhpcy5hdHRyKHIsdFtyXSk7cmV0dXJuIHRoaXN9cmV0dXJuKGk9RS5nZXRFbGVtZW50QnlJZChyWzJdKSkmJih0aGlzWzBdPWksdGhpcy5sZW5ndGg9MSksdGhpc31yZXR1cm4gZS5ub2RlVHlwZT8odGhpc1swXT1lLHRoaXMubGVuZ3RoPTEsdGhpcyk6bShlKT92b2lkIDAhPT1uLnJlYWR5P24ucmVhZHkoZSk6ZShTKTpTLm1ha2VBcnJheShlLHRoaXMpfSkucHJvdG90eXBlPVMuZm4sRD1TKEUpO3ZhciBMPS9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLEg9e2NoaWxkcmVuOiEwLGNvbnRlbnRzOiEwLG5leHQ6ITAscHJldjohMH07ZnVuY3Rpb24gTyhlLHQpe3doaWxlKChlPWVbdF0pJiYxIT09ZS5ub2RlVHlwZSk7cmV0dXJuIGV9Uy5mbi5leHRlbmQoe2hhczpmdW5jdGlvbihlKXt2YXIgdD1TKGUsdGhpcyksbj10Lmxlbmd0aDtyZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oKXtmb3IodmFyIGU9MDtlPG47ZSsrKWlmKFMuY29udGFpbnModGhpcyx0W2VdKSlyZXR1cm4hMH0pfSxjbG9zZXN0OmZ1bmN0aW9uKGUsdCl7dmFyIG4scj0wLGk9dGhpcy5sZW5ndGgsbz1bXSxhPVwic3RyaW5nXCIhPXR5cGVvZiBlJiZTKGUpO2lmKCFrLnRlc3QoZSkpZm9yKDtyPGk7cisrKWZvcihuPXRoaXNbcl07biYmbiE9PXQ7bj1uLnBhcmVudE5vZGUpaWYobi5ub2RlVHlwZTwxMSYmKGE/LTE8YS5pbmRleChuKToxPT09bi5ub2RlVHlwZSYmUy5maW5kLm1hdGNoZXNTZWxlY3RvcihuLGUpKSl7by5wdXNoKG4pO2JyZWFrfXJldHVybiB0aGlzLnB1c2hTdGFjaygxPG8ubGVuZ3RoP1MudW5pcXVlU29ydChvKTpvKX0saW5kZXg6ZnVuY3Rpb24oZSl7cmV0dXJuIGU/XCJzdHJpbmdcIj09dHlwZW9mIGU/aS5jYWxsKFMoZSksdGhpc1swXSk6aS5jYWxsKHRoaXMsZS5qcXVlcnk/ZVswXTplKTp0aGlzWzBdJiZ0aGlzWzBdLnBhcmVudE5vZGU/dGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGg6LTF9LGFkZDpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnB1c2hTdGFjayhTLnVuaXF1ZVNvcnQoUy5tZXJnZSh0aGlzLmdldCgpLFMoZSx0KSkpKX0sYWRkQmFjazpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5hZGQobnVsbD09ZT90aGlzLnByZXZPYmplY3Q6dGhpcy5wcmV2T2JqZWN0LmZpbHRlcihlKSl9fSksUy5lYWNoKHtwYXJlbnQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5wYXJlbnROb2RlO3JldHVybiB0JiYxMSE9PXQubm9kZVR5cGU/dDpudWxsfSxwYXJlbnRzOmZ1bmN0aW9uKGUpe3JldHVybiBoKGUsXCJwYXJlbnROb2RlXCIpfSxwYXJlbnRzVW50aWw6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBoKGUsXCJwYXJlbnROb2RlXCIsbil9LG5leHQ6ZnVuY3Rpb24oZSl7cmV0dXJuIE8oZSxcIm5leHRTaWJsaW5nXCIpfSxwcmV2OmZ1bmN0aW9uKGUpe3JldHVybiBPKGUsXCJwcmV2aW91c1NpYmxpbmdcIil9LG5leHRBbGw6ZnVuY3Rpb24oZSl7cmV0dXJuIGgoZSxcIm5leHRTaWJsaW5nXCIpfSxwcmV2QWxsOmZ1bmN0aW9uKGUpe3JldHVybiBoKGUsXCJwcmV2aW91c1NpYmxpbmdcIil9LG5leHRVbnRpbDpmdW5jdGlvbihlLHQsbil7cmV0dXJuIGgoZSxcIm5leHRTaWJsaW5nXCIsbil9LHByZXZVbnRpbDpmdW5jdGlvbihlLHQsbil7cmV0dXJuIGgoZSxcInByZXZpb3VzU2libGluZ1wiLG4pfSxzaWJsaW5nczpmdW5jdGlvbihlKXtyZXR1cm4gVCgoZS5wYXJlbnROb2RlfHx7fSkuZmlyc3RDaGlsZCxlKX0sY2hpbGRyZW46ZnVuY3Rpb24oZSl7cmV0dXJuIFQoZS5maXJzdENoaWxkKX0sY29udGVudHM6ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPWUuY29udGVudERvY3VtZW50JiZyKGUuY29udGVudERvY3VtZW50KT9lLmNvbnRlbnREb2N1bWVudDooQShlLFwidGVtcGxhdGVcIikmJihlPWUuY29udGVudHx8ZSksUy5tZXJnZShbXSxlLmNoaWxkTm9kZXMpKX19LGZ1bmN0aW9uKHIsaSl7Uy5mbltyXT1mdW5jdGlvbihlLHQpe3ZhciBuPVMubWFwKHRoaXMsaSxlKTtyZXR1cm5cIlVudGlsXCIhPT1yLnNsaWNlKC01KSYmKHQ9ZSksdCYmXCJzdHJpbmdcIj09dHlwZW9mIHQmJihuPVMuZmlsdGVyKHQsbikpLDE8dGhpcy5sZW5ndGgmJihIW3JdfHxTLnVuaXF1ZVNvcnQobiksTC50ZXN0KHIpJiZuLnJldmVyc2UoKSksdGhpcy5wdXNoU3RhY2sobil9fSk7dmFyIFA9L1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nO2Z1bmN0aW9uIFIoZSl7cmV0dXJuIGV9ZnVuY3Rpb24gTShlKXt0aHJvdyBlfWZ1bmN0aW9uIEkoZSx0LG4scil7dmFyIGk7dHJ5e2UmJm0oaT1lLnByb21pc2UpP2kuY2FsbChlKS5kb25lKHQpLmZhaWwobik6ZSYmbShpPWUudGhlbik/aS5jYWxsKGUsdCxuKTp0LmFwcGx5KHZvaWQgMCxbZV0uc2xpY2UocikpfWNhdGNoKGUpe24uYXBwbHkodm9pZCAwLFtlXSl9fVMuQ2FsbGJhY2tzPWZ1bmN0aW9uKHIpe3ZhciBlLG47cj1cInN0cmluZ1wiPT10eXBlb2Ygcj8oZT1yLG49e30sUy5lYWNoKGUubWF0Y2goUCl8fFtdLGZ1bmN0aW9uKGUsdCl7blt0XT0hMH0pLG4pOlMuZXh0ZW5kKHt9LHIpO3ZhciBpLHQsbyxhLHM9W10sdT1bXSxsPS0xLGM9ZnVuY3Rpb24oKXtmb3IoYT1hfHxyLm9uY2Usbz1pPSEwO3UubGVuZ3RoO2w9LTEpe3Q9dS5zaGlmdCgpO3doaWxlKCsrbDxzLmxlbmd0aCkhMT09PXNbbF0uYXBwbHkodFswXSx0WzFdKSYmci5zdG9wT25GYWxzZSYmKGw9cy5sZW5ndGgsdD0hMSl9ci5tZW1vcnl8fCh0PSExKSxpPSExLGEmJihzPXQ/W106XCJcIil9LGY9e2FkZDpmdW5jdGlvbigpe3JldHVybiBzJiYodCYmIWkmJihsPXMubGVuZ3RoLTEsdS5wdXNoKHQpKSxmdW5jdGlvbiBuKGUpe1MuZWFjaChlLGZ1bmN0aW9uKGUsdCl7bSh0KT9yLnVuaXF1ZSYmZi5oYXModCl8fHMucHVzaCh0KTp0JiZ0Lmxlbmd0aCYmXCJzdHJpbmdcIiE9PXcodCkmJm4odCl9KX0oYXJndW1lbnRzKSx0JiYhaSYmYygpKSx0aGlzfSxyZW1vdmU6ZnVuY3Rpb24oKXtyZXR1cm4gUy5lYWNoKGFyZ3VtZW50cyxmdW5jdGlvbihlLHQpe3ZhciBuO3doaWxlKC0xPChuPVMuaW5BcnJheSh0LHMsbikpKXMuc3BsaWNlKG4sMSksbjw9bCYmbC0tfSksdGhpc30saGFzOmZ1bmN0aW9uKGUpe3JldHVybiBlPy0xPFMuaW5BcnJheShlLHMpOjA8cy5sZW5ndGh9LGVtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIHMmJihzPVtdKSx0aGlzfSxkaXNhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIGE9dT1bXSxzPXQ9XCJcIix0aGlzfSxkaXNhYmxlZDpmdW5jdGlvbigpe3JldHVybiFzfSxsb2NrOmZ1bmN0aW9uKCl7cmV0dXJuIGE9dT1bXSx0fHxpfHwocz10PVwiXCIpLHRoaXN9LGxvY2tlZDpmdW5jdGlvbigpe3JldHVybiEhYX0sZmlyZVdpdGg6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gYXx8KHQ9W2UsKHQ9dHx8W10pLnNsaWNlP3Quc2xpY2UoKTp0XSx1LnB1c2godCksaXx8YygpKSx0aGlzfSxmaXJlOmZ1bmN0aW9uKCl7cmV0dXJuIGYuZmlyZVdpdGgodGhpcyxhcmd1bWVudHMpLHRoaXN9LGZpcmVkOmZ1bmN0aW9uKCl7cmV0dXJuISFvfX07cmV0dXJuIGZ9LFMuZXh0ZW5kKHtEZWZlcnJlZDpmdW5jdGlvbihlKXt2YXIgbz1bW1wibm90aWZ5XCIsXCJwcm9ncmVzc1wiLFMuQ2FsbGJhY2tzKFwibWVtb3J5XCIpLFMuQ2FsbGJhY2tzKFwibWVtb3J5XCIpLDJdLFtcInJlc29sdmVcIixcImRvbmVcIixTLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLFMuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksMCxcInJlc29sdmVkXCJdLFtcInJlamVjdFwiLFwiZmFpbFwiLFMuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksUy5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwxLFwicmVqZWN0ZWRcIl1dLGk9XCJwZW5kaW5nXCIsYT17c3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gaX0sYWx3YXlzOmZ1bmN0aW9uKCl7cmV0dXJuIHMuZG9uZShhcmd1bWVudHMpLmZhaWwoYXJndW1lbnRzKSx0aGlzfSxcImNhdGNoXCI6ZnVuY3Rpb24oZSl7cmV0dXJuIGEudGhlbihudWxsLGUpfSxwaXBlOmZ1bmN0aW9uKCl7dmFyIGk9YXJndW1lbnRzO3JldHVybiBTLkRlZmVycmVkKGZ1bmN0aW9uKHIpe1MuZWFjaChvLGZ1bmN0aW9uKGUsdCl7dmFyIG49bShpW3RbNF1dKSYmaVt0WzRdXTtzW3RbMV1dKGZ1bmN0aW9uKCl7dmFyIGU9biYmbi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7ZSYmbShlLnByb21pc2UpP2UucHJvbWlzZSgpLnByb2dyZXNzKHIubm90aWZ5KS5kb25lKHIucmVzb2x2ZSkuZmFpbChyLnJlamVjdCk6clt0WzBdK1wiV2l0aFwiXSh0aGlzLG4/W2VdOmFyZ3VtZW50cyl9KX0pLGk9bnVsbH0pLnByb21pc2UoKX0sdGhlbjpmdW5jdGlvbih0LG4scil7dmFyIHU9MDtmdW5jdGlvbiBsKGksbyxhLHMpe3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXMscj1hcmd1bWVudHMsZT1mdW5jdGlvbigpe3ZhciBlLHQ7aWYoIShpPHUpKXtpZigoZT1hLmFwcGx5KG4scikpPT09by5wcm9taXNlKCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiKTt0PWUmJihcIm9iamVjdFwiPT10eXBlb2YgZXx8XCJmdW5jdGlvblwiPT10eXBlb2YgZSkmJmUudGhlbixtKHQpP3M/dC5jYWxsKGUsbCh1LG8sUixzKSxsKHUsbyxNLHMpKToodSsrLHQuY2FsbChlLGwodSxvLFIscyksbCh1LG8sTSxzKSxsKHUsbyxSLG8ubm90aWZ5V2l0aCkpKTooYSE9PVImJihuPXZvaWQgMCxyPVtlXSksKHN8fG8ucmVzb2x2ZVdpdGgpKG4scikpfX0sdD1zP2U6ZnVuY3Rpb24oKXt0cnl7ZSgpfWNhdGNoKGUpe1MuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayYmUy5EZWZlcnJlZC5leGNlcHRpb25Ib29rKGUsdC5zdGFja1RyYWNlKSx1PD1pKzEmJihhIT09TSYmKG49dm9pZCAwLHI9W2VdKSxvLnJlamVjdFdpdGgobixyKSl9fTtpP3QoKTooUy5EZWZlcnJlZC5nZXRTdGFja0hvb2smJih0LnN0YWNrVHJhY2U9Uy5EZWZlcnJlZC5nZXRTdGFja0hvb2soKSksQy5zZXRUaW1lb3V0KHQpKX19cmV0dXJuIFMuRGVmZXJyZWQoZnVuY3Rpb24oZSl7b1swXVszXS5hZGQobCgwLGUsbShyKT9yOlIsZS5ub3RpZnlXaXRoKSksb1sxXVszXS5hZGQobCgwLGUsbSh0KT90OlIpKSxvWzJdWzNdLmFkZChsKDAsZSxtKG4pP246TSkpfSkucHJvbWlzZSgpfSxwcm9taXNlOmZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT1lP1MuZXh0ZW5kKGUsYSk6YX19LHM9e307cmV0dXJuIFMuZWFjaChvLGZ1bmN0aW9uKGUsdCl7dmFyIG49dFsyXSxyPXRbNV07YVt0WzFdXT1uLmFkZCxyJiZuLmFkZChmdW5jdGlvbigpe2k9cn0sb1szLWVdWzJdLmRpc2FibGUsb1szLWVdWzNdLmRpc2FibGUsb1swXVsyXS5sb2NrLG9bMF1bM10ubG9jayksbi5hZGQodFszXS5maXJlKSxzW3RbMF1dPWZ1bmN0aW9uKCl7cmV0dXJuIHNbdFswXStcIldpdGhcIl0odGhpcz09PXM/dm9pZCAwOnRoaXMsYXJndW1lbnRzKSx0aGlzfSxzW3RbMF0rXCJXaXRoXCJdPW4uZmlyZVdpdGh9KSxhLnByb21pc2UocyksZSYmZS5jYWxsKHMscyksc30sd2hlbjpmdW5jdGlvbihlKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoLHQ9bixyPUFycmF5KHQpLGk9cy5jYWxsKGFyZ3VtZW50cyksbz1TLkRlZmVycmVkKCksYT1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7clt0XT10aGlzLGlbdF09MTxhcmd1bWVudHMubGVuZ3RoP3MuY2FsbChhcmd1bWVudHMpOmUsLS1ufHxvLnJlc29sdmVXaXRoKHIsaSl9fTtpZihuPD0xJiYoSShlLG8uZG9uZShhKHQpKS5yZXNvbHZlLG8ucmVqZWN0LCFuKSxcInBlbmRpbmdcIj09PW8uc3RhdGUoKXx8bShpW3RdJiZpW3RdLnRoZW4pKSlyZXR1cm4gby50aGVuKCk7d2hpbGUodC0tKUkoaVt0XSxhKHQpLG8ucmVqZWN0KTtyZXR1cm4gby5wcm9taXNlKCl9fSk7dmFyIFc9L14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87Uy5EZWZlcnJlZC5leGNlcHRpb25Ib29rPWZ1bmN0aW9uKGUsdCl7Qy5jb25zb2xlJiZDLmNvbnNvbGUud2FybiYmZSYmVy50ZXN0KGUubmFtZSkmJkMuY29uc29sZS53YXJuKFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIrZS5tZXNzYWdlLGUuc3RhY2ssdCl9LFMucmVhZHlFeGNlcHRpb249ZnVuY3Rpb24oZSl7Qy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgZX0pfTt2YXIgRj1TLkRlZmVycmVkKCk7ZnVuY3Rpb24gJCgpe0UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwkKSxDLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsJCksUy5yZWFkeSgpfVMuZm4ucmVhZHk9ZnVuY3Rpb24oZSl7cmV0dXJuIEYudGhlbihlKVtcImNhdGNoXCJdKGZ1bmN0aW9uKGUpe1MucmVhZHlFeGNlcHRpb24oZSl9KSx0aGlzfSxTLmV4dGVuZCh7aXNSZWFkeTohMSxyZWFkeVdhaXQ6MSxyZWFkeTpmdW5jdGlvbihlKXsoITA9PT1lPy0tUy5yZWFkeVdhaXQ6Uy5pc1JlYWR5KXx8KFMuaXNSZWFkeT0hMCkhPT1lJiYwPC0tUy5yZWFkeVdhaXR8fEYucmVzb2x2ZVdpdGgoRSxbU10pfX0pLFMucmVhZHkudGhlbj1GLnRoZW4sXCJjb21wbGV0ZVwiPT09RS5yZWFkeVN0YXRlfHxcImxvYWRpbmdcIiE9PUUucmVhZHlTdGF0ZSYmIUUuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsP0Muc2V0VGltZW91dChTLnJlYWR5KTooRS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCQpLEMuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwkKSk7dmFyIEI9ZnVuY3Rpb24oZSx0LG4scixpLG8sYSl7dmFyIHM9MCx1PWUubGVuZ3RoLGw9bnVsbD09bjtpZihcIm9iamVjdFwiPT09dyhuKSlmb3IocyBpbiBpPSEwLG4pQihlLHQscyxuW3NdLCEwLG8sYSk7ZWxzZSBpZih2b2lkIDAhPT1yJiYoaT0hMCxtKHIpfHwoYT0hMCksbCYmKGE/KHQuY2FsbChlLHIpLHQ9bnVsbCk6KGw9dCx0PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gbC5jYWxsKFMoZSksbil9KSksdCkpZm9yKDtzPHU7cysrKXQoZVtzXSxuLGE/cjpyLmNhbGwoZVtzXSxzLHQoZVtzXSxuKSkpO3JldHVybiBpP2U6bD90LmNhbGwoZSk6dT90KGVbMF0sbik6b30sXz0vXi1tcy0vLHo9Ly0oW2Etel0pL2c7ZnVuY3Rpb24gVShlLHQpe3JldHVybiB0LnRvVXBwZXJDYXNlKCl9ZnVuY3Rpb24gWChlKXtyZXR1cm4gZS5yZXBsYWNlKF8sXCJtcy1cIikucmVwbGFjZSh6LFUpfXZhciBWPWZ1bmN0aW9uKGUpe3JldHVybiAxPT09ZS5ub2RlVHlwZXx8OT09PWUubm9kZVR5cGV8fCErZS5ub2RlVHlwZX07ZnVuY3Rpb24gRygpe3RoaXMuZXhwYW5kbz1TLmV4cGFuZG8rRy51aWQrK31HLnVpZD0xLEcucHJvdG90eXBlPXtjYWNoZTpmdW5jdGlvbihlKXt2YXIgdD1lW3RoaXMuZXhwYW5kb107cmV0dXJuIHR8fCh0PXt9LFYoZSkmJihlLm5vZGVUeXBlP2VbdGhpcy5leHBhbmRvXT10Ok9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHRoaXMuZXhwYW5kbyx7dmFsdWU6dCxjb25maWd1cmFibGU6ITB9KSkpLHR9LHNldDpmdW5jdGlvbihlLHQsbil7dmFyIHIsaT10aGlzLmNhY2hlKGUpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KWlbWCh0KV09bjtlbHNlIGZvcihyIGluIHQpaVtYKHIpXT10W3JdO3JldHVybiBpfSxnZXQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwPT09dD90aGlzLmNhY2hlKGUpOmVbdGhpcy5leHBhbmRvXSYmZVt0aGlzLmV4cGFuZG9dW1godCldfSxhY2Nlc3M6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB2b2lkIDA9PT10fHx0JiZcInN0cmluZ1wiPT10eXBlb2YgdCYmdm9pZCAwPT09bj90aGlzLmdldChlLHQpOih0aGlzLnNldChlLHQsbiksdm9pZCAwIT09bj9uOnQpfSxyZW1vdmU6ZnVuY3Rpb24oZSx0KXt2YXIgbixyPWVbdGhpcy5leHBhbmRvXTtpZih2b2lkIDAhPT1yKXtpZih2b2lkIDAhPT10KXtuPSh0PUFycmF5LmlzQXJyYXkodCk/dC5tYXAoWCk6KHQ9WCh0KSlpbiByP1t0XTp0Lm1hdGNoKFApfHxbXSkubGVuZ3RoO3doaWxlKG4tLSlkZWxldGUgclt0W25dXX0odm9pZCAwPT09dHx8Uy5pc0VtcHR5T2JqZWN0KHIpKSYmKGUubm9kZVR5cGU/ZVt0aGlzLmV4cGFuZG9dPXZvaWQgMDpkZWxldGUgZVt0aGlzLmV4cGFuZG9dKX19LGhhc0RhdGE6ZnVuY3Rpb24oZSl7dmFyIHQ9ZVt0aGlzLmV4cGFuZG9dO3JldHVybiB2b2lkIDAhPT10JiYhUy5pc0VtcHR5T2JqZWN0KHQpfX07dmFyIFk9bmV3IEcsUT1uZXcgRyxKPS9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxLPS9bQS1aXS9nO2Z1bmN0aW9uIFooZSx0LG4pe3ZhciByLGk7aWYodm9pZCAwPT09biYmMT09PWUubm9kZVR5cGUpaWYocj1cImRhdGEtXCIrdC5yZXBsYWNlKEssXCItJCZcIikudG9Mb3dlckNhc2UoKSxcInN0cmluZ1wiPT10eXBlb2Yobj1lLmdldEF0dHJpYnV0ZShyKSkpe3RyeXtuPVwidHJ1ZVwiPT09KGk9bil8fFwiZmFsc2VcIiE9PWkmJihcIm51bGxcIj09PWk/bnVsbDppPT09K2krXCJcIj8raTpKLnRlc3QoaSk/SlNPTi5wYXJzZShpKTppKX1jYXRjaChlKXt9US5zZXQoZSx0LG4pfWVsc2Ugbj12b2lkIDA7cmV0dXJuIG59Uy5leHRlbmQoe2hhc0RhdGE6ZnVuY3Rpb24oZSl7cmV0dXJuIFEuaGFzRGF0YShlKXx8WS5oYXNEYXRhKGUpfSxkYXRhOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gUS5hY2Nlc3MoZSx0LG4pfSxyZW1vdmVEYXRhOmZ1bmN0aW9uKGUsdCl7US5yZW1vdmUoZSx0KX0sX2RhdGE6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBZLmFjY2VzcyhlLHQsbil9LF9yZW1vdmVEYXRhOmZ1bmN0aW9uKGUsdCl7WS5yZW1vdmUoZSx0KX19KSxTLmZuLmV4dGVuZCh7ZGF0YTpmdW5jdGlvbihuLGUpe3ZhciB0LHIsaSxvPXRoaXNbMF0sYT1vJiZvLmF0dHJpYnV0ZXM7aWYodm9pZCAwPT09bil7aWYodGhpcy5sZW5ndGgmJihpPVEuZ2V0KG8pLDE9PT1vLm5vZGVUeXBlJiYhWS5nZXQobyxcImhhc0RhdGFBdHRyc1wiKSkpe3Q9YS5sZW5ndGg7d2hpbGUodC0tKWFbdF0mJjA9PT0ocj1hW3RdLm5hbWUpLmluZGV4T2YoXCJkYXRhLVwiKSYmKHI9WChyLnNsaWNlKDUpKSxaKG8scixpW3JdKSk7WS5zZXQobyxcImhhc0RhdGFBdHRyc1wiLCEwKX1yZXR1cm4gaX1yZXR1cm5cIm9iamVjdFwiPT10eXBlb2Ygbj90aGlzLmVhY2goZnVuY3Rpb24oKXtRLnNldCh0aGlzLG4pfSk6Qih0aGlzLGZ1bmN0aW9uKGUpe3ZhciB0O2lmKG8mJnZvaWQgMD09PWUpcmV0dXJuIHZvaWQgMCE9PSh0PVEuZ2V0KG8sbikpP3Q6dm9pZCAwIT09KHQ9WihvLG4pKT90OnZvaWQgMDt0aGlzLmVhY2goZnVuY3Rpb24oKXtRLnNldCh0aGlzLG4sZSl9KX0sbnVsbCxlLDE8YXJndW1lbnRzLmxlbmd0aCxudWxsLCEwKX0scmVtb3ZlRGF0YTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7US5yZW1vdmUodGhpcyxlKX0pfX0pLFMuZXh0ZW5kKHtxdWV1ZTpmdW5jdGlvbihlLHQsbil7dmFyIHI7aWYoZSlyZXR1cm4gdD0odHx8XCJmeFwiKStcInF1ZXVlXCIscj1ZLmdldChlLHQpLG4mJighcnx8QXJyYXkuaXNBcnJheShuKT9yPVkuYWNjZXNzKGUsdCxTLm1ha2VBcnJheShuKSk6ci5wdXNoKG4pKSxyfHxbXX0sZGVxdWV1ZTpmdW5jdGlvbihlLHQpe3Q9dHx8XCJmeFwiO3ZhciBuPVMucXVldWUoZSx0KSxyPW4ubGVuZ3RoLGk9bi5zaGlmdCgpLG89Uy5fcXVldWVIb29rcyhlLHQpO1wiaW5wcm9ncmVzc1wiPT09aSYmKGk9bi5zaGlmdCgpLHItLSksaSYmKFwiZnhcIj09PXQmJm4udW5zaGlmdChcImlucHJvZ3Jlc3NcIiksZGVsZXRlIG8uc3RvcCxpLmNhbGwoZSxmdW5jdGlvbigpe1MuZGVxdWV1ZShlLHQpfSxvKSksIXImJm8mJm8uZW1wdHkuZmlyZSgpfSxfcXVldWVIb29rczpmdW5jdGlvbihlLHQpe3ZhciBuPXQrXCJxdWV1ZUhvb2tzXCI7cmV0dXJuIFkuZ2V0KGUsbil8fFkuYWNjZXNzKGUsbix7ZW1wdHk6Uy5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKS5hZGQoZnVuY3Rpb24oKXtZLnJlbW92ZShlLFt0K1wicXVldWVcIixuXSl9KX0pfX0pLFMuZm4uZXh0ZW5kKHtxdWV1ZTpmdW5jdGlvbih0LG4pe3ZhciBlPTI7cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIHQmJihuPXQsdD1cImZ4XCIsZS0tKSxhcmd1bWVudHMubGVuZ3RoPGU/Uy5xdWV1ZSh0aGlzWzBdLHQpOnZvaWQgMD09PW4/dGhpczp0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZT1TLnF1ZXVlKHRoaXMsdCxuKTtTLl9xdWV1ZUhvb2tzKHRoaXMsdCksXCJmeFwiPT09dCYmXCJpbnByb2dyZXNzXCIhPT1lWzBdJiZTLmRlcXVldWUodGhpcyx0KX0pfSxkZXF1ZXVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtTLmRlcXVldWUodGhpcyxlKX0pfSxjbGVhclF1ZXVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnF1ZXVlKGV8fFwiZnhcIixbXSl9LHByb21pc2U6ZnVuY3Rpb24oZSx0KXt2YXIgbixyPTEsaT1TLkRlZmVycmVkKCksbz10aGlzLGE9dGhpcy5sZW5ndGgscz1mdW5jdGlvbigpey0tcnx8aS5yZXNvbHZlV2l0aChvLFtvXSl9O1wic3RyaW5nXCIhPXR5cGVvZiBlJiYodD1lLGU9dm9pZCAwKSxlPWV8fFwiZnhcIjt3aGlsZShhLS0pKG49WS5nZXQob1thXSxlK1wicXVldWVIb29rc1wiKSkmJm4uZW1wdHkmJihyKyssbi5lbXB0eS5hZGQocykpO3JldHVybiBzKCksaS5wcm9taXNlKHQpfX0pO3ZhciBlZT0vWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLy5zb3VyY2UsdGU9bmV3IFJlZ0V4cChcIl4oPzooWystXSk9fCkoXCIrZWUrXCIpKFthLXolXSopJFwiLFwiaVwiKSxuZT1bXCJUb3BcIixcIlJpZ2h0XCIsXCJCb3R0b21cIixcIkxlZnRcIl0scmU9RS5kb2N1bWVudEVsZW1lbnQsaWU9ZnVuY3Rpb24oZSl7cmV0dXJuIFMuY29udGFpbnMoZS5vd25lckRvY3VtZW50LGUpfSxvZT17Y29tcG9zZWQ6ITB9O3JlLmdldFJvb3ROb2RlJiYoaWU9ZnVuY3Rpb24oZSl7cmV0dXJuIFMuY29udGFpbnMoZS5vd25lckRvY3VtZW50LGUpfHxlLmdldFJvb3ROb2RlKG9lKT09PWUub3duZXJEb2N1bWVudH0pO3ZhciBhZT1mdW5jdGlvbihlLHQpe3JldHVyblwibm9uZVwiPT09KGU9dHx8ZSkuc3R5bGUuZGlzcGxheXx8XCJcIj09PWUuc3R5bGUuZGlzcGxheSYmaWUoZSkmJlwibm9uZVwiPT09Uy5jc3MoZSxcImRpc3BsYXlcIil9O2Z1bmN0aW9uIHNlKGUsdCxuLHIpe3ZhciBpLG8sYT0yMCxzPXI/ZnVuY3Rpb24oKXtyZXR1cm4gci5jdXIoKX06ZnVuY3Rpb24oKXtyZXR1cm4gUy5jc3MoZSx0LFwiXCIpfSx1PXMoKSxsPW4mJm5bM118fChTLmNzc051bWJlclt0XT9cIlwiOlwicHhcIiksYz1lLm5vZGVUeXBlJiYoUy5jc3NOdW1iZXJbdF18fFwicHhcIiE9PWwmJit1KSYmdGUuZXhlYyhTLmNzcyhlLHQpKTtpZihjJiZjWzNdIT09bCl7dS89MixsPWx8fGNbM10sYz0rdXx8MTt3aGlsZShhLS0pUy5zdHlsZShlLHQsYytsKSwoMS1vKSooMS0obz1zKCkvdXx8LjUpKTw9MCYmKGE9MCksYy89bztjKj0yLFMuc3R5bGUoZSx0LGMrbCksbj1ufHxbXX1yZXR1cm4gbiYmKGM9K2N8fCt1fHwwLGk9blsxXT9jKyhuWzFdKzEpKm5bMl06K25bMl0sciYmKHIudW5pdD1sLHIuc3RhcnQ9YyxyLmVuZD1pKSksaX12YXIgdWU9e307ZnVuY3Rpb24gbGUoZSx0KXtmb3IodmFyIG4scixpLG8sYSxzLHUsbD1bXSxjPTAsZj1lLmxlbmd0aDtjPGY7YysrKShyPWVbY10pLnN0eWxlJiYobj1yLnN0eWxlLmRpc3BsYXksdD8oXCJub25lXCI9PT1uJiYobFtjXT1ZLmdldChyLFwiZGlzcGxheVwiKXx8bnVsbCxsW2NdfHwoci5zdHlsZS5kaXNwbGF5PVwiXCIpKSxcIlwiPT09ci5zdHlsZS5kaXNwbGF5JiZhZShyKSYmKGxbY109KHU9YT1vPXZvaWQgMCxhPShpPXIpLm93bmVyRG9jdW1lbnQscz1pLm5vZGVOYW1lLCh1PXVlW3NdKXx8KG89YS5ib2R5LmFwcGVuZENoaWxkKGEuY3JlYXRlRWxlbWVudChzKSksdT1TLmNzcyhvLFwiZGlzcGxheVwiKSxvLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobyksXCJub25lXCI9PT11JiYodT1cImJsb2NrXCIpLHVlW3NdPXUpKSkpOlwibm9uZVwiIT09biYmKGxbY109XCJub25lXCIsWS5zZXQocixcImRpc3BsYXlcIixuKSkpO2ZvcihjPTA7YzxmO2MrKyludWxsIT1sW2NdJiYoZVtjXS5zdHlsZS5kaXNwbGF5PWxbY10pO3JldHVybiBlfVMuZm4uZXh0ZW5kKHtzaG93OmZ1bmN0aW9uKCl7cmV0dXJuIGxlKHRoaXMsITApfSxoaWRlOmZ1bmN0aW9uKCl7cmV0dXJuIGxlKHRoaXMpfSx0b2dnbGU6ZnVuY3Rpb24oZSl7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiBlP2U/dGhpcy5zaG93KCk6dGhpcy5oaWRlKCk6dGhpcy5lYWNoKGZ1bmN0aW9uKCl7YWUodGhpcyk/Uyh0aGlzKS5zaG93KCk6Uyh0aGlzKS5oaWRlKCl9KX19KTt2YXIgY2UsZmUscGU9L14oPzpjaGVja2JveHxyYWRpbykkL2ksZGU9LzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKS9pLGhlPS9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2k7Y2U9RS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkuYXBwZW5kQ2hpbGQoRS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSwoZmU9RS5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIikpLnNldEF0dHJpYnV0ZShcInR5cGVcIixcInJhZGlvXCIpLGZlLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIixcImNoZWNrZWRcIiksZmUuc2V0QXR0cmlidXRlKFwibmFtZVwiLFwidFwiKSxjZS5hcHBlbmRDaGlsZChmZSksdi5jaGVja0Nsb25lPWNlLmNsb25lTm9kZSghMCkuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuY2hlY2tlZCxjZS5pbm5lckhUTUw9XCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCIsdi5ub0Nsb25lQ2hlY2tlZD0hIWNlLmNsb25lTm9kZSghMCkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZSxjZS5pbm5lckhUTUw9XCI8b3B0aW9uPjwvb3B0aW9uPlwiLHYub3B0aW9uPSEhY2UubGFzdENoaWxkO3ZhciBnZT17dGhlYWQ6WzEsXCI8dGFibGU+XCIsXCI8L3RhYmxlPlwiXSxjb2w6WzIsXCI8dGFibGU+PGNvbGdyb3VwPlwiLFwiPC9jb2xncm91cD48L3RhYmxlPlwiXSx0cjpbMixcIjx0YWJsZT48dGJvZHk+XCIsXCI8L3Rib2R5PjwvdGFibGU+XCJdLHRkOlszLFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIl0sX2RlZmF1bHQ6WzAsXCJcIixcIlwiXX07ZnVuY3Rpb24geWUoZSx0KXt2YXIgbjtyZXR1cm4gbj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZS5nZXRFbGVtZW50c0J5VGFnTmFtZT9lLmdldEVsZW1lbnRzQnlUYWdOYW1lKHR8fFwiKlwiKTpcInVuZGVmaW5lZFwiIT10eXBlb2YgZS5xdWVyeVNlbGVjdG9yQWxsP2UucXVlcnlTZWxlY3RvckFsbCh0fHxcIipcIik6W10sdm9pZCAwPT09dHx8dCYmQShlLHQpP1MubWVyZ2UoW2VdLG4pOm59ZnVuY3Rpb24gdmUoZSx0KXtmb3IodmFyIG49MCxyPWUubGVuZ3RoO248cjtuKyspWS5zZXQoZVtuXSxcImdsb2JhbEV2YWxcIiwhdHx8WS5nZXQodFtuXSxcImdsb2JhbEV2YWxcIikpfWdlLnRib2R5PWdlLnRmb290PWdlLmNvbGdyb3VwPWdlLmNhcHRpb249Z2UudGhlYWQsZ2UudGg9Z2UudGQsdi5vcHRpb258fChnZS5vcHRncm91cD1nZS5vcHRpb249WzEsXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsXCI8L3NlbGVjdD5cIl0pO3ZhciBtZT0vPHwmIz9cXHcrOy87ZnVuY3Rpb24geGUoZSx0LG4scixpKXtmb3IodmFyIG8sYSxzLHUsbCxjLGY9dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkscD1bXSxkPTAsaD1lLmxlbmd0aDtkPGg7ZCsrKWlmKChvPWVbZF0pfHwwPT09bylpZihcIm9iamVjdFwiPT09dyhvKSlTLm1lcmdlKHAsby5ub2RlVHlwZT9bb106byk7ZWxzZSBpZihtZS50ZXN0KG8pKXthPWF8fGYuYXBwZW5kQ2hpbGQodC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSxzPShkZS5leGVjKG8pfHxbXCJcIixcIlwiXSlbMV0udG9Mb3dlckNhc2UoKSx1PWdlW3NdfHxnZS5fZGVmYXVsdCxhLmlubmVySFRNTD11WzFdK1MuaHRtbFByZWZpbHRlcihvKSt1WzJdLGM9dVswXTt3aGlsZShjLS0pYT1hLmxhc3RDaGlsZDtTLm1lcmdlKHAsYS5jaGlsZE5vZGVzKSwoYT1mLmZpcnN0Q2hpbGQpLnRleHRDb250ZW50PVwiXCJ9ZWxzZSBwLnB1c2godC5jcmVhdGVUZXh0Tm9kZShvKSk7Zi50ZXh0Q29udGVudD1cIlwiLGQ9MDt3aGlsZShvPXBbZCsrXSlpZihyJiYtMTxTLmluQXJyYXkobyxyKSlpJiZpLnB1c2gobyk7ZWxzZSBpZihsPWllKG8pLGE9eWUoZi5hcHBlbmRDaGlsZChvKSxcInNjcmlwdFwiKSxsJiZ2ZShhKSxuKXtjPTA7d2hpbGUobz1hW2MrK10paGUudGVzdChvLnR5cGV8fFwiXCIpJiZuLnB1c2gobyl9cmV0dXJuIGZ9dmFyIGJlPS9eKFteLl0qKSg/OlxcLiguKyl8KS87ZnVuY3Rpb24gd2UoKXtyZXR1cm4hMH1mdW5jdGlvbiBUZSgpe3JldHVybiExfWZ1bmN0aW9uIENlKGUsdCl7cmV0dXJuIGU9PT1mdW5jdGlvbigpe3RyeXtyZXR1cm4gRS5hY3RpdmVFbGVtZW50fWNhdGNoKGUpe319KCk9PShcImZvY3VzXCI9PT10KX1mdW5jdGlvbiBFZShlLHQsbixyLGksbyl7dmFyIGEscztpZihcIm9iamVjdFwiPT10eXBlb2YgdCl7Zm9yKHMgaW5cInN0cmluZ1wiIT10eXBlb2YgbiYmKHI9cnx8bixuPXZvaWQgMCksdClFZShlLHMsbixyLHRbc10sbyk7cmV0dXJuIGV9aWYobnVsbD09ciYmbnVsbD09aT8oaT1uLHI9bj12b2lkIDApOm51bGw9PWkmJihcInN0cmluZ1wiPT10eXBlb2Ygbj8oaT1yLHI9dm9pZCAwKTooaT1yLHI9bixuPXZvaWQgMCkpLCExPT09aSlpPVRlO2Vsc2UgaWYoIWkpcmV0dXJuIGU7cmV0dXJuIDE9PT1vJiYoYT1pLChpPWZ1bmN0aW9uKGUpe3JldHVybiBTKCkub2ZmKGUpLGEuYXBwbHkodGhpcyxhcmd1bWVudHMpfSkuZ3VpZD1hLmd1aWR8fChhLmd1aWQ9Uy5ndWlkKyspKSxlLmVhY2goZnVuY3Rpb24oKXtTLmV2ZW50LmFkZCh0aGlzLHQsaSxyLG4pfSl9ZnVuY3Rpb24gU2UoZSxpLG8pe28/KFkuc2V0KGUsaSwhMSksUy5ldmVudC5hZGQoZSxpLHtuYW1lc3BhY2U6ITEsaGFuZGxlcjpmdW5jdGlvbihlKXt2YXIgdCxuLHI9WS5nZXQodGhpcyxpKTtpZigxJmUuaXNUcmlnZ2VyJiZ0aGlzW2ldKXtpZihyLmxlbmd0aCkoUy5ldmVudC5zcGVjaWFsW2ldfHx7fSkuZGVsZWdhdGVUeXBlJiZlLnN0b3BQcm9wYWdhdGlvbigpO2Vsc2UgaWYocj1zLmNhbGwoYXJndW1lbnRzKSxZLnNldCh0aGlzLGksciksdD1vKHRoaXMsaSksdGhpc1tpXSgpLHIhPT0obj1ZLmdldCh0aGlzLGkpKXx8dD9ZLnNldCh0aGlzLGksITEpOm49e30sciE9PW4pcmV0dXJuIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksZS5wcmV2ZW50RGVmYXVsdCgpLG4mJm4udmFsdWV9ZWxzZSByLmxlbmd0aCYmKFkuc2V0KHRoaXMsaSx7dmFsdWU6Uy5ldmVudC50cmlnZ2VyKFMuZXh0ZW5kKHJbMF0sUy5FdmVudC5wcm90b3R5cGUpLHIuc2xpY2UoMSksdGhpcyl9KSxlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpKX19KSk6dm9pZCAwPT09WS5nZXQoZSxpKSYmUy5ldmVudC5hZGQoZSxpLHdlKX1TLmV2ZW50PXtnbG9iYWw6e30sYWRkOmZ1bmN0aW9uKHQsZSxuLHIsaSl7dmFyIG8sYSxzLHUsbCxjLGYscCxkLGgsZyx5PVkuZ2V0KHQpO2lmKFYodCkpe24uaGFuZGxlciYmKG49KG89bikuaGFuZGxlcixpPW8uc2VsZWN0b3IpLGkmJlMuZmluZC5tYXRjaGVzU2VsZWN0b3IocmUsaSksbi5ndWlkfHwobi5ndWlkPVMuZ3VpZCsrKSwodT15LmV2ZW50cyl8fCh1PXkuZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCkpLChhPXkuaGFuZGxlKXx8KGE9eS5oYW5kbGU9ZnVuY3Rpb24oZSl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFMmJlMuZXZlbnQudHJpZ2dlcmVkIT09ZS50eXBlP1MuZXZlbnQuZGlzcGF0Y2guYXBwbHkodCxhcmd1bWVudHMpOnZvaWQgMH0pLGw9KGU9KGV8fFwiXCIpLm1hdGNoKFApfHxbXCJcIl0pLmxlbmd0aDt3aGlsZShsLS0pZD1nPShzPWJlLmV4ZWMoZVtsXSl8fFtdKVsxXSxoPShzWzJdfHxcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLGQmJihmPVMuZXZlbnQuc3BlY2lhbFtkXXx8e30sZD0oaT9mLmRlbGVnYXRlVHlwZTpmLmJpbmRUeXBlKXx8ZCxmPVMuZXZlbnQuc3BlY2lhbFtkXXx8e30sYz1TLmV4dGVuZCh7dHlwZTpkLG9yaWdUeXBlOmcsZGF0YTpyLGhhbmRsZXI6bixndWlkOm4uZ3VpZCxzZWxlY3RvcjppLG5lZWRzQ29udGV4dDppJiZTLmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoaSksbmFtZXNwYWNlOmguam9pbihcIi5cIil9LG8pLChwPXVbZF0pfHwoKHA9dVtkXT1bXSkuZGVsZWdhdGVDb3VudD0wLGYuc2V0dXAmJiExIT09Zi5zZXR1cC5jYWxsKHQscixoLGEpfHx0LmFkZEV2ZW50TGlzdGVuZXImJnQuYWRkRXZlbnRMaXN0ZW5lcihkLGEpKSxmLmFkZCYmKGYuYWRkLmNhbGwodCxjKSxjLmhhbmRsZXIuZ3VpZHx8KGMuaGFuZGxlci5ndWlkPW4uZ3VpZCkpLGk/cC5zcGxpY2UocC5kZWxlZ2F0ZUNvdW50KyssMCxjKTpwLnB1c2goYyksUy5ldmVudC5nbG9iYWxbZF09ITApfX0scmVtb3ZlOmZ1bmN0aW9uKGUsdCxuLHIsaSl7dmFyIG8sYSxzLHUsbCxjLGYscCxkLGgsZyx5PVkuaGFzRGF0YShlKSYmWS5nZXQoZSk7aWYoeSYmKHU9eS5ldmVudHMpKXtsPSh0PSh0fHxcIlwiKS5tYXRjaChQKXx8W1wiXCJdKS5sZW5ndGg7d2hpbGUobC0tKWlmKGQ9Zz0ocz1iZS5leGVjKHRbbF0pfHxbXSlbMV0saD0oc1syXXx8XCJcIikuc3BsaXQoXCIuXCIpLnNvcnQoKSxkKXtmPVMuZXZlbnQuc3BlY2lhbFtkXXx8e30scD11W2Q9KHI/Zi5kZWxlZ2F0ZVR5cGU6Zi5iaW5kVHlwZSl8fGRdfHxbXSxzPXNbMl0mJm5ldyBSZWdFeHAoXCIoXnxcXFxcLilcIitoLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKStcIihcXFxcLnwkKVwiKSxhPW89cC5sZW5ndGg7d2hpbGUoby0tKWM9cFtvXSwhaSYmZyE9PWMub3JpZ1R5cGV8fG4mJm4uZ3VpZCE9PWMuZ3VpZHx8cyYmIXMudGVzdChjLm5hbWVzcGFjZSl8fHImJnIhPT1jLnNlbGVjdG9yJiYoXCIqKlwiIT09cnx8IWMuc2VsZWN0b3IpfHwocC5zcGxpY2UobywxKSxjLnNlbGVjdG9yJiZwLmRlbGVnYXRlQ291bnQtLSxmLnJlbW92ZSYmZi5yZW1vdmUuY2FsbChlLGMpKTthJiYhcC5sZW5ndGgmJihmLnRlYXJkb3duJiYhMSE9PWYudGVhcmRvd24uY2FsbChlLGgseS5oYW5kbGUpfHxTLnJlbW92ZUV2ZW50KGUsZCx5LmhhbmRsZSksZGVsZXRlIHVbZF0pfWVsc2UgZm9yKGQgaW4gdSlTLmV2ZW50LnJlbW92ZShlLGQrdFtsXSxuLHIsITApO1MuaXNFbXB0eU9iamVjdCh1KSYmWS5yZW1vdmUoZSxcImhhbmRsZSBldmVudHNcIil9fSxkaXNwYXRjaDpmdW5jdGlvbihlKXt2YXIgdCxuLHIsaSxvLGEscz1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCksdT1TLmV2ZW50LmZpeChlKSxsPShZLmdldCh0aGlzLFwiZXZlbnRzXCIpfHxPYmplY3QuY3JlYXRlKG51bGwpKVt1LnR5cGVdfHxbXSxjPVMuZXZlbnQuc3BlY2lhbFt1LnR5cGVdfHx7fTtmb3Ioc1swXT11LHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXNbdF09YXJndW1lbnRzW3RdO2lmKHUuZGVsZWdhdGVUYXJnZXQ9dGhpcywhYy5wcmVEaXNwYXRjaHx8ITEhPT1jLnByZURpc3BhdGNoLmNhbGwodGhpcyx1KSl7YT1TLmV2ZW50LmhhbmRsZXJzLmNhbGwodGhpcyx1LGwpLHQ9MDt3aGlsZSgoaT1hW3QrK10pJiYhdS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKXt1LmN1cnJlbnRUYXJnZXQ9aS5lbGVtLG49MDt3aGlsZSgobz1pLmhhbmRsZXJzW24rK10pJiYhdS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKXUucm5hbWVzcGFjZSYmITEhPT1vLm5hbWVzcGFjZSYmIXUucm5hbWVzcGFjZS50ZXN0KG8ubmFtZXNwYWNlKXx8KHUuaGFuZGxlT2JqPW8sdS5kYXRhPW8uZGF0YSx2b2lkIDAhPT0ocj0oKFMuZXZlbnQuc3BlY2lhbFtvLm9yaWdUeXBlXXx8e30pLmhhbmRsZXx8by5oYW5kbGVyKS5hcHBseShpLmVsZW0scykpJiYhMT09PSh1LnJlc3VsdD1yKSYmKHUucHJldmVudERlZmF1bHQoKSx1LnN0b3BQcm9wYWdhdGlvbigpKSl9cmV0dXJuIGMucG9zdERpc3BhdGNoJiZjLnBvc3REaXNwYXRjaC5jYWxsKHRoaXMsdSksdS5yZXN1bHR9fSxoYW5kbGVyczpmdW5jdGlvbihlLHQpe3ZhciBuLHIsaSxvLGEscz1bXSx1PXQuZGVsZWdhdGVDb3VudCxsPWUudGFyZ2V0O2lmKHUmJmwubm9kZVR5cGUmJiEoXCJjbGlja1wiPT09ZS50eXBlJiYxPD1lLmJ1dHRvbikpZm9yKDtsIT09dGhpcztsPWwucGFyZW50Tm9kZXx8dGhpcylpZigxPT09bC5ub2RlVHlwZSYmKFwiY2xpY2tcIiE9PWUudHlwZXx8ITAhPT1sLmRpc2FibGVkKSl7Zm9yKG89W10sYT17fSxuPTA7bjx1O24rKyl2b2lkIDA9PT1hW2k9KHI9dFtuXSkuc2VsZWN0b3IrXCIgXCJdJiYoYVtpXT1yLm5lZWRzQ29udGV4dD8tMTxTKGksdGhpcykuaW5kZXgobCk6Uy5maW5kKGksdGhpcyxudWxsLFtsXSkubGVuZ3RoKSxhW2ldJiZvLnB1c2gocik7by5sZW5ndGgmJnMucHVzaCh7ZWxlbTpsLGhhbmRsZXJzOm99KX1yZXR1cm4gbD10aGlzLHU8dC5sZW5ndGgmJnMucHVzaCh7ZWxlbTpsLGhhbmRsZXJzOnQuc2xpY2UodSl9KSxzfSxhZGRQcm9wOmZ1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KFMuRXZlbnQucHJvdG90eXBlLHQse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDptKGUpP2Z1bmN0aW9uKCl7aWYodGhpcy5vcmlnaW5hbEV2ZW50KXJldHVybiBlKHRoaXMub3JpZ2luYWxFdmVudCl9OmZ1bmN0aW9uKCl7aWYodGhpcy5vcmlnaW5hbEV2ZW50KXJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbdF19LHNldDpmdW5jdGlvbihlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyx0LHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTplfSl9fSl9LGZpeDpmdW5jdGlvbihlKXtyZXR1cm4gZVtTLmV4cGFuZG9dP2U6bmV3IFMuRXZlbnQoZSl9LHNwZWNpYWw6e2xvYWQ6e25vQnViYmxlOiEwfSxjbGljazp7c2V0dXA6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpc3x8ZTtyZXR1cm4gcGUudGVzdCh0LnR5cGUpJiZ0LmNsaWNrJiZBKHQsXCJpbnB1dFwiKSYmU2UodCxcImNsaWNrXCIsd2UpLCExfSx0cmlnZ2VyOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXN8fGU7cmV0dXJuIHBlLnRlc3QodC50eXBlKSYmdC5jbGljayYmQSh0LFwiaW5wdXRcIikmJlNlKHQsXCJjbGlja1wiKSwhMH0sX2RlZmF1bHQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS50YXJnZXQ7cmV0dXJuIHBlLnRlc3QodC50eXBlKSYmdC5jbGljayYmQSh0LFwiaW5wdXRcIikmJlkuZ2V0KHQsXCJjbGlja1wiKXx8QSh0LFwiYVwiKX19LGJlZm9yZXVubG9hZDp7cG9zdERpc3BhdGNoOmZ1bmN0aW9uKGUpe3ZvaWQgMCE9PWUucmVzdWx0JiZlLm9yaWdpbmFsRXZlbnQmJihlLm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWU9ZS5yZXN1bHQpfX19fSxTLnJlbW92ZUV2ZW50PWZ1bmN0aW9uKGUsdCxuKXtlLnJlbW92ZUV2ZW50TGlzdGVuZXImJmUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LG4pfSxTLkV2ZW50PWZ1bmN0aW9uKGUsdCl7aWYoISh0aGlzIGluc3RhbmNlb2YgUy5FdmVudCkpcmV0dXJuIG5ldyBTLkV2ZW50KGUsdCk7ZSYmZS50eXBlPyh0aGlzLm9yaWdpbmFsRXZlbnQ9ZSx0aGlzLnR5cGU9ZS50eXBlLHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPWUuZGVmYXVsdFByZXZlbnRlZHx8dm9pZCAwPT09ZS5kZWZhdWx0UHJldmVudGVkJiYhMT09PWUucmV0dXJuVmFsdWU/d2U6VGUsdGhpcy50YXJnZXQ9ZS50YXJnZXQmJjM9PT1lLnRhcmdldC5ub2RlVHlwZT9lLnRhcmdldC5wYXJlbnROb2RlOmUudGFyZ2V0LHRoaXMuY3VycmVudFRhcmdldD1lLmN1cnJlbnRUYXJnZXQsdGhpcy5yZWxhdGVkVGFyZ2V0PWUucmVsYXRlZFRhcmdldCk6dGhpcy50eXBlPWUsdCYmUy5leHRlbmQodGhpcyx0KSx0aGlzLnRpbWVTdGFtcD1lJiZlLnRpbWVTdGFtcHx8RGF0ZS5ub3coKSx0aGlzW1MuZXhwYW5kb109ITB9LFMuRXZlbnQucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpTLkV2ZW50LGlzRGVmYXVsdFByZXZlbnRlZDpUZSxpc1Byb3BhZ2F0aW9uU3RvcHBlZDpUZSxpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDpUZSxpc1NpbXVsYXRlZDohMSxwcmV2ZW50RGVmYXVsdDpmdW5jdGlvbigpe3ZhciBlPXRoaXMub3JpZ2luYWxFdmVudDt0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD13ZSxlJiYhdGhpcy5pc1NpbXVsYXRlZCYmZS5wcmV2ZW50RGVmYXVsdCgpfSxzdG9wUHJvcGFnYXRpb246ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm9yaWdpbmFsRXZlbnQ7dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD13ZSxlJiYhdGhpcy5pc1NpbXVsYXRlZCYmZS5zdG9wUHJvcGFnYXRpb24oKX0sc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5vcmlnaW5hbEV2ZW50O3RoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ9d2UsZSYmIXRoaXMuaXNTaW11bGF0ZWQmJmUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksdGhpcy5zdG9wUHJvcGFnYXRpb24oKX19LFMuZWFjaCh7YWx0S2V5OiEwLGJ1YmJsZXM6ITAsY2FuY2VsYWJsZTohMCxjaGFuZ2VkVG91Y2hlczohMCxjdHJsS2V5OiEwLGRldGFpbDohMCxldmVudFBoYXNlOiEwLG1ldGFLZXk6ITAscGFnZVg6ITAscGFnZVk6ITAsc2hpZnRLZXk6ITAsdmlldzohMCxcImNoYXJcIjohMCxjb2RlOiEwLGNoYXJDb2RlOiEwLGtleTohMCxrZXlDb2RlOiEwLGJ1dHRvbjohMCxidXR0b25zOiEwLGNsaWVudFg6ITAsY2xpZW50WTohMCxvZmZzZXRYOiEwLG9mZnNldFk6ITAscG9pbnRlcklkOiEwLHBvaW50ZXJUeXBlOiEwLHNjcmVlblg6ITAsc2NyZWVuWTohMCx0YXJnZXRUb3VjaGVzOiEwLHRvRWxlbWVudDohMCx0b3VjaGVzOiEwLHdoaWNoOiEwfSxTLmV2ZW50LmFkZFByb3ApLFMuZWFjaCh7Zm9jdXM6XCJmb2N1c2luXCIsYmx1cjpcImZvY3Vzb3V0XCJ9LGZ1bmN0aW9uKHQsZSl7Uy5ldmVudC5zcGVjaWFsW3RdPXtzZXR1cDpmdW5jdGlvbigpe3JldHVybiBTZSh0aGlzLHQsQ2UpLCExfSx0cmlnZ2VyOmZ1bmN0aW9uKCl7cmV0dXJuIFNlKHRoaXMsdCksITB9LF9kZWZhdWx0OmZ1bmN0aW9uKGUpe3JldHVybiBZLmdldChlLnRhcmdldCx0KX0sZGVsZWdhdGVUeXBlOmV9fSksUy5lYWNoKHttb3VzZWVudGVyOlwibW91c2VvdmVyXCIsbW91c2VsZWF2ZTpcIm1vdXNlb3V0XCIscG9pbnRlcmVudGVyOlwicG9pbnRlcm92ZXJcIixwb2ludGVybGVhdmU6XCJwb2ludGVyb3V0XCJ9LGZ1bmN0aW9uKGUsaSl7Uy5ldmVudC5zcGVjaWFsW2VdPXtkZWxlZ2F0ZVR5cGU6aSxiaW5kVHlwZTppLGhhbmRsZTpmdW5jdGlvbihlKXt2YXIgdCxuPWUucmVsYXRlZFRhcmdldCxyPWUuaGFuZGxlT2JqO3JldHVybiBuJiYobj09PXRoaXN8fFMuY29udGFpbnModGhpcyxuKSl8fChlLnR5cGU9ci5vcmlnVHlwZSx0PXIuaGFuZGxlci5hcHBseSh0aGlzLGFyZ3VtZW50cyksZS50eXBlPWkpLHR9fX0pLFMuZm4uZXh0ZW5kKHtvbjpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gRWUodGhpcyxlLHQsbixyKX0sb25lOmZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiBFZSh0aGlzLGUsdCxuLHIsMSl9LG9mZjpmdW5jdGlvbihlLHQsbil7dmFyIHIsaTtpZihlJiZlLnByZXZlbnREZWZhdWx0JiZlLmhhbmRsZU9iailyZXR1cm4gcj1lLmhhbmRsZU9iaixTKGUuZGVsZWdhdGVUYXJnZXQpLm9mZihyLm5hbWVzcGFjZT9yLm9yaWdUeXBlK1wiLlwiK3IubmFtZXNwYWNlOnIub3JpZ1R5cGUsci5zZWxlY3RvcixyLmhhbmRsZXIpLHRoaXM7aWYoXCJvYmplY3RcIj09dHlwZW9mIGUpe2ZvcihpIGluIGUpdGhpcy5vZmYoaSx0LGVbaV0pO3JldHVybiB0aGlzfXJldHVybiExIT09dCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdHx8KG49dCx0PXZvaWQgMCksITE9PT1uJiYobj1UZSksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7Uy5ldmVudC5yZW1vdmUodGhpcyxlLG4sdCl9KX19KTt2YXIga2U9LzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksQWU9L2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxOZT0vXlxccyo8IVxcW0NEQVRBXFxbfFxcXVxcXT5cXHMqJC9nO2Z1bmN0aW9uIGplKGUsdCl7cmV0dXJuIEEoZSxcInRhYmxlXCIpJiZBKDExIT09dC5ub2RlVHlwZT90OnQuZmlyc3RDaGlsZCxcInRyXCIpJiZTKGUpLmNoaWxkcmVuKFwidGJvZHlcIilbMF18fGV9ZnVuY3Rpb24gRGUoZSl7cmV0dXJuIGUudHlwZT0obnVsbCE9PWUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkrXCIvXCIrZS50eXBlLGV9ZnVuY3Rpb24gcWUoZSl7cmV0dXJuXCJ0cnVlL1wiPT09KGUudHlwZXx8XCJcIikuc2xpY2UoMCw1KT9lLnR5cGU9ZS50eXBlLnNsaWNlKDUpOmUucmVtb3ZlQXR0cmlidXRlKFwidHlwZVwiKSxlfWZ1bmN0aW9uIExlKGUsdCl7dmFyIG4scixpLG8sYSxzO2lmKDE9PT10Lm5vZGVUeXBlKXtpZihZLmhhc0RhdGEoZSkmJihzPVkuZ2V0KGUpLmV2ZW50cykpZm9yKGkgaW4gWS5yZW1vdmUodCxcImhhbmRsZSBldmVudHNcIikscylmb3Iobj0wLHI9c1tpXS5sZW5ndGg7bjxyO24rKylTLmV2ZW50LmFkZCh0LGksc1tpXVtuXSk7US5oYXNEYXRhKGUpJiYobz1RLmFjY2VzcyhlKSxhPVMuZXh0ZW5kKHt9LG8pLFEuc2V0KHQsYSkpfX1mdW5jdGlvbiBIZShuLHIsaSxvKXtyPWcocik7dmFyIGUsdCxhLHMsdSxsLGM9MCxmPW4ubGVuZ3RoLHA9Zi0xLGQ9clswXSxoPW0oZCk7aWYoaHx8MTxmJiZcInN0cmluZ1wiPT10eXBlb2YgZCYmIXYuY2hlY2tDbG9uZSYmQWUudGVzdChkKSlyZXR1cm4gbi5lYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PW4uZXEoZSk7aCYmKHJbMF09ZC5jYWxsKHRoaXMsZSx0Lmh0bWwoKSkpLEhlKHQscixpLG8pfSk7aWYoZiYmKHQ9KGU9eGUocixuWzBdLm93bmVyRG9jdW1lbnQsITEsbixvKSkuZmlyc3RDaGlsZCwxPT09ZS5jaGlsZE5vZGVzLmxlbmd0aCYmKGU9dCksdHx8bykpe2ZvcihzPShhPVMubWFwKHllKGUsXCJzY3JpcHRcIiksRGUpKS5sZW5ndGg7YzxmO2MrKyl1PWUsYyE9PXAmJih1PVMuY2xvbmUodSwhMCwhMCkscyYmUy5tZXJnZShhLHllKHUsXCJzY3JpcHRcIikpKSxpLmNhbGwobltjXSx1LGMpO2lmKHMpZm9yKGw9YVthLmxlbmd0aC0xXS5vd25lckRvY3VtZW50LFMubWFwKGEscWUpLGM9MDtjPHM7YysrKXU9YVtjXSxoZS50ZXN0KHUudHlwZXx8XCJcIikmJiFZLmFjY2Vzcyh1LFwiZ2xvYmFsRXZhbFwiKSYmUy5jb250YWlucyhsLHUpJiYodS5zcmMmJlwibW9kdWxlXCIhPT0odS50eXBlfHxcIlwiKS50b0xvd2VyQ2FzZSgpP1MuX2V2YWxVcmwmJiF1Lm5vTW9kdWxlJiZTLl9ldmFsVXJsKHUuc3JjLHtub25jZTp1Lm5vbmNlfHx1LmdldEF0dHJpYnV0ZShcIm5vbmNlXCIpfSxsKTpiKHUudGV4dENvbnRlbnQucmVwbGFjZShOZSxcIlwiKSx1LGwpKX1yZXR1cm4gbn1mdW5jdGlvbiBPZShlLHQsbil7Zm9yKHZhciByLGk9dD9TLmZpbHRlcih0LGUpOmUsbz0wO251bGwhPShyPWlbb10pO28rKylufHwxIT09ci5ub2RlVHlwZXx8Uy5jbGVhbkRhdGEoeWUocikpLHIucGFyZW50Tm9kZSYmKG4mJmllKHIpJiZ2ZSh5ZShyLFwic2NyaXB0XCIpKSxyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocikpO3JldHVybiBlfVMuZXh0ZW5kKHtodG1sUHJlZmlsdGVyOmZ1bmN0aW9uKGUpe3JldHVybiBlfSxjbG9uZTpmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvLGEscyx1LGwsYz1lLmNsb25lTm9kZSghMCksZj1pZShlKTtpZighKHYubm9DbG9uZUNoZWNrZWR8fDEhPT1lLm5vZGVUeXBlJiYxMSE9PWUubm9kZVR5cGV8fFMuaXNYTUxEb2MoZSkpKWZvcihhPXllKGMpLHI9MCxpPShvPXllKGUpKS5sZW5ndGg7cjxpO3IrKylzPW9bcl0sdT1hW3JdLHZvaWQgMCxcImlucHV0XCI9PT0obD11Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpJiZwZS50ZXN0KHMudHlwZSk/dS5jaGVja2VkPXMuY2hlY2tlZDpcImlucHV0XCIhPT1sJiZcInRleHRhcmVhXCIhPT1sfHwodS5kZWZhdWx0VmFsdWU9cy5kZWZhdWx0VmFsdWUpO2lmKHQpaWYobilmb3Iobz1vfHx5ZShlKSxhPWF8fHllKGMpLHI9MCxpPW8ubGVuZ3RoO3I8aTtyKyspTGUob1tyXSxhW3JdKTtlbHNlIExlKGUsYyk7cmV0dXJuIDA8KGE9eWUoYyxcInNjcmlwdFwiKSkubGVuZ3RoJiZ2ZShhLCFmJiZ5ZShlLFwic2NyaXB0XCIpKSxjfSxjbGVhbkRhdGE6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0LG4scixpPVMuZXZlbnQuc3BlY2lhbCxvPTA7dm9pZCAwIT09KG49ZVtvXSk7bysrKWlmKFYobikpe2lmKHQ9bltZLmV4cGFuZG9dKXtpZih0LmV2ZW50cylmb3IociBpbiB0LmV2ZW50cylpW3JdP1MuZXZlbnQucmVtb3ZlKG4scik6Uy5yZW1vdmVFdmVudChuLHIsdC5oYW5kbGUpO25bWS5leHBhbmRvXT12b2lkIDB9bltRLmV4cGFuZG9dJiYobltRLmV4cGFuZG9dPXZvaWQgMCl9fX0pLFMuZm4uZXh0ZW5kKHtkZXRhY2g6ZnVuY3Rpb24oZSl7cmV0dXJuIE9lKHRoaXMsZSwhMCl9LHJlbW92ZTpmdW5jdGlvbihlKXtyZXR1cm4gT2UodGhpcyxlKX0sdGV4dDpmdW5jdGlvbihlKXtyZXR1cm4gQih0aGlzLGZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lP1MudGV4dCh0aGlzKTp0aGlzLmVtcHR5KCkuZWFjaChmdW5jdGlvbigpezEhPT10aGlzLm5vZGVUeXBlJiYxMSE9PXRoaXMubm9kZVR5cGUmJjkhPT10aGlzLm5vZGVUeXBlfHwodGhpcy50ZXh0Q29udGVudD1lKX0pfSxudWxsLGUsYXJndW1lbnRzLmxlbmd0aCl9LGFwcGVuZDpmdW5jdGlvbigpe3JldHVybiBIZSh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihlKXsxIT09dGhpcy5ub2RlVHlwZSYmMTEhPT10aGlzLm5vZGVUeXBlJiY5IT09dGhpcy5ub2RlVHlwZXx8amUodGhpcyxlKS5hcHBlbmRDaGlsZChlKX0pfSxwcmVwZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIEhlKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKGUpe2lmKDE9PT10aGlzLm5vZGVUeXBlfHwxMT09PXRoaXMubm9kZVR5cGV8fDk9PT10aGlzLm5vZGVUeXBlKXt2YXIgdD1qZSh0aGlzLGUpO3QuaW5zZXJ0QmVmb3JlKGUsdC5maXJzdENoaWxkKX19KX0sYmVmb3JlOmZ1bmN0aW9uKCl7cmV0dXJuIEhlKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKGUpe3RoaXMucGFyZW50Tm9kZSYmdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLHRoaXMpfSl9LGFmdGVyOmZ1bmN0aW9uKCl7cmV0dXJuIEhlKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKGUpe3RoaXMucGFyZW50Tm9kZSYmdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLHRoaXMubmV4dFNpYmxpbmcpfSl9LGVtcHR5OmZ1bmN0aW9uKCl7Zm9yKHZhciBlLHQ9MDtudWxsIT0oZT10aGlzW3RdKTt0KyspMT09PWUubm9kZVR5cGUmJihTLmNsZWFuRGF0YSh5ZShlLCExKSksZS50ZXh0Q29udGVudD1cIlwiKTtyZXR1cm4gdGhpc30sY2xvbmU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT1udWxsIT1lJiZlLHQ9bnVsbD09dD9lOnQsdGhpcy5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gUy5jbG9uZSh0aGlzLGUsdCl9KX0saHRtbDpmdW5jdGlvbihlKXtyZXR1cm4gQih0aGlzLGZ1bmN0aW9uKGUpe3ZhciB0PXRoaXNbMF18fHt9LG49MCxyPXRoaXMubGVuZ3RoO2lmKHZvaWQgMD09PWUmJjE9PT10Lm5vZGVUeXBlKXJldHVybiB0LmlubmVySFRNTDtpZihcInN0cmluZ1wiPT10eXBlb2YgZSYmIWtlLnRlc3QoZSkmJiFnZVsoZGUuZXhlYyhlKXx8W1wiXCIsXCJcIl0pWzFdLnRvTG93ZXJDYXNlKCldKXtlPVMuaHRtbFByZWZpbHRlcihlKTt0cnl7Zm9yKDtuPHI7bisrKTE9PT0odD10aGlzW25dfHx7fSkubm9kZVR5cGUmJihTLmNsZWFuRGF0YSh5ZSh0LCExKSksdC5pbm5lckhUTUw9ZSk7dD0wfWNhdGNoKGUpe319dCYmdGhpcy5lbXB0eSgpLmFwcGVuZChlKX0sbnVsbCxlLGFyZ3VtZW50cy5sZW5ndGgpfSxyZXBsYWNlV2l0aDpmdW5jdGlvbigpe3ZhciBuPVtdO3JldHVybiBIZSh0aGlzLGFyZ3VtZW50cyxmdW5jdGlvbihlKXt2YXIgdD10aGlzLnBhcmVudE5vZGU7Uy5pbkFycmF5KHRoaXMsbik8MCYmKFMuY2xlYW5EYXRhKHllKHRoaXMpKSx0JiZ0LnJlcGxhY2VDaGlsZChlLHRoaXMpKX0sbil9fSksUy5lYWNoKHthcHBlbmRUbzpcImFwcGVuZFwiLHByZXBlbmRUbzpcInByZXBlbmRcIixpbnNlcnRCZWZvcmU6XCJiZWZvcmVcIixpbnNlcnRBZnRlcjpcImFmdGVyXCIscmVwbGFjZUFsbDpcInJlcGxhY2VXaXRoXCJ9LGZ1bmN0aW9uKGUsYSl7Uy5mbltlXT1mdW5jdGlvbihlKXtmb3IodmFyIHQsbj1bXSxyPVMoZSksaT1yLmxlbmd0aC0xLG89MDtvPD1pO28rKyl0PW89PT1pP3RoaXM6dGhpcy5jbG9uZSghMCksUyhyW29dKVthXSh0KSx1LmFwcGx5KG4sdC5nZXQoKSk7cmV0dXJuIHRoaXMucHVzaFN0YWNrKG4pfX0pO3ZhciBQZT1uZXcgUmVnRXhwKFwiXihcIitlZStcIikoPyFweClbYS16JV0rJFwiLFwiaVwiKSxSZT0vXi0tLyxNZT1mdW5jdGlvbihlKXt2YXIgdD1lLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7cmV0dXJuIHQmJnQub3BlbmVyfHwodD1DKSx0LmdldENvbXB1dGVkU3R5bGUoZSl9LEllPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG89e307Zm9yKGkgaW4gdClvW2ldPWUuc3R5bGVbaV0sZS5zdHlsZVtpXT10W2ldO2ZvcihpIGluIHI9bi5jYWxsKGUpLHQpZS5zdHlsZVtpXT1vW2ldO3JldHVybiByfSxXZT1uZXcgUmVnRXhwKG5lLmpvaW4oXCJ8XCIpLFwiaVwiKSxGZT1cIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsJGU9bmV3IFJlZ0V4cChcIl5cIitGZStcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIrRmUrXCIrJFwiLFwiZ1wiKTtmdW5jdGlvbiBCZShlLHQsbil7dmFyIHIsaSxvLGEscz1SZS50ZXN0KHQpLHU9ZS5zdHlsZTtyZXR1cm4obj1ufHxNZShlKSkmJihhPW4uZ2V0UHJvcGVydHlWYWx1ZSh0KXx8blt0XSxzJiYoYT1hLnJlcGxhY2UoJGUsXCIkMVwiKSksXCJcIiE9PWF8fGllKGUpfHwoYT1TLnN0eWxlKGUsdCkpLCF2LnBpeGVsQm94U3R5bGVzKCkmJlBlLnRlc3QoYSkmJldlLnRlc3QodCkmJihyPXUud2lkdGgsaT11Lm1pbldpZHRoLG89dS5tYXhXaWR0aCx1Lm1pbldpZHRoPXUubWF4V2lkdGg9dS53aWR0aD1hLGE9bi53aWR0aCx1LndpZHRoPXIsdS5taW5XaWR0aD1pLHUubWF4V2lkdGg9bykpLHZvaWQgMCE9PWE/YStcIlwiOmF9ZnVuY3Rpb24gX2UoZSx0KXtyZXR1cm57Z2V0OmZ1bmN0aW9uKCl7aWYoIWUoKSlyZXR1cm4odGhpcy5nZXQ9dCkuYXBwbHkodGhpcyxhcmd1bWVudHMpO2RlbGV0ZSB0aGlzLmdldH19fSFmdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtpZihsKXt1LnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7bWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCIsbC5zdHlsZS5jc3NUZXh0PVwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6c2Nyb2xsO21hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7d2lkdGg6NjAlO3RvcDoxJVwiLHJlLmFwcGVuZENoaWxkKHUpLmFwcGVuZENoaWxkKGwpO3ZhciBlPUMuZ2V0Q29tcHV0ZWRTdHlsZShsKTtuPVwiMSVcIiE9PWUudG9wLHM9MTI9PT10KGUubWFyZ2luTGVmdCksbC5zdHlsZS5yaWdodD1cIjYwJVwiLG89MzY9PT10KGUucmlnaHQpLHI9MzY9PT10KGUud2lkdGgpLGwuc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLGk9MTI9PT10KGwub2Zmc2V0V2lkdGgvMykscmUucmVtb3ZlQ2hpbGQodSksbD1udWxsfX1mdW5jdGlvbiB0KGUpe3JldHVybiBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoZSkpfXZhciBuLHIsaSxvLGEscyx1PUUuY3JlYXRlRWxlbWVudChcImRpdlwiKSxsPUUuY3JlYXRlRWxlbWVudChcImRpdlwiKTtsLnN0eWxlJiYobC5zdHlsZS5iYWNrZ3JvdW5kQ2xpcD1cImNvbnRlbnQtYm94XCIsbC5jbG9uZU5vZGUoITApLnN0eWxlLmJhY2tncm91bmRDbGlwPVwiXCIsdi5jbGVhckNsb25lU3R5bGU9XCJjb250ZW50LWJveFwiPT09bC5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCxTLmV4dGVuZCh2LHtib3hTaXppbmdSZWxpYWJsZTpmdW5jdGlvbigpe3JldHVybiBlKCkscn0scGl4ZWxCb3hTdHlsZXM6ZnVuY3Rpb24oKXtyZXR1cm4gZSgpLG99LHBpeGVsUG9zaXRpb246ZnVuY3Rpb24oKXtyZXR1cm4gZSgpLG59LHJlbGlhYmxlTWFyZ2luTGVmdDpmdW5jdGlvbigpe3JldHVybiBlKCksc30sc2Nyb2xsYm94U2l6ZTpmdW5jdGlvbigpe3JldHVybiBlKCksaX0scmVsaWFibGVUckRpbWVuc2lvbnM6ZnVuY3Rpb24oKXt2YXIgZSx0LG4scjtyZXR1cm4gbnVsbD09YSYmKGU9RS5jcmVhdGVFbGVtZW50KFwidGFibGVcIiksdD1FLmNyZWF0ZUVsZW1lbnQoXCJ0clwiKSxuPUUuY3JlYXRlRWxlbWVudChcImRpdlwiKSxlLnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O2JvcmRlci1jb2xsYXBzZTpzZXBhcmF0ZVwiLHQuc3R5bGUuY3NzVGV4dD1cImJvcmRlcjoxcHggc29saWRcIix0LnN0eWxlLmhlaWdodD1cIjFweFwiLG4uc3R5bGUuaGVpZ2h0PVwiOXB4XCIsbi5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIixyZS5hcHBlbmRDaGlsZChlKS5hcHBlbmRDaGlsZCh0KS5hcHBlbmRDaGlsZChuKSxyPUMuZ2V0Q29tcHV0ZWRTdHlsZSh0KSxhPXBhcnNlSW50KHIuaGVpZ2h0LDEwKStwYXJzZUludChyLmJvcmRlclRvcFdpZHRoLDEwKStwYXJzZUludChyLmJvcmRlckJvdHRvbVdpZHRoLDEwKT09PXQub2Zmc2V0SGVpZ2h0LHJlLnJlbW92ZUNoaWxkKGUpKSxhfX0pKX0oKTt2YXIgemU9W1wiV2Via2l0XCIsXCJNb3pcIixcIm1zXCJdLFVlPUUuY3JlYXRlRWxlbWVudChcImRpdlwiKS5zdHlsZSxYZT17fTtmdW5jdGlvbiBWZShlKXt2YXIgdD1TLmNzc1Byb3BzW2VdfHxYZVtlXTtyZXR1cm4gdHx8KGUgaW4gVWU/ZTpYZVtlXT1mdW5jdGlvbihlKXt2YXIgdD1lWzBdLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSxuPXplLmxlbmd0aDt3aGlsZShuLS0paWYoKGU9emVbbl0rdClpbiBVZSlyZXR1cm4gZX0oZSl8fGUpfXZhciBHZT0vXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sWWU9e3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix2aXNpYmlsaXR5OlwiaGlkZGVuXCIsZGlzcGxheTpcImJsb2NrXCJ9LFFlPXtsZXR0ZXJTcGFjaW5nOlwiMFwiLGZvbnRXZWlnaHQ6XCI0MDBcIn07ZnVuY3Rpb24gSmUoZSx0LG4pe3ZhciByPXRlLmV4ZWModCk7cmV0dXJuIHI/TWF0aC5tYXgoMCxyWzJdLShufHwwKSkrKHJbM118fFwicHhcIik6dH1mdW5jdGlvbiBLZShlLHQsbixyLGksbyl7dmFyIGE9XCJ3aWR0aFwiPT09dD8xOjAscz0wLHU9MDtpZihuPT09KHI/XCJib3JkZXJcIjpcImNvbnRlbnRcIikpcmV0dXJuIDA7Zm9yKDthPDQ7YSs9MilcIm1hcmdpblwiPT09biYmKHUrPVMuY3NzKGUsbituZVthXSwhMCxpKSkscj8oXCJjb250ZW50XCI9PT1uJiYodS09Uy5jc3MoZSxcInBhZGRpbmdcIituZVthXSwhMCxpKSksXCJtYXJnaW5cIiE9PW4mJih1LT1TLmNzcyhlLFwiYm9yZGVyXCIrbmVbYV0rXCJXaWR0aFwiLCEwLGkpKSk6KHUrPVMuY3NzKGUsXCJwYWRkaW5nXCIrbmVbYV0sITAsaSksXCJwYWRkaW5nXCIhPT1uP3UrPVMuY3NzKGUsXCJib3JkZXJcIituZVthXStcIldpZHRoXCIsITAsaSk6cys9Uy5jc3MoZSxcImJvcmRlclwiK25lW2FdK1wiV2lkdGhcIiwhMCxpKSk7cmV0dXJuIXImJjA8PW8mJih1Kz1NYXRoLm1heCgwLE1hdGguY2VpbChlW1wib2Zmc2V0XCIrdFswXS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSldLW8tdS1zLS41KSl8fDApLHV9ZnVuY3Rpb24gWmUoZSx0LG4pe3ZhciByPU1lKGUpLGk9KCF2LmJveFNpemluZ1JlbGlhYmxlKCl8fG4pJiZcImJvcmRlci1ib3hcIj09PVMuY3NzKGUsXCJib3hTaXppbmdcIiwhMSxyKSxvPWksYT1CZShlLHQscikscz1cIm9mZnNldFwiK3RbMF0udG9VcHBlckNhc2UoKSt0LnNsaWNlKDEpO2lmKFBlLnRlc3QoYSkpe2lmKCFuKXJldHVybiBhO2E9XCJhdXRvXCJ9cmV0dXJuKCF2LmJveFNpemluZ1JlbGlhYmxlKCkmJml8fCF2LnJlbGlhYmxlVHJEaW1lbnNpb25zKCkmJkEoZSxcInRyXCIpfHxcImF1dG9cIj09PWF8fCFwYXJzZUZsb2F0KGEpJiZcImlubGluZVwiPT09Uy5jc3MoZSxcImRpc3BsYXlcIiwhMSxyKSkmJmUuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgmJihpPVwiYm9yZGVyLWJveFwiPT09Uy5jc3MoZSxcImJveFNpemluZ1wiLCExLHIpLChvPXMgaW4gZSkmJihhPWVbc10pKSwoYT1wYXJzZUZsb2F0KGEpfHwwKStLZShlLHQsbnx8KGk/XCJib3JkZXJcIjpcImNvbnRlbnRcIiksbyxyLGEpK1wicHhcIn1mdW5jdGlvbiBldChlLHQsbixyLGkpe3JldHVybiBuZXcgZXQucHJvdG90eXBlLmluaXQoZSx0LG4scixpKX1TLmV4dGVuZCh7Y3NzSG9va3M6e29wYWNpdHk6e2dldDpmdW5jdGlvbihlLHQpe2lmKHQpe3ZhciBuPUJlKGUsXCJvcGFjaXR5XCIpO3JldHVyblwiXCI9PT1uP1wiMVwiOm59fX19LGNzc051bWJlcjp7YW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6ITAsY29sdW1uQ291bnQ6ITAsZmlsbE9wYWNpdHk6ITAsZmxleEdyb3c6ITAsZmxleFNocmluazohMCxmb250V2VpZ2h0OiEwLGdyaWRBcmVhOiEwLGdyaWRDb2x1bW46ITAsZ3JpZENvbHVtbkVuZDohMCxncmlkQ29sdW1uU3RhcnQ6ITAsZ3JpZFJvdzohMCxncmlkUm93RW5kOiEwLGdyaWRSb3dTdGFydDohMCxsaW5lSGVpZ2h0OiEwLG9wYWNpdHk6ITAsb3JkZXI6ITAsb3JwaGFuczohMCx3aWRvd3M6ITAsekluZGV4OiEwLHpvb206ITB9LGNzc1Byb3BzOnt9LHN0eWxlOmZ1bmN0aW9uKGUsdCxuLHIpe2lmKGUmJjMhPT1lLm5vZGVUeXBlJiY4IT09ZS5ub2RlVHlwZSYmZS5zdHlsZSl7dmFyIGksbyxhLHM9WCh0KSx1PVJlLnRlc3QodCksbD1lLnN0eWxlO2lmKHV8fCh0PVZlKHMpKSxhPVMuY3NzSG9va3NbdF18fFMuY3NzSG9va3Nbc10sdm9pZCAwPT09bilyZXR1cm4gYSYmXCJnZXRcImluIGEmJnZvaWQgMCE9PShpPWEuZ2V0KGUsITEscikpP2k6bFt0XTtcInN0cmluZ1wiPT09KG89dHlwZW9mIG4pJiYoaT10ZS5leGVjKG4pKSYmaVsxXSYmKG49c2UoZSx0LGkpLG89XCJudW1iZXJcIiksbnVsbCE9biYmbj09biYmKFwibnVtYmVyXCIhPT1vfHx1fHwobis9aSYmaVszXXx8KFMuY3NzTnVtYmVyW3NdP1wiXCI6XCJweFwiKSksdi5jbGVhckNsb25lU3R5bGV8fFwiXCIhPT1ufHwwIT09dC5pbmRleE9mKFwiYmFja2dyb3VuZFwiKXx8KGxbdF09XCJpbmhlcml0XCIpLGEmJlwic2V0XCJpbiBhJiZ2b2lkIDA9PT0obj1hLnNldChlLG4scikpfHwodT9sLnNldFByb3BlcnR5KHQsbik6bFt0XT1uKSl9fSxjc3M6ZnVuY3Rpb24oZSx0LG4scil7dmFyIGksbyxhLHM9WCh0KTtyZXR1cm4gUmUudGVzdCh0KXx8KHQ9VmUocykpLChhPVMuY3NzSG9va3NbdF18fFMuY3NzSG9va3Nbc10pJiZcImdldFwiaW4gYSYmKGk9YS5nZXQoZSwhMCxuKSksdm9pZCAwPT09aSYmKGk9QmUoZSx0LHIpKSxcIm5vcm1hbFwiPT09aSYmdCBpbiBRZSYmKGk9UWVbdF0pLFwiXCI9PT1ufHxuPyhvPXBhcnNlRmxvYXQoaSksITA9PT1ufHxpc0Zpbml0ZShvKT9vfHwwOmkpOml9fSksUy5lYWNoKFtcImhlaWdodFwiLFwid2lkdGhcIl0sZnVuY3Rpb24oZSx1KXtTLmNzc0hvb2tzW3VdPXtnZXQ6ZnVuY3Rpb24oZSx0LG4pe2lmKHQpcmV0dXJuIUdlLnRlc3QoUy5jc3MoZSxcImRpc3BsYXlcIikpfHxlLmdldENsaWVudFJlY3RzKCkubGVuZ3RoJiZlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoP1plKGUsdSxuKTpJZShlLFllLGZ1bmN0aW9uKCl7cmV0dXJuIFplKGUsdSxuKX0pfSxzZXQ6ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGk9TWUoZSksbz0hdi5zY3JvbGxib3hTaXplKCkmJlwiYWJzb2x1dGVcIj09PWkucG9zaXRpb24sYT0ob3x8bikmJlwiYm9yZGVyLWJveFwiPT09Uy5jc3MoZSxcImJveFNpemluZ1wiLCExLGkpLHM9bj9LZShlLHUsbixhLGkpOjA7cmV0dXJuIGEmJm8mJihzLT1NYXRoLmNlaWwoZVtcIm9mZnNldFwiK3VbMF0udG9VcHBlckNhc2UoKSt1LnNsaWNlKDEpXS1wYXJzZUZsb2F0KGlbdV0pLUtlKGUsdSxcImJvcmRlclwiLCExLGkpLS41KSkscyYmKHI9dGUuZXhlYyh0KSkmJlwicHhcIiE9PShyWzNdfHxcInB4XCIpJiYoZS5zdHlsZVt1XT10LHQ9Uy5jc3MoZSx1KSksSmUoMCx0LHMpfX19KSxTLmNzc0hvb2tzLm1hcmdpbkxlZnQ9X2Uodi5yZWxpYWJsZU1hcmdpbkxlZnQsZnVuY3Rpb24oZSx0KXtpZih0KXJldHVybihwYXJzZUZsb2F0KEJlKGUsXCJtYXJnaW5MZWZ0XCIpKXx8ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0LUllKGUse21hcmdpbkxlZnQ6MH0sZnVuY3Rpb24oKXtyZXR1cm4gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0fSkpK1wicHhcIn0pLFMuZWFjaCh7bWFyZ2luOlwiXCIscGFkZGluZzpcIlwiLGJvcmRlcjpcIldpZHRoXCJ9LGZ1bmN0aW9uKGksbyl7Uy5jc3NIb29rc1tpK29dPXtleHBhbmQ6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTAsbj17fSxyPVwic3RyaW5nXCI9PXR5cGVvZiBlP2Uuc3BsaXQoXCIgXCIpOltlXTt0PDQ7dCsrKW5baStuZVt0XStvXT1yW3RdfHxyW3QtMl18fHJbMF07cmV0dXJuIG59fSxcIm1hcmdpblwiIT09aSYmKFMuY3NzSG9va3NbaStvXS5zZXQ9SmUpfSksUy5mbi5leHRlbmQoe2NzczpmdW5jdGlvbihlLHQpe3JldHVybiBCKHRoaXMsZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbz17fSxhPTA7aWYoQXJyYXkuaXNBcnJheSh0KSl7Zm9yKHI9TWUoZSksaT10Lmxlbmd0aDthPGk7YSsrKW9bdFthXV09Uy5jc3MoZSx0W2FdLCExLHIpO3JldHVybiBvfXJldHVybiB2b2lkIDAhPT1uP1Muc3R5bGUoZSx0LG4pOlMuY3NzKGUsdCl9LGUsdCwxPGFyZ3VtZW50cy5sZW5ndGgpfX0pLCgoUy5Ud2Vlbj1ldCkucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpldCxpbml0OmZ1bmN0aW9uKGUsdCxuLHIsaSxvKXt0aGlzLmVsZW09ZSx0aGlzLnByb3A9bix0aGlzLmVhc2luZz1pfHxTLmVhc2luZy5fZGVmYXVsdCx0aGlzLm9wdGlvbnM9dCx0aGlzLnN0YXJ0PXRoaXMubm93PXRoaXMuY3VyKCksdGhpcy5lbmQ9cix0aGlzLnVuaXQ9b3x8KFMuY3NzTnVtYmVyW25dP1wiXCI6XCJweFwiKX0sY3VyOmZ1bmN0aW9uKCl7dmFyIGU9ZXQucHJvcEhvb2tzW3RoaXMucHJvcF07cmV0dXJuIGUmJmUuZ2V0P2UuZ2V0KHRoaXMpOmV0LnByb3BIb29rcy5fZGVmYXVsdC5nZXQodGhpcyl9LHJ1bjpmdW5jdGlvbihlKXt2YXIgdCxuPWV0LnByb3BIb29rc1t0aGlzLnByb3BdO3JldHVybiB0aGlzLm9wdGlvbnMuZHVyYXRpb24/dGhpcy5wb3M9dD1TLmVhc2luZ1t0aGlzLmVhc2luZ10oZSx0aGlzLm9wdGlvbnMuZHVyYXRpb24qZSwwLDEsdGhpcy5vcHRpb25zLmR1cmF0aW9uKTp0aGlzLnBvcz10PWUsdGhpcy5ub3c9KHRoaXMuZW5kLXRoaXMuc3RhcnQpKnQrdGhpcy5zdGFydCx0aGlzLm9wdGlvbnMuc3RlcCYmdGhpcy5vcHRpb25zLnN0ZXAuY2FsbCh0aGlzLmVsZW0sdGhpcy5ub3csdGhpcyksbiYmbi5zZXQ/bi5zZXQodGhpcyk6ZXQucHJvcEhvb2tzLl9kZWZhdWx0LnNldCh0aGlzKSx0aGlzfX0pLmluaXQucHJvdG90eXBlPWV0LnByb3RvdHlwZSwoZXQucHJvcEhvb2tzPXtfZGVmYXVsdDp7Z2V0OmZ1bmN0aW9uKGUpe3ZhciB0O3JldHVybiAxIT09ZS5lbGVtLm5vZGVUeXBlfHxudWxsIT1lLmVsZW1bZS5wcm9wXSYmbnVsbD09ZS5lbGVtLnN0eWxlW2UucHJvcF0/ZS5lbGVtW2UucHJvcF06KHQ9Uy5jc3MoZS5lbGVtLGUucHJvcCxcIlwiKSkmJlwiYXV0b1wiIT09dD90OjB9LHNldDpmdW5jdGlvbihlKXtTLmZ4LnN0ZXBbZS5wcm9wXT9TLmZ4LnN0ZXBbZS5wcm9wXShlKToxIT09ZS5lbGVtLm5vZGVUeXBlfHwhUy5jc3NIb29rc1tlLnByb3BdJiZudWxsPT1lLmVsZW0uc3R5bGVbVmUoZS5wcm9wKV0/ZS5lbGVtW2UucHJvcF09ZS5ub3c6Uy5zdHlsZShlLmVsZW0sZS5wcm9wLGUubm93K2UudW5pdCl9fX0pLnNjcm9sbFRvcD1ldC5wcm9wSG9va3Muc2Nyb2xsTGVmdD17c2V0OmZ1bmN0aW9uKGUpe2UuZWxlbS5ub2RlVHlwZSYmZS5lbGVtLnBhcmVudE5vZGUmJihlLmVsZW1bZS5wcm9wXT1lLm5vdyl9fSxTLmVhc2luZz17bGluZWFyOmZ1bmN0aW9uKGUpe3JldHVybiBlfSxzd2luZzpmdW5jdGlvbihlKXtyZXR1cm4uNS1NYXRoLmNvcyhlKk1hdGguUEkpLzJ9LF9kZWZhdWx0Olwic3dpbmdcIn0sUy5meD1ldC5wcm90b3R5cGUuaW5pdCxTLmZ4LnN0ZXA9e307dmFyIHR0LG50LHJ0LGl0LG90PS9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxhdD0vcXVldWVIb29rcyQvO2Z1bmN0aW9uIHN0KCl7bnQmJighMT09PUUuaGlkZGVuJiZDLnJlcXVlc3RBbmltYXRpb25GcmFtZT9DLnJlcXVlc3RBbmltYXRpb25GcmFtZShzdCk6Qy5zZXRUaW1lb3V0KHN0LFMuZnguaW50ZXJ2YWwpLFMuZngudGljaygpKX1mdW5jdGlvbiB1dCgpe3JldHVybiBDLnNldFRpbWVvdXQoZnVuY3Rpb24oKXt0dD12b2lkIDB9KSx0dD1EYXRlLm5vdygpfWZ1bmN0aW9uIGx0KGUsdCl7dmFyIG4scj0wLGk9e2hlaWdodDplfTtmb3IodD10PzE6MDtyPDQ7cis9Mi10KWlbXCJtYXJnaW5cIisobj1uZVtyXSldPWlbXCJwYWRkaW5nXCIrbl09ZTtyZXR1cm4gdCYmKGkub3BhY2l0eT1pLndpZHRoPWUpLGl9ZnVuY3Rpb24gY3QoZSx0LG4pe2Zvcih2YXIgcixpPShmdC50d2VlbmVyc1t0XXx8W10pLmNvbmNhdChmdC50d2VlbmVyc1tcIipcIl0pLG89MCxhPWkubGVuZ3RoO288YTtvKyspaWYocj1pW29dLmNhbGwobix0LGUpKXJldHVybiByfWZ1bmN0aW9uIGZ0KG8sZSx0KXt2YXIgbixhLHI9MCxpPWZ0LnByZWZpbHRlcnMubGVuZ3RoLHM9Uy5EZWZlcnJlZCgpLmFsd2F5cyhmdW5jdGlvbigpe2RlbGV0ZSB1LmVsZW19KSx1PWZ1bmN0aW9uKCl7aWYoYSlyZXR1cm4hMTtmb3IodmFyIGU9dHR8fHV0KCksdD1NYXRoLm1heCgwLGwuc3RhcnRUaW1lK2wuZHVyYXRpb24tZSksbj0xLSh0L2wuZHVyYXRpb258fDApLHI9MCxpPWwudHdlZW5zLmxlbmd0aDtyPGk7cisrKWwudHdlZW5zW3JdLnJ1bihuKTtyZXR1cm4gcy5ub3RpZnlXaXRoKG8sW2wsbix0XSksbjwxJiZpP3Q6KGl8fHMubm90aWZ5V2l0aChvLFtsLDEsMF0pLHMucmVzb2x2ZVdpdGgobyxbbF0pLCExKX0sbD1zLnByb21pc2Uoe2VsZW06byxwcm9wczpTLmV4dGVuZCh7fSxlKSxvcHRzOlMuZXh0ZW5kKCEwLHtzcGVjaWFsRWFzaW5nOnt9LGVhc2luZzpTLmVhc2luZy5fZGVmYXVsdH0sdCksb3JpZ2luYWxQcm9wZXJ0aWVzOmUsb3JpZ2luYWxPcHRpb25zOnQsc3RhcnRUaW1lOnR0fHx1dCgpLGR1cmF0aW9uOnQuZHVyYXRpb24sdHdlZW5zOltdLGNyZWF0ZVR3ZWVuOmZ1bmN0aW9uKGUsdCl7dmFyIG49Uy5Ud2VlbihvLGwub3B0cyxlLHQsbC5vcHRzLnNwZWNpYWxFYXNpbmdbZV18fGwub3B0cy5lYXNpbmcpO3JldHVybiBsLnR3ZWVucy5wdXNoKG4pLG59LHN0b3A6ZnVuY3Rpb24oZSl7dmFyIHQ9MCxuPWU/bC50d2VlbnMubGVuZ3RoOjA7aWYoYSlyZXR1cm4gdGhpcztmb3IoYT0hMDt0PG47dCsrKWwudHdlZW5zW3RdLnJ1bigxKTtyZXR1cm4gZT8ocy5ub3RpZnlXaXRoKG8sW2wsMSwwXSkscy5yZXNvbHZlV2l0aChvLFtsLGVdKSk6cy5yZWplY3RXaXRoKG8sW2wsZV0pLHRoaXN9fSksYz1sLnByb3BzO2ZvcighZnVuY3Rpb24oZSx0KXt2YXIgbixyLGksbyxhO2ZvcihuIGluIGUpaWYoaT10W3I9WChuKV0sbz1lW25dLEFycmF5LmlzQXJyYXkobykmJihpPW9bMV0sbz1lW25dPW9bMF0pLG4hPT1yJiYoZVtyXT1vLGRlbGV0ZSBlW25dKSwoYT1TLmNzc0hvb2tzW3JdKSYmXCJleHBhbmRcImluIGEpZm9yKG4gaW4gbz1hLmV4cGFuZChvKSxkZWxldGUgZVtyXSxvKW4gaW4gZXx8KGVbbl09b1tuXSx0W25dPWkpO2Vsc2UgdFtyXT1pfShjLGwub3B0cy5zcGVjaWFsRWFzaW5nKTtyPGk7cisrKWlmKG49ZnQucHJlZmlsdGVyc1tyXS5jYWxsKGwsbyxjLGwub3B0cykpcmV0dXJuIG0obi5zdG9wKSYmKFMuX3F1ZXVlSG9va3MobC5lbGVtLGwub3B0cy5xdWV1ZSkuc3RvcD1uLnN0b3AuYmluZChuKSksbjtyZXR1cm4gUy5tYXAoYyxjdCxsKSxtKGwub3B0cy5zdGFydCkmJmwub3B0cy5zdGFydC5jYWxsKG8sbCksbC5wcm9ncmVzcyhsLm9wdHMucHJvZ3Jlc3MpLmRvbmUobC5vcHRzLmRvbmUsbC5vcHRzLmNvbXBsZXRlKS5mYWlsKGwub3B0cy5mYWlsKS5hbHdheXMobC5vcHRzLmFsd2F5cyksUy5meC50aW1lcihTLmV4dGVuZCh1LHtlbGVtOm8sYW5pbTpsLHF1ZXVlOmwub3B0cy5xdWV1ZX0pKSxsfVMuQW5pbWF0aW9uPVMuZXh0ZW5kKGZ0LHt0d2VlbmVyczp7XCIqXCI6W2Z1bmN0aW9uKGUsdCl7dmFyIG49dGhpcy5jcmVhdGVUd2VlbihlLHQpO3JldHVybiBzZShuLmVsZW0sZSx0ZS5leGVjKHQpLG4pLG59XX0sdHdlZW5lcjpmdW5jdGlvbihlLHQpe20oZSk/KHQ9ZSxlPVtcIipcIl0pOmU9ZS5tYXRjaChQKTtmb3IodmFyIG4scj0wLGk9ZS5sZW5ndGg7cjxpO3IrKyluPWVbcl0sZnQudHdlZW5lcnNbbl09ZnQudHdlZW5lcnNbbl18fFtdLGZ0LnR3ZWVuZXJzW25dLnVuc2hpZnQodCl9LHByZWZpbHRlcnM6W2Z1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG8sYSxzLHUsbCxjLGY9XCJ3aWR0aFwiaW4gdHx8XCJoZWlnaHRcImluIHQscD10aGlzLGQ9e30saD1lLnN0eWxlLGc9ZS5ub2RlVHlwZSYmYWUoZSkseT1ZLmdldChlLFwiZnhzaG93XCIpO2ZvcihyIGluIG4ucXVldWV8fChudWxsPT0oYT1TLl9xdWV1ZUhvb2tzKGUsXCJmeFwiKSkudW5xdWV1ZWQmJihhLnVucXVldWVkPTAscz1hLmVtcHR5LmZpcmUsYS5lbXB0eS5maXJlPWZ1bmN0aW9uKCl7YS51bnF1ZXVlZHx8cygpfSksYS51bnF1ZXVlZCsrLHAuYWx3YXlzKGZ1bmN0aW9uKCl7cC5hbHdheXMoZnVuY3Rpb24oKXthLnVucXVldWVkLS0sUy5xdWV1ZShlLFwiZnhcIikubGVuZ3RofHxhLmVtcHR5LmZpcmUoKX0pfSkpLHQpaWYoaT10W3JdLG90LnRlc3QoaSkpe2lmKGRlbGV0ZSB0W3JdLG89b3x8XCJ0b2dnbGVcIj09PWksaT09PShnP1wiaGlkZVwiOlwic2hvd1wiKSl7aWYoXCJzaG93XCIhPT1pfHwheXx8dm9pZCAwPT09eVtyXSljb250aW51ZTtnPSEwfWRbcl09eSYmeVtyXXx8Uy5zdHlsZShlLHIpfWlmKCh1PSFTLmlzRW1wdHlPYmplY3QodCkpfHwhUy5pc0VtcHR5T2JqZWN0KGQpKWZvcihyIGluIGYmJjE9PT1lLm5vZGVUeXBlJiYobi5vdmVyZmxvdz1baC5vdmVyZmxvdyxoLm92ZXJmbG93WCxoLm92ZXJmbG93WV0sbnVsbD09KGw9eSYmeS5kaXNwbGF5KSYmKGw9WS5nZXQoZSxcImRpc3BsYXlcIikpLFwibm9uZVwiPT09KGM9Uy5jc3MoZSxcImRpc3BsYXlcIikpJiYobD9jPWw6KGxlKFtlXSwhMCksbD1lLnN0eWxlLmRpc3BsYXl8fGwsYz1TLmNzcyhlLFwiZGlzcGxheVwiKSxsZShbZV0pKSksKFwiaW5saW5lXCI9PT1jfHxcImlubGluZS1ibG9ja1wiPT09YyYmbnVsbCE9bCkmJlwibm9uZVwiPT09Uy5jc3MoZSxcImZsb2F0XCIpJiYodXx8KHAuZG9uZShmdW5jdGlvbigpe2guZGlzcGxheT1sfSksbnVsbD09bCYmKGM9aC5kaXNwbGF5LGw9XCJub25lXCI9PT1jP1wiXCI6YykpLGguZGlzcGxheT1cImlubGluZS1ibG9ja1wiKSksbi5vdmVyZmxvdyYmKGgub3ZlcmZsb3c9XCJoaWRkZW5cIixwLmFsd2F5cyhmdW5jdGlvbigpe2gub3ZlcmZsb3c9bi5vdmVyZmxvd1swXSxoLm92ZXJmbG93WD1uLm92ZXJmbG93WzFdLGgub3ZlcmZsb3dZPW4ub3ZlcmZsb3dbMl19KSksdT0hMSxkKXV8fCh5P1wiaGlkZGVuXCJpbiB5JiYoZz15LmhpZGRlbik6eT1ZLmFjY2VzcyhlLFwiZnhzaG93XCIse2Rpc3BsYXk6bH0pLG8mJih5LmhpZGRlbj0hZyksZyYmbGUoW2VdLCEwKSxwLmRvbmUoZnVuY3Rpb24oKXtmb3IociBpbiBnfHxsZShbZV0pLFkucmVtb3ZlKGUsXCJmeHNob3dcIiksZClTLnN0eWxlKGUscixkW3JdKX0pKSx1PWN0KGc/eVtyXTowLHIscCksciBpbiB5fHwoeVtyXT11LnN0YXJ0LGcmJih1LmVuZD11LnN0YXJ0LHUuc3RhcnQ9MCkpfV0scHJlZmlsdGVyOmZ1bmN0aW9uKGUsdCl7dD9mdC5wcmVmaWx0ZXJzLnVuc2hpZnQoZSk6ZnQucHJlZmlsdGVycy5wdXNoKGUpfX0pLFMuc3BlZWQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWUmJlwib2JqZWN0XCI9PXR5cGVvZiBlP1MuZXh0ZW5kKHt9LGUpOntjb21wbGV0ZTpufHwhbiYmdHx8bShlKSYmZSxkdXJhdGlvbjplLGVhc2luZzpuJiZ0fHx0JiYhbSh0KSYmdH07cmV0dXJuIFMuZngub2ZmP3IuZHVyYXRpb249MDpcIm51bWJlclwiIT10eXBlb2Ygci5kdXJhdGlvbiYmKHIuZHVyYXRpb24gaW4gUy5meC5zcGVlZHM/ci5kdXJhdGlvbj1TLmZ4LnNwZWVkc1tyLmR1cmF0aW9uXTpyLmR1cmF0aW9uPVMuZnguc3BlZWRzLl9kZWZhdWx0KSxudWxsIT1yLnF1ZXVlJiYhMCE9PXIucXVldWV8fChyLnF1ZXVlPVwiZnhcIiksci5vbGQ9ci5jb21wbGV0ZSxyLmNvbXBsZXRlPWZ1bmN0aW9uKCl7bShyLm9sZCkmJnIub2xkLmNhbGwodGhpcyksci5xdWV1ZSYmUy5kZXF1ZXVlKHRoaXMsci5xdWV1ZSl9LHJ9LFMuZm4uZXh0ZW5kKHtmYWRlVG86ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIHRoaXMuZmlsdGVyKGFlKS5jc3MoXCJvcGFjaXR5XCIsMCkuc2hvdygpLmVuZCgpLmFuaW1hdGUoe29wYWNpdHk6dH0sZSxuLHIpfSxhbmltYXRlOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpPVMuaXNFbXB0eU9iamVjdCh0KSxvPVMuc3BlZWQoZSxuLHIpLGE9ZnVuY3Rpb24oKXt2YXIgZT1mdCh0aGlzLFMuZXh0ZW5kKHt9LHQpLG8pOyhpfHxZLmdldCh0aGlzLFwiZmluaXNoXCIpKSYmZS5zdG9wKCEwKX07cmV0dXJuIGEuZmluaXNoPWEsaXx8ITE9PT1vLnF1ZXVlP3RoaXMuZWFjaChhKTp0aGlzLnF1ZXVlKG8ucXVldWUsYSl9LHN0b3A6ZnVuY3Rpb24oaSxlLG8pe3ZhciBhPWZ1bmN0aW9uKGUpe3ZhciB0PWUuc3RvcDtkZWxldGUgZS5zdG9wLHQobyl9O3JldHVyblwic3RyaW5nXCIhPXR5cGVvZiBpJiYobz1lLGU9aSxpPXZvaWQgMCksZSYmdGhpcy5xdWV1ZShpfHxcImZ4XCIsW10pLHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBlPSEwLHQ9bnVsbCE9aSYmaStcInF1ZXVlSG9va3NcIixuPVMudGltZXJzLHI9WS5nZXQodGhpcyk7aWYodClyW3RdJiZyW3RdLnN0b3AmJmEoclt0XSk7ZWxzZSBmb3IodCBpbiByKXJbdF0mJnJbdF0uc3RvcCYmYXQudGVzdCh0KSYmYShyW3RdKTtmb3IodD1uLmxlbmd0aDt0LS07KW5bdF0uZWxlbSE9PXRoaXN8fG51bGwhPWkmJm5bdF0ucXVldWUhPT1pfHwoblt0XS5hbmltLnN0b3AobyksZT0hMSxuLnNwbGljZSh0LDEpKTshZSYmb3x8Uy5kZXF1ZXVlKHRoaXMsaSl9KX0sZmluaXNoOmZ1bmN0aW9uKGEpe3JldHVybiExIT09YSYmKGE9YXx8XCJmeFwiKSx0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZSx0PVkuZ2V0KHRoaXMpLG49dFthK1wicXVldWVcIl0scj10W2ErXCJxdWV1ZUhvb2tzXCJdLGk9Uy50aW1lcnMsbz1uP24ubGVuZ3RoOjA7Zm9yKHQuZmluaXNoPSEwLFMucXVldWUodGhpcyxhLFtdKSxyJiZyLnN0b3AmJnIuc3RvcC5jYWxsKHRoaXMsITApLGU9aS5sZW5ndGg7ZS0tOylpW2VdLmVsZW09PT10aGlzJiZpW2VdLnF1ZXVlPT09YSYmKGlbZV0uYW5pbS5zdG9wKCEwKSxpLnNwbGljZShlLDEpKTtmb3IoZT0wO2U8bztlKyspbltlXSYmbltlXS5maW5pc2gmJm5bZV0uZmluaXNoLmNhbGwodGhpcyk7ZGVsZXRlIHQuZmluaXNofSl9fSksUy5lYWNoKFtcInRvZ2dsZVwiLFwic2hvd1wiLFwiaGlkZVwiXSxmdW5jdGlvbihlLHIpe3ZhciBpPVMuZm5bcl07Uy5mbltyXT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIG51bGw9PWV8fFwiYm9vbGVhblwiPT10eXBlb2YgZT9pLmFwcGx5KHRoaXMsYXJndW1lbnRzKTp0aGlzLmFuaW1hdGUobHQociwhMCksZSx0LG4pfX0pLFMuZWFjaCh7c2xpZGVEb3duOmx0KFwic2hvd1wiKSxzbGlkZVVwOmx0KFwiaGlkZVwiKSxzbGlkZVRvZ2dsZTpsdChcInRvZ2dsZVwiKSxmYWRlSW46e29wYWNpdHk6XCJzaG93XCJ9LGZhZGVPdXQ6e29wYWNpdHk6XCJoaWRlXCJ9LGZhZGVUb2dnbGU6e29wYWNpdHk6XCJ0b2dnbGVcIn19LGZ1bmN0aW9uKGUscil7Uy5mbltlXT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIHRoaXMuYW5pbWF0ZShyLGUsdCxuKX19KSxTLnRpbWVycz1bXSxTLmZ4LnRpY2s9ZnVuY3Rpb24oKXt2YXIgZSx0PTAsbj1TLnRpbWVycztmb3IodHQ9RGF0ZS5ub3coKTt0PG4ubGVuZ3RoO3QrKykoZT1uW3RdKSgpfHxuW3RdIT09ZXx8bi5zcGxpY2UodC0tLDEpO24ubGVuZ3RofHxTLmZ4LnN0b3AoKSx0dD12b2lkIDB9LFMuZngudGltZXI9ZnVuY3Rpb24oZSl7Uy50aW1lcnMucHVzaChlKSxTLmZ4LnN0YXJ0KCl9LFMuZnguaW50ZXJ2YWw9MTMsUy5meC5zdGFydD1mdW5jdGlvbigpe250fHwobnQ9ITAsc3QoKSl9LFMuZnguc3RvcD1mdW5jdGlvbigpe250PW51bGx9LFMuZnguc3BlZWRzPXtzbG93OjYwMCxmYXN0OjIwMCxfZGVmYXVsdDo0MDB9LFMuZm4uZGVsYXk9ZnVuY3Rpb24ocixlKXtyZXR1cm4gcj1TLmZ4JiZTLmZ4LnNwZWVkc1tyXXx8cixlPWV8fFwiZnhcIix0aGlzLnF1ZXVlKGUsZnVuY3Rpb24oZSx0KXt2YXIgbj1DLnNldFRpbWVvdXQoZSxyKTt0LnN0b3A9ZnVuY3Rpb24oKXtDLmNsZWFyVGltZW91dChuKX19KX0scnQ9RS5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksaXQ9RS5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpLmFwcGVuZENoaWxkKEUuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSkscnQudHlwZT1cImNoZWNrYm94XCIsdi5jaGVja09uPVwiXCIhPT1ydC52YWx1ZSx2Lm9wdFNlbGVjdGVkPWl0LnNlbGVjdGVkLChydD1FLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSkudmFsdWU9XCJ0XCIscnQudHlwZT1cInJhZGlvXCIsdi5yYWRpb1ZhbHVlPVwidFwiPT09cnQudmFsdWU7dmFyIHB0LGR0PVMuZXhwci5hdHRySGFuZGxlO1MuZm4uZXh0ZW5kKHthdHRyOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIEIodGhpcyxTLmF0dHIsZSx0LDE8YXJndW1lbnRzLmxlbmd0aCl9LHJlbW92ZUF0dHI6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1MucmVtb3ZlQXR0cih0aGlzLGUpfSl9fSksUy5leHRlbmQoe2F0dHI6ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbz1lLm5vZGVUeXBlO2lmKDMhPT1vJiY4IT09byYmMiE9PW8pcmV0dXJuXCJ1bmRlZmluZWRcIj09dHlwZW9mIGUuZ2V0QXR0cmlidXRlP1MucHJvcChlLHQsbik6KDE9PT1vJiZTLmlzWE1MRG9jKGUpfHwoaT1TLmF0dHJIb29rc1t0LnRvTG93ZXJDYXNlKCldfHwoUy5leHByLm1hdGNoLmJvb2wudGVzdCh0KT9wdDp2b2lkIDApKSx2b2lkIDAhPT1uP251bGw9PT1uP3ZvaWQgUy5yZW1vdmVBdHRyKGUsdCk6aSYmXCJzZXRcImluIGkmJnZvaWQgMCE9PShyPWkuc2V0KGUsbix0KSk/cjooZS5zZXRBdHRyaWJ1dGUodCxuK1wiXCIpLG4pOmkmJlwiZ2V0XCJpbiBpJiZudWxsIT09KHI9aS5nZXQoZSx0KSk/cjpudWxsPT0ocj1TLmZpbmQuYXR0cihlLHQpKT92b2lkIDA6cil9LGF0dHJIb29rczp7dHlwZTp7c2V0OmZ1bmN0aW9uKGUsdCl7aWYoIXYucmFkaW9WYWx1ZSYmXCJyYWRpb1wiPT09dCYmQShlLFwiaW5wdXRcIikpe3ZhciBuPWUudmFsdWU7cmV0dXJuIGUuc2V0QXR0cmlidXRlKFwidHlwZVwiLHQpLG4mJihlLnZhbHVlPW4pLHR9fX19LHJlbW92ZUF0dHI6ZnVuY3Rpb24oZSx0KXt2YXIgbixyPTAsaT10JiZ0Lm1hdGNoKFApO2lmKGkmJjE9PT1lLm5vZGVUeXBlKXdoaWxlKG49aVtyKytdKWUucmVtb3ZlQXR0cmlidXRlKG4pfX0pLHB0PXtzZXQ6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiExPT09dD9TLnJlbW92ZUF0dHIoZSxuKTplLnNldEF0dHJpYnV0ZShuLG4pLG59fSxTLmVhY2goUy5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKC9cXHcrL2cpLGZ1bmN0aW9uKGUsdCl7dmFyIGE9ZHRbdF18fFMuZmluZC5hdHRyO2R0W3RdPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG89dC50b0xvd2VyQ2FzZSgpO3JldHVybiBufHwoaT1kdFtvXSxkdFtvXT1yLHI9bnVsbCE9YShlLHQsbik/bzpudWxsLGR0W29dPWkpLHJ9fSk7dmFyIGh0PS9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksZ3Q9L14oPzphfGFyZWEpJC9pO2Z1bmN0aW9uIHl0KGUpe3JldHVybihlLm1hdGNoKFApfHxbXSkuam9pbihcIiBcIil9ZnVuY3Rpb24gdnQoZSl7cmV0dXJuIGUuZ2V0QXR0cmlidXRlJiZlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpfHxcIlwifWZ1bmN0aW9uIG10KGUpe3JldHVybiBBcnJheS5pc0FycmF5KGUpP2U6XCJzdHJpbmdcIj09dHlwZW9mIGUmJmUubWF0Y2goUCl8fFtdfVMuZm4uZXh0ZW5kKHtwcm9wOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIEIodGhpcyxTLnByb3AsZSx0LDE8YXJndW1lbnRzLmxlbmd0aCl9LHJlbW92ZVByb3A6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe2RlbGV0ZSB0aGlzW1MucHJvcEZpeFtlXXx8ZV19KX19KSxTLmV4dGVuZCh7cHJvcDpmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvPWUubm9kZVR5cGU7aWYoMyE9PW8mJjghPT1vJiYyIT09bylyZXR1cm4gMT09PW8mJlMuaXNYTUxEb2MoZSl8fCh0PVMucHJvcEZpeFt0XXx8dCxpPVMucHJvcEhvb2tzW3RdKSx2b2lkIDAhPT1uP2kmJlwic2V0XCJpbiBpJiZ2b2lkIDAhPT0ocj1pLnNldChlLG4sdCkpP3I6ZVt0XT1uOmkmJlwiZ2V0XCJpbiBpJiZudWxsIT09KHI9aS5nZXQoZSx0KSk/cjplW3RdfSxwcm9wSG9va3M6e3RhYkluZGV4OntnZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9Uy5maW5kLmF0dHIoZSxcInRhYmluZGV4XCIpO3JldHVybiB0P3BhcnNlSW50KHQsMTApOmh0LnRlc3QoZS5ub2RlTmFtZSl8fGd0LnRlc3QoZS5ub2RlTmFtZSkmJmUuaHJlZj8wOi0xfX19LHByb3BGaXg6e1wiZm9yXCI6XCJodG1sRm9yXCIsXCJjbGFzc1wiOlwiY2xhc3NOYW1lXCJ9fSksdi5vcHRTZWxlY3RlZHx8KFMucHJvcEhvb2tzLnNlbGVjdGVkPXtnZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5wYXJlbnROb2RlO3JldHVybiB0JiZ0LnBhcmVudE5vZGUmJnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LG51bGx9LHNldDpmdW5jdGlvbihlKXt2YXIgdD1lLnBhcmVudE5vZGU7dCYmKHQuc2VsZWN0ZWRJbmRleCx0LnBhcmVudE5vZGUmJnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4KX19KSxTLmVhY2goW1widGFiSW5kZXhcIixcInJlYWRPbmx5XCIsXCJtYXhMZW5ndGhcIixcImNlbGxTcGFjaW5nXCIsXCJjZWxsUGFkZGluZ1wiLFwicm93U3BhblwiLFwiY29sU3BhblwiLFwidXNlTWFwXCIsXCJmcmFtZUJvcmRlclwiLFwiY29udGVudEVkaXRhYmxlXCJdLGZ1bmN0aW9uKCl7Uy5wcm9wRml4W3RoaXMudG9Mb3dlckNhc2UoKV09dGhpc30pLFMuZm4uZXh0ZW5kKHthZGRDbGFzczpmdW5jdGlvbih0KXt2YXIgZSxuLHIsaSxvLGE7cmV0dXJuIG0odCk/dGhpcy5lYWNoKGZ1bmN0aW9uKGUpe1ModGhpcykuYWRkQ2xhc3ModC5jYWxsKHRoaXMsZSx2dCh0aGlzKSkpfSk6KGU9bXQodCkpLmxlbmd0aD90aGlzLmVhY2goZnVuY3Rpb24oKXtpZihyPXZ0KHRoaXMpLG49MT09PXRoaXMubm9kZVR5cGUmJlwiIFwiK3l0KHIpK1wiIFwiKXtmb3Iobz0wO288ZS5sZW5ndGg7bysrKWk9ZVtvXSxuLmluZGV4T2YoXCIgXCIraStcIiBcIik8MCYmKG4rPWkrXCIgXCIpO2E9eXQobiksciE9PWEmJnRoaXMuc2V0QXR0cmlidXRlKFwiY2xhc3NcIixhKX19KTp0aGlzfSxyZW1vdmVDbGFzczpmdW5jdGlvbih0KXt2YXIgZSxuLHIsaSxvLGE7cmV0dXJuIG0odCk/dGhpcy5lYWNoKGZ1bmN0aW9uKGUpe1ModGhpcykucmVtb3ZlQ2xhc3ModC5jYWxsKHRoaXMsZSx2dCh0aGlzKSkpfSk6YXJndW1lbnRzLmxlbmd0aD8oZT1tdCh0KSkubGVuZ3RoP3RoaXMuZWFjaChmdW5jdGlvbigpe2lmKHI9dnQodGhpcyksbj0xPT09dGhpcy5ub2RlVHlwZSYmXCIgXCIreXQocikrXCIgXCIpe2ZvcihvPTA7bzxlLmxlbmd0aDtvKyspe2k9ZVtvXTt3aGlsZSgtMTxuLmluZGV4T2YoXCIgXCIraStcIiBcIikpbj1uLnJlcGxhY2UoXCIgXCIraStcIiBcIixcIiBcIil9YT15dChuKSxyIT09YSYmdGhpcy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLGEpfX0pOnRoaXM6dGhpcy5hdHRyKFwiY2xhc3NcIixcIlwiKX0sdG9nZ2xlQ2xhc3M6ZnVuY3Rpb24odCxuKXt2YXIgZSxyLGksbyxhPXR5cGVvZiB0LHM9XCJzdHJpbmdcIj09PWF8fEFycmF5LmlzQXJyYXkodCk7cmV0dXJuIG0odCk/dGhpcy5lYWNoKGZ1bmN0aW9uKGUpe1ModGhpcykudG9nZ2xlQ2xhc3ModC5jYWxsKHRoaXMsZSx2dCh0aGlzKSxuKSxuKX0pOlwiYm9vbGVhblwiPT10eXBlb2YgbiYmcz9uP3RoaXMuYWRkQ2xhc3ModCk6dGhpcy5yZW1vdmVDbGFzcyh0KTooZT1tdCh0KSx0aGlzLmVhY2goZnVuY3Rpb24oKXtpZihzKWZvcihvPVModGhpcyksaT0wO2k8ZS5sZW5ndGg7aSsrKXI9ZVtpXSxvLmhhc0NsYXNzKHIpP28ucmVtb3ZlQ2xhc3Mocik6by5hZGRDbGFzcyhyKTtlbHNlIHZvaWQgMCE9PXQmJlwiYm9vbGVhblwiIT09YXx8KChyPXZ0KHRoaXMpKSYmWS5zZXQodGhpcyxcIl9fY2xhc3NOYW1lX19cIixyKSx0aGlzLnNldEF0dHJpYnV0ZSYmdGhpcy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLHJ8fCExPT09dD9cIlwiOlkuZ2V0KHRoaXMsXCJfX2NsYXNzTmFtZV9fXCIpfHxcIlwiKSl9KSl9LGhhc0NsYXNzOmZ1bmN0aW9uKGUpe3ZhciB0LG4scj0wO3Q9XCIgXCIrZStcIiBcIjt3aGlsZShuPXRoaXNbcisrXSlpZigxPT09bi5ub2RlVHlwZSYmLTE8KFwiIFwiK3l0KHZ0KG4pKStcIiBcIikuaW5kZXhPZih0KSlyZXR1cm4hMDtyZXR1cm4hMX19KTt2YXIgeHQ9L1xcci9nO1MuZm4uZXh0ZW5kKHt2YWw6ZnVuY3Rpb24obil7dmFyIHIsZSxpLHQ9dGhpc1swXTtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oaT1tKG4pLHRoaXMuZWFjaChmdW5jdGlvbihlKXt2YXIgdDsxPT09dGhpcy5ub2RlVHlwZSYmKG51bGw9PSh0PWk/bi5jYWxsKHRoaXMsZSxTKHRoaXMpLnZhbCgpKTpuKT90PVwiXCI6XCJudW1iZXJcIj09dHlwZW9mIHQ/dCs9XCJcIjpBcnJheS5pc0FycmF5KHQpJiYodD1TLm1hcCh0LGZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lP1wiXCI6ZStcIlwifSkpLChyPVMudmFsSG9va3NbdGhpcy50eXBlXXx8Uy52YWxIb29rc1t0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldKSYmXCJzZXRcImluIHImJnZvaWQgMCE9PXIuc2V0KHRoaXMsdCxcInZhbHVlXCIpfHwodGhpcy52YWx1ZT10KSl9KSk6dD8ocj1TLnZhbEhvb2tzW3QudHlwZV18fFMudmFsSG9va3NbdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSkmJlwiZ2V0XCJpbiByJiZ2b2lkIDAhPT0oZT1yLmdldCh0LFwidmFsdWVcIikpP2U6XCJzdHJpbmdcIj09dHlwZW9mKGU9dC52YWx1ZSk/ZS5yZXBsYWNlKHh0LFwiXCIpOm51bGw9PWU/XCJcIjplOnZvaWQgMH19KSxTLmV4dGVuZCh7dmFsSG9va3M6e29wdGlvbjp7Z2V0OmZ1bmN0aW9uKGUpe3ZhciB0PVMuZmluZC5hdHRyKGUsXCJ2YWx1ZVwiKTtyZXR1cm4gbnVsbCE9dD90Onl0KFMudGV4dChlKSl9fSxzZWxlY3Q6e2dldDpmdW5jdGlvbihlKXt2YXIgdCxuLHIsaT1lLm9wdGlvbnMsbz1lLnNlbGVjdGVkSW5kZXgsYT1cInNlbGVjdC1vbmVcIj09PWUudHlwZSxzPWE/bnVsbDpbXSx1PWE/bysxOmkubGVuZ3RoO2ZvcihyPW88MD91OmE/bzowO3I8dTtyKyspaWYoKChuPWlbcl0pLnNlbGVjdGVkfHxyPT09bykmJiFuLmRpc2FibGVkJiYoIW4ucGFyZW50Tm9kZS5kaXNhYmxlZHx8IUEobi5wYXJlbnROb2RlLFwib3B0Z3JvdXBcIikpKXtpZih0PVMobikudmFsKCksYSlyZXR1cm4gdDtzLnB1c2godCl9cmV0dXJuIHN9LHNldDpmdW5jdGlvbihlLHQpe3ZhciBuLHIsaT1lLm9wdGlvbnMsbz1TLm1ha2VBcnJheSh0KSxhPWkubGVuZ3RoO3doaWxlKGEtLSkoKHI9aVthXSkuc2VsZWN0ZWQ9LTE8Uy5pbkFycmF5KFMudmFsSG9va3Mub3B0aW9uLmdldChyKSxvKSkmJihuPSEwKTtyZXR1cm4gbnx8KGUuc2VsZWN0ZWRJbmRleD0tMSksb319fX0pLFMuZWFjaChbXCJyYWRpb1wiLFwiY2hlY2tib3hcIl0sZnVuY3Rpb24oKXtTLnZhbEhvb2tzW3RoaXNdPXtzZXQ6ZnVuY3Rpb24oZSx0KXtpZihBcnJheS5pc0FycmF5KHQpKXJldHVybiBlLmNoZWNrZWQ9LTE8Uy5pbkFycmF5KFMoZSkudmFsKCksdCl9fSx2LmNoZWNrT258fChTLnZhbEhvb2tzW3RoaXNdLmdldD1mdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09PWUuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik/XCJvblwiOmUudmFsdWV9KX0pLHYuZm9jdXNpbj1cIm9uZm9jdXNpblwiaW4gQzt2YXIgYnQ9L14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLHd0PWZ1bmN0aW9uKGUpe2Uuc3RvcFByb3BhZ2F0aW9uKCl9O1MuZXh0ZW5kKFMuZXZlbnQse3RyaWdnZXI6ZnVuY3Rpb24oZSx0LG4scil7dmFyIGksbyxhLHMsdSxsLGMsZixwPVtufHxFXSxkPXkuY2FsbChlLFwidHlwZVwiKT9lLnR5cGU6ZSxoPXkuY2FsbChlLFwibmFtZXNwYWNlXCIpP2UubmFtZXNwYWNlLnNwbGl0KFwiLlwiKTpbXTtpZihvPWY9YT1uPW58fEUsMyE9PW4ubm9kZVR5cGUmJjghPT1uLm5vZGVUeXBlJiYhYnQudGVzdChkK1MuZXZlbnQudHJpZ2dlcmVkKSYmKC0xPGQuaW5kZXhPZihcIi5cIikmJihkPShoPWQuc3BsaXQoXCIuXCIpKS5zaGlmdCgpLGguc29ydCgpKSx1PWQuaW5kZXhPZihcIjpcIik8MCYmXCJvblwiK2QsKGU9ZVtTLmV4cGFuZG9dP2U6bmV3IFMuRXZlbnQoZCxcIm9iamVjdFwiPT10eXBlb2YgZSYmZSkpLmlzVHJpZ2dlcj1yPzI6MyxlLm5hbWVzcGFjZT1oLmpvaW4oXCIuXCIpLGUucm5hbWVzcGFjZT1lLm5hbWVzcGFjZT9uZXcgUmVnRXhwKFwiKF58XFxcXC4pXCIraC5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikrXCIoXFxcXC58JClcIik6bnVsbCxlLnJlc3VsdD12b2lkIDAsZS50YXJnZXR8fChlLnRhcmdldD1uKSx0PW51bGw9PXQ/W2VdOlMubWFrZUFycmF5KHQsW2VdKSxjPVMuZXZlbnQuc3BlY2lhbFtkXXx8e30scnx8IWMudHJpZ2dlcnx8ITEhPT1jLnRyaWdnZXIuYXBwbHkobix0KSkpe2lmKCFyJiYhYy5ub0J1YmJsZSYmIXgobikpe2ZvcihzPWMuZGVsZWdhdGVUeXBlfHxkLGJ0LnRlc3QocytkKXx8KG89by5wYXJlbnROb2RlKTtvO289by5wYXJlbnROb2RlKXAucHVzaChvKSxhPW87YT09PShuLm93bmVyRG9jdW1lbnR8fEUpJiZwLnB1c2goYS5kZWZhdWx0Vmlld3x8YS5wYXJlbnRXaW5kb3d8fEMpfWk9MDt3aGlsZSgobz1wW2krK10pJiYhZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKWY9byxlLnR5cGU9MTxpP3M6Yy5iaW5kVHlwZXx8ZCwobD0oWS5nZXQobyxcImV2ZW50c1wiKXx8T2JqZWN0LmNyZWF0ZShudWxsKSlbZS50eXBlXSYmWS5nZXQobyxcImhhbmRsZVwiKSkmJmwuYXBwbHkobyx0KSwobD11JiZvW3VdKSYmbC5hcHBseSYmVihvKSYmKGUucmVzdWx0PWwuYXBwbHkobyx0KSwhMT09PWUucmVzdWx0JiZlLnByZXZlbnREZWZhdWx0KCkpO3JldHVybiBlLnR5cGU9ZCxyfHxlLmlzRGVmYXVsdFByZXZlbnRlZCgpfHxjLl9kZWZhdWx0JiYhMSE9PWMuX2RlZmF1bHQuYXBwbHkocC5wb3AoKSx0KXx8IVYobil8fHUmJm0obltkXSkmJiF4KG4pJiYoKGE9blt1XSkmJihuW3VdPW51bGwpLFMuZXZlbnQudHJpZ2dlcmVkPWQsZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpJiZmLmFkZEV2ZW50TGlzdGVuZXIoZCx3dCksbltkXSgpLGUuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSYmZi5yZW1vdmVFdmVudExpc3RlbmVyKGQsd3QpLFMuZXZlbnQudHJpZ2dlcmVkPXZvaWQgMCxhJiYoblt1XT1hKSksZS5yZXN1bHR9fSxzaW11bGF0ZTpmdW5jdGlvbihlLHQsbil7dmFyIHI9Uy5leHRlbmQobmV3IFMuRXZlbnQsbix7dHlwZTplLGlzU2ltdWxhdGVkOiEwfSk7Uy5ldmVudC50cmlnZ2VyKHIsbnVsbCx0KX19KSxTLmZuLmV4dGVuZCh7dHJpZ2dlcjpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtTLmV2ZW50LnRyaWdnZXIoZSx0LHRoaXMpfSl9LHRyaWdnZXJIYW5kbGVyOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpc1swXTtpZihuKXJldHVybiBTLmV2ZW50LnRyaWdnZXIoZSx0LG4sITApfX0pLHYuZm9jdXNpbnx8Uy5lYWNoKHtmb2N1czpcImZvY3VzaW5cIixibHVyOlwiZm9jdXNvdXRcIn0sZnVuY3Rpb24obixyKXt2YXIgaT1mdW5jdGlvbihlKXtTLmV2ZW50LnNpbXVsYXRlKHIsZS50YXJnZXQsUy5ldmVudC5maXgoZSkpfTtTLmV2ZW50LnNwZWNpYWxbcl09e3NldHVwOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5vd25lckRvY3VtZW50fHx0aGlzLmRvY3VtZW50fHx0aGlzLHQ9WS5hY2Nlc3MoZSxyKTt0fHxlLmFkZEV2ZW50TGlzdGVuZXIobixpLCEwKSxZLmFjY2VzcyhlLHIsKHR8fDApKzEpfSx0ZWFyZG93bjpmdW5jdGlvbigpe3ZhciBlPXRoaXMub3duZXJEb2N1bWVudHx8dGhpcy5kb2N1bWVudHx8dGhpcyx0PVkuYWNjZXNzKGUsciktMTt0P1kuYWNjZXNzKGUscix0KTooZS5yZW1vdmVFdmVudExpc3RlbmVyKG4saSwhMCksWS5yZW1vdmUoZSxyKSl9fX0pO3ZhciBUdD1DLmxvY2F0aW9uLEN0PXtndWlkOkRhdGUubm93KCl9LEV0PS9cXD8vO1MucGFyc2VYTUw9ZnVuY3Rpb24oZSl7dmFyIHQsbjtpZighZXx8XCJzdHJpbmdcIiE9dHlwZW9mIGUpcmV0dXJuIG51bGw7dHJ5e3Q9KG5ldyBDLkRPTVBhcnNlcikucGFyc2VGcm9tU3RyaW5nKGUsXCJ0ZXh0L3htbFwiKX1jYXRjaChlKXt9cmV0dXJuIG49dCYmdC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInBhcnNlcmVycm9yXCIpWzBdLHQmJiFufHxTLmVycm9yKFwiSW52YWxpZCBYTUw6IFwiKyhuP1MubWFwKG4uY2hpbGROb2RlcyxmdW5jdGlvbihlKXtyZXR1cm4gZS50ZXh0Q29udGVudH0pLmpvaW4oXCJcXG5cIik6ZSkpLHR9O3ZhciBTdD0vXFxbXFxdJC8sa3Q9L1xccj9cXG4vZyxBdD0vXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksTnQ9L14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO2Z1bmN0aW9uIGp0KG4sZSxyLGkpe3ZhciB0O2lmKEFycmF5LmlzQXJyYXkoZSkpUy5lYWNoKGUsZnVuY3Rpb24oZSx0KXtyfHxTdC50ZXN0KG4pP2kobix0KTpqdChuK1wiW1wiKyhcIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9dD9lOlwiXCIpK1wiXVwiLHQscixpKX0pO2Vsc2UgaWYocnx8XCJvYmplY3RcIiE9PXcoZSkpaShuLGUpO2Vsc2UgZm9yKHQgaW4gZSlqdChuK1wiW1wiK3QrXCJdXCIsZVt0XSxyLGkpfVMucGFyYW09ZnVuY3Rpb24oZSx0KXt2YXIgbixyPVtdLGk9ZnVuY3Rpb24oZSx0KXt2YXIgbj1tKHQpP3QoKTp0O3Jbci5sZW5ndGhdPWVuY29kZVVSSUNvbXBvbmVudChlKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQobnVsbD09bj9cIlwiOm4pfTtpZihudWxsPT1lKXJldHVyblwiXCI7aWYoQXJyYXkuaXNBcnJheShlKXx8ZS5qcXVlcnkmJiFTLmlzUGxhaW5PYmplY3QoZSkpUy5lYWNoKGUsZnVuY3Rpb24oKXtpKHRoaXMubmFtZSx0aGlzLnZhbHVlKX0pO2Vsc2UgZm9yKG4gaW4gZSlqdChuLGVbbl0sdCxpKTtyZXR1cm4gci5qb2luKFwiJlwiKX0sUy5mbi5leHRlbmQoe3NlcmlhbGl6ZTpmdW5jdGlvbigpe3JldHVybiBTLnBhcmFtKHRoaXMuc2VyaWFsaXplQXJyYXkoKSl9LHNlcmlhbGl6ZUFycmF5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCl7dmFyIGU9Uy5wcm9wKHRoaXMsXCJlbGVtZW50c1wiKTtyZXR1cm4gZT9TLm1ha2VBcnJheShlKTp0aGlzfSkuZmlsdGVyKGZ1bmN0aW9uKCl7dmFyIGU9dGhpcy50eXBlO3JldHVybiB0aGlzLm5hbWUmJiFTKHRoaXMpLmlzKFwiOmRpc2FibGVkXCIpJiZOdC50ZXN0KHRoaXMubm9kZU5hbWUpJiYhQXQudGVzdChlKSYmKHRoaXMuY2hlY2tlZHx8IXBlLnRlc3QoZSkpfSkubWFwKGZ1bmN0aW9uKGUsdCl7dmFyIG49Uyh0aGlzKS52YWwoKTtyZXR1cm4gbnVsbD09bj9udWxsOkFycmF5LmlzQXJyYXkobik/Uy5tYXAobixmdW5jdGlvbihlKXtyZXR1cm57bmFtZTp0Lm5hbWUsdmFsdWU6ZS5yZXBsYWNlKGt0LFwiXFxyXFxuXCIpfX0pOntuYW1lOnQubmFtZSx2YWx1ZTpuLnJlcGxhY2Uoa3QsXCJcXHJcXG5cIil9fSkuZ2V0KCl9fSk7dmFyIER0PS8lMjAvZyxxdD0vIy4qJC8sTHQ9LyhbPyZdKV89W14mXSovLEh0PS9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvZ20sT3Q9L14oPzpHRVR8SEVBRCkkLyxQdD0vXlxcL1xcLy8sUnQ9e30sTXQ9e30sSXQ9XCIqL1wiLmNvbmNhdChcIipcIiksV3Q9RS5jcmVhdGVFbGVtZW50KFwiYVwiKTtmdW5jdGlvbiBGdChvKXtyZXR1cm4gZnVuY3Rpb24oZSx0KXtcInN0cmluZ1wiIT10eXBlb2YgZSYmKHQ9ZSxlPVwiKlwiKTt2YXIgbixyPTAsaT1lLnRvTG93ZXJDYXNlKCkubWF0Y2goUCl8fFtdO2lmKG0odCkpd2hpbGUobj1pW3IrK10pXCIrXCI9PT1uWzBdPyhuPW4uc2xpY2UoMSl8fFwiKlwiLChvW25dPW9bbl18fFtdKS51bnNoaWZ0KHQpKToob1tuXT1vW25dfHxbXSkucHVzaCh0KX19ZnVuY3Rpb24gJHQodCxpLG8sYSl7dmFyIHM9e30sdT10PT09TXQ7ZnVuY3Rpb24gbChlKXt2YXIgcjtyZXR1cm4gc1tlXT0hMCxTLmVhY2godFtlXXx8W10sZnVuY3Rpb24oZSx0KXt2YXIgbj10KGksbyxhKTtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2Ygbnx8dXx8c1tuXT91PyEocj1uKTp2b2lkIDA6KGkuZGF0YVR5cGVzLnVuc2hpZnQobiksbChuKSwhMSl9KSxyfXJldHVybiBsKGkuZGF0YVR5cGVzWzBdKXx8IXNbXCIqXCJdJiZsKFwiKlwiKX1mdW5jdGlvbiBCdChlLHQpe3ZhciBuLHIsaT1TLmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9uc3x8e307Zm9yKG4gaW4gdCl2b2lkIDAhPT10W25dJiYoKGlbbl0/ZTpyfHwocj17fSkpW25dPXRbbl0pO3JldHVybiByJiZTLmV4dGVuZCghMCxlLHIpLGV9V3QuaHJlZj1UdC5ocmVmLFMuZXh0ZW5kKHthY3RpdmU6MCxsYXN0TW9kaWZpZWQ6e30sZXRhZzp7fSxhamF4U2V0dGluZ3M6e3VybDpUdC5ocmVmLHR5cGU6XCJHRVRcIixpc0xvY2FsOi9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLnRlc3QoVHQucHJvdG9jb2wpLGdsb2JhbDohMCxwcm9jZXNzRGF0YTohMCxhc3luYzohMCxjb250ZW50VHlwZTpcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLGFjY2VwdHM6e1wiKlwiOkl0LHRleHQ6XCJ0ZXh0L3BsYWluXCIsaHRtbDpcInRleHQvaHRtbFwiLHhtbDpcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixqc29uOlwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJ9LGNvbnRlbnRzOnt4bWw6L1xcYnhtbFxcYi8saHRtbDovXFxiaHRtbC8sanNvbjovXFxianNvblxcYi99LHJlc3BvbnNlRmllbGRzOnt4bWw6XCJyZXNwb25zZVhNTFwiLHRleHQ6XCJyZXNwb25zZVRleHRcIixqc29uOlwicmVzcG9uc2VKU09OXCJ9LGNvbnZlcnRlcnM6e1wiKiB0ZXh0XCI6U3RyaW5nLFwidGV4dCBodG1sXCI6ITAsXCJ0ZXh0IGpzb25cIjpKU09OLnBhcnNlLFwidGV4dCB4bWxcIjpTLnBhcnNlWE1MfSxmbGF0T3B0aW9uczp7dXJsOiEwLGNvbnRleHQ6ITB9fSxhamF4U2V0dXA6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdD9CdChCdChlLFMuYWpheFNldHRpbmdzKSx0KTpCdChTLmFqYXhTZXR0aW5ncyxlKX0sYWpheFByZWZpbHRlcjpGdChSdCksYWpheFRyYW5zcG9ydDpGdChNdCksYWpheDpmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBlJiYodD1lLGU9dm9pZCAwKSx0PXR8fHt9O3ZhciBjLGYscCxuLGQscixoLGcsaSxvLHk9Uy5hamF4U2V0dXAoe30sdCksdj15LmNvbnRleHR8fHksbT15LmNvbnRleHQmJih2Lm5vZGVUeXBlfHx2LmpxdWVyeSk/Uyh2KTpTLmV2ZW50LHg9Uy5EZWZlcnJlZCgpLGI9Uy5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSx3PXkuc3RhdHVzQ29kZXx8e30sYT17fSxzPXt9LHU9XCJjYW5jZWxlZFwiLFQ9e3JlYWR5U3RhdGU6MCxnZXRSZXNwb25zZUhlYWRlcjpmdW5jdGlvbihlKXt2YXIgdDtpZihoKXtpZighbil7bj17fTt3aGlsZSh0PUh0LmV4ZWMocCkpblt0WzFdLnRvTG93ZXJDYXNlKCkrXCIgXCJdPShuW3RbMV0udG9Mb3dlckNhc2UoKStcIiBcIl18fFtdKS5jb25jYXQodFsyXSl9dD1uW2UudG9Mb3dlckNhc2UoKStcIiBcIl19cmV0dXJuIG51bGw9PXQ/bnVsbDp0LmpvaW4oXCIsIFwiKX0sZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOmZ1bmN0aW9uKCl7cmV0dXJuIGg/cDpudWxsfSxzZXRSZXF1ZXN0SGVhZGVyOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIG51bGw9PWgmJihlPXNbZS50b0xvd2VyQ2FzZSgpXT1zW2UudG9Mb3dlckNhc2UoKV18fGUsYVtlXT10KSx0aGlzfSxvdmVycmlkZU1pbWVUeXBlOmZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1oJiYoeS5taW1lVHlwZT1lKSx0aGlzfSxzdGF0dXNDb2RlOmZ1bmN0aW9uKGUpe3ZhciB0O2lmKGUpaWYoaClULmFsd2F5cyhlW1Quc3RhdHVzXSk7ZWxzZSBmb3IodCBpbiBlKXdbdF09W3dbdF0sZVt0XV07cmV0dXJuIHRoaXN9LGFib3J0OmZ1bmN0aW9uKGUpe3ZhciB0PWV8fHU7cmV0dXJuIGMmJmMuYWJvcnQodCksbCgwLHQpLHRoaXN9fTtpZih4LnByb21pc2UoVCkseS51cmw9KChlfHx5LnVybHx8VHQuaHJlZikrXCJcIikucmVwbGFjZShQdCxUdC5wcm90b2NvbCtcIi8vXCIpLHkudHlwZT10Lm1ldGhvZHx8dC50eXBlfHx5Lm1ldGhvZHx8eS50eXBlLHkuZGF0YVR5cGVzPSh5LmRhdGFUeXBlfHxcIipcIikudG9Mb3dlckNhc2UoKS5tYXRjaChQKXx8W1wiXCJdLG51bGw9PXkuY3Jvc3NEb21haW4pe3I9RS5jcmVhdGVFbGVtZW50KFwiYVwiKTt0cnl7ci5ocmVmPXkudXJsLHIuaHJlZj1yLmhyZWYseS5jcm9zc0RvbWFpbj1XdC5wcm90b2NvbCtcIi8vXCIrV3QuaG9zdCE9ci5wcm90b2NvbCtcIi8vXCIrci5ob3N0fWNhdGNoKGUpe3kuY3Jvc3NEb21haW49ITB9fWlmKHkuZGF0YSYmeS5wcm9jZXNzRGF0YSYmXCJzdHJpbmdcIiE9dHlwZW9mIHkuZGF0YSYmKHkuZGF0YT1TLnBhcmFtKHkuZGF0YSx5LnRyYWRpdGlvbmFsKSksJHQoUnQseSx0LFQpLGgpcmV0dXJuIFQ7Zm9yKGkgaW4oZz1TLmV2ZW50JiZ5Lmdsb2JhbCkmJjA9PVMuYWN0aXZlKysmJlMuZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKSx5LnR5cGU9eS50eXBlLnRvVXBwZXJDYXNlKCkseS5oYXNDb250ZW50PSFPdC50ZXN0KHkudHlwZSksZj15LnVybC5yZXBsYWNlKHF0LFwiXCIpLHkuaGFzQ29udGVudD95LmRhdGEmJnkucHJvY2Vzc0RhdGEmJjA9PT0oeS5jb250ZW50VHlwZXx8XCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSYmKHkuZGF0YT15LmRhdGEucmVwbGFjZShEdCxcIitcIikpOihvPXkudXJsLnNsaWNlKGYubGVuZ3RoKSx5LmRhdGEmJih5LnByb2Nlc3NEYXRhfHxcInN0cmluZ1wiPT10eXBlb2YgeS5kYXRhKSYmKGYrPShFdC50ZXN0KGYpP1wiJlwiOlwiP1wiKSt5LmRhdGEsZGVsZXRlIHkuZGF0YSksITE9PT15LmNhY2hlJiYoZj1mLnJlcGxhY2UoTHQsXCIkMVwiKSxvPShFdC50ZXN0KGYpP1wiJlwiOlwiP1wiKStcIl89XCIrQ3QuZ3VpZCsrK28pLHkudXJsPWYrbykseS5pZk1vZGlmaWVkJiYoUy5sYXN0TW9kaWZpZWRbZl0mJlQuc2V0UmVxdWVzdEhlYWRlcihcIklmLU1vZGlmaWVkLVNpbmNlXCIsUy5sYXN0TW9kaWZpZWRbZl0pLFMuZXRhZ1tmXSYmVC5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTm9uZS1NYXRjaFwiLFMuZXRhZ1tmXSkpLCh5LmRhdGEmJnkuaGFzQ29udGVudCYmITEhPT15LmNvbnRlbnRUeXBlfHx0LmNvbnRlbnRUeXBlKSYmVC5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIseS5jb250ZW50VHlwZSksVC5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIseS5kYXRhVHlwZXNbMF0mJnkuYWNjZXB0c1t5LmRhdGFUeXBlc1swXV0/eS5hY2NlcHRzW3kuZGF0YVR5cGVzWzBdXSsoXCIqXCIhPT15LmRhdGFUeXBlc1swXT9cIiwgXCIrSXQrXCI7IHE9MC4wMVwiOlwiXCIpOnkuYWNjZXB0c1tcIipcIl0pLHkuaGVhZGVycylULnNldFJlcXVlc3RIZWFkZXIoaSx5LmhlYWRlcnNbaV0pO2lmKHkuYmVmb3JlU2VuZCYmKCExPT09eS5iZWZvcmVTZW5kLmNhbGwodixULHkpfHxoKSlyZXR1cm4gVC5hYm9ydCgpO2lmKHU9XCJhYm9ydFwiLGIuYWRkKHkuY29tcGxldGUpLFQuZG9uZSh5LnN1Y2Nlc3MpLFQuZmFpbCh5LmVycm9yKSxjPSR0KE10LHksdCxUKSl7aWYoVC5yZWFkeVN0YXRlPTEsZyYmbS50cmlnZ2VyKFwiYWpheFNlbmRcIixbVCx5XSksaClyZXR1cm4gVDt5LmFzeW5jJiYwPHkudGltZW91dCYmKGQ9Qy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7VC5hYm9ydChcInRpbWVvdXRcIil9LHkudGltZW91dCkpO3RyeXtoPSExLGMuc2VuZChhLGwpfWNhdGNoKGUpe2lmKGgpdGhyb3cgZTtsKC0xLGUpfX1lbHNlIGwoLTEsXCJObyBUcmFuc3BvcnRcIik7ZnVuY3Rpb24gbChlLHQsbixyKXt2YXIgaSxvLGEscyx1LGw9dDtofHwoaD0hMCxkJiZDLmNsZWFyVGltZW91dChkKSxjPXZvaWQgMCxwPXJ8fFwiXCIsVC5yZWFkeVN0YXRlPTA8ZT80OjAsaT0yMDA8PWUmJmU8MzAwfHwzMDQ9PT1lLG4mJihzPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG8sYSxzPWUuY29udGVudHMsdT1lLmRhdGFUeXBlczt3aGlsZShcIipcIj09PXVbMF0pdS5zaGlmdCgpLHZvaWQgMD09PXImJihyPWUubWltZVR5cGV8fHQuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIikpO2lmKHIpZm9yKGkgaW4gcylpZihzW2ldJiZzW2ldLnRlc3Qocikpe3UudW5zaGlmdChpKTticmVha31pZih1WzBdaW4gbilvPXVbMF07ZWxzZXtmb3IoaSBpbiBuKXtpZighdVswXXx8ZS5jb252ZXJ0ZXJzW2krXCIgXCIrdVswXV0pe289aTticmVha31hfHwoYT1pKX1vPW98fGF9aWYobylyZXR1cm4gbyE9PXVbMF0mJnUudW5zaGlmdChvKSxuW29dfSh5LFQsbikpLCFpJiYtMTxTLmluQXJyYXkoXCJzY3JpcHRcIix5LmRhdGFUeXBlcykmJlMuaW5BcnJheShcImpzb25cIix5LmRhdGFUeXBlcyk8MCYmKHkuY29udmVydGVyc1tcInRleHQgc2NyaXB0XCJdPWZ1bmN0aW9uKCl7fSkscz1mdW5jdGlvbihlLHQsbixyKXt2YXIgaSxvLGEscyx1LGw9e30sYz1lLmRhdGFUeXBlcy5zbGljZSgpO2lmKGNbMV0pZm9yKGEgaW4gZS5jb252ZXJ0ZXJzKWxbYS50b0xvd2VyQ2FzZSgpXT1lLmNvbnZlcnRlcnNbYV07bz1jLnNoaWZ0KCk7d2hpbGUobylpZihlLnJlc3BvbnNlRmllbGRzW29dJiYobltlLnJlc3BvbnNlRmllbGRzW29dXT10KSwhdSYmciYmZS5kYXRhRmlsdGVyJiYodD1lLmRhdGFGaWx0ZXIodCxlLmRhdGFUeXBlKSksdT1vLG89Yy5zaGlmdCgpKWlmKFwiKlwiPT09bylvPXU7ZWxzZSBpZihcIipcIiE9PXUmJnUhPT1vKXtpZighKGE9bFt1K1wiIFwiK29dfHxsW1wiKiBcIitvXSkpZm9yKGkgaW4gbClpZigocz1pLnNwbGl0KFwiIFwiKSlbMV09PT1vJiYoYT1sW3UrXCIgXCIrc1swXV18fGxbXCIqIFwiK3NbMF1dKSl7ITA9PT1hP2E9bFtpXTohMCE9PWxbaV0mJihvPXNbMF0sYy51bnNoaWZ0KHNbMV0pKTticmVha31pZighMCE9PWEpaWYoYSYmZVtcInRocm93c1wiXSl0PWEodCk7ZWxzZSB0cnl7dD1hKHQpfWNhdGNoKGUpe3JldHVybntzdGF0ZTpcInBhcnNlcmVycm9yXCIsZXJyb3I6YT9lOlwiTm8gY29udmVyc2lvbiBmcm9tIFwiK3UrXCIgdG8gXCIrb319fXJldHVybntzdGF0ZTpcInN1Y2Nlc3NcIixkYXRhOnR9fSh5LHMsVCxpKSxpPyh5LmlmTW9kaWZpZWQmJigodT1ULmdldFJlc3BvbnNlSGVhZGVyKFwiTGFzdC1Nb2RpZmllZFwiKSkmJihTLmxhc3RNb2RpZmllZFtmXT11KSwodT1ULmdldFJlc3BvbnNlSGVhZGVyKFwiZXRhZ1wiKSkmJihTLmV0YWdbZl09dSkpLDIwND09PWV8fFwiSEVBRFwiPT09eS50eXBlP2w9XCJub2NvbnRlbnRcIjozMDQ9PT1lP2w9XCJub3Rtb2RpZmllZFwiOihsPXMuc3RhdGUsbz1zLmRhdGEsaT0hKGE9cy5lcnJvcikpKTooYT1sLCFlJiZsfHwobD1cImVycm9yXCIsZTwwJiYoZT0wKSkpLFQuc3RhdHVzPWUsVC5zdGF0dXNUZXh0PSh0fHxsKStcIlwiLGk/eC5yZXNvbHZlV2l0aCh2LFtvLGwsVF0pOngucmVqZWN0V2l0aCh2LFtULGwsYV0pLFQuc3RhdHVzQ29kZSh3KSx3PXZvaWQgMCxnJiZtLnRyaWdnZXIoaT9cImFqYXhTdWNjZXNzXCI6XCJhamF4RXJyb3JcIixbVCx5LGk/bzphXSksYi5maXJlV2l0aCh2LFtULGxdKSxnJiYobS50cmlnZ2VyKFwiYWpheENvbXBsZXRlXCIsW1QseV0pLC0tUy5hY3RpdmV8fFMuZXZlbnQudHJpZ2dlcihcImFqYXhTdG9wXCIpKSl9cmV0dXJuIFR9LGdldEpTT046ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBTLmdldChlLHQsbixcImpzb25cIil9LGdldFNjcmlwdDpmdW5jdGlvbihlLHQpe3JldHVybiBTLmdldChlLHZvaWQgMCx0LFwic2NyaXB0XCIpfX0pLFMuZWFjaChbXCJnZXRcIixcInBvc3RcIl0sZnVuY3Rpb24oZSxpKXtTW2ldPWZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiBtKHQpJiYocj1yfHxuLG49dCx0PXZvaWQgMCksUy5hamF4KFMuZXh0ZW5kKHt1cmw6ZSx0eXBlOmksZGF0YVR5cGU6cixkYXRhOnQsc3VjY2VzczpufSxTLmlzUGxhaW5PYmplY3QoZSkmJmUpKX19KSxTLmFqYXhQcmVmaWx0ZXIoZnVuY3Rpb24oZSl7dmFyIHQ7Zm9yKHQgaW4gZS5oZWFkZXJzKVwiY29udGVudC10eXBlXCI9PT10LnRvTG93ZXJDYXNlKCkmJihlLmNvbnRlbnRUeXBlPWUuaGVhZGVyc1t0XXx8XCJcIil9KSxTLl9ldmFsVXJsPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gUy5hamF4KHt1cmw6ZSx0eXBlOlwiR0VUXCIsZGF0YVR5cGU6XCJzY3JpcHRcIixjYWNoZTohMCxhc3luYzohMSxnbG9iYWw6ITEsY29udmVydGVyczp7XCJ0ZXh0IHNjcmlwdFwiOmZ1bmN0aW9uKCl7fX0sZGF0YUZpbHRlcjpmdW5jdGlvbihlKXtTLmdsb2JhbEV2YWwoZSx0LG4pfX0pfSxTLmZuLmV4dGVuZCh7d3JhcEFsbDpmdW5jdGlvbihlKXt2YXIgdDtyZXR1cm4gdGhpc1swXSYmKG0oZSkmJihlPWUuY2FsbCh0aGlzWzBdKSksdD1TKGUsdGhpc1swXS5vd25lckRvY3VtZW50KS5lcSgwKS5jbG9uZSghMCksdGhpc1swXS5wYXJlbnROb2RlJiZ0Lmluc2VydEJlZm9yZSh0aGlzWzBdKSx0Lm1hcChmdW5jdGlvbigpe3ZhciBlPXRoaXM7d2hpbGUoZS5maXJzdEVsZW1lbnRDaGlsZCllPWUuZmlyc3RFbGVtZW50Q2hpbGQ7cmV0dXJuIGV9KS5hcHBlbmQodGhpcykpLHRoaXN9LHdyYXBJbm5lcjpmdW5jdGlvbihuKXtyZXR1cm4gbShuKT90aGlzLmVhY2goZnVuY3Rpb24oZSl7Uyh0aGlzKS53cmFwSW5uZXIobi5jYWxsKHRoaXMsZSkpfSk6dGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGU9Uyh0aGlzKSx0PWUuY29udGVudHMoKTt0Lmxlbmd0aD90LndyYXBBbGwobik6ZS5hcHBlbmQobil9KX0sd3JhcDpmdW5jdGlvbih0KXt2YXIgbj1tKHQpO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oZSl7Uyh0aGlzKS53cmFwQWxsKG4/dC5jYWxsKHRoaXMsZSk6dCl9KX0sdW53cmFwOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnBhcmVudChlKS5ub3QoXCJib2R5XCIpLmVhY2goZnVuY3Rpb24oKXtTKHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuY2hpbGROb2Rlcyl9KSx0aGlzfX0pLFMuZXhwci5wc2V1ZG9zLmhpZGRlbj1mdW5jdGlvbihlKXtyZXR1cm4hUy5leHByLnBzZXVkb3MudmlzaWJsZShlKX0sUy5leHByLnBzZXVkb3MudmlzaWJsZT1mdW5jdGlvbihlKXtyZXR1cm4hIShlLm9mZnNldFdpZHRofHxlLm9mZnNldEhlaWdodHx8ZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCl9LFMuYWpheFNldHRpbmdzLnhocj1mdW5jdGlvbigpe3RyeXtyZXR1cm4gbmV3IEMuWE1MSHR0cFJlcXVlc3R9Y2F0Y2goZSl7fX07dmFyIF90PXswOjIwMCwxMjIzOjIwNH0senQ9Uy5hamF4U2V0dGluZ3MueGhyKCk7di5jb3JzPSEhenQmJlwid2l0aENyZWRlbnRpYWxzXCJpbiB6dCx2LmFqYXg9enQ9ISF6dCxTLmFqYXhUcmFuc3BvcnQoZnVuY3Rpb24oaSl7dmFyIG8sYTtpZih2LmNvcnN8fHp0JiYhaS5jcm9zc0RvbWFpbilyZXR1cm57c2VuZDpmdW5jdGlvbihlLHQpe3ZhciBuLHI9aS54aHIoKTtpZihyLm9wZW4oaS50eXBlLGkudXJsLGkuYXN5bmMsaS51c2VybmFtZSxpLnBhc3N3b3JkKSxpLnhockZpZWxkcylmb3IobiBpbiBpLnhockZpZWxkcylyW25dPWkueGhyRmllbGRzW25dO2ZvcihuIGluIGkubWltZVR5cGUmJnIub3ZlcnJpZGVNaW1lVHlwZSYmci5vdmVycmlkZU1pbWVUeXBlKGkubWltZVR5cGUpLGkuY3Jvc3NEb21haW58fGVbXCJYLVJlcXVlc3RlZC1XaXRoXCJdfHwoZVtcIlgtUmVxdWVzdGVkLVdpdGhcIl09XCJYTUxIdHRwUmVxdWVzdFwiKSxlKXIuc2V0UmVxdWVzdEhlYWRlcihuLGVbbl0pO289ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKCl7byYmKG89YT1yLm9ubG9hZD1yLm9uZXJyb3I9ci5vbmFib3J0PXIub250aW1lb3V0PXIub25yZWFkeXN0YXRlY2hhbmdlPW51bGwsXCJhYm9ydFwiPT09ZT9yLmFib3J0KCk6XCJlcnJvclwiPT09ZT9cIm51bWJlclwiIT10eXBlb2Ygci5zdGF0dXM/dCgwLFwiZXJyb3JcIik6dChyLnN0YXR1cyxyLnN0YXR1c1RleHQpOnQoX3Rbci5zdGF0dXNdfHxyLnN0YXR1cyxyLnN0YXR1c1RleHQsXCJ0ZXh0XCIhPT0oci5yZXNwb25zZVR5cGV8fFwidGV4dFwiKXx8XCJzdHJpbmdcIiE9dHlwZW9mIHIucmVzcG9uc2VUZXh0P3tiaW5hcnk6ci5yZXNwb25zZX06e3RleHQ6ci5yZXNwb25zZVRleHR9LHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKX19LHIub25sb2FkPW8oKSxhPXIub25lcnJvcj1yLm9udGltZW91dD1vKFwiZXJyb3JcIiksdm9pZCAwIT09ci5vbmFib3J0P3Iub25hYm9ydD1hOnIub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7ND09PXIucmVhZHlTdGF0ZSYmQy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7byYmYSgpfSl9LG89byhcImFib3J0XCIpO3RyeXtyLnNlbmQoaS5oYXNDb250ZW50JiZpLmRhdGF8fG51bGwpfWNhdGNoKGUpe2lmKG8pdGhyb3cgZX19LGFib3J0OmZ1bmN0aW9uKCl7byYmbygpfX19KSxTLmFqYXhQcmVmaWx0ZXIoZnVuY3Rpb24oZSl7ZS5jcm9zc0RvbWFpbiYmKGUuY29udGVudHMuc2NyaXB0PSExKX0pLFMuYWpheFNldHVwKHthY2NlcHRzOntzY3JpcHQ6XCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwifSxjb250ZW50czp7c2NyaXB0Oi9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL30sY29udmVydGVyczp7XCJ0ZXh0IHNjcmlwdFwiOmZ1bmN0aW9uKGUpe3JldHVybiBTLmdsb2JhbEV2YWwoZSksZX19fSksUy5hamF4UHJlZmlsdGVyKFwic2NyaXB0XCIsZnVuY3Rpb24oZSl7dm9pZCAwPT09ZS5jYWNoZSYmKGUuY2FjaGU9ITEpLGUuY3Jvc3NEb21haW4mJihlLnR5cGU9XCJHRVRcIil9KSxTLmFqYXhUcmFuc3BvcnQoXCJzY3JpcHRcIixmdW5jdGlvbihuKXt2YXIgcixpO2lmKG4uY3Jvc3NEb21haW58fG4uc2NyaXB0QXR0cnMpcmV0dXJue3NlbmQ6ZnVuY3Rpb24oZSx0KXtyPVMoXCI8c2NyaXB0PlwiKS5hdHRyKG4uc2NyaXB0QXR0cnN8fHt9KS5wcm9wKHtjaGFyc2V0Om4uc2NyaXB0Q2hhcnNldCxzcmM6bi51cmx9KS5vbihcImxvYWQgZXJyb3JcIixpPWZ1bmN0aW9uKGUpe3IucmVtb3ZlKCksaT1udWxsLGUmJnQoXCJlcnJvclwiPT09ZS50eXBlPzQwNDoyMDAsZS50eXBlKX0pLEUuaGVhZC5hcHBlbmRDaGlsZChyWzBdKX0sYWJvcnQ6ZnVuY3Rpb24oKXtpJiZpKCl9fX0pO3ZhciBVdCxYdD1bXSxWdD0vKD0pXFw/KD89JnwkKXxcXD9cXD8vO1MuYWpheFNldHVwKHtqc29ucDpcImNhbGxiYWNrXCIsanNvbnBDYWxsYmFjazpmdW5jdGlvbigpe3ZhciBlPVh0LnBvcCgpfHxTLmV4cGFuZG8rXCJfXCIrQ3QuZ3VpZCsrO3JldHVybiB0aGlzW2VdPSEwLGV9fSksUy5hamF4UHJlZmlsdGVyKFwianNvbiBqc29ucFwiLGZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG8sYT0hMSE9PWUuanNvbnAmJihWdC50ZXN0KGUudXJsKT9cInVybFwiOlwic3RyaW5nXCI9PXR5cGVvZiBlLmRhdGEmJjA9PT0oZS5jb250ZW50VHlwZXx8XCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSYmVnQudGVzdChlLmRhdGEpJiZcImRhdGFcIik7aWYoYXx8XCJqc29ucFwiPT09ZS5kYXRhVHlwZXNbMF0pcmV0dXJuIHI9ZS5qc29ucENhbGxiYWNrPW0oZS5qc29ucENhbGxiYWNrKT9lLmpzb25wQ2FsbGJhY2soKTplLmpzb25wQ2FsbGJhY2ssYT9lW2FdPWVbYV0ucmVwbGFjZShWdCxcIiQxXCIrcik6ITEhPT1lLmpzb25wJiYoZS51cmwrPShFdC50ZXN0KGUudXJsKT9cIiZcIjpcIj9cIikrZS5qc29ucCtcIj1cIityKSxlLmNvbnZlcnRlcnNbXCJzY3JpcHQganNvblwiXT1mdW5jdGlvbigpe3JldHVybiBvfHxTLmVycm9yKHIrXCIgd2FzIG5vdCBjYWxsZWRcIiksb1swXX0sZS5kYXRhVHlwZXNbMF09XCJqc29uXCIsaT1DW3JdLENbcl09ZnVuY3Rpb24oKXtvPWFyZ3VtZW50c30sbi5hbHdheXMoZnVuY3Rpb24oKXt2b2lkIDA9PT1pP1MoQykucmVtb3ZlUHJvcChyKTpDW3JdPWksZVtyXSYmKGUuanNvbnBDYWxsYmFjaz10Lmpzb25wQ2FsbGJhY2ssWHQucHVzaChyKSksbyYmbShpKSYmaShvWzBdKSxvPWk9dm9pZCAwfSksXCJzY3JpcHRcIn0pLHYuY3JlYXRlSFRNTERvY3VtZW50PSgoVXQ9RS5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJcIikuYm9keSkuaW5uZXJIVE1MPVwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIiwyPT09VXQuY2hpbGROb2Rlcy5sZW5ndGgpLFMucGFyc2VIVE1MPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgZT9bXTooXCJib29sZWFuXCI9PXR5cGVvZiB0JiYobj10LHQ9ITEpLHR8fCh2LmNyZWF0ZUhUTUxEb2N1bWVudD8oKHI9KHQ9RS5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJcIikpLmNyZWF0ZUVsZW1lbnQoXCJiYXNlXCIpKS5ocmVmPUUubG9jYXRpb24uaHJlZix0LmhlYWQuYXBwZW5kQ2hpbGQocikpOnQ9RSksbz0hbiYmW10sKGk9Ti5leGVjKGUpKT9bdC5jcmVhdGVFbGVtZW50KGlbMV0pXTooaT14ZShbZV0sdCxvKSxvJiZvLmxlbmd0aCYmUyhvKS5yZW1vdmUoKSxTLm1lcmdlKFtdLGkuY2hpbGROb2RlcykpKTt2YXIgcixpLG99LFMuZm4ubG9hZD1mdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvLGE9dGhpcyxzPWUuaW5kZXhPZihcIiBcIik7cmV0dXJuLTE8cyYmKHI9eXQoZS5zbGljZShzKSksZT1lLnNsaWNlKDAscykpLG0odCk/KG49dCx0PXZvaWQgMCk6dCYmXCJvYmplY3RcIj09dHlwZW9mIHQmJihpPVwiUE9TVFwiKSwwPGEubGVuZ3RoJiZTLmFqYXgoe3VybDplLHR5cGU6aXx8XCJHRVRcIixkYXRhVHlwZTpcImh0bWxcIixkYXRhOnR9KS5kb25lKGZ1bmN0aW9uKGUpe289YXJndW1lbnRzLGEuaHRtbChyP1MoXCI8ZGl2PlwiKS5hcHBlbmQoUy5wYXJzZUhUTUwoZSkpLmZpbmQocik6ZSl9KS5hbHdheXMobiYmZnVuY3Rpb24oZSx0KXthLmVhY2goZnVuY3Rpb24oKXtuLmFwcGx5KHRoaXMsb3x8W2UucmVzcG9uc2VUZXh0LHQsZV0pfSl9KSx0aGlzfSxTLmV4cHIucHNldWRvcy5hbmltYXRlZD1mdW5jdGlvbih0KXtyZXR1cm4gUy5ncmVwKFMudGltZXJzLGZ1bmN0aW9uKGUpe3JldHVybiB0PT09ZS5lbGVtfSkubGVuZ3RofSxTLm9mZnNldD17c2V0T2Zmc2V0OmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG8sYSxzLHUsbD1TLmNzcyhlLFwicG9zaXRpb25cIiksYz1TKGUpLGY9e307XCJzdGF0aWNcIj09PWwmJihlLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIikscz1jLm9mZnNldCgpLG89Uy5jc3MoZSxcInRvcFwiKSx1PVMuY3NzKGUsXCJsZWZ0XCIpLChcImFic29sdXRlXCI9PT1sfHxcImZpeGVkXCI9PT1sKSYmLTE8KG8rdSkuaW5kZXhPZihcImF1dG9cIik/KGE9KHI9Yy5wb3NpdGlvbigpKS50b3AsaT1yLmxlZnQpOihhPXBhcnNlRmxvYXQobyl8fDAsaT1wYXJzZUZsb2F0KHUpfHwwKSxtKHQpJiYodD10LmNhbGwoZSxuLFMuZXh0ZW5kKHt9LHMpKSksbnVsbCE9dC50b3AmJihmLnRvcD10LnRvcC1zLnRvcCthKSxudWxsIT10LmxlZnQmJihmLmxlZnQ9dC5sZWZ0LXMubGVmdCtpKSxcInVzaW5nXCJpbiB0P3QudXNpbmcuY2FsbChlLGYpOmMuY3NzKGYpfX0sUy5mbi5leHRlbmQoe29mZnNldDpmdW5jdGlvbih0KXtpZihhcmd1bWVudHMubGVuZ3RoKXJldHVybiB2b2lkIDA9PT10P3RoaXM6dGhpcy5lYWNoKGZ1bmN0aW9uKGUpe1Mub2Zmc2V0LnNldE9mZnNldCh0aGlzLHQsZSl9KTt2YXIgZSxuLHI9dGhpc1swXTtyZXR1cm4gcj9yLmdldENsaWVudFJlY3RzKCkubGVuZ3RoPyhlPXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksbj1yLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcse3RvcDplLnRvcCtuLnBhZ2VZT2Zmc2V0LGxlZnQ6ZS5sZWZ0K24ucGFnZVhPZmZzZXR9KTp7dG9wOjAsbGVmdDowfTp2b2lkIDB9LHBvc2l0aW9uOmZ1bmN0aW9uKCl7aWYodGhpc1swXSl7dmFyIGUsdCxuLHI9dGhpc1swXSxpPXt0b3A6MCxsZWZ0OjB9O2lmKFwiZml4ZWRcIj09PVMuY3NzKHIsXCJwb3NpdGlvblwiKSl0PXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7ZWxzZXt0PXRoaXMub2Zmc2V0KCksbj1yLm93bmVyRG9jdW1lbnQsZT1yLm9mZnNldFBhcmVudHx8bi5kb2N1bWVudEVsZW1lbnQ7d2hpbGUoZSYmKGU9PT1uLmJvZHl8fGU9PT1uLmRvY3VtZW50RWxlbWVudCkmJlwic3RhdGljXCI9PT1TLmNzcyhlLFwicG9zaXRpb25cIikpZT1lLnBhcmVudE5vZGU7ZSYmZSE9PXImJjE9PT1lLm5vZGVUeXBlJiYoKGk9UyhlKS5vZmZzZXQoKSkudG9wKz1TLmNzcyhlLFwiYm9yZGVyVG9wV2lkdGhcIiwhMCksaS5sZWZ0Kz1TLmNzcyhlLFwiYm9yZGVyTGVmdFdpZHRoXCIsITApKX1yZXR1cm57dG9wOnQudG9wLWkudG9wLVMuY3NzKHIsXCJtYXJnaW5Ub3BcIiwhMCksbGVmdDp0LmxlZnQtaS5sZWZ0LVMuY3NzKHIsXCJtYXJnaW5MZWZ0XCIsITApfX19LG9mZnNldFBhcmVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3ZhciBlPXRoaXMub2Zmc2V0UGFyZW50O3doaWxlKGUmJlwic3RhdGljXCI9PT1TLmNzcyhlLFwicG9zaXRpb25cIikpZT1lLm9mZnNldFBhcmVudDtyZXR1cm4gZXx8cmV9KX19KSxTLmVhY2goe3Njcm9sbExlZnQ6XCJwYWdlWE9mZnNldFwiLHNjcm9sbFRvcDpcInBhZ2VZT2Zmc2V0XCJ9LGZ1bmN0aW9uKHQsaSl7dmFyIG89XCJwYWdlWU9mZnNldFwiPT09aTtTLmZuW3RdPWZ1bmN0aW9uKGUpe3JldHVybiBCKHRoaXMsZnVuY3Rpb24oZSx0LG4pe3ZhciByO2lmKHgoZSk/cj1lOjk9PT1lLm5vZGVUeXBlJiYocj1lLmRlZmF1bHRWaWV3KSx2b2lkIDA9PT1uKXJldHVybiByP3JbaV06ZVt0XTtyP3Iuc2Nyb2xsVG8obz9yLnBhZ2VYT2Zmc2V0Om4sbz9uOnIucGFnZVlPZmZzZXQpOmVbdF09bn0sdCxlLGFyZ3VtZW50cy5sZW5ndGgpfX0pLFMuZWFjaChbXCJ0b3BcIixcImxlZnRcIl0sZnVuY3Rpb24oZSxuKXtTLmNzc0hvb2tzW25dPV9lKHYucGl4ZWxQb3NpdGlvbixmdW5jdGlvbihlLHQpe2lmKHQpcmV0dXJuIHQ9QmUoZSxuKSxQZS50ZXN0KHQpP1MoZSkucG9zaXRpb24oKVtuXStcInB4XCI6dH0pfSksUy5lYWNoKHtIZWlnaHQ6XCJoZWlnaHRcIixXaWR0aDpcIndpZHRoXCJ9LGZ1bmN0aW9uKGEscyl7Uy5lYWNoKHtwYWRkaW5nOlwiaW5uZXJcIithLGNvbnRlbnQ6cyxcIlwiOlwib3V0ZXJcIithfSxmdW5jdGlvbihyLG8pe1MuZm5bb109ZnVuY3Rpb24oZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoJiYocnx8XCJib29sZWFuXCIhPXR5cGVvZiBlKSxpPXJ8fCghMD09PWV8fCEwPT09dD9cIm1hcmdpblwiOlwiYm9yZGVyXCIpO3JldHVybiBCKHRoaXMsZnVuY3Rpb24oZSx0LG4pe3ZhciByO3JldHVybiB4KGUpPzA9PT1vLmluZGV4T2YoXCJvdXRlclwiKT9lW1wiaW5uZXJcIithXTplLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtcImNsaWVudFwiK2FdOjk9PT1lLm5vZGVUeXBlPyhyPWUuZG9jdW1lbnRFbGVtZW50LE1hdGgubWF4KGUuYm9keVtcInNjcm9sbFwiK2FdLHJbXCJzY3JvbGxcIithXSxlLmJvZHlbXCJvZmZzZXRcIithXSxyW1wib2Zmc2V0XCIrYV0scltcImNsaWVudFwiK2FdKSk6dm9pZCAwPT09bj9TLmNzcyhlLHQsaSk6Uy5zdHlsZShlLHQsbixpKX0scyxuP2U6dm9pZCAwLG4pfX0pfSksUy5lYWNoKFtcImFqYXhTdGFydFwiLFwiYWpheFN0b3BcIixcImFqYXhDb21wbGV0ZVwiLFwiYWpheEVycm9yXCIsXCJhamF4U3VjY2Vzc1wiLFwiYWpheFNlbmRcIl0sZnVuY3Rpb24oZSx0KXtTLmZuW3RdPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9uKHQsZSl9fSksUy5mbi5leHRlbmQoe2JpbmQ6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB0aGlzLm9uKGUsbnVsbCx0LG4pfSx1bmJpbmQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5vZmYoZSxudWxsLHQpfSxkZWxlZ2F0ZTpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gdGhpcy5vbih0LGUsbixyKX0sdW5kZWxlZ2F0ZTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIDE9PT1hcmd1bWVudHMubGVuZ3RoP3RoaXMub2ZmKGUsXCIqKlwiKTp0aGlzLm9mZih0LGV8fFwiKipcIixuKX0saG92ZXI6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5tb3VzZWVudGVyKGUpLm1vdXNlbGVhdmUodHx8ZSl9fSksUy5lYWNoKFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihlLG4pe1MuZm5bbl09ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMDxhcmd1bWVudHMubGVuZ3RoP3RoaXMub24obixudWxsLGUsdCk6dGhpcy50cmlnZ2VyKG4pfX0pO3ZhciBHdD0vXltcXHNcXHVGRUZGXFx4QTBdK3woW15cXHNcXHVGRUZGXFx4QTBdKVtcXHNcXHVGRUZGXFx4QTBdKyQvZztTLnByb3h5PWZ1bmN0aW9uKGUsdCl7dmFyIG4scixpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0JiYobj1lW3RdLHQ9ZSxlPW4pLG0oZSkpcmV0dXJuIHI9cy5jYWxsKGFyZ3VtZW50cywyKSwoaT1mdW5jdGlvbigpe3JldHVybiBlLmFwcGx5KHR8fHRoaXMsci5jb25jYXQocy5jYWxsKGFyZ3VtZW50cykpKX0pLmd1aWQ9ZS5ndWlkPWUuZ3VpZHx8Uy5ndWlkKyssaX0sUy5ob2xkUmVhZHk9ZnVuY3Rpb24oZSl7ZT9TLnJlYWR5V2FpdCsrOlMucmVhZHkoITApfSxTLmlzQXJyYXk9QXJyYXkuaXNBcnJheSxTLnBhcnNlSlNPTj1KU09OLnBhcnNlLFMubm9kZU5hbWU9QSxTLmlzRnVuY3Rpb249bSxTLmlzV2luZG93PXgsUy5jYW1lbENhc2U9WCxTLnR5cGU9dyxTLm5vdz1EYXRlLm5vdyxTLmlzTnVtZXJpYz1mdW5jdGlvbihlKXt2YXIgdD1TLnR5cGUoZSk7cmV0dXJuKFwibnVtYmVyXCI9PT10fHxcInN0cmluZ1wiPT09dCkmJiFpc05hTihlLXBhcnNlRmxvYXQoZSkpfSxTLnRyaW09ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWU/XCJcIjooZStcIlwiKS5yZXBsYWNlKEd0LFwiJDFcIil9LFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZCYmZGVmaW5lKFwianF1ZXJ5XCIsW10sZnVuY3Rpb24oKXtyZXR1cm4gU30pO3ZhciBZdD1DLmpRdWVyeSxRdD1DLiQ7cmV0dXJuIFMubm9Db25mbGljdD1mdW5jdGlvbihlKXtyZXR1cm4gQy4kPT09UyYmKEMuJD1RdCksZSYmQy5qUXVlcnk9PT1TJiYoQy5qUXVlcnk9WXQpLFN9LFwidW5kZWZpbmVkXCI9PXR5cGVvZiBlJiYoQy5qUXVlcnk9Qy4kPVMpLFN9KTsiLCIvKipcclxuICogU3dpcGVyIDguNC43XHJcbiAqIE1vc3QgbW9kZXJuIG1vYmlsZSB0b3VjaCBzbGlkZXIgYW5kIGZyYW1ld29yayB3aXRoIGhhcmR3YXJlIGFjY2VsZXJhdGVkIHRyYW5zaXRpb25zXHJcbiAqIGh0dHBzOi8vc3dpcGVyanMuY29tXHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDE0LTIwMjMgVmxhZGltaXIgS2hhcmxhbXBpZGlcclxuICpcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXHJcbiAqXHJcbiAqIFJlbGVhc2VkIG9uOiBKYW51YXJ5IDMwLCAyMDIzXHJcbiAqL1xyXG5cclxuIWZ1bmN0aW9uIChlLCB0KSB7XHJcbiAgICBcIm9iamVjdFwiID09IHR5cGVvZiBleHBvcnRzICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIG1vZHVsZSA/IG1vZHVsZS5leHBvcnRzID0gdCgpIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSh0KSA6IChlID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMgOiBlIHx8IHNlbGYpLlN3aXBlciA9IHQoKVxyXG59KHRoaXMsIChmdW5jdGlvbiAoKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICBmdW5jdGlvbiBlKGUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbCAhPT0gZSAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBlICYmIFwiY29uc3RydWN0b3JcIiBpbiBlICYmIGUuY29uc3RydWN0b3IgPT09IE9iamVjdFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHQocywgYSkge1xyXG4gICAgICAgIHZvaWQgMCA9PT0gcyAmJiAocyA9IHt9KSwgdm9pZCAwID09PSBhICYmIChhID0ge30pLCBPYmplY3Qua2V5cyhhKS5mb3JFYWNoKChpID0+IHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBzW2ldID8gc1tpXSA9IGFbaV0gOiBlKGFbaV0pICYmIGUoc1tpXSkgJiYgT2JqZWN0LmtleXMoYVtpXSkubGVuZ3RoID4gMCAmJiB0KHNbaV0sIGFbaV0pXHJcbiAgICAgICAgfSkpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcyA9IHtcclxuICAgICAgICBib2R5OiB7fSxcclxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCkge1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFjdGl2ZUVsZW1lbnQ6IHtcclxuICAgICAgICAgICAgYmx1cigpIHtcclxuICAgICAgICAgICAgfSwgbm9kZU5hbWU6IFwiXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIHF1ZXJ5U2VsZWN0b3I6ICgpID0+IG51bGwsXHJcbiAgICAgICAgcXVlcnlTZWxlY3RvckFsbDogKCkgPT4gW10sXHJcbiAgICAgICAgZ2V0RWxlbWVudEJ5SWQ6ICgpID0+IG51bGwsXHJcbiAgICAgICAgY3JlYXRlRXZlbnQ6ICgpID0+ICh7XHJcbiAgICAgICAgICAgIGluaXRFdmVudCgpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQ6ICgpID0+ICh7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSwgY2hpbGROb2RlczogW10sIHN0eWxlOiB7fSwgc2V0QXR0cmlidXRlKCkge1xyXG4gICAgICAgICAgICB9LCBnZXRFbGVtZW50c0J5VGFnTmFtZTogKCkgPT4gW11cclxuICAgICAgICB9KSxcclxuICAgICAgICBjcmVhdGVFbGVtZW50TlM6ICgpID0+ICh7fSksXHJcbiAgICAgICAgaW1wb3J0Tm9kZTogKCkgPT4gbnVsbCxcclxuICAgICAgICBsb2NhdGlvbjoge2hhc2g6IFwiXCIsIGhvc3Q6IFwiXCIsIGhvc3RuYW1lOiBcIlwiLCBocmVmOiBcIlwiLCBvcmlnaW46IFwiXCIsIHBhdGhuYW1lOiBcIlwiLCBwcm90b2NvbDogXCJcIiwgc2VhcmNoOiBcIlwifVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBhKCkge1xyXG4gICAgICAgIGNvbnN0IGUgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBkb2N1bWVudCA/IGRvY3VtZW50IDoge307XHJcbiAgICAgICAgcmV0dXJuIHQoZSwgcyksIGVcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpID0ge1xyXG4gICAgICAgIGRvY3VtZW50OiBzLFxyXG4gICAgICAgIG5hdmlnYXRvcjoge3VzZXJBZ2VudDogXCJcIn0sXHJcbiAgICAgICAgbG9jYXRpb246IHtoYXNoOiBcIlwiLCBob3N0OiBcIlwiLCBob3N0bmFtZTogXCJcIiwgaHJlZjogXCJcIiwgb3JpZ2luOiBcIlwiLCBwYXRobmFtZTogXCJcIiwgcHJvdG9jb2w6IFwiXCIsIHNlYXJjaDogXCJcIn0sXHJcbiAgICAgICAgaGlzdG9yeToge1xyXG4gICAgICAgICAgICByZXBsYWNlU3RhdGUoKSB7XHJcbiAgICAgICAgICAgIH0sIHB1c2hTdGF0ZSgpIHtcclxuICAgICAgICAgICAgfSwgZ28oKSB7XHJcbiAgICAgICAgICAgIH0sIGJhY2soKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIEN1c3RvbUV2ZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKCkge1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldENvbXB1dGVkU3R5bGU6ICgpID0+ICh7Z2V0UHJvcGVydHlWYWx1ZTogKCkgPT4gXCJcIn0pLFxyXG4gICAgICAgIEltYWdlKCkge1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgRGF0ZSgpIHtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNjcmVlbjoge30sXHJcbiAgICAgICAgc2V0VGltZW91dCgpIHtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsZWFyVGltZW91dCgpIHtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1hdGNoTWVkaWE6ICgpID0+ICh7fSksXHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lOiBlID0+IFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIHNldFRpbWVvdXQgPyAoZSgpLCBudWxsKSA6IHNldFRpbWVvdXQoZSwgMCksXHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZSkge1xyXG4gICAgICAgICAgICBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBzZXRUaW1lb3V0ICYmIGNsZWFyVGltZW91dChlKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcigpIHtcclxuICAgICAgICBjb25zdCBlID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ID8gd2luZG93IDoge307XHJcbiAgICAgICAgcmV0dXJuIHQoZSwgaSksIGVcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBuIGV4dGVuZHMgQXJyYXkge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGUpIHtcclxuICAgICAgICAgICAgXCJudW1iZXJcIiA9PSB0eXBlb2YgZSA/IHN1cGVyKGUpIDogKHN1cGVyKC4uLmUgfHwgW10pLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IGUuX19wcm90b19fO1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwiX19wcm90b19fXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHQsIHNldChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuX19wcm90b19fID0gZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0odGhpcykpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGwoZSkge1xyXG4gICAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IFtdKTtcclxuICAgICAgICBjb25zdCB0ID0gW107XHJcbiAgICAgICAgcmV0dXJuIGUuZm9yRWFjaCgoZSA9PiB7XHJcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZSkgPyB0LnB1c2goLi4ubChlKSkgOiB0LnB1c2goZSlcclxuICAgICAgICB9KSksIHRcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvKGUsIHQpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGUsIHQpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZChlLCB0KSB7XHJcbiAgICAgICAgY29uc3QgcyA9IHIoKSwgaSA9IGEoKTtcclxuICAgICAgICBsZXQgbCA9IFtdO1xyXG4gICAgICAgIGlmICghdCAmJiBlIGluc3RhbmNlb2YgbikgcmV0dXJuIGU7XHJcbiAgICAgICAgaWYgKCFlKSByZXR1cm4gbmV3IG4obCk7XHJcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcclxuICAgICAgICAgICAgY29uc3QgcyA9IGUudHJpbSgpO1xyXG4gICAgICAgICAgICBpZiAocy5pbmRleE9mKFwiPFwiKSA+PSAwICYmIHMuaW5kZXhPZihcIj5cIikgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGUgPSBcImRpdlwiO1xyXG4gICAgICAgICAgICAgICAgMCA9PT0gcy5pbmRleE9mKFwiPGxpXCIpICYmIChlID0gXCJ1bFwiKSwgMCA9PT0gcy5pbmRleE9mKFwiPHRyXCIpICYmIChlID0gXCJ0Ym9keVwiKSwgMCAhPT0gcy5pbmRleE9mKFwiPHRkXCIpICYmIDAgIT09IHMuaW5kZXhPZihcIjx0aFwiKSB8fCAoZSA9IFwidHJcIiksIDAgPT09IHMuaW5kZXhPZihcIjx0Ym9keVwiKSAmJiAoZSA9IFwidGFibGVcIiksIDAgPT09IHMuaW5kZXhPZihcIjxvcHRpb25cIikgJiYgKGUgPSBcInNlbGVjdFwiKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBpLmNyZWF0ZUVsZW1lbnQoZSk7XHJcbiAgICAgICAgICAgICAgICB0LmlubmVySFRNTCA9IHM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlID0gMDsgZSA8IHQuY2hpbGROb2Rlcy5sZW5ndGg7IGUgKz0gMSkgbC5wdXNoKHQuY2hpbGROb2Rlc1tlXSlcclxuICAgICAgICAgICAgfSBlbHNlIGwgPSBmdW5jdGlvbiAoZSwgdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGUpIHJldHVybiBbZV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gW10sIGEgPSB0LnF1ZXJ5U2VsZWN0b3JBbGwoZSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlID0gMDsgZSA8IGEubGVuZ3RoOyBlICs9IDEpIHMucHVzaChhW2VdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzXHJcbiAgICAgICAgICAgIH0oZS50cmltKCksIHQgfHwgaSlcclxuICAgICAgICB9IGVsc2UgaWYgKGUubm9kZVR5cGUgfHwgZSA9PT0gcyB8fCBlID09PSBpKSBsLnB1c2goZSk7IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcclxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBuKSByZXR1cm4gZTtcclxuICAgICAgICAgICAgbCA9IGVcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBuKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBlLmxlbmd0aDsgcyArPSAxKSAtMSA9PT0gdC5pbmRleE9mKGVbc10pICYmIHQucHVzaChlW3NdKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRcclxuICAgICAgICB9KGwpKVxyXG4gICAgfVxyXG5cclxuICAgIGQuZm4gPSBuLnByb3RvdHlwZTtcclxuICAgIGNvbnN0IGMgPSB7XHJcbiAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoZSksIHMgPSAwOyBzIDwgZTsgcysrKSB0W3NdID0gYXJndW1lbnRzW3NdO1xyXG4gICAgICAgICAgICBjb25zdCBhID0gbCh0Lm1hcCgoZSA9PiBlLnNwbGl0KFwiIFwiKSkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlLmNsYXNzTGlzdC5hZGQoLi4uYSlcclxuICAgICAgICAgICAgfSkpLCB0aGlzXHJcbiAgICAgICAgfSwgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoZSksIHMgPSAwOyBzIDwgZTsgcysrKSB0W3NdID0gYXJndW1lbnRzW3NdO1xyXG4gICAgICAgICAgICBjb25zdCBhID0gbCh0Lm1hcCgoZSA9PiBlLnNwbGl0KFwiIFwiKSkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9yRWFjaCgoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlLmNsYXNzTGlzdC5yZW1vdmUoLi4uYSlcclxuICAgICAgICAgICAgfSkpLCB0aGlzXHJcbiAgICAgICAgfSwgaGFzQ2xhc3M6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoZSksIHMgPSAwOyBzIDwgZTsgcysrKSB0W3NdID0gYXJndW1lbnRzW3NdO1xyXG4gICAgICAgICAgICBjb25zdCBhID0gbCh0Lm1hcCgoZSA9PiBlLnNwbGl0KFwiIFwiKSkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG8odGhpcywgKGUgPT4gYS5maWx0ZXIoKHQgPT4gZS5jbGFzc0xpc3QuY29udGFpbnModCkpKS5sZW5ndGggPiAwKSkubGVuZ3RoID4gMFxyXG4gICAgICAgIH0sIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGUgPSBhcmd1bWVudHMubGVuZ3RoLCB0ID0gbmV3IEFycmF5KGUpLCBzID0gMDsgcyA8IGU7IHMrKykgdFtzXSA9IGFyZ3VtZW50c1tzXTtcclxuICAgICAgICAgICAgY29uc3QgYSA9IGwodC5tYXAoKGUgPT4gZS5zcGxpdChcIiBcIikpKSk7XHJcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaCgoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhLmZvckVhY2goKHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGUuY2xhc3NMaXN0LnRvZ2dsZSh0KVxyXG4gICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgIH0sIGF0dHI6IGZ1bmN0aW9uIChlLCB0KSB7XHJcbiAgICAgICAgICAgIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHJldHVybiB0aGlzWzBdID8gdGhpc1swXS5nZXRBdHRyaWJ1dGUoZSkgOiB2b2lkIDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgdGhpcy5sZW5ndGg7IHMgKz0gMSkgaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHRoaXNbc10uc2V0QXR0cmlidXRlKGUsIHQpOyBlbHNlIGZvciAoY29uc3QgdCBpbiBlKSB0aGlzW3NdW3RdID0gZVt0XSwgdGhpc1tzXS5zZXRBdHRyaWJ1dGUodCwgZVt0XSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgcmVtb3ZlQXR0cjogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLmxlbmd0aDsgdCArPSAxKSB0aGlzW3RdLnJlbW92ZUF0dHJpYnV0ZShlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCB0cmFuc2Zvcm06IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdGhpcy5sZW5ndGg7IHQgKz0gMSkgdGhpc1t0XS5zdHlsZS50cmFuc2Zvcm0gPSBlO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHRyYW5zaXRpb246IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdGhpcy5sZW5ndGg7IHQgKz0gMSkgdGhpc1t0XS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBcInN0cmluZ1wiICE9IHR5cGVvZiBlID8gYCR7ZX1tc2AgOiBlO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIG9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGUgPSBhcmd1bWVudHMubGVuZ3RoLCB0ID0gbmV3IEFycmF5KGUpLCBzID0gMDsgcyA8IGU7IHMrKykgdFtzXSA9IGFyZ3VtZW50c1tzXTtcclxuICAgICAgICAgICAgbGV0IFthLCBpLCByLCBuXSA9IHQ7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBsKGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlLnRhcmdldDtcclxuICAgICAgICAgICAgICAgIGlmICghdCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGUudGFyZ2V0LmRvbTdFdmVudERhdGEgfHwgW107XHJcbiAgICAgICAgICAgICAgICBpZiAocy5pbmRleE9mKGUpIDwgMCAmJiBzLnVuc2hpZnQoZSksIGQodCkuaXMoaSkpIHIuYXBwbHkodCwgcyk7IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBkKHQpLnBhcmVudHMoKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0ICs9IDEpIGQoZVt0XSkuaXMoaSkgJiYgci5hcHBseShlW3RdLCBzKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBvKGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlICYmIGUudGFyZ2V0ICYmIGUudGFyZ2V0LmRvbTdFdmVudERhdGEgfHwgW107XHJcbiAgICAgICAgICAgICAgICB0LmluZGV4T2YoZSkgPCAwICYmIHQudW5zaGlmdChlKSwgci5hcHBseSh0aGlzLCB0KVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHRbMV0gJiYgKFthLCByLCBuXSA9IHQsIGkgPSB2b2lkIDApLCBuIHx8IChuID0gITEpO1xyXG4gICAgICAgICAgICBjb25zdCBjID0gYS5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgICAgIGxldCBwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBlID0gMDsgZSA8IHRoaXMubGVuZ3RoOyBlICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzW2VdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGkpIGZvciAocCA9IDA7IHAgPCBjLmxlbmd0aDsgcCArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGNbcF07XHJcbiAgICAgICAgICAgICAgICAgICAgdC5kb203TGl2ZUxpc3RlbmVycyB8fCAodC5kb203TGl2ZUxpc3RlbmVycyA9IHt9KSwgdC5kb203TGl2ZUxpc3RlbmVyc1tlXSB8fCAodC5kb203TGl2ZUxpc3RlbmVyc1tlXSA9IFtdKSwgdC5kb203TGl2ZUxpc3RlbmVyc1tlXS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXI6IHIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5TGlzdGVuZXI6IGxcclxuICAgICAgICAgICAgICAgICAgICB9KSwgdC5hZGRFdmVudExpc3RlbmVyKGUsIGwsIG4pXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgZm9yIChwID0gMDsgcCA8IGMubGVuZ3RoOyBwICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gY1twXTtcclxuICAgICAgICAgICAgICAgICAgICB0LmRvbTdMaXN0ZW5lcnMgfHwgKHQuZG9tN0xpc3RlbmVycyA9IHt9KSwgdC5kb203TGlzdGVuZXJzW2VdIHx8ICh0LmRvbTdMaXN0ZW5lcnNbZV0gPSBbXSksIHQuZG9tN0xpc3RlbmVyc1tlXS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXI6IHIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5TGlzdGVuZXI6IG9cclxuICAgICAgICAgICAgICAgICAgICB9KSwgdC5hZGRFdmVudExpc3RlbmVyKGUsIG8sIG4pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBvZmY6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoZSksIHMgPSAwOyBzIDwgZTsgcysrKSB0W3NdID0gYXJndW1lbnRzW3NdO1xyXG4gICAgICAgICAgICBsZXQgW2EsIGksIHIsIG5dID0gdDtcclxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09IHR5cGVvZiB0WzFdICYmIChbYSwgciwgbl0gPSB0LCBpID0gdm9pZCAwKSwgbiB8fCAobiA9ICExKTtcclxuICAgICAgICAgICAgY29uc3QgbCA9IGEuc3BsaXQoXCIgXCIpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBlID0gMDsgZSA8IGwubGVuZ3RoOyBlICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBsW2VdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZSA9IDA7IGUgPCB0aGlzLmxlbmd0aDsgZSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IHRoaXNbZV07XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpICYmIHMuZG9tN0xpc3RlbmVycyA/IGEgPSBzLmRvbTdMaXN0ZW5lcnNbdF0gOiBpICYmIHMuZG9tN0xpdmVMaXN0ZW5lcnMgJiYgKGEgPSBzLmRvbTdMaXZlTGlzdGVuZXJzW3RdKSwgYSAmJiBhLmxlbmd0aCkgZm9yIChsZXQgZSA9IGEubGVuZ3RoIC0gMTsgZSA+PSAwOyBlIC09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaSA9IGFbZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgJiYgaS5saXN0ZW5lciA9PT0gciB8fCByICYmIGkubGlzdGVuZXIgJiYgaS5saXN0ZW5lci5kb203cHJveHkgJiYgaS5saXN0ZW5lci5kb203cHJveHkgPT09IHIgPyAocy5yZW1vdmVFdmVudExpc3RlbmVyKHQsIGkucHJveHlMaXN0ZW5lciwgbiksIGEuc3BsaWNlKGUsIDEpKSA6IHIgfHwgKHMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LCBpLnByb3h5TGlzdGVuZXIsIG4pLCBhLnNwbGljZShlLCAxKSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCB0cmlnZ2VyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSByKCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSBhcmd1bWVudHMubGVuZ3RoLCBzID0gbmV3IEFycmF5KHQpLCBhID0gMDsgYSA8IHQ7IGErKykgc1thXSA9IGFyZ3VtZW50c1thXTtcclxuICAgICAgICAgICAgY29uc3QgaSA9IHNbMF0uc3BsaXQoXCIgXCIpLCBuID0gc1sxXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCBpLmxlbmd0aDsgdCArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gaVt0XTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdGhpcy5sZW5ndGg7IHQgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGkgPSB0aGlzW3RdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLkN1c3RvbUV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBuZXcgZS5DdXN0b21FdmVudChhLCB7ZGV0YWlsOiBuLCBidWJibGVzOiAhMCwgY2FuY2VsYWJsZTogITB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaS5kb203RXZlbnREYXRhID0gcy5maWx0ZXIoKChlLCB0KSA9PiB0ID4gMCkpLCBpLmRpc3BhdGNoRXZlbnQodCksIGkuZG9tN0V2ZW50RGF0YSA9IFtdLCBkZWxldGUgaS5kb203RXZlbnREYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgdHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgY29uc3QgdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBlICYmIHQub24oXCJ0cmFuc2l0aW9uZW5kXCIsIChmdW5jdGlvbiBzKGEpIHtcclxuICAgICAgICAgICAgICAgIGEudGFyZ2V0ID09PSB0aGlzICYmIChlLmNhbGwodGhpcywgYSksIHQub2ZmKFwidHJhbnNpdGlvbmVuZFwiLCBzKSlcclxuICAgICAgICAgICAgfSkpLCB0aGlzXHJcbiAgICAgICAgfSwgb3V0ZXJXaWR0aDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gdGhpcy5zdHlsZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1swXS5vZmZzZXRXaWR0aCArIHBhcnNlRmxvYXQoZS5nZXRQcm9wZXJ0eVZhbHVlKFwibWFyZ2luLXJpZ2h0XCIpKSArIHBhcnNlRmxvYXQoZS5nZXRQcm9wZXJ0eVZhbHVlKFwibWFyZ2luLWxlZnRcIikpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1swXS5vZmZzZXRXaWR0aFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgICAgfSwgb3V0ZXJIZWlnaHQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IHRoaXMuc3R5bGVzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF0ub2Zmc2V0SGVpZ2h0ICsgcGFyc2VGbG9hdChlLmdldFByb3BlcnR5VmFsdWUoXCJtYXJnaW4tdG9wXCIpKSArIHBhcnNlRmxvYXQoZS5nZXRQcm9wZXJ0eVZhbHVlKFwibWFyZ2luLWJvdHRvbVwiKSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzWzBdLm9mZnNldEhlaWdodFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgICAgfSwgc3R5bGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSByKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzWzBdID8gZS5nZXRDb21wdXRlZFN0eWxlKHRoaXNbMF0sIG51bGwpIDoge31cclxuICAgICAgICB9LCBvZmZzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHIoKSwgdCA9IGEoKSwgcyA9IHRoaXNbMF0sIGkgPSBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBuID0gdC5ib2R5LFxyXG4gICAgICAgICAgICAgICAgICAgIGwgPSBzLmNsaWVudFRvcCB8fCBuLmNsaWVudFRvcCB8fCAwLCBvID0gcy5jbGllbnRMZWZ0IHx8IG4uY2xpZW50TGVmdCB8fCAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGQgPSBzID09PSBlID8gZS5zY3JvbGxZIDogcy5zY3JvbGxUb3AsIGMgPSBzID09PSBlID8gZS5zY3JvbGxYIDogcy5zY3JvbGxMZWZ0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt0b3A6IGkudG9wICsgZCAtIGwsIGxlZnQ6IGkubGVmdCArIGMgLSBvfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgICAgfSwgY3NzOiBmdW5jdGlvbiAoZSwgdCkge1xyXG4gICAgICAgICAgICBjb25zdCBzID0gcigpO1xyXG4gICAgICAgICAgICBsZXQgYTtcclxuICAgICAgICAgICAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChhID0gMDsgYSA8IHRoaXMubGVuZ3RoOyBhICs9IDEpIGZvciAoY29uc3QgdCBpbiBlKSB0aGlzW2FdLnN0eWxlW3RdID0gZVt0XTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbMF0pIHJldHVybiBzLmdldENvbXB1dGVkU3R5bGUodGhpc1swXSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgyID09PSBhcmd1bWVudHMubGVuZ3RoICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoYSA9IDA7IGEgPCB0aGlzLmxlbmd0aDsgYSArPSAxKSB0aGlzW2FdLnN0eWxlW2VdID0gdDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBlYWNoOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZSA/ICh0aGlzLmZvckVhY2goKCh0LCBzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlLmFwcGx5KHQsIFt0LCBzXSlcclxuICAgICAgICAgICAgfSkpLCB0aGlzKSA6IHRoaXNcclxuICAgICAgICB9LCBodG1sOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwID09PSBlKSByZXR1cm4gdGhpc1swXSA/IHRoaXNbMF0uaW5uZXJIVE1MIDogbnVsbDtcclxuICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLmxlbmd0aDsgdCArPSAxKSB0aGlzW3RdLmlubmVySFRNTCA9IGU7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgdGV4dDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZSkgcmV0dXJuIHRoaXNbMF0gPyB0aGlzWzBdLnRleHRDb250ZW50LnRyaW0oKSA6IG51bGw7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdGhpcy5sZW5ndGg7IHQgKz0gMSkgdGhpc1t0XS50ZXh0Q29udGVudCA9IGU7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgaXM6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSByKCksIHMgPSBhKCksIGkgPSB0aGlzWzBdO1xyXG4gICAgICAgICAgICBsZXQgbCwgbztcclxuICAgICAgICAgICAgaWYgKCFpIHx8IHZvaWQgMCA9PT0gZSkgcmV0dXJuICExO1xyXG4gICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkubWF0Y2hlcykgcmV0dXJuIGkubWF0Y2hlcyhlKTtcclxuICAgICAgICAgICAgICAgIGlmIChpLndlYmtpdE1hdGNoZXNTZWxlY3RvcikgcmV0dXJuIGkud2Via2l0TWF0Y2hlc1NlbGVjdG9yKGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGkubXNNYXRjaGVzU2VsZWN0b3IpIHJldHVybiBpLm1zTWF0Y2hlc1NlbGVjdG9yKGUpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsID0gZChlKSwgbyA9IDA7IG8gPCBsLmxlbmd0aDsgbyArPSAxKSBpZiAobFtvXSA9PT0gaSkgcmV0dXJuICEwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICExXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGUgPT09IHMpIHJldHVybiBpID09PSBzO1xyXG4gICAgICAgICAgICBpZiAoZSA9PT0gdCkgcmV0dXJuIGkgPT09IHQ7XHJcbiAgICAgICAgICAgIGlmIChlLm5vZGVUeXBlIHx8IGUgaW5zdGFuY2VvZiBuKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGwgPSBlLm5vZGVUeXBlID8gW2VdIDogZSwgbyA9IDA7IG8gPCBsLmxlbmd0aDsgbyArPSAxKSBpZiAobFtvXSA9PT0gaSkgcmV0dXJuICEwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICExXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICExXHJcbiAgICAgICAgfSwgaW5kZXg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbGV0IGUsIHQgPSB0aGlzWzBdO1xyXG4gICAgICAgICAgICBpZiAodCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChlID0gMDsgbnVsbCAhPT0gKHQgPSB0LnByZXZpb3VzU2libGluZyk7KSAxID09PSB0Lm5vZGVUeXBlICYmIChlICs9IDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGVxOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwID09PSBlKSByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoZSA+IHQgLSAxKSByZXR1cm4gZChbXSk7XHJcbiAgICAgICAgICAgIGlmIChlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IHQgKyBlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQocyA8IDAgPyBbXSA6IFt0aGlzW3NdXSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZChbdGhpc1tlXV0pXHJcbiAgICAgICAgfSwgYXBwZW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGxldCBlO1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gYSgpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgZSA9IHMgPCAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gcyA/IHZvaWQgMCA6IGFyZ3VtZW50c1tzXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgdGhpcy5sZW5ndGg7IHMgKz0gMSkgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoYS5pbm5lckhUTUwgPSBlOyBhLmZpcnN0Q2hpbGQ7KSB0aGlzW3NdLmFwcGVuZENoaWxkKGEuZmlyc3RDaGlsZClcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIG4pIGZvciAobGV0IHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQgKz0gMSkgdGhpc1tzXS5hcHBlbmRDaGlsZChlW3RdKTsgZWxzZSB0aGlzW3NdLmFwcGVuZENoaWxkKGUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBwcmVwZW5kOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gYSgpO1xyXG4gICAgICAgICAgICBsZXQgcywgaTtcclxuICAgICAgICAgICAgZm9yIChzID0gMDsgcyA8IHRoaXMubGVuZ3RoOyBzICs9IDEpIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChhLmlubmVySFRNTCA9IGUsIGkgPSBhLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHRoaXNbc10uaW5zZXJ0QmVmb3JlKGEuY2hpbGROb2Rlc1tpXSwgdGhpc1tzXS5jaGlsZE5vZGVzWzBdKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBuKSBmb3IgKGkgPSAwOyBpIDwgZS5sZW5ndGg7IGkgKz0gMSkgdGhpc1tzXS5pbnNlcnRCZWZvcmUoZVtpXSwgdGhpc1tzXS5jaGlsZE5vZGVzWzBdKTsgZWxzZSB0aGlzW3NdLmluc2VydEJlZm9yZShlLCB0aGlzW3NdLmNoaWxkTm9kZXNbMF0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIG5leHQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IDAgPyBlID8gdGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmcgJiYgZCh0aGlzWzBdLm5leHRFbGVtZW50U2libGluZykuaXMoZSkgPyBkKFt0aGlzWzBdLm5leHRFbGVtZW50U2libGluZ10pIDogZChbXSkgOiB0aGlzWzBdLm5leHRFbGVtZW50U2libGluZyA/IGQoW3RoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nXSkgOiBkKFtdKSA6IGQoW10pXHJcbiAgICAgICAgfSwgbmV4dEFsbDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgY29uc3QgdCA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgcyA9IHRoaXNbMF07XHJcbiAgICAgICAgICAgIGlmICghcykgcmV0dXJuIGQoW10pO1xyXG4gICAgICAgICAgICBmb3IgKDsgcy5uZXh0RWxlbWVudFNpYmxpbmc7KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gcy5uZXh0RWxlbWVudFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICBlID8gZChhKS5pcyhlKSAmJiB0LnB1c2goYSkgOiB0LnB1c2goYSksIHMgPSBhXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGQodClcclxuICAgICAgICB9LCBwcmV2OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gdGhpc1swXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlID8gdC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICYmIGQodC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKS5pcyhlKSA/IGQoW3QucHJldmlvdXNFbGVtZW50U2libGluZ10pIDogZChbXSkgOiB0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcgPyBkKFt0LnByZXZpb3VzRWxlbWVudFNpYmxpbmddKSA6IGQoW10pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGQoW10pXHJcbiAgICAgICAgfSwgcHJldkFsbDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgY29uc3QgdCA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgcyA9IHRoaXNbMF07XHJcbiAgICAgICAgICAgIGlmICghcykgcmV0dXJuIGQoW10pO1xyXG4gICAgICAgICAgICBmb3IgKDsgcy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nOykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IHMucHJldmlvdXNFbGVtZW50U2libGluZztcclxuICAgICAgICAgICAgICAgIGUgPyBkKGEpLmlzKGUpICYmIHQucHVzaChhKSA6IHQucHVzaChhKSwgcyA9IGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZCh0KVxyXG4gICAgICAgIH0sIHBhcmVudDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgY29uc3QgdCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IHRoaXMubGVuZ3RoOyBzICs9IDEpIG51bGwgIT09IHRoaXNbc10ucGFyZW50Tm9kZSAmJiAoZSA/IGQodGhpc1tzXS5wYXJlbnROb2RlKS5pcyhlKSAmJiB0LnB1c2godGhpc1tzXS5wYXJlbnROb2RlKSA6IHQucHVzaCh0aGlzW3NdLnBhcmVudE5vZGUpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGQodClcclxuICAgICAgICB9LCBwYXJlbnRzOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgdGhpcy5sZW5ndGg7IHMgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGEgPSB0aGlzW3NdLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgYTspIGUgPyBkKGEpLmlzKGUpICYmIHQucHVzaChhKSA6IHQucHVzaChhKSwgYSA9IGEucGFyZW50Tm9kZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkKHQpXHJcbiAgICAgICAgfSwgY2xvc2VzdDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgbGV0IHQgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSBlID8gZChbXSkgOiAodC5pcyhlKSB8fCAodCA9IHQucGFyZW50cyhlKS5lcSgwKSksIHQpXHJcbiAgICAgICAgfSwgZmluZDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgY29uc3QgdCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IHRoaXMubGVuZ3RoOyBzICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzW3NdLnF1ZXJ5U2VsZWN0b3JBbGwoZSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlID0gMDsgZSA8IGEubGVuZ3RoOyBlICs9IDEpIHQucHVzaChhW2VdKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkKHQpXHJcbiAgICAgICAgfSwgY2hpbGRyZW46IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCB0aGlzLmxlbmd0aDsgcyArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gdGhpc1tzXS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgYS5sZW5ndGg7IHMgKz0gMSkgZSAmJiAhZChhW3NdKS5pcyhlKSB8fCB0LnB1c2goYVtzXSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZCh0KVxyXG4gICAgICAgIH0sIGZpbHRlcjogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQobyh0aGlzLCBlKSlcclxuICAgICAgICB9LCByZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgZSA9IDA7IGUgPCB0aGlzLmxlbmd0aDsgZSArPSAxKSB0aGlzW2VdLnBhcmVudE5vZGUgJiYgdGhpc1tlXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXNbZV0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcChlLCB0KSB7XHJcbiAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gdCAmJiAodCA9IDApLCBzZXRUaW1lb3V0KGUsIHQpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdSgpIHtcclxuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGgoZSwgdCkge1xyXG4gICAgICAgIHZvaWQgMCA9PT0gdCAmJiAodCA9IFwieFwiKTtcclxuICAgICAgICBjb25zdCBzID0gcigpO1xyXG4gICAgICAgIGxldCBhLCBpLCBuO1xyXG4gICAgICAgIGNvbnN0IGwgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gcigpO1xyXG4gICAgICAgICAgICBsZXQgcztcclxuICAgICAgICAgICAgcmV0dXJuIHQuZ2V0Q29tcHV0ZWRTdHlsZSAmJiAocyA9IHQuZ2V0Q29tcHV0ZWRTdHlsZShlLCBudWxsKSksICFzICYmIGUuY3VycmVudFN0eWxlICYmIChzID0gZS5jdXJyZW50U3R5bGUpLCBzIHx8IChzID0gZS5zdHlsZSksIHNcclxuICAgICAgICB9KGUpO1xyXG4gICAgICAgIHJldHVybiBzLldlYktpdENTU01hdHJpeCA/IChpID0gbC50cmFuc2Zvcm0gfHwgbC53ZWJraXRUcmFuc2Zvcm0sIGkuc3BsaXQoXCIsXCIpLmxlbmd0aCA+IDYgJiYgKGkgPSBpLnNwbGl0KFwiLCBcIikubWFwKChlID0+IGUucmVwbGFjZShcIixcIiwgXCIuXCIpKSkuam9pbihcIiwgXCIpKSwgbiA9IG5ldyBzLldlYktpdENTU01hdHJpeChcIm5vbmVcIiA9PT0gaSA/IFwiXCIgOiBpKSkgOiAobiA9IGwuTW96VHJhbnNmb3JtIHx8IGwuT1RyYW5zZm9ybSB8fCBsLk1zVHJhbnNmb3JtIHx8IGwubXNUcmFuc2Zvcm0gfHwgbC50cmFuc2Zvcm0gfHwgbC5nZXRQcm9wZXJ0eVZhbHVlKFwidHJhbnNmb3JtXCIpLnJlcGxhY2UoXCJ0cmFuc2xhdGUoXCIsIFwibWF0cml4KDEsIDAsIDAsIDEsXCIpLCBhID0gbi50b1N0cmluZygpLnNwbGl0KFwiLFwiKSksIFwieFwiID09PSB0ICYmIChpID0gcy5XZWJLaXRDU1NNYXRyaXggPyBuLm00MSA6IDE2ID09PSBhLmxlbmd0aCA/IHBhcnNlRmxvYXQoYVsxMl0pIDogcGFyc2VGbG9hdChhWzRdKSksIFwieVwiID09PSB0ICYmIChpID0gcy5XZWJLaXRDU1NNYXRyaXggPyBuLm00MiA6IDE2ID09PSBhLmxlbmd0aCA/IHBhcnNlRmxvYXQoYVsxM10pIDogcGFyc2VGbG9hdChhWzVdKSksIGkgfHwgMFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG0oZSkge1xyXG4gICAgICAgIHJldHVybiBcIm9iamVjdFwiID09IHR5cGVvZiBlICYmIG51bGwgIT09IGUgJiYgZS5jb25zdHJ1Y3RvciAmJiBcIk9iamVjdFwiID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwgLTEpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZihlKSB7XHJcbiAgICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyAmJiB2b2lkIDAgIT09IHdpbmRvdy5IVE1MRWxlbWVudCA/IGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA6IGUgJiYgKDEgPT09IGUubm9kZVR5cGUgfHwgMTEgPT09IGUubm9kZVR5cGUpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZygpIHtcclxuICAgICAgICBjb25zdCBlID0gT2JqZWN0KGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHZvaWQgMCA6IGFyZ3VtZW50c1swXSksIHQgPSBbXCJfX3Byb3RvX19cIiwgXCJjb25zdHJ1Y3RvclwiLCBcInByb3RvdHlwZVwiXTtcclxuICAgICAgICBmb3IgKGxldCBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMgKz0gMSkge1xyXG4gICAgICAgICAgICBjb25zdCBhID0gcyA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBzID8gdm9pZCAwIDogYXJndW1lbnRzW3NdO1xyXG4gICAgICAgICAgICBpZiAobnVsbCAhPSBhICYmICFmKGEpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gT2JqZWN0LmtleXMoT2JqZWN0KGEpKS5maWx0ZXIoKGUgPT4gdC5pbmRleE9mKGUpIDwgMCkpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdCA9IDAsIGkgPSBzLmxlbmd0aDsgdCA8IGk7IHQgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBzW3RdLCByID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IHIgJiYgci5lbnVtZXJhYmxlICYmIChtKGVbaV0pICYmIG0oYVtpXSkgPyBhW2ldLl9fc3dpcGVyX18gPyBlW2ldID0gYVtpXSA6IGcoZVtpXSwgYVtpXSkgOiAhbShlW2ldKSAmJiBtKGFbaV0pID8gKGVbaV0gPSB7fSwgYVtpXS5fX3N3aXBlcl9fID8gZVtpXSA9IGFbaV0gOiBnKGVbaV0sIGFbaV0pKSA6IGVbaV0gPSBhW2ldKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdihlLCB0LCBzKSB7XHJcbiAgICAgICAgZS5zdHlsZS5zZXRQcm9wZXJ0eSh0LCBzKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHcoZSkge1xyXG4gICAgICAgIGxldCB7c3dpcGVyOiB0LCB0YXJnZXRQb3NpdGlvbjogcywgc2lkZTogYX0gPSBlO1xyXG4gICAgICAgIGNvbnN0IGkgPSByKCksIG4gPSAtdC50cmFuc2xhdGU7XHJcbiAgICAgICAgbGV0IGwsIG8gPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IGQgPSB0LnBhcmFtcy5zcGVlZDtcclxuICAgICAgICB0LndyYXBwZXJFbC5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9IFwibm9uZVwiLCBpLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHQuY3NzTW9kZUZyYW1lSUQpO1xyXG4gICAgICAgIGNvbnN0IGMgPSBzID4gbiA/IFwibmV4dFwiIDogXCJwcmV2XCIsIHAgPSAoZSwgdCkgPT4gXCJuZXh0XCIgPT09IGMgJiYgZSA+PSB0IHx8IFwicHJldlwiID09PSBjICYmIGUgPD0gdCwgdSA9ICgpID0+IHtcclxuICAgICAgICAgICAgbCA9IChuZXcgRGF0ZSkuZ2V0VGltZSgpLCBudWxsID09PSBvICYmIChvID0gbCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSBNYXRoLm1heChNYXRoLm1pbigobCAtIG8pIC8gZCwgMSksIDApLCByID0gLjUgLSBNYXRoLmNvcyhlICogTWF0aC5QSSkgLyAyO1xyXG4gICAgICAgICAgICBsZXQgYyA9IG4gKyByICogKHMgLSBuKTtcclxuICAgICAgICAgICAgaWYgKHAoYywgcykgJiYgKGMgPSBzKSwgdC53cmFwcGVyRWwuc2Nyb2xsVG8oe1thXTogY30pLCBwKGMsIHMpKSByZXR1cm4gdC53cmFwcGVyRWwuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiLCB0LndyYXBwZXJFbC5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9IFwiXCIsIHNldFRpbWVvdXQoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHQud3JhcHBlckVsLnN0eWxlLm92ZXJmbG93ID0gXCJcIiwgdC53cmFwcGVyRWwuc2Nyb2xsVG8oe1thXTogY30pXHJcbiAgICAgICAgICAgIH0pKSwgdm9pZCBpLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHQuY3NzTW9kZUZyYW1lSUQpO1xyXG4gICAgICAgICAgICB0LmNzc01vZGVGcmFtZUlEID0gaS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHUoKVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBiLCB4LCB5O1xyXG5cclxuICAgIGZ1bmN0aW9uIEUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGIgfHwgKGIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSByKCksIHQgPSBhKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzbW9vdGhTY3JvbGw6IHQuZG9jdW1lbnRFbGVtZW50ICYmIFwic2Nyb2xsQmVoYXZpb3JcIiBpbiB0LmRvY3VtZW50RWxlbWVudC5zdHlsZSxcclxuICAgICAgICAgICAgICAgIHRvdWNoOiAhIShcIm9udG91Y2hzdGFydFwiIGluIGUgfHwgZS5Eb2N1bWVudFRvdWNoICYmIHQgaW5zdGFuY2VvZiBlLkRvY3VtZW50VG91Y2gpLFxyXG4gICAgICAgICAgICAgICAgcGFzc2l2ZUxpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHQgPSAhMTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInBhc3NpdmVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAhMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5hZGRFdmVudExpc3RlbmVyKFwidGVzdFBhc3NpdmVMaXN0ZW5lclwiLCBudWxsLCBzKVxyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRcclxuICAgICAgICAgICAgICAgIH0oKSxcclxuICAgICAgICAgICAgICAgIGdlc3R1cmVzOiBcIm9uZ2VzdHVyZXN0YXJ0XCIgaW4gZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpKSwgYlxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEMoZSkge1xyXG4gICAgICAgIHJldHVybiB2b2lkIDAgPT09IGUgJiYgKGUgPSB7fSksIHggfHwgKHggPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBsZXQge3VzZXJBZ2VudDogdH0gPSB2b2lkIDAgPT09IGUgPyB7fSA6IGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSBFKCksIGEgPSByKCksIGkgPSBhLm5hdmlnYXRvci5wbGF0Zm9ybSwgbiA9IHQgfHwgYS5uYXZpZ2F0b3IudXNlckFnZW50LFxyXG4gICAgICAgICAgICAgICAgbCA9IHtpb3M6ICExLCBhbmRyb2lkOiAhMX0sIG8gPSBhLnNjcmVlbi53aWR0aCwgZCA9IGEuc2NyZWVuLmhlaWdodCxcclxuICAgICAgICAgICAgICAgIGMgPSBuLm1hdGNoKC8oQW5kcm9pZCk7P1tcXHNcXC9dKyhbXFxkLl0rKT8vKTtcclxuICAgICAgICAgICAgbGV0IHAgPSBuLm1hdGNoKC8oaVBhZCkuKk9TXFxzKFtcXGRfXSspLyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHUgPSBuLm1hdGNoKC8oaVBvZCkoLipPU1xccyhbXFxkX10rKSk/LyksIGggPSAhcCAmJiBuLm1hdGNoKC8oaVBob25lXFxzT1N8aU9TKVxccyhbXFxkX10rKS8pLFxyXG4gICAgICAgICAgICAgICAgbSA9IFwiV2luMzJcIiA9PT0gaTtcclxuICAgICAgICAgICAgbGV0IGYgPSBcIk1hY0ludGVsXCIgPT09IGk7XHJcbiAgICAgICAgICAgIHJldHVybiAhcCAmJiBmICYmIHMudG91Y2ggJiYgW1wiMTAyNHgxMzY2XCIsIFwiMTM2NngxMDI0XCIsIFwiODM0eDExOTRcIiwgXCIxMTk0eDgzNFwiLCBcIjgzNHgxMTEyXCIsIFwiMTExMng4MzRcIiwgXCI3Njh4MTAyNFwiLCBcIjEwMjR4NzY4XCIsIFwiODIweDExODBcIiwgXCIxMTgweDgyMFwiLCBcIjgxMHgxMDgwXCIsIFwiMTA4MHg4MTBcIl0uaW5kZXhPZihgJHtvfXgke2R9YCkgPj0gMCAmJiAocCA9IG4ubWF0Y2goLyhWZXJzaW9uKVxcLyhbXFxkLl0rKS8pLCBwIHx8IChwID0gWzAsIDEsIFwiMTNfMF8wXCJdKSwgZiA9ICExKSwgYyAmJiAhbSAmJiAobC5vcyA9IFwiYW5kcm9pZFwiLCBsLmFuZHJvaWQgPSAhMCksIChwIHx8IGggfHwgdSkgJiYgKGwub3MgPSBcImlvc1wiLCBsLmlvcyA9ICEwKSwgbFxyXG4gICAgICAgIH0oZSkpLCB4XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gVCgpIHtcclxuICAgICAgICByZXR1cm4geSB8fCAoeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGlzU2FmYXJpOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGUubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmluZGV4T2YoXCJzYWZhcmlcIikgPj0gMCAmJiB0LmluZGV4T2YoXCJjaHJvbWVcIikgPCAwICYmIHQuaW5kZXhPZihcImFuZHJvaWRcIikgPCAwXHJcbiAgICAgICAgICAgICAgICB9KCksIGlzV2ViVmlldzogLyhpUGhvbmV8aVBvZHxpUGFkKS4qQXBwbGVXZWJLaXQoPyEuKlNhZmFyaSkvaS50ZXN0KGUubmF2aWdhdG9yLnVzZXJBZ2VudClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0oKSksIHlcclxuICAgIH1cclxuXHJcbiAgICBPYmplY3Qua2V5cyhjKS5mb3JFYWNoKChlID0+IHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZC5mbiwgZSwge3ZhbHVlOiBjW2VdLCB3cml0YWJsZTogITB9KVxyXG4gICAgfSkpO1xyXG4gICAgdmFyICQgPSB7XHJcbiAgICAgICAgb24oZSwgdCwgcykge1xyXG4gICAgICAgICAgICBjb25zdCBhID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKCFhLmV2ZW50c0xpc3RlbmVycyB8fCBhLmRlc3Ryb3llZCkgcmV0dXJuIGE7XHJcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQpIHJldHVybiBhO1xyXG4gICAgICAgICAgICBjb25zdCBpID0gcyA/IFwidW5zaGlmdFwiIDogXCJwdXNoXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBlLnNwbGl0KFwiIFwiKS5mb3JFYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgIGEuZXZlbnRzTGlzdGVuZXJzW2VdIHx8IChhLmV2ZW50c0xpc3RlbmVyc1tlXSA9IFtdKSwgYS5ldmVudHNMaXN0ZW5lcnNbZV1baV0odClcclxuICAgICAgICAgICAgfSkpLCBhXHJcbiAgICAgICAgfSwgb25jZShlLCB0LCBzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoIWEuZXZlbnRzTGlzdGVuZXJzIHx8IGEuZGVzdHJveWVkKSByZXR1cm4gYTtcclxuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCkgcmV0dXJuIGE7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBpKCkge1xyXG4gICAgICAgICAgICAgICAgYS5vZmYoZSwgaSksIGkuX19lbWl0dGVyUHJveHkgJiYgZGVsZXRlIGkuX19lbWl0dGVyUHJveHk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IG5ldyBBcnJheShzKSwgbiA9IDA7IG4gPCBzOyBuKyspIHJbbl0gPSBhcmd1bWVudHNbbl07XHJcbiAgICAgICAgICAgICAgICB0LmFwcGx5KGEsIHIpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpLl9fZW1pdHRlclByb3h5ID0gdCwgYS5vbihlLCBpLCBzKVxyXG4gICAgICAgIH0sIG9uQW55KGUsIHQpIHtcclxuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICghcy5ldmVudHNMaXN0ZW5lcnMgfHwgcy5kZXN0cm95ZWQpIHJldHVybiBzO1xyXG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4gcztcclxuICAgICAgICAgICAgY29uc3QgYSA9IHQgPyBcInVuc2hpZnRcIiA6IFwicHVzaFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gcy5ldmVudHNBbnlMaXN0ZW5lcnMuaW5kZXhPZihlKSA8IDAgJiYgcy5ldmVudHNBbnlMaXN0ZW5lcnNbYV0oZSksIHNcclxuICAgICAgICB9LCBvZmZBbnkoZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKCF0LmV2ZW50c0xpc3RlbmVycyB8fCB0LmRlc3Ryb3llZCkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICghdC5ldmVudHNBbnlMaXN0ZW5lcnMpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBjb25zdCBzID0gdC5ldmVudHNBbnlMaXN0ZW5lcnMuaW5kZXhPZihlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHMgPj0gMCAmJiB0LmV2ZW50c0FueUxpc3RlbmVycy5zcGxpY2UocywgMSksIHRcclxuICAgICAgICB9LCBvZmYoZSwgdCkge1xyXG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuICFzLmV2ZW50c0xpc3RlbmVycyB8fCBzLmRlc3Ryb3llZCA/IHMgOiBzLmV2ZW50c0xpc3RlbmVycyA/IChlLnNwbGl0KFwiIFwiKS5mb3JFYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gdCA/IHMuZXZlbnRzTGlzdGVuZXJzW2VdID0gW10gOiBzLmV2ZW50c0xpc3RlbmVyc1tlXSAmJiBzLmV2ZW50c0xpc3RlbmVyc1tlXS5mb3JFYWNoKCgoYSwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIChhID09PSB0IHx8IGEuX19lbWl0dGVyUHJveHkgJiYgYS5fX2VtaXR0ZXJQcm94eSA9PT0gdCkgJiYgcy5ldmVudHNMaXN0ZW5lcnNbZV0uc3BsaWNlKGksIDEpXHJcbiAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgfSkpLCBzKSA6IHNcclxuICAgICAgICB9LCBlbWl0KCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKCFlLmV2ZW50c0xpc3RlbmVycyB8fCBlLmRlc3Ryb3llZCkgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgIGlmICghZS5ldmVudHNMaXN0ZW5lcnMpIHJldHVybiBlO1xyXG4gICAgICAgICAgICBsZXQgdCwgcywgYTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBuZXcgQXJyYXkoaSksIG4gPSAwOyBuIDwgaTsgbisrKSByW25dID0gYXJndW1lbnRzW25dO1xyXG4gICAgICAgICAgICBcInN0cmluZ1wiID09IHR5cGVvZiByWzBdIHx8IEFycmF5LmlzQXJyYXkoclswXSkgPyAodCA9IHJbMF0sIHMgPSByLnNsaWNlKDEsIHIubGVuZ3RoKSwgYSA9IGUpIDogKHQgPSByWzBdLmV2ZW50cywgcyA9IHJbMF0uZGF0YSwgYSA9IHJbMF0uY29udGV4dCB8fCBlKSwgcy51bnNoaWZ0KGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkodCkgPyB0IDogdC5zcGxpdChcIiBcIikpLmZvckVhY2goKHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgZS5ldmVudHNBbnlMaXN0ZW5lcnMgJiYgZS5ldmVudHNBbnlMaXN0ZW5lcnMubGVuZ3RoICYmIGUuZXZlbnRzQW55TGlzdGVuZXJzLmZvckVhY2goKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGUuYXBwbHkoYSwgW3QsIC4uLnNdKVxyXG4gICAgICAgICAgICAgICAgfSkpLCBlLmV2ZW50c0xpc3RlbmVycyAmJiBlLmV2ZW50c0xpc3RlbmVyc1t0XSAmJiBlLmV2ZW50c0xpc3RlbmVyc1t0XS5mb3JFYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBlLmFwcGx5KGEsIHMpXHJcbiAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgfSkpLCBlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBTID0ge1xyXG4gICAgICAgIHVwZGF0ZVNpemU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB0LCBzO1xyXG4gICAgICAgICAgICBjb25zdCBhID0gZS4kZWw7XHJcbiAgICAgICAgICAgIHQgPSB2b2lkIDAgIT09IGUucGFyYW1zLndpZHRoICYmIG51bGwgIT09IGUucGFyYW1zLndpZHRoID8gZS5wYXJhbXMud2lkdGggOiBhWzBdLmNsaWVudFdpZHRoLCBzID0gdm9pZCAwICE9PSBlLnBhcmFtcy5oZWlnaHQgJiYgbnVsbCAhPT0gZS5wYXJhbXMuaGVpZ2h0ID8gZS5wYXJhbXMuaGVpZ2h0IDogYVswXS5jbGllbnRIZWlnaHQsIDAgPT09IHQgJiYgZS5pc0hvcml6b250YWwoKSB8fCAwID09PSBzICYmIGUuaXNWZXJ0aWNhbCgpIHx8ICh0ID0gdCAtIHBhcnNlSW50KGEuY3NzKFwicGFkZGluZy1sZWZ0XCIpIHx8IDAsIDEwKSAtIHBhcnNlSW50KGEuY3NzKFwicGFkZGluZy1yaWdodFwiKSB8fCAwLCAxMCksIHMgPSBzIC0gcGFyc2VJbnQoYS5jc3MoXCJwYWRkaW5nLXRvcFwiKSB8fCAwLCAxMCkgLSBwYXJzZUludChhLmNzcyhcInBhZGRpbmctYm90dG9tXCIpIHx8IDAsIDEwKSwgTnVtYmVyLmlzTmFOKHQpICYmICh0ID0gMCksIE51bWJlci5pc05hTihzKSAmJiAocyA9IDApLCBPYmplY3QuYXNzaWduKGUsIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB0LFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogZS5pc0hvcml6b250YWwoKSA/IHQgOiBzXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgIH0sIHVwZGF0ZVNsaWRlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHQodCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuaXNIb3Jpem9udGFsKCkgPyB0IDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcImhlaWdodFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLXRvcFwiOiBcIm1hcmdpbi1sZWZ0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tYm90dG9tIFwiOiBcIm1hcmdpbi1yaWdodFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLWxlZnRcIjogXCJtYXJnaW4tdG9wXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tcmlnaHRcIjogXCJtYXJnaW4tYm90dG9tXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nLWxlZnRcIjogXCJwYWRkaW5nLXRvcFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwicGFkZGluZy1yaWdodFwiOiBcInBhZGRpbmctYm90dG9tXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IFwibWFyZ2luQm90dG9tXCJcclxuICAgICAgICAgICAgICAgIH1bdF1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gcyhlLCBzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChlLmdldFByb3BlcnR5VmFsdWUodChzKSkgfHwgMClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgYSA9IGUucGFyYW1zLCB7JHdyYXBwZXJFbDogaSwgc2l6ZTogciwgcnRsVHJhbnNsYXRlOiBuLCB3cm9uZ1JUTDogbH0gPSBlLFxyXG4gICAgICAgICAgICAgICAgbyA9IGUudmlydHVhbCAmJiBhLnZpcnR1YWwuZW5hYmxlZCwgZCA9IG8gPyBlLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCA6IGUuc2xpZGVzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGMgPSBpLmNoaWxkcmVuKGAuJHtlLnBhcmFtcy5zbGlkZUNsYXNzfWApLCBwID0gbyA/IGUudmlydHVhbC5zbGlkZXMubGVuZ3RoIDogYy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGxldCB1ID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IGggPSBbXSwgbSA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgZiA9IGEuc2xpZGVzT2Zmc2V0QmVmb3JlO1xyXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGYgJiYgKGYgPSBhLnNsaWRlc09mZnNldEJlZm9yZS5jYWxsKGUpKTtcclxuICAgICAgICAgICAgbGV0IGcgPSBhLnNsaWRlc09mZnNldEFmdGVyO1xyXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGcgJiYgKGcgPSBhLnNsaWRlc09mZnNldEFmdGVyLmNhbGwoZSkpO1xyXG4gICAgICAgICAgICBjb25zdCB3ID0gZS5zbmFwR3JpZC5sZW5ndGgsIGIgPSBlLnNsaWRlc0dyaWQubGVuZ3RoO1xyXG4gICAgICAgICAgICBsZXQgeCA9IGEuc3BhY2VCZXR3ZWVuLCB5ID0gLWYsIEUgPSAwLCBDID0gMDtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gcikgcmV0dXJuO1xyXG4gICAgICAgICAgICBcInN0cmluZ1wiID09IHR5cGVvZiB4ICYmIHguaW5kZXhPZihcIiVcIikgPj0gMCAmJiAoeCA9IHBhcnNlRmxvYXQoeC5yZXBsYWNlKFwiJVwiLCBcIlwiKSkgLyAxMDAgKiByKSwgZS52aXJ0dWFsU2l6ZSA9IC14LCBuID8gYy5jc3Moe1xyXG4gICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogXCJcIixcclxuICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogXCJcIixcclxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogXCJcIlxyXG4gICAgICAgICAgICB9KSA6IGMuY3NzKHtcclxuICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBcIlwiXHJcbiAgICAgICAgICAgIH0pLCBhLmNlbnRlcmVkU2xpZGVzICYmIGEuY3NzTW9kZSAmJiAodihlLndyYXBwZXJFbCwgXCItLXN3aXBlci1jZW50ZXJlZC1vZmZzZXQtYmVmb3JlXCIsIFwiXCIpLCB2KGUud3JhcHBlckVsLCBcIi0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1hZnRlclwiLCBcIlwiKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IFQgPSBhLmdyaWQgJiYgYS5ncmlkLnJvd3MgPiAxICYmIGUuZ3JpZDtcclxuICAgICAgICAgICAgbGV0ICQ7XHJcbiAgICAgICAgICAgIFQgJiYgZS5ncmlkLmluaXRTbGlkZXMocCk7XHJcbiAgICAgICAgICAgIGNvbnN0IFMgPSBcImF1dG9cIiA9PT0gYS5zbGlkZXNQZXJWaWV3ICYmIGEuYnJlYWtwb2ludHMgJiYgT2JqZWN0LmtleXMoYS5icmVha3BvaW50cykuZmlsdGVyKChlID0+IHZvaWQgMCAhPT0gYS5icmVha3BvaW50c1tlXS5zbGlkZXNQZXJWaWV3KSkubGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICQgPSAwO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbiA9IGMuZXEoaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoVCAmJiBlLmdyaWQudXBkYXRlU2xpZGUoaSwgbiwgcCwgdCksIFwibm9uZVwiICE9PSBuLmNzcyhcImRpc3BsYXlcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJhdXRvXCIgPT09IGEuc2xpZGVzUGVyVmlldykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBTICYmIChjW2ldLnN0eWxlW3QoXCJ3aWR0aFwiKV0gPSBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IGdldENvbXB1dGVkU3R5bGUoblswXSksIGwgPSBuWzBdLnN0eWxlLnRyYW5zZm9ybSwgbyA9IG5bMF0uc3R5bGUud2Via2l0VHJhbnNmb3JtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobCAmJiAoblswXS5zdHlsZS50cmFuc2Zvcm0gPSBcIm5vbmVcIiksIG8gJiYgKG5bMF0uc3R5bGUud2Via2l0VHJhbnNmb3JtID0gXCJub25lXCIpLCBhLnJvdW5kTGVuZ3RocykgJCA9IGUuaXNIb3Jpem9udGFsKCkgPyBuLm91dGVyV2lkdGgoITApIDogbi5vdXRlckhlaWdodCghMCk7IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IHMociwgXCJ3aWR0aFwiKSwgdCA9IHMociwgXCJwYWRkaW5nLWxlZnRcIiksIGEgPSBzKHIsIFwicGFkZGluZy1yaWdodFwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gcyhyLCBcIm1hcmdpbi1sZWZ0XCIpLCBsID0gcyhyLCBcIm1hcmdpbi1yaWdodFwiKSwgbyA9IHIuZ2V0UHJvcGVydHlWYWx1ZShcImJveC1zaXppbmdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobyAmJiBcImJvcmRlci1ib3hcIiA9PT0gbykgJCA9IGUgKyBpICsgbDsgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qge2NsaWVudFdpZHRoOiBzLCBvZmZzZXRXaWR0aDogcn0gPSBuWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQgPSBlICsgdCArIGEgKyBpICsgbCArIChyIC0gcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsICYmIChuWzBdLnN0eWxlLnRyYW5zZm9ybSA9IGwpLCBvICYmIChuWzBdLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IG8pLCBhLnJvdW5kTGVuZ3RocyAmJiAoJCA9IE1hdGguZmxvb3IoJCkpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlICQgPSAociAtIChhLnNsaWRlc1BlclZpZXcgLSAxKSAqIHgpIC8gYS5zbGlkZXNQZXJWaWV3LCBhLnJvdW5kTGVuZ3RocyAmJiAoJCA9IE1hdGguZmxvb3IoJCkpLCBjW2ldICYmIChjW2ldLnN0eWxlW3QoXCJ3aWR0aFwiKV0gPSBgJHskfXB4YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY1tpXSAmJiAoY1tpXS5zd2lwZXJTbGlkZVNpemUgPSAkKSwgbS5wdXNoKCQpLCBhLmNlbnRlcmVkU2xpZGVzID8gKHkgPSB5ICsgJCAvIDIgKyBFIC8gMiArIHgsIDAgPT09IEUgJiYgMCAhPT0gaSAmJiAoeSA9IHkgLSByIC8gMiAtIHgpLCAwID09PSBpICYmICh5ID0geSAtIHIgLyAyIC0geCksIE1hdGguYWJzKHkpIDwgLjAwMSAmJiAoeSA9IDApLCBhLnJvdW5kTGVuZ3RocyAmJiAoeSA9IE1hdGguZmxvb3IoeSkpLCBDICUgYS5zbGlkZXNQZXJHcm91cCA9PSAwICYmIHUucHVzaCh5KSwgaC5wdXNoKHkpKSA6IChhLnJvdW5kTGVuZ3RocyAmJiAoeSA9IE1hdGguZmxvb3IoeSkpLCAoQyAtIE1hdGgubWluKGUucGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCwgQykpICUgZS5wYXJhbXMuc2xpZGVzUGVyR3JvdXAgPT0gMCAmJiB1LnB1c2goeSksIGgucHVzaCh5KSwgeSA9IHkgKyAkICsgeCksIGUudmlydHVhbFNpemUgKz0gJCArIHgsIEUgPSAkLCBDICs9IDFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZS52aXJ0dWFsU2l6ZSA9IE1hdGgubWF4KGUudmlydHVhbFNpemUsIHIpICsgZywgbiAmJiBsICYmIChcInNsaWRlXCIgPT09IGEuZWZmZWN0IHx8IFwiY292ZXJmbG93XCIgPT09IGEuZWZmZWN0KSAmJiBpLmNzcyh7d2lkdGg6IGAke2UudmlydHVhbFNpemUgKyBhLnNwYWNlQmV0d2Vlbn1weGB9KSwgYS5zZXRXcmFwcGVyU2l6ZSAmJiBpLmNzcyh7W3QoXCJ3aWR0aFwiKV06IGAke2UudmlydHVhbFNpemUgKyBhLnNwYWNlQmV0d2Vlbn1weGB9KSwgVCAmJiBlLmdyaWQudXBkYXRlV3JhcHBlclNpemUoJCwgdSwgdCksICFhLmNlbnRlcmVkU2xpZGVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IHUubGVuZ3RoOyBzICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IHVbc107XHJcbiAgICAgICAgICAgICAgICAgICAgYS5yb3VuZExlbmd0aHMgJiYgKGkgPSBNYXRoLmZsb29yKGkpKSwgdVtzXSA8PSBlLnZpcnR1YWxTaXplIC0gciAmJiB0LnB1c2goaSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHUgPSB0LCBNYXRoLmZsb29yKGUudmlydHVhbFNpemUgLSByKSAtIE1hdGguZmxvb3IodVt1Lmxlbmd0aCAtIDFdKSA+IDEgJiYgdS5wdXNoKGUudmlydHVhbFNpemUgLSByKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgwID09PSB1Lmxlbmd0aCAmJiAodSA9IFswXSksIDAgIT09IGEuc3BhY2VCZXR3ZWVuKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gZS5pc0hvcml6b250YWwoKSAmJiBuID8gXCJtYXJnaW5MZWZ0XCIgOiB0KFwibWFyZ2luUmlnaHRcIik7XHJcbiAgICAgICAgICAgICAgICBjLmZpbHRlcigoKGUsIHQpID0+ICFhLmNzc01vZGUgfHwgdCAhPT0gYy5sZW5ndGggLSAxKSkuY3NzKHtbc106IGAke3h9cHhgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYS5jZW50ZXJlZFNsaWRlcyAmJiBhLmNlbnRlcmVkU2xpZGVzQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBtLmZvckVhY2goKHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGUgKz0gdCArIChhLnNwYWNlQmV0d2VlbiA/IGEuc3BhY2VCZXR3ZWVuIDogMClcclxuICAgICAgICAgICAgICAgIH0pKSwgZSAtPSBhLnNwYWNlQmV0d2VlbjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlIC0gcjtcclxuICAgICAgICAgICAgICAgIHUgPSB1Lm1hcCgoZSA9PiBlIDwgMCA/IC1mIDogZSA+IHQgPyB0ICsgZyA6IGUpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhLmNlbnRlckluc3VmZmljaWVudFNsaWRlcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKG0uZm9yRWFjaCgodCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZSArPSB0ICsgKGEuc3BhY2VCZXR3ZWVuID8gYS5zcGFjZUJldHdlZW4gOiAwKVxyXG4gICAgICAgICAgICAgICAgfSkpLCBlIC09IGEuc3BhY2VCZXR3ZWVuLCBlIDwgcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSAociAtIGUpIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICB1LmZvckVhY2goKChlLCBzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVbc10gPSBlIC0gdFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKSwgaC5mb3JFYWNoKCgoZSwgcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoW3NdID0gZSArIHRcclxuICAgICAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmFzc2lnbihlLCB7XHJcbiAgICAgICAgICAgICAgICBzbGlkZXM6IGMsXHJcbiAgICAgICAgICAgICAgICBzbmFwR3JpZDogdSxcclxuICAgICAgICAgICAgICAgIHNsaWRlc0dyaWQ6IGgsXHJcbiAgICAgICAgICAgICAgICBzbGlkZXNTaXplc0dyaWQ6IG1cclxuICAgICAgICAgICAgfSksIGEuY2VudGVyZWRTbGlkZXMgJiYgYS5jc3NNb2RlICYmICFhLmNlbnRlcmVkU2xpZGVzQm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICB2KGUud3JhcHBlckVsLCBcIi0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1iZWZvcmVcIiwgLXVbMF0gKyBcInB4XCIpLCB2KGUud3JhcHBlckVsLCBcIi0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1hZnRlclwiLCBlLnNpemUgLyAyIC0gbVttLmxlbmd0aCAtIDFdIC8gMiArIFwicHhcIik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gLWUuc25hcEdyaWRbMF0sIHMgPSAtZS5zbGlkZXNHcmlkWzBdO1xyXG4gICAgICAgICAgICAgICAgZS5zbmFwR3JpZCA9IGUuc25hcEdyaWQubWFwKChlID0+IGUgKyB0KSksIGUuc2xpZGVzR3JpZCA9IGUuc2xpZGVzR3JpZC5tYXAoKGUgPT4gZSArIHMpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwICE9PSBkICYmIGUuZW1pdChcInNsaWRlc0xlbmd0aENoYW5nZVwiKSwgdS5sZW5ndGggIT09IHcgJiYgKGUucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgZS5jaGVja092ZXJmbG93KCksIGUuZW1pdChcInNuYXBHcmlkTGVuZ3RoQ2hhbmdlXCIpKSwgaC5sZW5ndGggIT09IGIgJiYgZS5lbWl0KFwic2xpZGVzR3JpZExlbmd0aENoYW5nZVwiKSwgYS53YXRjaFNsaWRlc1Byb2dyZXNzICYmIGUudXBkYXRlU2xpZGVzT2Zmc2V0KCksICEobyB8fCBhLmNzc01vZGUgfHwgXCJzbGlkZVwiICE9PSBhLmVmZmVjdCAmJiBcImZhZGVcIiAhPT0gYS5lZmZlY3QpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gYCR7YS5jb250YWluZXJNb2RpZmllckNsYXNzfWJhY2tmYWNlLWhpZGRlbmAsIHMgPSBlLiRlbC5oYXNDbGFzcyh0KTtcclxuICAgICAgICAgICAgICAgIHAgPD0gYS5tYXhCYWNrZmFjZUhpZGRlblNsaWRlcyA/IHMgfHwgZS4kZWwuYWRkQ2xhc3ModCkgOiBzICYmIGUuJGVsLnJlbW92ZUNsYXNzKHQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB1cGRhdGVBdXRvSGVpZ2h0OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gdGhpcywgcyA9IFtdLCBhID0gdC52aXJ0dWFsICYmIHQucGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcclxuICAgICAgICAgICAgbGV0IGksIHIgPSAwO1xyXG4gICAgICAgICAgICBcIm51bWJlclwiID09IHR5cGVvZiBlID8gdC5zZXRUcmFuc2l0aW9uKGUpIDogITAgPT09IGUgJiYgdC5zZXRUcmFuc2l0aW9uKHQucGFyYW1zLnNwZWVkKTtcclxuICAgICAgICAgICAgY29uc3QgbiA9IGUgPT4gYSA/IHQuc2xpZGVzLmZpbHRlcigodCA9PiBwYXJzZUludCh0LmdldEF0dHJpYnV0ZShcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpLCAxMCkgPT09IGUpKVswXSA6IHQuc2xpZGVzLmVxKGUpWzBdO1xyXG4gICAgICAgICAgICBpZiAoXCJhdXRvXCIgIT09IHQucGFyYW1zLnNsaWRlc1BlclZpZXcgJiYgdC5wYXJhbXMuc2xpZGVzUGVyVmlldyA+IDEpIGlmICh0LnBhcmFtcy5jZW50ZXJlZFNsaWRlcykgKHQudmlzaWJsZVNsaWRlcyB8fCBkKFtdKSkuZWFjaCgoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzLnB1c2goZSlcclxuICAgICAgICAgICAgfSkpOyBlbHNlIGZvciAoaSA9IDA7IGkgPCBNYXRoLmNlaWwodC5wYXJhbXMuc2xpZGVzUGVyVmlldyk7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHQuYWN0aXZlSW5kZXggKyBpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUgPiB0LnNsaWRlcy5sZW5ndGggJiYgIWEpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgcy5wdXNoKG4oZSkpXHJcbiAgICAgICAgICAgIH0gZWxzZSBzLnB1c2gobih0LmFjdGl2ZUluZGV4KSk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSArPSAxKSBpZiAodm9pZCAwICE9PSBzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gc1tpXS5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICByID0gZSA+IHIgPyBlIDogclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIChyIHx8IDAgPT09IHIpICYmIHQuJHdyYXBwZXJFbC5jc3MoXCJoZWlnaHRcIiwgYCR7cn1weGApXHJcbiAgICAgICAgfSwgdXBkYXRlU2xpZGVzT2Zmc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0aGlzLCB0ID0gZS5zbGlkZXM7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgdC5sZW5ndGg7IHMgKz0gMSkgdFtzXS5zd2lwZXJTbGlkZU9mZnNldCA9IGUuaXNIb3Jpem9udGFsKCkgPyB0W3NdLm9mZnNldExlZnQgOiB0W3NdLm9mZnNldFRvcFxyXG4gICAgICAgIH0sIHVwZGF0ZVNsaWRlc1Byb2dyZXNzOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSB0aGlzICYmIHRoaXMudHJhbnNsYXRlIHx8IDApO1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gdGhpcywgcyA9IHQucGFyYW1zLCB7c2xpZGVzOiBhLCBydGxUcmFuc2xhdGU6IGksIHNuYXBHcmlkOiByfSA9IHQ7XHJcbiAgICAgICAgICAgIGlmICgwID09PSBhLmxlbmd0aCkgcmV0dXJuO1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGFbMF0uc3dpcGVyU2xpZGVPZmZzZXQgJiYgdC51cGRhdGVTbGlkZXNPZmZzZXQoKTtcclxuICAgICAgICAgICAgbGV0IG4gPSAtZTtcclxuICAgICAgICAgICAgaSAmJiAobiA9IGUpLCBhLnJlbW92ZUNsYXNzKHMuc2xpZGVWaXNpYmxlQ2xhc3MpLCB0LnZpc2libGVTbGlkZXNJbmRleGVzID0gW10sIHQudmlzaWJsZVNsaWRlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBlID0gMDsgZSA8IGEubGVuZ3RoOyBlICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGwgPSBhW2VdO1xyXG4gICAgICAgICAgICAgICAgbGV0IG8gPSBsLnN3aXBlclNsaWRlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgcy5jc3NNb2RlICYmIHMuY2VudGVyZWRTbGlkZXMgJiYgKG8gLT0gYVswXS5zd2lwZXJTbGlkZU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkID0gKG4gKyAocy5jZW50ZXJlZFNsaWRlcyA/IHQubWluVHJhbnNsYXRlKCkgOiAwKSAtIG8pIC8gKGwuc3dpcGVyU2xpZGVTaXplICsgcy5zcGFjZUJldHdlZW4pLFxyXG4gICAgICAgICAgICAgICAgICAgIGMgPSAobiAtIHJbMF0gKyAocy5jZW50ZXJlZFNsaWRlcyA/IHQubWluVHJhbnNsYXRlKCkgOiAwKSAtIG8pIC8gKGwuc3dpcGVyU2xpZGVTaXplICsgcy5zcGFjZUJldHdlZW4pLFxyXG4gICAgICAgICAgICAgICAgICAgIHAgPSAtKG4gLSBvKSwgdSA9IHAgKyB0LnNsaWRlc1NpemVzR3JpZFtlXTtcclxuICAgICAgICAgICAgICAgIChwID49IDAgJiYgcCA8IHQuc2l6ZSAtIDEgfHwgdSA+IDEgJiYgdSA8PSB0LnNpemUgfHwgcCA8PSAwICYmIHUgPj0gdC5zaXplKSAmJiAodC52aXNpYmxlU2xpZGVzLnB1c2gobCksIHQudmlzaWJsZVNsaWRlc0luZGV4ZXMucHVzaChlKSwgYS5lcShlKS5hZGRDbGFzcyhzLnNsaWRlVmlzaWJsZUNsYXNzKSksIGwucHJvZ3Jlc3MgPSBpID8gLWQgOiBkLCBsLm9yaWdpbmFsUHJvZ3Jlc3MgPSBpID8gLWMgOiBjXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdC52aXNpYmxlU2xpZGVzID0gZCh0LnZpc2libGVTbGlkZXMpXHJcbiAgICAgICAgfSwgdXBkYXRlUHJvZ3Jlc3M6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwID09PSBlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gdC5ydGxUcmFuc2xhdGUgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgICAgICBlID0gdCAmJiB0LnRyYW5zbGF0ZSAmJiB0LnRyYW5zbGF0ZSAqIHMgfHwgMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0LnBhcmFtcywgYSA9IHQubWF4VHJhbnNsYXRlKCkgLSB0Lm1pblRyYW5zbGF0ZSgpO1xyXG4gICAgICAgICAgICBsZXQge3Byb2dyZXNzOiBpLCBpc0JlZ2lubmluZzogciwgaXNFbmQ6IG59ID0gdDtcclxuICAgICAgICAgICAgY29uc3QgbCA9IHIsIG8gPSBuO1xyXG4gICAgICAgICAgICAwID09PSBhID8gKGkgPSAwLCByID0gITAsIG4gPSAhMCkgOiAoaSA9IChlIC0gdC5taW5UcmFuc2xhdGUoKSkgLyBhLCByID0gaSA8PSAwLCBuID0gaSA+PSAxKSwgT2JqZWN0LmFzc2lnbih0LCB7XHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzczogaSxcclxuICAgICAgICAgICAgICAgIGlzQmVnaW5uaW5nOiByLFxyXG4gICAgICAgICAgICAgICAgaXNFbmQ6IG5cclxuICAgICAgICAgICAgfSksIChzLndhdGNoU2xpZGVzUHJvZ3Jlc3MgfHwgcy5jZW50ZXJlZFNsaWRlcyAmJiBzLmF1dG9IZWlnaHQpICYmIHQudXBkYXRlU2xpZGVzUHJvZ3Jlc3MoZSksIHIgJiYgIWwgJiYgdC5lbWl0KFwicmVhY2hCZWdpbm5pbmcgdG9FZGdlXCIpLCBuICYmICFvICYmIHQuZW1pdChcInJlYWNoRW5kIHRvRWRnZVwiKSwgKGwgJiYgIXIgfHwgbyAmJiAhbikgJiYgdC5lbWl0KFwiZnJvbUVkZ2VcIiksIHQuZW1pdChcInByb2dyZXNzXCIsIGkpXHJcbiAgICAgICAgfSwgdXBkYXRlU2xpZGVzQ2xhc3NlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdGhpcywge3NsaWRlczogdCwgcGFyYW1zOiBzLCAkd3JhcHBlckVsOiBhLCBhY3RpdmVJbmRleDogaSwgcmVhbEluZGV4OiByfSA9IGUsXHJcbiAgICAgICAgICAgICAgICBuID0gZS52aXJ0dWFsICYmIHMudmlydHVhbC5lbmFibGVkO1xyXG4gICAgICAgICAgICBsZXQgbDtcclxuICAgICAgICAgICAgdC5yZW1vdmVDbGFzcyhgJHtzLnNsaWRlQWN0aXZlQ2xhc3N9ICR7cy5zbGlkZU5leHRDbGFzc30gJHtzLnNsaWRlUHJldkNsYXNzfSAke3Muc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzc30gJHtzLnNsaWRlRHVwbGljYXRlTmV4dENsYXNzfSAke3Muc2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3N9YCksIGwgPSBuID8gZS4kd3JhcHBlckVsLmZpbmQoYC4ke3Muc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2l9XCJdYCkgOiB0LmVxKGkpLCBsLmFkZENsYXNzKHMuc2xpZGVBY3RpdmVDbGFzcyksIHMubG9vcCAmJiAobC5oYXNDbGFzcyhzLnNsaWRlRHVwbGljYXRlQ2xhc3MpID8gYS5jaGlsZHJlbihgLiR7cy5zbGlkZUNsYXNzfTpub3QoLiR7cy5zbGlkZUR1cGxpY2F0ZUNsYXNzfSlbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3J9XCJdYCkuYWRkQ2xhc3Mocy5zbGlkZUR1cGxpY2F0ZUFjdGl2ZUNsYXNzKSA6IGEuY2hpbGRyZW4oYC4ke3Muc2xpZGVDbGFzc30uJHtzLnNsaWRlRHVwbGljYXRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtyfVwiXWApLmFkZENsYXNzKHMuc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzcykpO1xyXG4gICAgICAgICAgICBsZXQgbyA9IGwubmV4dEFsbChgLiR7cy5zbGlkZUNsYXNzfWApLmVxKDApLmFkZENsYXNzKHMuc2xpZGVOZXh0Q2xhc3MpO1xyXG4gICAgICAgICAgICBzLmxvb3AgJiYgMCA9PT0gby5sZW5ndGggJiYgKG8gPSB0LmVxKDApLCBvLmFkZENsYXNzKHMuc2xpZGVOZXh0Q2xhc3MpKTtcclxuICAgICAgICAgICAgbGV0IGQgPSBsLnByZXZBbGwoYC4ke3Muc2xpZGVDbGFzc31gKS5lcSgwKS5hZGRDbGFzcyhzLnNsaWRlUHJldkNsYXNzKTtcclxuICAgICAgICAgICAgcy5sb29wICYmIDAgPT09IGQubGVuZ3RoICYmIChkID0gdC5lcSgtMSksIGQuYWRkQ2xhc3Mocy5zbGlkZVByZXZDbGFzcykpLCBzLmxvb3AgJiYgKG8uaGFzQ2xhc3Mocy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSA/IGEuY2hpbGRyZW4oYC4ke3Muc2xpZGVDbGFzc306bm90KC4ke3Muc2xpZGVEdXBsaWNhdGVDbGFzc30pW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtvLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKX1cIl1gKS5hZGRDbGFzcyhzLnNsaWRlRHVwbGljYXRlTmV4dENsYXNzKSA6IGEuY2hpbGRyZW4oYC4ke3Muc2xpZGVDbGFzc30uJHtzLnNsaWRlRHVwbGljYXRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtvLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKX1cIl1gKS5hZGRDbGFzcyhzLnNsaWRlRHVwbGljYXRlTmV4dENsYXNzKSwgZC5oYXNDbGFzcyhzLnNsaWRlRHVwbGljYXRlQ2xhc3MpID8gYS5jaGlsZHJlbihgLiR7cy5zbGlkZUNsYXNzfTpub3QoLiR7cy5zbGlkZUR1cGxpY2F0ZUNsYXNzfSlbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2QuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpfVwiXWApLmFkZENsYXNzKHMuc2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3MpIDogYS5jaGlsZHJlbihgLiR7cy5zbGlkZUNsYXNzfS4ke3Muc2xpZGVEdXBsaWNhdGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2QuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpfVwiXWApLmFkZENsYXNzKHMuc2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3MpKSwgZS5lbWl0U2xpZGVzQ2xhc3NlcygpXHJcbiAgICAgICAgfSwgdXBkYXRlQWN0aXZlSW5kZXg6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLCBzID0gdC5ydGxUcmFuc2xhdGUgPyB0LnRyYW5zbGF0ZSA6IC10LnRyYW5zbGF0ZSwge1xyXG4gICAgICAgICAgICAgICAgc2xpZGVzR3JpZDogYSxcclxuICAgICAgICAgICAgICAgIHNuYXBHcmlkOiBpLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1zOiByLFxyXG4gICAgICAgICAgICAgICAgYWN0aXZlSW5kZXg6IG4sXHJcbiAgICAgICAgICAgICAgICByZWFsSW5kZXg6IGwsXHJcbiAgICAgICAgICAgICAgICBzbmFwSW5kZXg6IG9cclxuICAgICAgICAgICAgfSA9IHQ7XHJcbiAgICAgICAgICAgIGxldCBkLCBjID0gZTtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gYykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZSA9IDA7IGUgPCBhLmxlbmd0aDsgZSArPSAxKSB2b2lkIDAgIT09IGFbZSArIDFdID8gcyA+PSBhW2VdICYmIHMgPCBhW2UgKyAxXSAtIChhW2UgKyAxXSAtIGFbZV0pIC8gMiA/IGMgPSBlIDogcyA+PSBhW2VdICYmIHMgPCBhW2UgKyAxXSAmJiAoYyA9IGUgKyAxKSA6IHMgPj0gYVtlXSAmJiAoYyA9IGUpO1xyXG4gICAgICAgICAgICAgICAgci5ub3JtYWxpemVTbGlkZUluZGV4ICYmIChjIDwgMCB8fCB2b2lkIDAgPT09IGMpICYmIChjID0gMClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaS5pbmRleE9mKHMpID49IDApIGQgPSBpLmluZGV4T2Yocyk7IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IE1hdGgubWluKHIuc2xpZGVzUGVyR3JvdXBTa2lwLCBjKTtcclxuICAgICAgICAgICAgICAgIGQgPSBlICsgTWF0aC5mbG9vcigoYyAtIGUpIC8gci5zbGlkZXNQZXJHcm91cClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZCA+PSBpLmxlbmd0aCAmJiAoZCA9IGkubGVuZ3RoIC0gMSksIGMgPT09IG4pIHJldHVybiB2b2lkIChkICE9PSBvICYmICh0LnNuYXBJbmRleCA9IGQsIHQuZW1pdChcInNuYXBJbmRleENoYW5nZVwiKSkpO1xyXG4gICAgICAgICAgICBjb25zdCBwID0gcGFyc2VJbnQodC5zbGlkZXMuZXEoYykuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpIHx8IGMsIDEwKTtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0LCB7XHJcbiAgICAgICAgICAgICAgICBzbmFwSW5kZXg6IGQsXHJcbiAgICAgICAgICAgICAgICByZWFsSW5kZXg6IHAsXHJcbiAgICAgICAgICAgICAgICBwcmV2aW91c0luZGV4OiBuLFxyXG4gICAgICAgICAgICAgICAgYWN0aXZlSW5kZXg6IGNcclxuICAgICAgICAgICAgfSksIHQuZW1pdChcImFjdGl2ZUluZGV4Q2hhbmdlXCIpLCB0LmVtaXQoXCJzbmFwSW5kZXhDaGFuZ2VcIiksIGwgIT09IHAgJiYgdC5lbWl0KFwicmVhbEluZGV4Q2hhbmdlXCIpLCAodC5pbml0aWFsaXplZCB8fCB0LnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQpICYmIHQuZW1pdChcInNsaWRlQ2hhbmdlXCIpXHJcbiAgICAgICAgfSwgdXBkYXRlQ2xpY2tlZFNsaWRlOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gdGhpcywgcyA9IHQucGFyYW1zLCBhID0gZChlKS5jbG9zZXN0KGAuJHtzLnNsaWRlQ2xhc3N9YClbMF07XHJcbiAgICAgICAgICAgIGxldCBpLCByID0gITE7XHJcbiAgICAgICAgICAgIGlmIChhKSBmb3IgKGxldCBlID0gMDsgZSA8IHQuc2xpZGVzLmxlbmd0aDsgZSArPSAxKSBpZiAodC5zbGlkZXNbZV0gPT09IGEpIHtcclxuICAgICAgICAgICAgICAgIHIgPSAhMCwgaSA9IGU7XHJcbiAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghYSB8fCAhcikgcmV0dXJuIHQuY2xpY2tlZFNsaWRlID0gdm9pZCAwLCB2b2lkICh0LmNsaWNrZWRJbmRleCA9IHZvaWQgMCk7XHJcbiAgICAgICAgICAgIHQuY2xpY2tlZFNsaWRlID0gYSwgdC52aXJ0dWFsICYmIHQucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCA/IHQuY2xpY2tlZEluZGV4ID0gcGFyc2VJbnQoZChhKS5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIiksIDEwKSA6IHQuY2xpY2tlZEluZGV4ID0gaSwgcy5zbGlkZVRvQ2xpY2tlZFNsaWRlICYmIHZvaWQgMCAhPT0gdC5jbGlja2VkSW5kZXggJiYgdC5jbGlja2VkSW5kZXggIT09IHQuYWN0aXZlSW5kZXggJiYgdC5zbGlkZVRvQ2xpY2tlZFNsaWRlKClcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIE0gPSB7XHJcbiAgICAgICAgZ2V0VHJhbnNsYXRlOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSB0aGlzLmlzSG9yaXpvbnRhbCgpID8gXCJ4XCIgOiBcInlcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IHtwYXJhbXM6IHQsIHJ0bFRyYW5zbGF0ZTogcywgdHJhbnNsYXRlOiBhLCAkd3JhcHBlckVsOiBpfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh0LnZpcnR1YWxUcmFuc2xhdGUpIHJldHVybiBzID8gLWEgOiBhO1xyXG4gICAgICAgICAgICBpZiAodC5jc3NNb2RlKSByZXR1cm4gYTtcclxuICAgICAgICAgICAgbGV0IHIgPSBoKGlbMF0sIGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gcyAmJiAociA9IC1yKSwgciB8fCAwXHJcbiAgICAgICAgfSwgc2V0VHJhbnNsYXRlOiBmdW5jdGlvbiAoZSwgdCkge1xyXG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcywge3J0bFRyYW5zbGF0ZTogYSwgcGFyYW1zOiBpLCAkd3JhcHBlckVsOiByLCB3cmFwcGVyRWw6IG4sIHByb2dyZXNzOiBsfSA9IHM7XHJcbiAgICAgICAgICAgIGxldCBvLCBkID0gMCwgYyA9IDA7XHJcbiAgICAgICAgICAgIHMuaXNIb3Jpem9udGFsKCkgPyBkID0gYSA/IC1lIDogZSA6IGMgPSBlLCBpLnJvdW5kTGVuZ3RocyAmJiAoZCA9IE1hdGguZmxvb3IoZCksIGMgPSBNYXRoLmZsb29yKGMpKSwgaS5jc3NNb2RlID8gbltzLmlzSG9yaXpvbnRhbCgpID8gXCJzY3JvbGxMZWZ0XCIgOiBcInNjcm9sbFRvcFwiXSA9IHMuaXNIb3Jpem9udGFsKCkgPyAtZCA6IC1jIDogaS52aXJ0dWFsVHJhbnNsYXRlIHx8IHIudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke2R9cHgsICR7Y31weCwgMHB4KWApLCBzLnByZXZpb3VzVHJhbnNsYXRlID0gcy50cmFuc2xhdGUsIHMudHJhbnNsYXRlID0gcy5pc0hvcml6b250YWwoKSA/IGQgOiBjO1xyXG4gICAgICAgICAgICBjb25zdCBwID0gcy5tYXhUcmFuc2xhdGUoKSAtIHMubWluVHJhbnNsYXRlKCk7XHJcbiAgICAgICAgICAgIG8gPSAwID09PSBwID8gMCA6IChlIC0gcy5taW5UcmFuc2xhdGUoKSkgLyBwLCBvICE9PSBsICYmIHMudXBkYXRlUHJvZ3Jlc3MoZSksIHMuZW1pdChcInNldFRyYW5zbGF0ZVwiLCBzLnRyYW5zbGF0ZSwgdClcclxuICAgICAgICB9LCBtaW5UcmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnNuYXBHcmlkWzBdXHJcbiAgICAgICAgfSwgbWF4VHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtdGhpcy5zbmFwR3JpZFt0aGlzLnNuYXBHcmlkLmxlbmd0aCAtIDFdXHJcbiAgICAgICAgfSwgdHJhbnNsYXRlVG86IGZ1bmN0aW9uIChlLCB0LCBzLCBhLCBpKSB7XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IDApLCB2b2lkIDAgPT09IHQgJiYgKHQgPSB0aGlzLnBhcmFtcy5zcGVlZCksIHZvaWQgMCA9PT0gcyAmJiAocyA9ICEwKSwgdm9pZCAwID09PSBhICYmIChhID0gITApO1xyXG4gICAgICAgICAgICBjb25zdCByID0gdGhpcywge3BhcmFtczogbiwgd3JhcHBlckVsOiBsfSA9IHI7XHJcbiAgICAgICAgICAgIGlmIChyLmFuaW1hdGluZyAmJiBuLnByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbikgcmV0dXJuICExO1xyXG4gICAgICAgICAgICBjb25zdCBvID0gci5taW5UcmFuc2xhdGUoKSwgZCA9IHIubWF4VHJhbnNsYXRlKCk7XHJcbiAgICAgICAgICAgIGxldCBjO1xyXG4gICAgICAgICAgICBpZiAoYyA9IGEgJiYgZSA+IG8gPyBvIDogYSAmJiBlIDwgZCA/IGQgOiBlLCByLnVwZGF0ZVByb2dyZXNzKGMpLCBuLmNzc01vZGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSByLmlzSG9yaXpvbnRhbCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IHQpIGxbZSA/IFwic2Nyb2xsTGVmdFwiIDogXCJzY3JvbGxUb3BcIl0gPSAtYzsgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyLnN1cHBvcnQuc21vb3RoU2Nyb2xsKSByZXR1cm4gdyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXBlcjogcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UG9zaXRpb246IC1jLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlOiBlID8gXCJsZWZ0XCIgOiBcInRvcFwiXHJcbiAgICAgICAgICAgICAgICAgICAgfSksICEwO1xyXG4gICAgICAgICAgICAgICAgICAgIGwuc2Nyb2xsVG8oe1tlID8gXCJsZWZ0XCIgOiBcInRvcFwiXTogLWMsIGJlaGF2aW9yOiBcInNtb290aFwifSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAhMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAwID09PSB0ID8gKHIuc2V0VHJhbnNpdGlvbigwKSwgci5zZXRUcmFuc2xhdGUoYyksIHMgJiYgKHIuZW1pdChcImJlZm9yZVRyYW5zaXRpb25TdGFydFwiLCB0LCBpKSwgci5lbWl0KFwidHJhbnNpdGlvbkVuZFwiKSkpIDogKHIuc2V0VHJhbnNpdGlvbih0KSwgci5zZXRUcmFuc2xhdGUoYyksIHMgJiYgKHIuZW1pdChcImJlZm9yZVRyYW5zaXRpb25TdGFydFwiLCB0LCBpKSwgci5lbWl0KFwidHJhbnNpdGlvblN0YXJ0XCIpKSwgci5hbmltYXRpbmcgfHwgKHIuYW5pbWF0aW5nID0gITAsIHIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kIHx8IChyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICByICYmICFyLmRlc3Ryb3llZCAmJiBlLnRhcmdldCA9PT0gdGhpcyAmJiAoci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIHIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKSwgci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIsIHIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKSwgci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgPSBudWxsLCBkZWxldGUgci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQsIHMgJiYgci5lbWl0KFwidHJhbnNpdGlvbkVuZFwiKSlcclxuICAgICAgICAgICAgfSksIHIuJHdyYXBwZXJFbFswXS5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCByLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCksIHIuJHdyYXBwZXJFbFswXS5hZGRFdmVudExpc3RlbmVyKFwid2Via2l0VHJhbnNpdGlvbkVuZFwiLCByLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCkpKSwgITBcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIFAoZSkge1xyXG4gICAgICAgIGxldCB7c3dpcGVyOiB0LCBydW5DYWxsYmFja3M6IHMsIGRpcmVjdGlvbjogYSwgc3RlcDogaX0gPSBlO1xyXG4gICAgICAgIGNvbnN0IHthY3RpdmVJbmRleDogciwgcHJldmlvdXNJbmRleDogbn0gPSB0O1xyXG4gICAgICAgIGxldCBsID0gYTtcclxuICAgICAgICBpZiAobCB8fCAobCA9IHIgPiBuID8gXCJuZXh0XCIgOiByIDwgbiA/IFwicHJldlwiIDogXCJyZXNldFwiKSwgdC5lbWl0KGB0cmFuc2l0aW9uJHtpfWApLCBzICYmIHIgIT09IG4pIHtcclxuICAgICAgICAgICAgaWYgKFwicmVzZXRcIiA9PT0gbCkgcmV0dXJuIHZvaWQgdC5lbWl0KGBzbGlkZVJlc2V0VHJhbnNpdGlvbiR7aX1gKTtcclxuICAgICAgICAgICAgdC5lbWl0KGBzbGlkZUNoYW5nZVRyYW5zaXRpb24ke2l9YCksIFwibmV4dFwiID09PSBsID8gdC5lbWl0KGBzbGlkZU5leHRUcmFuc2l0aW9uJHtpfWApIDogdC5lbWl0KGBzbGlkZVByZXZUcmFuc2l0aW9uJHtpfWApXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBrID0ge1xyXG4gICAgICAgIHNsaWRlVG86IGZ1bmN0aW9uIChlLCB0LCBzLCBhLCBpKSB7XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGUgJiYgKGUgPSAwKSwgdm9pZCAwID09PSB0ICYmICh0ID0gdGhpcy5wYXJhbXMuc3BlZWQpLCB2b2lkIDAgPT09IHMgJiYgKHMgPSAhMCksIFwibnVtYmVyXCIgIT0gdHlwZW9mIGUgJiYgXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSkgdGhyb3cgbmV3IEVycm9yKGBUaGUgJ2luZGV4JyBhcmd1bWVudCBjYW5ub3QgaGF2ZSB0eXBlIG90aGVyIHRoYW4gJ251bWJlcicgb3IgJ3N0cmluZycuIFske3R5cGVvZiBlfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gcGFyc2VJbnQoZSwgMTApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZSh0KSkgdGhyb3cgbmV3IEVycm9yKGBUaGUgcGFzc2VkLWluICdpbmRleCcgKHN0cmluZykgY291bGRuJ3QgYmUgY29udmVydGVkIHRvICdudW1iZXInLiBbJHtlfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgICAgICAgICBlID0gdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgbiA9IGU7XHJcbiAgICAgICAgICAgIG4gPCAwICYmIChuID0gMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgICAgIHBhcmFtczogbCxcclxuICAgICAgICAgICAgICAgIHNuYXBHcmlkOiBvLFxyXG4gICAgICAgICAgICAgICAgc2xpZGVzR3JpZDogZCxcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzSW5kZXg6IGMsXHJcbiAgICAgICAgICAgICAgICBhY3RpdmVJbmRleDogcCxcclxuICAgICAgICAgICAgICAgIHJ0bFRyYW5zbGF0ZTogdSxcclxuICAgICAgICAgICAgICAgIHdyYXBwZXJFbDogaCxcclxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IG1cclxuICAgICAgICAgICAgfSA9IHI7XHJcbiAgICAgICAgICAgIGlmIChyLmFuaW1hdGluZyAmJiBsLnByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbiB8fCAhbSAmJiAhYSAmJiAhaSkgcmV0dXJuICExO1xyXG4gICAgICAgICAgICBjb25zdCBmID0gTWF0aC5taW4oci5wYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwLCBuKTtcclxuICAgICAgICAgICAgbGV0IGcgPSBmICsgTWF0aC5mbG9vcigobiAtIGYpIC8gci5wYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xyXG4gICAgICAgICAgICBnID49IG8ubGVuZ3RoICYmIChnID0gby5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgY29uc3QgdiA9IC1vW2ddO1xyXG4gICAgICAgICAgICBpZiAobC5ub3JtYWxpemVTbGlkZUluZGV4KSBmb3IgKGxldCBlID0gMDsgZSA8IGQubGVuZ3RoOyBlICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSAtTWF0aC5mbG9vcigxMDAgKiB2KSwgcyA9IE1hdGguZmxvb3IoMTAwICogZFtlXSksIGEgPSBNYXRoLmZsb29yKDEwMCAqIGRbZSArIDFdKTtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gZFtlICsgMV0gPyB0ID49IHMgJiYgdCA8IGEgLSAoYSAtIHMpIC8gMiA/IG4gPSBlIDogdCA+PSBzICYmIHQgPCBhICYmIChuID0gZSArIDEpIDogdCA+PSBzICYmIChuID0gZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoci5pbml0aWFsaXplZCAmJiBuICE9PSBwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXIuYWxsb3dTbGlkZU5leHQgJiYgdiA8IHIudHJhbnNsYXRlICYmIHYgPCByLm1pblRyYW5zbGF0ZSgpKSByZXR1cm4gITE7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXIuYWxsb3dTbGlkZVByZXYgJiYgdiA+IHIudHJhbnNsYXRlICYmIHYgPiByLm1heFRyYW5zbGF0ZSgpICYmIChwIHx8IDApICE9PSBuKSByZXR1cm4gITFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgYjtcclxuICAgICAgICAgICAgaWYgKG4gIT09IChjIHx8IDApICYmIHMgJiYgci5lbWl0KFwiYmVmb3JlU2xpZGVDaGFuZ2VTdGFydFwiKSwgci51cGRhdGVQcm9ncmVzcyh2KSwgYiA9IG4gPiBwID8gXCJuZXh0XCIgOiBuIDwgcCA/IFwicHJldlwiIDogXCJyZXNldFwiLCB1ICYmIC12ID09PSByLnRyYW5zbGF0ZSB8fCAhdSAmJiB2ID09PSByLnRyYW5zbGF0ZSkgcmV0dXJuIHIudXBkYXRlQWN0aXZlSW5kZXgobiksIGwuYXV0b0hlaWdodCAmJiByLnVwZGF0ZUF1dG9IZWlnaHQoKSwgci51cGRhdGVTbGlkZXNDbGFzc2VzKCksIFwic2xpZGVcIiAhPT0gbC5lZmZlY3QgJiYgci5zZXRUcmFuc2xhdGUodiksIFwicmVzZXRcIiAhPT0gYiAmJiAoci50cmFuc2l0aW9uU3RhcnQocywgYiksIHIudHJhbnNpdGlvbkVuZChzLCBiKSksICExO1xyXG4gICAgICAgICAgICBpZiAobC5jc3NNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gci5pc0hvcml6b250YWwoKSwgcyA9IHUgPyB2IDogLXY7XHJcbiAgICAgICAgICAgICAgICBpZiAoMCA9PT0gdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSByLnZpcnR1YWwgJiYgci5wYXJhbXMudmlydHVhbC5lbmFibGVkO1xyXG4gICAgICAgICAgICAgICAgICAgIHQgJiYgKHIud3JhcHBlckVsLnN0eWxlLnNjcm9sbFNuYXBUeXBlID0gXCJub25lXCIsIHIuX2ltbWVkaWF0ZVZpcnR1YWwgPSAhMCksIGhbZSA/IFwic2Nyb2xsTGVmdFwiIDogXCJzY3JvbGxUb3BcIl0gPSBzLCB0ICYmIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByLndyYXBwZXJFbC5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9IFwiXCIsIHIuX3N3aXBlckltbWVkaWF0ZVZpcnR1YWwgPSAhMVxyXG4gICAgICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXIuc3VwcG9ydC5zbW9vdGhTY3JvbGwpIHJldHVybiB3KHtzd2lwZXI6IHIsIHRhcmdldFBvc2l0aW9uOiBzLCBzaWRlOiBlID8gXCJsZWZ0XCIgOiBcInRvcFwifSksICEwO1xyXG4gICAgICAgICAgICAgICAgICAgIGguc2Nyb2xsVG8oe1tlID8gXCJsZWZ0XCIgOiBcInRvcFwiXTogcywgYmVoYXZpb3I6IFwic21vb3RoXCJ9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHIuc2V0VHJhbnNpdGlvbih0KSwgci5zZXRUcmFuc2xhdGUodiksIHIudXBkYXRlQWN0aXZlSW5kZXgobiksIHIudXBkYXRlU2xpZGVzQ2xhc3NlcygpLCByLmVtaXQoXCJiZWZvcmVUcmFuc2l0aW9uU3RhcnRcIiwgdCwgYSksIHIudHJhbnNpdGlvblN0YXJ0KHMsIGIpLCAwID09PSB0ID8gci50cmFuc2l0aW9uRW5kKHMsIGIpIDogci5hbmltYXRpbmcgfHwgKHIuYW5pbWF0aW5nID0gITAsIHIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgfHwgKHIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgciAmJiAhci5kZXN0cm95ZWQgJiYgZS50YXJnZXQgPT09IHRoaXMgJiYgKHIuJHdyYXBwZXJFbFswXS5yZW1vdmVFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCByLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKSwgci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIsIHIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpLCByLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kID0gbnVsbCwgZGVsZXRlIHIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQsIHIudHJhbnNpdGlvbkVuZChzLCBiKSlcclxuICAgICAgICAgICAgfSksIHIuJHdyYXBwZXJFbFswXS5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCByLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKSwgci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIsIHIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpKSwgITBcclxuICAgICAgICB9LCBzbGlkZVRvTG9vcDogZnVuY3Rpb24gKGUsIHQsIHMsIGEpIHtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZSAmJiAoZSA9IDApLCB2b2lkIDAgPT09IHQgJiYgKHQgPSB0aGlzLnBhcmFtcy5zcGVlZCksIHZvaWQgMCA9PT0gcyAmJiAocyA9ICEwKSwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHBhcnNlSW50KGUsIDEwKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUodCkpIHRocm93IG5ldyBFcnJvcihgVGhlIHBhc3NlZC1pbiAnaW5kZXgnIChzdHJpbmcpIGNvdWxkbid0IGJlIGNvbnZlcnRlZCB0byAnbnVtYmVyJy4gWyR7ZX1dIGdpdmVuLmApO1xyXG4gICAgICAgICAgICAgICAgZSA9IHRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBpID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHIgPSBlO1xyXG4gICAgICAgICAgICByZXR1cm4gaS5wYXJhbXMubG9vcCAmJiAociArPSBpLmxvb3BlZFNsaWRlcyksIGkuc2xpZGVUbyhyLCB0LCBzLCBhKVxyXG4gICAgICAgIH0sIHNsaWRlTmV4dDogZnVuY3Rpb24gKGUsIHQsIHMpIHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBlICYmIChlID0gdGhpcy5wYXJhbXMuc3BlZWQpLCB2b2lkIDAgPT09IHQgJiYgKHQgPSAhMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLCB7YW5pbWF0aW5nOiBpLCBlbmFibGVkOiByLCBwYXJhbXM6IG59ID0gYTtcclxuICAgICAgICAgICAgaWYgKCFyKSByZXR1cm4gYTtcclxuICAgICAgICAgICAgbGV0IGwgPSBuLnNsaWRlc1Blckdyb3VwO1xyXG4gICAgICAgICAgICBcImF1dG9cIiA9PT0gbi5zbGlkZXNQZXJWaWV3ICYmIDEgPT09IG4uc2xpZGVzUGVyR3JvdXAgJiYgbi5zbGlkZXNQZXJHcm91cEF1dG8gJiYgKGwgPSBNYXRoLm1heChhLnNsaWRlc1BlclZpZXdEeW5hbWljKFwiY3VycmVudFwiLCAhMCksIDEpKTtcclxuICAgICAgICAgICAgY29uc3QgbyA9IGEuYWN0aXZlSW5kZXggPCBuLnNsaWRlc1Blckdyb3VwU2tpcCA/IDEgOiBsO1xyXG4gICAgICAgICAgICBpZiAobi5sb29wKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSAmJiBuLmxvb3BQcmV2ZW50c1NsaWRlKSByZXR1cm4gITE7XHJcbiAgICAgICAgICAgICAgICBhLmxvb3BGaXgoKSwgYS5fY2xpZW50TGVmdCA9IGEuJHdyYXBwZXJFbFswXS5jbGllbnRMZWZ0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG4ucmV3aW5kICYmIGEuaXNFbmQgPyBhLnNsaWRlVG8oMCwgZSwgdCwgcykgOiBhLnNsaWRlVG8oYS5hY3RpdmVJbmRleCArIG8sIGUsIHQsIHMpXHJcbiAgICAgICAgfSwgc2xpZGVQcmV2OiBmdW5jdGlvbiAoZSwgdCwgcykge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSB0aGlzLnBhcmFtcy5zcGVlZCksIHZvaWQgMCA9PT0gdCAmJiAodCA9ICEwKTtcclxuICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMsIHtwYXJhbXM6IGksIGFuaW1hdGluZzogciwgc25hcEdyaWQ6IG4sIHNsaWRlc0dyaWQ6IGwsIHJ0bFRyYW5zbGF0ZTogbywgZW5hYmxlZDogZH0gPSBhO1xyXG4gICAgICAgICAgICBpZiAoIWQpIHJldHVybiBhO1xyXG4gICAgICAgICAgICBpZiAoaS5sb29wKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAociAmJiBpLmxvb3BQcmV2ZW50c1NsaWRlKSByZXR1cm4gITE7XHJcbiAgICAgICAgICAgICAgICBhLmxvb3BGaXgoKSwgYS5fY2xpZW50TGVmdCA9IGEuJHdyYXBwZXJFbFswXS5jbGllbnRMZWZ0XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGMoZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUgPCAwID8gLU1hdGguZmxvb3IoTWF0aC5hYnMoZSkpIDogTWF0aC5mbG9vcihlKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwID0gYyhvID8gYS50cmFuc2xhdGUgOiAtYS50cmFuc2xhdGUpLCB1ID0gbi5tYXAoKGUgPT4gYyhlKSkpO1xyXG4gICAgICAgICAgICBsZXQgaCA9IG5bdS5pbmRleE9mKHApIC0gMV07XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGggJiYgaS5jc3NNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZTtcclxuICAgICAgICAgICAgICAgIG4uZm9yRWFjaCgoKHQsIHMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBwID49IHQgJiYgKGUgPSBzKVxyXG4gICAgICAgICAgICAgICAgfSkpLCB2b2lkIDAgIT09IGUgJiYgKGggPSBuW2UgPiAwID8gZSAtIDEgOiBlXSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgbSA9IDA7XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGggJiYgKG0gPSBsLmluZGV4T2YoaCksIG0gPCAwICYmIChtID0gYS5hY3RpdmVJbmRleCAtIDEpLCBcImF1dG9cIiA9PT0gaS5zbGlkZXNQZXJWaWV3ICYmIDEgPT09IGkuc2xpZGVzUGVyR3JvdXAgJiYgaS5zbGlkZXNQZXJHcm91cEF1dG8gJiYgKG0gPSBtIC0gYS5zbGlkZXNQZXJWaWV3RHluYW1pYyhcInByZXZpb3VzXCIsICEwKSArIDEsIG0gPSBNYXRoLm1heChtLCAwKSkpLCBpLnJld2luZCAmJiBhLmlzQmVnaW5uaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gYS5wYXJhbXMudmlydHVhbCAmJiBhLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgJiYgYS52aXJ0dWFsID8gYS52aXJ0dWFsLnNsaWRlcy5sZW5ndGggLSAxIDogYS5zbGlkZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhLnNsaWRlVG8oaSwgZSwgdCwgcylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYS5zbGlkZVRvKG0sIGUsIHQsIHMpXHJcbiAgICAgICAgfSwgc2xpZGVSZXNldDogZnVuY3Rpb24gKGUsIHQsIHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gZSAmJiAoZSA9IHRoaXMucGFyYW1zLnNwZWVkKSwgdm9pZCAwID09PSB0ICYmICh0ID0gITApLCB0aGlzLnNsaWRlVG8odGhpcy5hY3RpdmVJbmRleCwgZSwgdCwgcylcclxuICAgICAgICB9LCBzbGlkZVRvQ2xvc2VzdDogZnVuY3Rpb24gKGUsIHQsIHMsIGEpIHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBlICYmIChlID0gdGhpcy5wYXJhbXMuc3BlZWQpLCB2b2lkIDAgPT09IHQgJiYgKHQgPSAhMCksIHZvaWQgMCA9PT0gYSAmJiAoYSA9IC41KTtcclxuICAgICAgICAgICAgY29uc3QgaSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCByID0gaS5hY3RpdmVJbmRleDtcclxuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKGkucGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCwgciksIGwgPSBuICsgTWF0aC5mbG9vcigociAtIG4pIC8gaS5wYXJhbXMuc2xpZGVzUGVyR3JvdXApLFxyXG4gICAgICAgICAgICAgICAgbyA9IGkucnRsVHJhbnNsYXRlID8gaS50cmFuc2xhdGUgOiAtaS50cmFuc2xhdGU7XHJcbiAgICAgICAgICAgIGlmIChvID49IGkuc25hcEdyaWRbbF0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBpLnNuYXBHcmlkW2xdO1xyXG4gICAgICAgICAgICAgICAgbyAtIGUgPiAoaS5zbmFwR3JpZFtsICsgMV0gLSBlKSAqIGEgJiYgKHIgKz0gaS5wYXJhbXMuc2xpZGVzUGVyR3JvdXApXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gaS5zbmFwR3JpZFtsIC0gMV07XHJcbiAgICAgICAgICAgICAgICBvIC0gZSA8PSAoaS5zbmFwR3JpZFtsXSAtIGUpICogYSAmJiAociAtPSBpLnBhcmFtcy5zbGlkZXNQZXJHcm91cClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gciA9IE1hdGgubWF4KHIsIDApLCByID0gTWF0aC5taW4ociwgaS5zbGlkZXNHcmlkLmxlbmd0aCAtIDEpLCBpLnNsaWRlVG8ociwgZSwgdCwgcylcclxuICAgICAgICB9LCBzbGlkZVRvQ2xpY2tlZFNsaWRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0aGlzLCB7cGFyYW1zOiB0LCAkd3JhcHBlckVsOiBzfSA9IGUsXHJcbiAgICAgICAgICAgICAgICBhID0gXCJhdXRvXCIgPT09IHQuc2xpZGVzUGVyVmlldyA/IGUuc2xpZGVzUGVyVmlld0R5bmFtaWMoKSA6IHQuc2xpZGVzUGVyVmlldztcclxuICAgICAgICAgICAgbGV0IGksIHIgPSBlLmNsaWNrZWRJbmRleDtcclxuICAgICAgICAgICAgaWYgKHQubG9vcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuYW5pbWF0aW5nKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBpID0gcGFyc2VJbnQoZChlLmNsaWNrZWRTbGlkZSkuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpLCAxMCksIHQuY2VudGVyZWRTbGlkZXMgPyByIDwgZS5sb29wZWRTbGlkZXMgLSBhIC8gMiB8fCByID4gZS5zbGlkZXMubGVuZ3RoIC0gZS5sb29wZWRTbGlkZXMgKyBhIC8gMiA/IChlLmxvb3BGaXgoKSwgciA9IHMuY2hpbGRyZW4oYC4ke3Quc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2l9XCJdOm5vdCguJHt0LnNsaWRlRHVwbGljYXRlQ2xhc3N9KWApLmVxKDApLmluZGV4KCksIHAoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBlLnNsaWRlVG8ocilcclxuICAgICAgICAgICAgICAgIH0pKSkgOiBlLnNsaWRlVG8ocikgOiByID4gZS5zbGlkZXMubGVuZ3RoIC0gYSA/IChlLmxvb3BGaXgoKSwgciA9IHMuY2hpbGRyZW4oYC4ke3Quc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2l9XCJdOm5vdCguJHt0LnNsaWRlRHVwbGljYXRlQ2xhc3N9KWApLmVxKDApLmluZGV4KCksIHAoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBlLnNsaWRlVG8ocilcclxuICAgICAgICAgICAgICAgIH0pKSkgOiBlLnNsaWRlVG8ocilcclxuICAgICAgICAgICAgfSBlbHNlIGUuc2xpZGVUbyhyKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgeiA9IHtcclxuICAgICAgICBsb29wQ3JlYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0aGlzLCB0ID0gYSgpLCB7cGFyYW1zOiBzLCAkd3JhcHBlckVsOiBpfSA9IGUsXHJcbiAgICAgICAgICAgICAgICByID0gaS5jaGlsZHJlbigpLmxlbmd0aCA+IDAgPyBkKGkuY2hpbGRyZW4oKVswXS5wYXJlbnROb2RlKSA6IGk7XHJcbiAgICAgICAgICAgIHIuY2hpbGRyZW4oYC4ke3Muc2xpZGVDbGFzc30uJHtzLnNsaWRlRHVwbGljYXRlQ2xhc3N9YCkucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIGxldCBuID0gci5jaGlsZHJlbihgLiR7cy5zbGlkZUNsYXNzfWApO1xyXG4gICAgICAgICAgICBpZiAocy5sb29wRmlsbEdyb3VwV2l0aEJsYW5rKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gcy5zbGlkZXNQZXJHcm91cCAtIG4ubGVuZ3RoICUgcy5zbGlkZXNQZXJHcm91cDtcclxuICAgICAgICAgICAgICAgIGlmIChlICE9PSBzLnNsaWRlc1Blckdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCBlOyBhICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGQodC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKS5hZGRDbGFzcyhgJHtzLnNsaWRlQ2xhc3N9ICR7cy5zbGlkZUJsYW5rQ2xhc3N9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuYXBwZW5kKGUpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG4gPSByLmNoaWxkcmVuKGAuJHtzLnNsaWRlQ2xhc3N9YClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcImF1dG9cIiAhPT0gcy5zbGlkZXNQZXJWaWV3IHx8IHMubG9vcGVkU2xpZGVzIHx8IChzLmxvb3BlZFNsaWRlcyA9IG4ubGVuZ3RoKSwgZS5sb29wZWRTbGlkZXMgPSBNYXRoLmNlaWwocGFyc2VGbG9hdChzLmxvb3BlZFNsaWRlcyB8fCBzLnNsaWRlc1BlclZpZXcsIDEwKSksIGUubG9vcGVkU2xpZGVzICs9IHMubG9vcEFkZGl0aW9uYWxTbGlkZXMsIGUubG9vcGVkU2xpZGVzID4gbi5sZW5ndGggJiYgZS5wYXJhbXMubG9vcGVkU2xpZGVzTGltaXQgJiYgKGUubG9vcGVkU2xpZGVzID0gbi5sZW5ndGgpO1xyXG4gICAgICAgICAgICBjb25zdCBsID0gW10sIG8gPSBbXTtcclxuICAgICAgICAgICAgbi5lYWNoKCgoZSwgdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZChlKS5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIiwgdClcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IGUubG9vcGVkU2xpZGVzOyB0ICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSB0IC0gTWF0aC5mbG9vcih0IC8gbi5sZW5ndGgpICogbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBvLnB1c2gobi5lcShlKVswXSksIGwudW5zaGlmdChuLmVxKG4ubGVuZ3RoIC0gZSAtIDEpWzBdKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgby5sZW5ndGg7IGUgKz0gMSkgci5hcHBlbmQoZChvW2VdLmNsb25lTm9kZSghMCkpLmFkZENsYXNzKHMuc2xpZGVEdXBsaWNhdGVDbGFzcykpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBlID0gbC5sZW5ndGggLSAxOyBlID49IDA7IGUgLT0gMSkgci5wcmVwZW5kKGQobFtlXS5jbG9uZU5vZGUoITApKS5hZGRDbGFzcyhzLnNsaWRlRHVwbGljYXRlQ2xhc3MpKVxyXG4gICAgICAgIH0sIGxvb3BGaXg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGUuZW1pdChcImJlZm9yZUxvb3BGaXhcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUluZGV4OiB0LFxyXG4gICAgICAgICAgICAgICAgc2xpZGVzOiBzLFxyXG4gICAgICAgICAgICAgICAgbG9vcGVkU2xpZGVzOiBhLFxyXG4gICAgICAgICAgICAgICAgYWxsb3dTbGlkZVByZXY6IGksXHJcbiAgICAgICAgICAgICAgICBhbGxvd1NsaWRlTmV4dDogcixcclxuICAgICAgICAgICAgICAgIHNuYXBHcmlkOiBuLFxyXG4gICAgICAgICAgICAgICAgcnRsVHJhbnNsYXRlOiBsXHJcbiAgICAgICAgICAgIH0gPSBlO1xyXG4gICAgICAgICAgICBsZXQgbztcclxuICAgICAgICAgICAgZS5hbGxvd1NsaWRlUHJldiA9ICEwLCBlLmFsbG93U2xpZGVOZXh0ID0gITA7XHJcbiAgICAgICAgICAgIGNvbnN0IGQgPSAtblt0XSAtIGUuZ2V0VHJhbnNsYXRlKCk7XHJcbiAgICAgICAgICAgIGlmICh0IDwgYSkge1xyXG4gICAgICAgICAgICAgICAgbyA9IHMubGVuZ3RoIC0gMyAqIGEgKyB0LCBvICs9IGE7XHJcbiAgICAgICAgICAgICAgICBlLnNsaWRlVG8obywgMCwgITEsICEwKSAmJiAwICE9PSBkICYmIGUuc2V0VHJhbnNsYXRlKChsID8gLWUudHJhbnNsYXRlIDogZS50cmFuc2xhdGUpIC0gZClcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0ID49IHMubGVuZ3RoIC0gYSkge1xyXG4gICAgICAgICAgICAgICAgbyA9IC1zLmxlbmd0aCArIHQgKyBhLCBvICs9IGE7XHJcbiAgICAgICAgICAgICAgICBlLnNsaWRlVG8obywgMCwgITEsICEwKSAmJiAwICE9PSBkICYmIGUuc2V0VHJhbnNsYXRlKChsID8gLWUudHJhbnNsYXRlIDogZS50cmFuc2xhdGUpIC0gZClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlLmFsbG93U2xpZGVQcmV2ID0gaSwgZS5hbGxvd1NsaWRlTmV4dCA9IHIsIGUuZW1pdChcImxvb3BGaXhcIilcclxuICAgICAgICB9LCBsb29wRGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7JHdyYXBwZXJFbDogZSwgcGFyYW1zOiB0LCBzbGlkZXM6IHN9ID0gdGhpcztcclxuICAgICAgICAgICAgZS5jaGlsZHJlbihgLiR7dC5zbGlkZUNsYXNzfS4ke3Quc2xpZGVEdXBsaWNhdGVDbGFzc30sLiR7dC5zbGlkZUNsYXNzfS4ke3Quc2xpZGVCbGFua0NsYXNzfWApLnJlbW92ZSgpLCBzLnJlbW92ZUF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gTChlKSB7XHJcbiAgICAgICAgY29uc3QgdCA9IHRoaXMsIHMgPSBhKCksIGkgPSByKCksIG4gPSB0LnRvdWNoRXZlbnRzRGF0YSwge3BhcmFtczogbCwgdG91Y2hlczogbywgZW5hYmxlZDogY30gPSB0O1xyXG4gICAgICAgIGlmICghYykgcmV0dXJuO1xyXG4gICAgICAgIGlmICh0LmFuaW1hdGluZyAmJiBsLnByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbikgcmV0dXJuO1xyXG4gICAgICAgICF0LmFuaW1hdGluZyAmJiBsLmNzc01vZGUgJiYgbC5sb29wICYmIHQubG9vcEZpeCgpO1xyXG4gICAgICAgIGxldCBwID0gZTtcclxuICAgICAgICBwLm9yaWdpbmFsRXZlbnQgJiYgKHAgPSBwLm9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgIGxldCBoID0gZChwLnRhcmdldCk7XHJcbiAgICAgICAgaWYgKFwid3JhcHBlclwiID09PSBsLnRvdWNoRXZlbnRzVGFyZ2V0ICYmICFoLmNsb3Nlc3QodC53cmFwcGVyRWwpLmxlbmd0aCkgcmV0dXJuO1xyXG4gICAgICAgIGlmIChuLmlzVG91Y2hFdmVudCA9IFwidG91Y2hzdGFydFwiID09PSBwLnR5cGUsICFuLmlzVG91Y2hFdmVudCAmJiBcIndoaWNoXCIgaW4gcCAmJiAzID09PSBwLndoaWNoKSByZXR1cm47XHJcbiAgICAgICAgaWYgKCFuLmlzVG91Y2hFdmVudCAmJiBcImJ1dHRvblwiIGluIHAgJiYgcC5idXR0b24gPiAwKSByZXR1cm47XHJcbiAgICAgICAgaWYgKG4uaXNUb3VjaGVkICYmIG4uaXNNb3ZlZCkgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IG0gPSAhIWwubm9Td2lwaW5nQ2xhc3MgJiYgXCJcIiAhPT0gbC5ub1N3aXBpbmdDbGFzcywgZiA9IGUuY29tcG9zZWRQYXRoID8gZS5jb21wb3NlZFBhdGgoKSA6IGUucGF0aDtcclxuICAgICAgICBtICYmIHAudGFyZ2V0ICYmIHAudGFyZ2V0LnNoYWRvd1Jvb3QgJiYgZiAmJiAoaCA9IGQoZlswXSkpO1xyXG4gICAgICAgIGNvbnN0IGcgPSBsLm5vU3dpcGluZ1NlbGVjdG9yID8gbC5ub1N3aXBpbmdTZWxlY3RvciA6IGAuJHtsLm5vU3dpcGluZ0NsYXNzfWAsXHJcbiAgICAgICAgICAgIHYgPSAhKCFwLnRhcmdldCB8fCAhcC50YXJnZXQuc2hhZG93Um9vdCk7XHJcbiAgICAgICAgaWYgKGwubm9Td2lwaW5nICYmICh2ID8gZnVuY3Rpb24gKGUsIHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gdCAmJiAodCA9IHRoaXMpLCBmdW5jdGlvbiB0KHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcyB8fCBzID09PSBhKCkgfHwgcyA9PT0gcigpKSByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIHMuYXNzaWduZWRTbG90ICYmIChzID0gcy5hc3NpZ25lZFNsb3QpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IHMuY2xvc2VzdChlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpIHx8IHMuZ2V0Um9vdE5vZGUgPyBpIHx8IHQocy5nZXRSb290Tm9kZSgpLmhvc3QpIDogbnVsbFxyXG4gICAgICAgICAgICB9KHQpXHJcbiAgICAgICAgfShnLCBoWzBdKSA6IGguY2xvc2VzdChnKVswXSkpIHJldHVybiB2b2lkICh0LmFsbG93Q2xpY2sgPSAhMCk7XHJcbiAgICAgICAgaWYgKGwuc3dpcGVIYW5kbGVyICYmICFoLmNsb3Nlc3QobC5zd2lwZUhhbmRsZXIpWzBdKSByZXR1cm47XHJcbiAgICAgICAgby5jdXJyZW50WCA9IFwidG91Y2hzdGFydFwiID09PSBwLnR5cGUgPyBwLnRhcmdldFRvdWNoZXNbMF0ucGFnZVggOiBwLnBhZ2VYLCBvLmN1cnJlbnRZID0gXCJ0b3VjaHN0YXJ0XCIgPT09IHAudHlwZSA/IHAudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSA6IHAucGFnZVk7XHJcbiAgICAgICAgY29uc3QgdyA9IG8uY3VycmVudFgsIGIgPSBvLmN1cnJlbnRZLCB4ID0gbC5lZGdlU3dpcGVEZXRlY3Rpb24gfHwgbC5pT1NFZGdlU3dpcGVEZXRlY3Rpb24sXHJcbiAgICAgICAgICAgIHkgPSBsLmVkZ2VTd2lwZVRocmVzaG9sZCB8fCBsLmlPU0VkZ2VTd2lwZVRocmVzaG9sZDtcclxuICAgICAgICBpZiAoeCAmJiAodyA8PSB5IHx8IHcgPj0gaS5pbm5lcldpZHRoIC0geSkpIHtcclxuICAgICAgICAgICAgaWYgKFwicHJldmVudFwiICE9PSB4KSByZXR1cm47XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoT2JqZWN0LmFzc2lnbihuLCB7XHJcbiAgICAgICAgICAgIGlzVG91Y2hlZDogITAsXHJcbiAgICAgICAgICAgIGlzTW92ZWQ6ICExLFxyXG4gICAgICAgICAgICBhbGxvd1RvdWNoQ2FsbGJhY2tzOiAhMCxcclxuICAgICAgICAgICAgaXNTY3JvbGxpbmc6IHZvaWQgMCxcclxuICAgICAgICAgICAgc3RhcnRNb3Zpbmc6IHZvaWQgMFxyXG4gICAgICAgIH0pLCBvLnN0YXJ0WCA9IHcsIG8uc3RhcnRZID0gYiwgbi50b3VjaFN0YXJ0VGltZSA9IHUoKSwgdC5hbGxvd0NsaWNrID0gITAsIHQudXBkYXRlU2l6ZSgpLCB0LnN3aXBlRGlyZWN0aW9uID0gdm9pZCAwLCBsLnRocmVzaG9sZCA+IDAgJiYgKG4uYWxsb3dUaHJlc2hvbGRNb3ZlID0gITEpLCBcInRvdWNoc3RhcnRcIiAhPT0gcC50eXBlKSB7XHJcbiAgICAgICAgICAgIGxldCBlID0gITA7XHJcbiAgICAgICAgICAgIGguaXMobi5mb2N1c2FibGVFbGVtZW50cykgJiYgKGUgPSAhMSwgXCJTRUxFQ1RcIiA9PT0gaFswXS5ub2RlTmFtZSAmJiAobi5pc1RvdWNoZWQgPSAhMSkpLCBzLmFjdGl2ZUVsZW1lbnQgJiYgZChzLmFjdGl2ZUVsZW1lbnQpLmlzKG4uZm9jdXNhYmxlRWxlbWVudHMpICYmIHMuYWN0aXZlRWxlbWVudCAhPT0gaFswXSAmJiBzLmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xyXG4gICAgICAgICAgICBjb25zdCBhID0gZSAmJiB0LmFsbG93VG91Y2hNb3ZlICYmIGwudG91Y2hTdGFydFByZXZlbnREZWZhdWx0O1xyXG4gICAgICAgICAgICAhbC50b3VjaFN0YXJ0Rm9yY2VQcmV2ZW50RGVmYXVsdCAmJiAhYSB8fCBoWzBdLmlzQ29udGVudEVkaXRhYmxlIHx8IHAucHJldmVudERlZmF1bHQoKVxyXG4gICAgICAgIH1cclxuICAgICAgICB0LnBhcmFtcy5mcmVlTW9kZSAmJiB0LnBhcmFtcy5mcmVlTW9kZS5lbmFibGVkICYmIHQuZnJlZU1vZGUgJiYgdC5hbmltYXRpbmcgJiYgIWwuY3NzTW9kZSAmJiB0LmZyZWVNb2RlLm9uVG91Y2hTdGFydCgpLCB0LmVtaXQoXCJ0b3VjaFN0YXJ0XCIsIHApXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gTyhlKSB7XHJcbiAgICAgICAgY29uc3QgdCA9IGEoKSwgcyA9IHRoaXMsIGkgPSBzLnRvdWNoRXZlbnRzRGF0YSwge3BhcmFtczogciwgdG91Y2hlczogbiwgcnRsVHJhbnNsYXRlOiBsLCBlbmFibGVkOiBvfSA9IHM7XHJcbiAgICAgICAgaWYgKCFvKSByZXR1cm47XHJcbiAgICAgICAgbGV0IGMgPSBlO1xyXG4gICAgICAgIGlmIChjLm9yaWdpbmFsRXZlbnQgJiYgKGMgPSBjLm9yaWdpbmFsRXZlbnQpLCAhaS5pc1RvdWNoZWQpIHJldHVybiB2b2lkIChpLnN0YXJ0TW92aW5nICYmIGkuaXNTY3JvbGxpbmcgJiYgcy5lbWl0KFwidG91Y2hNb3ZlT3Bwb3NpdGVcIiwgYykpO1xyXG4gICAgICAgIGlmIChpLmlzVG91Y2hFdmVudCAmJiBcInRvdWNobW92ZVwiICE9PSBjLnR5cGUpIHJldHVybjtcclxuICAgICAgICBjb25zdCBwID0gXCJ0b3VjaG1vdmVcIiA9PT0gYy50eXBlICYmIGMudGFyZ2V0VG91Y2hlcyAmJiAoYy50YXJnZXRUb3VjaGVzWzBdIHx8IGMuY2hhbmdlZFRvdWNoZXNbMF0pLFxyXG4gICAgICAgICAgICBoID0gXCJ0b3VjaG1vdmVcIiA9PT0gYy50eXBlID8gcC5wYWdlWCA6IGMucGFnZVgsIG0gPSBcInRvdWNobW92ZVwiID09PSBjLnR5cGUgPyBwLnBhZ2VZIDogYy5wYWdlWTtcclxuICAgICAgICBpZiAoYy5wcmV2ZW50ZWRCeU5lc3RlZFN3aXBlcikgcmV0dXJuIG4uc3RhcnRYID0gaCwgdm9pZCAobi5zdGFydFkgPSBtKTtcclxuICAgICAgICBpZiAoIXMuYWxsb3dUb3VjaE1vdmUpIHJldHVybiBkKGMudGFyZ2V0KS5pcyhpLmZvY3VzYWJsZUVsZW1lbnRzKSB8fCAocy5hbGxvd0NsaWNrID0gITEpLCB2b2lkIChpLmlzVG91Y2hlZCAmJiAoT2JqZWN0LmFzc2lnbihuLCB7XHJcbiAgICAgICAgICAgIHN0YXJ0WDogaCxcclxuICAgICAgICAgICAgc3RhcnRZOiBtLFxyXG4gICAgICAgICAgICBjdXJyZW50WDogaCxcclxuICAgICAgICAgICAgY3VycmVudFk6IG1cclxuICAgICAgICB9KSwgaS50b3VjaFN0YXJ0VGltZSA9IHUoKSkpO1xyXG4gICAgICAgIGlmIChpLmlzVG91Y2hFdmVudCAmJiByLnRvdWNoUmVsZWFzZU9uRWRnZXMgJiYgIXIubG9vcCkgaWYgKHMuaXNWZXJ0aWNhbCgpKSB7XHJcbiAgICAgICAgICAgIGlmIChtIDwgbi5zdGFydFkgJiYgcy50cmFuc2xhdGUgPD0gcy5tYXhUcmFuc2xhdGUoKSB8fCBtID4gbi5zdGFydFkgJiYgcy50cmFuc2xhdGUgPj0gcy5taW5UcmFuc2xhdGUoKSkgcmV0dXJuIGkuaXNUb3VjaGVkID0gITEsIHZvaWQgKGkuaXNNb3ZlZCA9ICExKVxyXG4gICAgICAgIH0gZWxzZSBpZiAoaCA8IG4uc3RhcnRYICYmIHMudHJhbnNsYXRlIDw9IHMubWF4VHJhbnNsYXRlKCkgfHwgaCA+IG4uc3RhcnRYICYmIHMudHJhbnNsYXRlID49IHMubWluVHJhbnNsYXRlKCkpIHJldHVybjtcclxuICAgICAgICBpZiAoaS5pc1RvdWNoRXZlbnQgJiYgdC5hY3RpdmVFbGVtZW50ICYmIGMudGFyZ2V0ID09PSB0LmFjdGl2ZUVsZW1lbnQgJiYgZChjLnRhcmdldCkuaXMoaS5mb2N1c2FibGVFbGVtZW50cykpIHJldHVybiBpLmlzTW92ZWQgPSAhMCwgdm9pZCAocy5hbGxvd0NsaWNrID0gITEpO1xyXG4gICAgICAgIGlmIChpLmFsbG93VG91Y2hDYWxsYmFja3MgJiYgcy5lbWl0KFwidG91Y2hNb3ZlXCIsIGMpLCBjLnRhcmdldFRvdWNoZXMgJiYgYy50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEpIHJldHVybjtcclxuICAgICAgICBuLmN1cnJlbnRYID0gaCwgbi5jdXJyZW50WSA9IG07XHJcbiAgICAgICAgY29uc3QgZiA9IG4uY3VycmVudFggLSBuLnN0YXJ0WCwgZyA9IG4uY3VycmVudFkgLSBuLnN0YXJ0WTtcclxuICAgICAgICBpZiAocy5wYXJhbXMudGhyZXNob2xkICYmIE1hdGguc3FydChmICoqIDIgKyBnICoqIDIpIDwgcy5wYXJhbXMudGhyZXNob2xkKSByZXR1cm47XHJcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gaS5pc1Njcm9sbGluZykge1xyXG4gICAgICAgICAgICBsZXQgZTtcclxuICAgICAgICAgICAgcy5pc0hvcml6b250YWwoKSAmJiBuLmN1cnJlbnRZID09PSBuLnN0YXJ0WSB8fCBzLmlzVmVydGljYWwoKSAmJiBuLmN1cnJlbnRYID09PSBuLnN0YXJ0WCA/IGkuaXNTY3JvbGxpbmcgPSAhMSA6IGYgKiBmICsgZyAqIGcgPj0gMjUgJiYgKGUgPSAxODAgKiBNYXRoLmF0YW4yKE1hdGguYWJzKGcpLCBNYXRoLmFicyhmKSkgLyBNYXRoLlBJLCBpLmlzU2Nyb2xsaW5nID0gcy5pc0hvcml6b250YWwoKSA/IGUgPiByLnRvdWNoQW5nbGUgOiA5MCAtIGUgPiByLnRvdWNoQW5nbGUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpLmlzU2Nyb2xsaW5nICYmIHMuZW1pdChcInRvdWNoTW92ZU9wcG9zaXRlXCIsIGMpLCB2b2lkIDAgPT09IGkuc3RhcnRNb3ZpbmcgJiYgKG4uY3VycmVudFggPT09IG4uc3RhcnRYICYmIG4uY3VycmVudFkgPT09IG4uc3RhcnRZIHx8IChpLnN0YXJ0TW92aW5nID0gITApKSwgaS5pc1Njcm9sbGluZykgcmV0dXJuIHZvaWQgKGkuaXNUb3VjaGVkID0gITEpO1xyXG4gICAgICAgIGlmICghaS5zdGFydE1vdmluZykgcmV0dXJuO1xyXG4gICAgICAgIHMuYWxsb3dDbGljayA9ICExLCAhci5jc3NNb2RlICYmIGMuY2FuY2VsYWJsZSAmJiBjLnByZXZlbnREZWZhdWx0KCksIHIudG91Y2hNb3ZlU3RvcFByb3BhZ2F0aW9uICYmICFyLm5lc3RlZCAmJiBjLnN0b3BQcm9wYWdhdGlvbigpLCBpLmlzTW92ZWQgfHwgKHIubG9vcCAmJiAhci5jc3NNb2RlICYmIHMubG9vcEZpeCgpLCBpLnN0YXJ0VHJhbnNsYXRlID0gcy5nZXRUcmFuc2xhdGUoKSwgcy5zZXRUcmFuc2l0aW9uKDApLCBzLmFuaW1hdGluZyAmJiBzLiR3cmFwcGVyRWwudHJpZ2dlcihcIndlYmtpdFRyYW5zaXRpb25FbmQgdHJhbnNpdGlvbmVuZFwiKSwgaS5hbGxvd01vbWVudHVtQm91bmNlID0gITEsICFyLmdyYWJDdXJzb3IgfHwgITAgIT09IHMuYWxsb3dTbGlkZU5leHQgJiYgITAgIT09IHMuYWxsb3dTbGlkZVByZXYgfHwgcy5zZXRHcmFiQ3Vyc29yKCEwKSwgcy5lbWl0KFwic2xpZGVyRmlyc3RNb3ZlXCIsIGMpKSwgcy5lbWl0KFwic2xpZGVyTW92ZVwiLCBjKSwgaS5pc01vdmVkID0gITA7XHJcbiAgICAgICAgbGV0IHYgPSBzLmlzSG9yaXpvbnRhbCgpID8gZiA6IGc7XHJcbiAgICAgICAgbi5kaWZmID0gdiwgdiAqPSByLnRvdWNoUmF0aW8sIGwgJiYgKHYgPSAtdiksIHMuc3dpcGVEaXJlY3Rpb24gPSB2ID4gMCA/IFwicHJldlwiIDogXCJuZXh0XCIsIGkuY3VycmVudFRyYW5zbGF0ZSA9IHYgKyBpLnN0YXJ0VHJhbnNsYXRlO1xyXG4gICAgICAgIGxldCB3ID0gITAsIGIgPSByLnJlc2lzdGFuY2VSYXRpbztcclxuICAgICAgICBpZiAoci50b3VjaFJlbGVhc2VPbkVkZ2VzICYmIChiID0gMCksIHYgPiAwICYmIGkuY3VycmVudFRyYW5zbGF0ZSA+IHMubWluVHJhbnNsYXRlKCkgPyAodyA9ICExLCByLnJlc2lzdGFuY2UgJiYgKGkuY3VycmVudFRyYW5zbGF0ZSA9IHMubWluVHJhbnNsYXRlKCkgLSAxICsgKC1zLm1pblRyYW5zbGF0ZSgpICsgaS5zdGFydFRyYW5zbGF0ZSArIHYpICoqIGIpKSA6IHYgPCAwICYmIGkuY3VycmVudFRyYW5zbGF0ZSA8IHMubWF4VHJhbnNsYXRlKCkgJiYgKHcgPSAhMSwgci5yZXNpc3RhbmNlICYmIChpLmN1cnJlbnRUcmFuc2xhdGUgPSBzLm1heFRyYW5zbGF0ZSgpICsgMSAtIChzLm1heFRyYW5zbGF0ZSgpIC0gaS5zdGFydFRyYW5zbGF0ZSAtIHYpICoqIGIpKSwgdyAmJiAoYy5wcmV2ZW50ZWRCeU5lc3RlZFN3aXBlciA9ICEwKSwgIXMuYWxsb3dTbGlkZU5leHQgJiYgXCJuZXh0XCIgPT09IHMuc3dpcGVEaXJlY3Rpb24gJiYgaS5jdXJyZW50VHJhbnNsYXRlIDwgaS5zdGFydFRyYW5zbGF0ZSAmJiAoaS5jdXJyZW50VHJhbnNsYXRlID0gaS5zdGFydFRyYW5zbGF0ZSksICFzLmFsbG93U2xpZGVQcmV2ICYmIFwicHJldlwiID09PSBzLnN3aXBlRGlyZWN0aW9uICYmIGkuY3VycmVudFRyYW5zbGF0ZSA+IGkuc3RhcnRUcmFuc2xhdGUgJiYgKGkuY3VycmVudFRyYW5zbGF0ZSA9IGkuc3RhcnRUcmFuc2xhdGUpLCBzLmFsbG93U2xpZGVQcmV2IHx8IHMuYWxsb3dTbGlkZU5leHQgfHwgKGkuY3VycmVudFRyYW5zbGF0ZSA9IGkuc3RhcnRUcmFuc2xhdGUpLCByLnRocmVzaG9sZCA+IDApIHtcclxuICAgICAgICAgICAgaWYgKCEoTWF0aC5hYnModikgPiByLnRocmVzaG9sZCB8fCBpLmFsbG93VGhyZXNob2xkTW92ZSkpIHJldHVybiB2b2lkIChpLmN1cnJlbnRUcmFuc2xhdGUgPSBpLnN0YXJ0VHJhbnNsYXRlKTtcclxuICAgICAgICAgICAgaWYgKCFpLmFsbG93VGhyZXNob2xkTW92ZSkgcmV0dXJuIGkuYWxsb3dUaHJlc2hvbGRNb3ZlID0gITAsIG4uc3RhcnRYID0gbi5jdXJyZW50WCwgbi5zdGFydFkgPSBuLmN1cnJlbnRZLCBpLmN1cnJlbnRUcmFuc2xhdGUgPSBpLnN0YXJ0VHJhbnNsYXRlLCB2b2lkIChuLmRpZmYgPSBzLmlzSG9yaXpvbnRhbCgpID8gbi5jdXJyZW50WCAtIG4uc3RhcnRYIDogbi5jdXJyZW50WSAtIG4uc3RhcnRZKVxyXG4gICAgICAgIH1cclxuICAgICAgICByLmZvbGxvd0ZpbmdlciAmJiAhci5jc3NNb2RlICYmICgoci5mcmVlTW9kZSAmJiByLmZyZWVNb2RlLmVuYWJsZWQgJiYgcy5mcmVlTW9kZSB8fCByLndhdGNoU2xpZGVzUHJvZ3Jlc3MpICYmIChzLnVwZGF0ZUFjdGl2ZUluZGV4KCksIHMudXBkYXRlU2xpZGVzQ2xhc3NlcygpKSwgcy5wYXJhbXMuZnJlZU1vZGUgJiYgci5mcmVlTW9kZS5lbmFibGVkICYmIHMuZnJlZU1vZGUgJiYgcy5mcmVlTW9kZS5vblRvdWNoTW92ZSgpLCBzLnVwZGF0ZVByb2dyZXNzKGkuY3VycmVudFRyYW5zbGF0ZSksIHMuc2V0VHJhbnNsYXRlKGkuY3VycmVudFRyYW5zbGF0ZSkpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gSShlKSB7XHJcbiAgICAgICAgY29uc3QgdCA9IHRoaXMsIHMgPSB0LnRvdWNoRXZlbnRzRGF0YSwge3BhcmFtczogYSwgdG91Y2hlczogaSwgcnRsVHJhbnNsYXRlOiByLCBzbGlkZXNHcmlkOiBuLCBlbmFibGVkOiBsfSA9IHQ7XHJcbiAgICAgICAgaWYgKCFsKSByZXR1cm47XHJcbiAgICAgICAgbGV0IG8gPSBlO1xyXG4gICAgICAgIGlmIChvLm9yaWdpbmFsRXZlbnQgJiYgKG8gPSBvLm9yaWdpbmFsRXZlbnQpLCBzLmFsbG93VG91Y2hDYWxsYmFja3MgJiYgdC5lbWl0KFwidG91Y2hFbmRcIiwgbyksIHMuYWxsb3dUb3VjaENhbGxiYWNrcyA9ICExLCAhcy5pc1RvdWNoZWQpIHJldHVybiBzLmlzTW92ZWQgJiYgYS5ncmFiQ3Vyc29yICYmIHQuc2V0R3JhYkN1cnNvcighMSksIHMuaXNNb3ZlZCA9ICExLCB2b2lkIChzLnN0YXJ0TW92aW5nID0gITEpO1xyXG4gICAgICAgIGEuZ3JhYkN1cnNvciAmJiBzLmlzTW92ZWQgJiYgcy5pc1RvdWNoZWQgJiYgKCEwID09PSB0LmFsbG93U2xpZGVOZXh0IHx8ICEwID09PSB0LmFsbG93U2xpZGVQcmV2KSAmJiB0LnNldEdyYWJDdXJzb3IoITEpO1xyXG4gICAgICAgIGNvbnN0IGQgPSB1KCksIGMgPSBkIC0gcy50b3VjaFN0YXJ0VGltZTtcclxuICAgICAgICBpZiAodC5hbGxvd0NsaWNrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSBvLnBhdGggfHwgby5jb21wb3NlZFBhdGggJiYgby5jb21wb3NlZFBhdGgoKTtcclxuICAgICAgICAgICAgdC51cGRhdGVDbGlja2VkU2xpZGUoZSAmJiBlWzBdIHx8IG8udGFyZ2V0KSwgdC5lbWl0KFwidGFwIGNsaWNrXCIsIG8pLCBjIDwgMzAwICYmIGQgLSBzLmxhc3RDbGlja1RpbWUgPCAzMDAgJiYgdC5lbWl0KFwiZG91YmxlVGFwIGRvdWJsZUNsaWNrXCIsIG8pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzLmxhc3RDbGlja1RpbWUgPSB1KCksIHAoKCgpID0+IHtcclxuICAgICAgICAgICAgdC5kZXN0cm95ZWQgfHwgKHQuYWxsb3dDbGljayA9ICEwKVxyXG4gICAgICAgIH0pKSwgIXMuaXNUb3VjaGVkIHx8ICFzLmlzTW92ZWQgfHwgIXQuc3dpcGVEaXJlY3Rpb24gfHwgMCA9PT0gaS5kaWZmIHx8IHMuY3VycmVudFRyYW5zbGF0ZSA9PT0gcy5zdGFydFRyYW5zbGF0ZSkgcmV0dXJuIHMuaXNUb3VjaGVkID0gITEsIHMuaXNNb3ZlZCA9ICExLCB2b2lkIChzLnN0YXJ0TW92aW5nID0gITEpO1xyXG4gICAgICAgIGxldCBoO1xyXG4gICAgICAgIGlmIChzLmlzVG91Y2hlZCA9ICExLCBzLmlzTW92ZWQgPSAhMSwgcy5zdGFydE1vdmluZyA9ICExLCBoID0gYS5mb2xsb3dGaW5nZXIgPyByID8gdC50cmFuc2xhdGUgOiAtdC50cmFuc2xhdGUgOiAtcy5jdXJyZW50VHJhbnNsYXRlLCBhLmNzc01vZGUpIHJldHVybjtcclxuICAgICAgICBpZiAodC5wYXJhbXMuZnJlZU1vZGUgJiYgYS5mcmVlTW9kZS5lbmFibGVkKSByZXR1cm4gdm9pZCB0LmZyZWVNb2RlLm9uVG91Y2hFbmQoe2N1cnJlbnRQb3M6IGh9KTtcclxuICAgICAgICBsZXQgbSA9IDAsIGYgPSB0LnNsaWRlc1NpemVzR3JpZFswXTtcclxuICAgICAgICBmb3IgKGxldCBlID0gMDsgZSA8IG4ubGVuZ3RoOyBlICs9IGUgPCBhLnNsaWRlc1Blckdyb3VwU2tpcCA/IDEgOiBhLnNsaWRlc1Blckdyb3VwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSBlIDwgYS5zbGlkZXNQZXJHcm91cFNraXAgLSAxID8gMSA6IGEuc2xpZGVzUGVyR3JvdXA7XHJcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gbltlICsgdF0gPyBoID49IG5bZV0gJiYgaCA8IG5bZSArIHRdICYmIChtID0gZSwgZiA9IG5bZSArIHRdIC0gbltlXSkgOiBoID49IG5bZV0gJiYgKG0gPSBlLCBmID0gbltuLmxlbmd0aCAtIDFdIC0gbltuLmxlbmd0aCAtIDJdKVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZyA9IG51bGwsIHYgPSBudWxsO1xyXG4gICAgICAgIGEucmV3aW5kICYmICh0LmlzQmVnaW5uaW5nID8gdiA9IHQucGFyYW1zLnZpcnR1YWwgJiYgdC5wYXJhbXMudmlydHVhbC5lbmFibGVkICYmIHQudmlydHVhbCA/IHQudmlydHVhbC5zbGlkZXMubGVuZ3RoIC0gMSA6IHQuc2xpZGVzLmxlbmd0aCAtIDEgOiB0LmlzRW5kICYmIChnID0gMCkpO1xyXG4gICAgICAgIGNvbnN0IHcgPSAoaCAtIG5bbV0pIC8gZiwgYiA9IG0gPCBhLnNsaWRlc1Blckdyb3VwU2tpcCAtIDEgPyAxIDogYS5zbGlkZXNQZXJHcm91cDtcclxuICAgICAgICBpZiAoYyA+IGEubG9uZ1N3aXBlc01zKSB7XHJcbiAgICAgICAgICAgIGlmICghYS5sb25nU3dpcGVzKSByZXR1cm4gdm9pZCB0LnNsaWRlVG8odC5hY3RpdmVJbmRleCk7XHJcbiAgICAgICAgICAgIFwibmV4dFwiID09PSB0LnN3aXBlRGlyZWN0aW9uICYmICh3ID49IGEubG9uZ1N3aXBlc1JhdGlvID8gdC5zbGlkZVRvKGEucmV3aW5kICYmIHQuaXNFbmQgPyBnIDogbSArIGIpIDogdC5zbGlkZVRvKG0pKSwgXCJwcmV2XCIgPT09IHQuc3dpcGVEaXJlY3Rpb24gJiYgKHcgPiAxIC0gYS5sb25nU3dpcGVzUmF0aW8gPyB0LnNsaWRlVG8obSArIGIpIDogbnVsbCAhPT0gdiAmJiB3IDwgMCAmJiBNYXRoLmFicyh3KSA+IGEubG9uZ1N3aXBlc1JhdGlvID8gdC5zbGlkZVRvKHYpIDogdC5zbGlkZVRvKG0pKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghYS5zaG9ydFN3aXBlcykgcmV0dXJuIHZvaWQgdC5zbGlkZVRvKHQuYWN0aXZlSW5kZXgpO1xyXG4gICAgICAgICAgICB0Lm5hdmlnYXRpb24gJiYgKG8udGFyZ2V0ID09PSB0Lm5hdmlnYXRpb24ubmV4dEVsIHx8IG8udGFyZ2V0ID09PSB0Lm5hdmlnYXRpb24ucHJldkVsKSA/IG8udGFyZ2V0ID09PSB0Lm5hdmlnYXRpb24ubmV4dEVsID8gdC5zbGlkZVRvKG0gKyBiKSA6IHQuc2xpZGVUbyhtKSA6IChcIm5leHRcIiA9PT0gdC5zd2lwZURpcmVjdGlvbiAmJiB0LnNsaWRlVG8obnVsbCAhPT0gZyA/IGcgOiBtICsgYiksIFwicHJldlwiID09PSB0LnN3aXBlRGlyZWN0aW9uICYmIHQuc2xpZGVUbyhudWxsICE9PSB2ID8gdiA6IG0pKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBBKCkge1xyXG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLCB7cGFyYW1zOiB0LCBlbDogc30gPSBlO1xyXG4gICAgICAgIGlmIChzICYmIDAgPT09IHMub2Zmc2V0V2lkdGgpIHJldHVybjtcclxuICAgICAgICB0LmJyZWFrcG9pbnRzICYmIGUuc2V0QnJlYWtwb2ludCgpO1xyXG4gICAgICAgIGNvbnN0IHthbGxvd1NsaWRlTmV4dDogYSwgYWxsb3dTbGlkZVByZXY6IGksIHNuYXBHcmlkOiByfSA9IGU7XHJcbiAgICAgICAgZS5hbGxvd1NsaWRlTmV4dCA9ICEwLCBlLmFsbG93U2xpZGVQcmV2ID0gITAsIGUudXBkYXRlU2l6ZSgpLCBlLnVwZGF0ZVNsaWRlcygpLCBlLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKSwgKFwiYXV0b1wiID09PSB0LnNsaWRlc1BlclZpZXcgfHwgdC5zbGlkZXNQZXJWaWV3ID4gMSkgJiYgZS5pc0VuZCAmJiAhZS5pc0JlZ2lubmluZyAmJiAhZS5wYXJhbXMuY2VudGVyZWRTbGlkZXMgPyBlLnNsaWRlVG8oZS5zbGlkZXMubGVuZ3RoIC0gMSwgMCwgITEsICEwKSA6IGUuc2xpZGVUbyhlLmFjdGl2ZUluZGV4LCAwLCAhMSwgITApLCBlLmF1dG9wbGF5ICYmIGUuYXV0b3BsYXkucnVubmluZyAmJiBlLmF1dG9wbGF5LnBhdXNlZCAmJiBlLmF1dG9wbGF5LnJ1bigpLCBlLmFsbG93U2xpZGVQcmV2ID0gaSwgZS5hbGxvd1NsaWRlTmV4dCA9IGEsIGUucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgciAhPT0gZS5zbmFwR3JpZCAmJiBlLmNoZWNrT3ZlcmZsb3coKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEQoZSkge1xyXG4gICAgICAgIGNvbnN0IHQgPSB0aGlzO1xyXG4gICAgICAgIHQuZW5hYmxlZCAmJiAodC5hbGxvd0NsaWNrIHx8ICh0LnBhcmFtcy5wcmV2ZW50Q2xpY2tzICYmIGUucHJldmVudERlZmF1bHQoKSwgdC5wYXJhbXMucHJldmVudENsaWNrc1Byb3BhZ2F0aW9uICYmIHQuYW5pbWF0aW5nICYmIChlLnN0b3BQcm9wYWdhdGlvbigpLCBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpKSkpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gRygpIHtcclxuICAgICAgICBjb25zdCBlID0gdGhpcywge3dyYXBwZXJFbDogdCwgcnRsVHJhbnNsYXRlOiBzLCBlbmFibGVkOiBhfSA9IGU7XHJcbiAgICAgICAgaWYgKCFhKSByZXR1cm47XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgZS5wcmV2aW91c1RyYW5zbGF0ZSA9IGUudHJhbnNsYXRlLCBlLmlzSG9yaXpvbnRhbCgpID8gZS50cmFuc2xhdGUgPSAtdC5zY3JvbGxMZWZ0IDogZS50cmFuc2xhdGUgPSAtdC5zY3JvbGxUb3AsIDAgPT09IGUudHJhbnNsYXRlICYmIChlLnRyYW5zbGF0ZSA9IDApLCBlLnVwZGF0ZUFjdGl2ZUluZGV4KCksIGUudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xyXG4gICAgICAgIGNvbnN0IHIgPSBlLm1heFRyYW5zbGF0ZSgpIC0gZS5taW5UcmFuc2xhdGUoKTtcclxuICAgICAgICBpID0gMCA9PT0gciA/IDAgOiAoZS50cmFuc2xhdGUgLSBlLm1pblRyYW5zbGF0ZSgpKSAvIHIsIGkgIT09IGUucHJvZ3Jlc3MgJiYgZS51cGRhdGVQcm9ncmVzcyhzID8gLWUudHJhbnNsYXRlIDogZS50cmFuc2xhdGUpLCBlLmVtaXQoXCJzZXRUcmFuc2xhdGVcIiwgZS50cmFuc2xhdGUsICExKVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBOID0gITE7XHJcblxyXG4gICAgZnVuY3Rpb24gQigpIHtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBIID0gKGUsIHQpID0+IHtcclxuICAgICAgICBjb25zdCBzID0gYSgpLCB7cGFyYW1zOiBpLCB0b3VjaEV2ZW50czogciwgZWw6IG4sIHdyYXBwZXJFbDogbCwgZGV2aWNlOiBvLCBzdXBwb3J0OiBkfSA9IGUsIGMgPSAhIWkubmVzdGVkLFxyXG4gICAgICAgICAgICBwID0gXCJvblwiID09PSB0ID8gXCJhZGRFdmVudExpc3RlbmVyXCIgOiBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIiwgdSA9IHQ7XHJcbiAgICAgICAgaWYgKGQudG91Y2gpIHtcclxuICAgICAgICAgICAgY29uc3QgdCA9ICEoXCJ0b3VjaHN0YXJ0XCIgIT09IHIuc3RhcnQgfHwgIWQucGFzc2l2ZUxpc3RlbmVyIHx8ICFpLnBhc3NpdmVMaXN0ZW5lcnMpICYmIHtcclxuICAgICAgICAgICAgICAgIHBhc3NpdmU6ICEwLFxyXG4gICAgICAgICAgICAgICAgY2FwdHVyZTogITFcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbltwXShyLnN0YXJ0LCBlLm9uVG91Y2hTdGFydCwgdCksIG5bcF0oci5tb3ZlLCBlLm9uVG91Y2hNb3ZlLCBkLnBhc3NpdmVMaXN0ZW5lciA/IHtcclxuICAgICAgICAgICAgICAgIHBhc3NpdmU6ICExLFxyXG4gICAgICAgICAgICAgICAgY2FwdHVyZTogY1xyXG4gICAgICAgICAgICB9IDogYyksIG5bcF0oci5lbmQsIGUub25Ub3VjaEVuZCwgdCksIHIuY2FuY2VsICYmIG5bcF0oci5jYW5jZWwsIGUub25Ub3VjaEVuZCwgdClcclxuICAgICAgICB9IGVsc2UgbltwXShyLnN0YXJ0LCBlLm9uVG91Y2hTdGFydCwgITEpLCBzW3BdKHIubW92ZSwgZS5vblRvdWNoTW92ZSwgYyksIHNbcF0oci5lbmQsIGUub25Ub3VjaEVuZCwgITEpO1xyXG4gICAgICAgIChpLnByZXZlbnRDbGlja3MgfHwgaS5wcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb24pICYmIG5bcF0oXCJjbGlja1wiLCBlLm9uQ2xpY2ssICEwKSwgaS5jc3NNb2RlICYmIGxbcF0oXCJzY3JvbGxcIiwgZS5vblNjcm9sbCksIGkudXBkYXRlT25XaW5kb3dSZXNpemUgPyBlW3VdKG8uaW9zIHx8IG8uYW5kcm9pZCA/IFwicmVzaXplIG9yaWVudGF0aW9uY2hhbmdlIG9ic2VydmVyVXBkYXRlXCIgOiBcInJlc2l6ZSBvYnNlcnZlclVwZGF0ZVwiLCBBLCAhMCkgOiBlW3VdKFwib2JzZXJ2ZXJVcGRhdGVcIiwgQSwgITApXHJcbiAgICB9O1xyXG4gICAgdmFyIFggPSB7XHJcbiAgICAgICAgYXR0YWNoRXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0aGlzLCB0ID0gYSgpLCB7cGFyYW1zOiBzLCBzdXBwb3J0OiBpfSA9IGU7XHJcbiAgICAgICAgICAgIGUub25Ub3VjaFN0YXJ0ID0gTC5iaW5kKGUpLCBlLm9uVG91Y2hNb3ZlID0gTy5iaW5kKGUpLCBlLm9uVG91Y2hFbmQgPSBJLmJpbmQoZSksIHMuY3NzTW9kZSAmJiAoZS5vblNjcm9sbCA9IEcuYmluZChlKSksIGUub25DbGljayA9IEQuYmluZChlKSwgaS50b3VjaCAmJiAhTiAmJiAodC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBCKSwgTiA9ICEwKSwgSChlLCBcIm9uXCIpXHJcbiAgICAgICAgfSwgZGV0YWNoRXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIEgodGhpcywgXCJvZmZcIilcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgWSA9IChlLCB0KSA9PiBlLmdyaWQgJiYgdC5ncmlkICYmIHQuZ3JpZC5yb3dzID4gMTtcclxuICAgIHZhciBSID0ge1xyXG4gICAgICAgIGFkZENsYXNzZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHRoaXMsIHtjbGFzc05hbWVzOiB0LCBwYXJhbXM6IHMsIHJ0bDogYSwgJGVsOiBpLCBkZXZpY2U6IHIsIHN1cHBvcnQ6IG59ID0gZSwgbCA9IGZ1bmN0aW9uIChlLCB0KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gW107XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5mb3JFYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09IHR5cGVvZiBlID8gT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoYSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVbYV0gJiYgcy5wdXNoKHQgKyBhKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pKSA6IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgcy5wdXNoKHQgKyBlKVxyXG4gICAgICAgICAgICAgICAgfSkpLCBzXHJcbiAgICAgICAgICAgIH0oW1wiaW5pdGlhbGl6ZWRcIiwgcy5kaXJlY3Rpb24sIHtcInBvaW50ZXItZXZlbnRzXCI6ICFuLnRvdWNofSwge1wiZnJlZS1tb2RlXCI6IGUucGFyYW1zLmZyZWVNb2RlICYmIHMuZnJlZU1vZGUuZW5hYmxlZH0sIHthdXRvaGVpZ2h0OiBzLmF1dG9IZWlnaHR9LCB7cnRsOiBhfSwge2dyaWQ6IHMuZ3JpZCAmJiBzLmdyaWQucm93cyA+IDF9LCB7XCJncmlkLWNvbHVtblwiOiBzLmdyaWQgJiYgcy5ncmlkLnJvd3MgPiAxICYmIFwiY29sdW1uXCIgPT09IHMuZ3JpZC5maWxsfSwge2FuZHJvaWQ6IHIuYW5kcm9pZH0sIHtpb3M6IHIuaW9zfSwge1wiY3NzLW1vZGVcIjogcy5jc3NNb2RlfSwge2NlbnRlcmVkOiBzLmNzc01vZGUgJiYgcy5jZW50ZXJlZFNsaWRlc30sIHtcIndhdGNoLXByb2dyZXNzXCI6IHMud2F0Y2hTbGlkZXNQcm9ncmVzc31dLCBzLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MpO1xyXG4gICAgICAgICAgICB0LnB1c2goLi4ubCksIGkuYWRkQ2xhc3MoWy4uLnRdLmpvaW4oXCIgXCIpKSwgZS5lbWl0Q29udGFpbmVyQ2xhc3NlcygpXHJcbiAgICAgICAgfSwgcmVtb3ZlQ2xhc3NlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7JGVsOiBlLCBjbGFzc05hbWVzOiB0fSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGUucmVtb3ZlQ2xhc3ModC5qb2luKFwiIFwiKSksIHRoaXMuZW1pdENvbnRhaW5lckNsYXNzZXMoKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgVyA9IHtcclxuICAgICAgICBpbml0OiAhMCxcclxuICAgICAgICBkaXJlY3Rpb246IFwiaG9yaXpvbnRhbFwiLFxyXG4gICAgICAgIHRvdWNoRXZlbnRzVGFyZ2V0OiBcIndyYXBwZXJcIixcclxuICAgICAgICBpbml0aWFsU2xpZGU6IDAsXHJcbiAgICAgICAgc3BlZWQ6IDMwMCxcclxuICAgICAgICBjc3NNb2RlOiAhMSxcclxuICAgICAgICB1cGRhdGVPbldpbmRvd1Jlc2l6ZTogITAsXHJcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXI6ICEwLFxyXG4gICAgICAgIG5lc3RlZDogITEsXHJcbiAgICAgICAgY3JlYXRlRWxlbWVudHM6ICExLFxyXG4gICAgICAgIGVuYWJsZWQ6ICEwLFxyXG4gICAgICAgIGZvY3VzYWJsZUVsZW1lbnRzOiBcImlucHV0LCBzZWxlY3QsIG9wdGlvbiwgdGV4dGFyZWEsIGJ1dHRvbiwgdmlkZW8sIGxhYmVsXCIsXHJcbiAgICAgICAgd2lkdGg6IG51bGwsXHJcbiAgICAgICAgaGVpZ2h0OiBudWxsLFxyXG4gICAgICAgIHByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbjogITEsXHJcbiAgICAgICAgdXNlckFnZW50OiBudWxsLFxyXG4gICAgICAgIHVybDogbnVsbCxcclxuICAgICAgICBlZGdlU3dpcGVEZXRlY3Rpb246ICExLFxyXG4gICAgICAgIGVkZ2VTd2lwZVRocmVzaG9sZDogMjAsXHJcbiAgICAgICAgYXV0b0hlaWdodDogITEsXHJcbiAgICAgICAgc2V0V3JhcHBlclNpemU6ICExLFxyXG4gICAgICAgIHZpcnR1YWxUcmFuc2xhdGU6ICExLFxyXG4gICAgICAgIGVmZmVjdDogXCJzbGlkZVwiLFxyXG4gICAgICAgIGJyZWFrcG9pbnRzOiB2b2lkIDAsXHJcbiAgICAgICAgYnJlYWtwb2ludHNCYXNlOiBcIndpbmRvd1wiLFxyXG4gICAgICAgIHNwYWNlQmV0d2VlbjogMCxcclxuICAgICAgICBzbGlkZXNQZXJWaWV3OiAxLFxyXG4gICAgICAgIHNsaWRlc1Blckdyb3VwOiAxLFxyXG4gICAgICAgIHNsaWRlc1Blckdyb3VwU2tpcDogMCxcclxuICAgICAgICBzbGlkZXNQZXJHcm91cEF1dG86ICExLFxyXG4gICAgICAgIGNlbnRlcmVkU2xpZGVzOiAhMSxcclxuICAgICAgICBjZW50ZXJlZFNsaWRlc0JvdW5kczogITEsXHJcbiAgICAgICAgc2xpZGVzT2Zmc2V0QmVmb3JlOiAwLFxyXG4gICAgICAgIHNsaWRlc09mZnNldEFmdGVyOiAwLFxyXG4gICAgICAgIG5vcm1hbGl6ZVNsaWRlSW5kZXg6ICEwLFxyXG4gICAgICAgIGNlbnRlckluc3VmZmljaWVudFNsaWRlczogITEsXHJcbiAgICAgICAgd2F0Y2hPdmVyZmxvdzogITAsXHJcbiAgICAgICAgcm91bmRMZW5ndGhzOiAhMSxcclxuICAgICAgICB0b3VjaFJhdGlvOiAxLFxyXG4gICAgICAgIHRvdWNoQW5nbGU6IDQ1LFxyXG4gICAgICAgIHNpbXVsYXRlVG91Y2g6ICEwLFxyXG4gICAgICAgIHNob3J0U3dpcGVzOiAhMCxcclxuICAgICAgICBsb25nU3dpcGVzOiAhMCxcclxuICAgICAgICBsb25nU3dpcGVzUmF0aW86IC41LFxyXG4gICAgICAgIGxvbmdTd2lwZXNNczogMzAwLFxyXG4gICAgICAgIGZvbGxvd0ZpbmdlcjogITAsXHJcbiAgICAgICAgYWxsb3dUb3VjaE1vdmU6ICEwLFxyXG4gICAgICAgIHRocmVzaG9sZDogMCxcclxuICAgICAgICB0b3VjaE1vdmVTdG9wUHJvcGFnYXRpb246ICExLFxyXG4gICAgICAgIHRvdWNoU3RhcnRQcmV2ZW50RGVmYXVsdDogITAsXHJcbiAgICAgICAgdG91Y2hTdGFydEZvcmNlUHJldmVudERlZmF1bHQ6ICExLFxyXG4gICAgICAgIHRvdWNoUmVsZWFzZU9uRWRnZXM6ICExLFxyXG4gICAgICAgIHVuaXF1ZU5hdkVsZW1lbnRzOiAhMCxcclxuICAgICAgICByZXNpc3RhbmNlOiAhMCxcclxuICAgICAgICByZXNpc3RhbmNlUmF0aW86IC44NSxcclxuICAgICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiAhMSxcclxuICAgICAgICBncmFiQ3Vyc29yOiAhMSxcclxuICAgICAgICBwcmV2ZW50Q2xpY2tzOiAhMCxcclxuICAgICAgICBwcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb246ICEwLFxyXG4gICAgICAgIHNsaWRlVG9DbGlja2VkU2xpZGU6ICExLFxyXG4gICAgICAgIHByZWxvYWRJbWFnZXM6ICEwLFxyXG4gICAgICAgIHVwZGF0ZU9uSW1hZ2VzUmVhZHk6ICEwLFxyXG4gICAgICAgIGxvb3A6ICExLFxyXG4gICAgICAgIGxvb3BBZGRpdGlvbmFsU2xpZGVzOiAwLFxyXG4gICAgICAgIGxvb3BlZFNsaWRlczogbnVsbCxcclxuICAgICAgICBsb29wZWRTbGlkZXNMaW1pdDogITAsXHJcbiAgICAgICAgbG9vcEZpbGxHcm91cFdpdGhCbGFuazogITEsXHJcbiAgICAgICAgbG9vcFByZXZlbnRzU2xpZGU6ICEwLFxyXG4gICAgICAgIHJld2luZDogITEsXHJcbiAgICAgICAgYWxsb3dTbGlkZVByZXY6ICEwLFxyXG4gICAgICAgIGFsbG93U2xpZGVOZXh0OiAhMCxcclxuICAgICAgICBzd2lwZUhhbmRsZXI6IG51bGwsXHJcbiAgICAgICAgbm9Td2lwaW5nOiAhMCxcclxuICAgICAgICBub1N3aXBpbmdDbGFzczogXCJzd2lwZXItbm8tc3dpcGluZ1wiLFxyXG4gICAgICAgIG5vU3dpcGluZ1NlbGVjdG9yOiBudWxsLFxyXG4gICAgICAgIHBhc3NpdmVMaXN0ZW5lcnM6ICEwLFxyXG4gICAgICAgIG1heEJhY2tmYWNlSGlkZGVuU2xpZGVzOiAxMCxcclxuICAgICAgICBjb250YWluZXJNb2RpZmllckNsYXNzOiBcInN3aXBlci1cIixcclxuICAgICAgICBzbGlkZUNsYXNzOiBcInN3aXBlci1zbGlkZVwiLFxyXG4gICAgICAgIHNsaWRlQmxhbmtDbGFzczogXCJzd2lwZXItc2xpZGUtaW52aXNpYmxlLWJsYW5rXCIsXHJcbiAgICAgICAgc2xpZGVBY3RpdmVDbGFzczogXCJzd2lwZXItc2xpZGUtYWN0aXZlXCIsXHJcbiAgICAgICAgc2xpZGVEdXBsaWNhdGVBY3RpdmVDbGFzczogXCJzd2lwZXItc2xpZGUtZHVwbGljYXRlLWFjdGl2ZVwiLFxyXG4gICAgICAgIHNsaWRlVmlzaWJsZUNsYXNzOiBcInN3aXBlci1zbGlkZS12aXNpYmxlXCIsXHJcbiAgICAgICAgc2xpZGVEdXBsaWNhdGVDbGFzczogXCJzd2lwZXItc2xpZGUtZHVwbGljYXRlXCIsXHJcbiAgICAgICAgc2xpZGVOZXh0Q2xhc3M6IFwic3dpcGVyLXNsaWRlLW5leHRcIixcclxuICAgICAgICBzbGlkZUR1cGxpY2F0ZU5leHRDbGFzczogXCJzd2lwZXItc2xpZGUtZHVwbGljYXRlLW5leHRcIixcclxuICAgICAgICBzbGlkZVByZXZDbGFzczogXCJzd2lwZXItc2xpZGUtcHJldlwiLFxyXG4gICAgICAgIHNsaWRlRHVwbGljYXRlUHJldkNsYXNzOiBcInN3aXBlci1zbGlkZS1kdXBsaWNhdGUtcHJldlwiLFxyXG4gICAgICAgIHdyYXBwZXJDbGFzczogXCJzd2lwZXItd3JhcHBlclwiLFxyXG4gICAgICAgIHJ1bkNhbGxiYWNrc09uSW5pdDogITAsXHJcbiAgICAgICAgX2VtaXRDbGFzc2VzOiAhMVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBxKGUsIHQpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBzICYmIChzID0ge30pO1xyXG4gICAgICAgICAgICBjb25zdCBhID0gT2JqZWN0LmtleXMocylbMF0sIGkgPSBzW2FdO1xyXG4gICAgICAgICAgICBcIm9iamVjdFwiID09IHR5cGVvZiBpICYmIG51bGwgIT09IGkgPyAoW1wibmF2aWdhdGlvblwiLCBcInBhZ2luYXRpb25cIiwgXCJzY3JvbGxiYXJcIl0uaW5kZXhPZihhKSA+PSAwICYmICEwID09PSBlW2FdICYmIChlW2FdID0ge2F1dG86ICEwfSksIGEgaW4gZSAmJiBcImVuYWJsZWRcIiBpbiBpID8gKCEwID09PSBlW2FdICYmIChlW2FdID0ge2VuYWJsZWQ6ICEwfSksIFwib2JqZWN0XCIgIT0gdHlwZW9mIGVbYV0gfHwgXCJlbmFibGVkXCIgaW4gZVthXSB8fCAoZVthXS5lbmFibGVkID0gITApLCBlW2FdIHx8IChlW2FdID0ge2VuYWJsZWQ6ICExfSksIGcodCwgcykpIDogZyh0LCBzKSkgOiBnKHQsIHMpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGogPSB7XHJcbiAgICAgICAgZXZlbnRzRW1pdHRlcjogJCwgdXBkYXRlOiBTLCB0cmFuc2xhdGU6IE0sIHRyYW5zaXRpb246IHtcclxuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbjogZnVuY3Rpb24gKGUsIHQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgcy5wYXJhbXMuY3NzTW9kZSB8fCBzLiR3cmFwcGVyRWwudHJhbnNpdGlvbihlKSwgcy5lbWl0KFwic2V0VHJhbnNpdGlvblwiLCBlLCB0KVxyXG4gICAgICAgICAgICB9LCB0cmFuc2l0aW9uU3RhcnQ6IGZ1bmN0aW9uIChlLCB0KSB7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSAhMCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gdGhpcywge3BhcmFtczogYX0gPSBzO1xyXG4gICAgICAgICAgICAgICAgYS5jc3NNb2RlIHx8IChhLmF1dG9IZWlnaHQgJiYgcy51cGRhdGVBdXRvSGVpZ2h0KCksIFAoe1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXBlcjogcyxcclxuICAgICAgICAgICAgICAgICAgICBydW5DYWxsYmFja3M6IGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiB0LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IFwiU3RhcnRcIlxyXG4gICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgIH0sIHRyYW5zaXRpb25FbmQ6IGZ1bmN0aW9uIChlLCB0KSB7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSAhMCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gdGhpcywge3BhcmFtczogYX0gPSBzO1xyXG4gICAgICAgICAgICAgICAgcy5hbmltYXRpbmcgPSAhMSwgYS5jc3NNb2RlIHx8IChzLnNldFRyYW5zaXRpb24oMCksIFAoe1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXBlcjogcyxcclxuICAgICAgICAgICAgICAgICAgICBydW5DYWxsYmFja3M6IGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiB0LFxyXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IFwiRW5kXCJcclxuICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgc2xpZGU6IGssIGxvb3A6IHosIGdyYWJDdXJzb3I6IHtcclxuICAgICAgICAgICAgc2V0R3JhYkN1cnNvcjogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHQuc3VwcG9ydC50b3VjaCB8fCAhdC5wYXJhbXMuc2ltdWxhdGVUb3VjaCB8fCB0LnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHQuaXNMb2NrZWQgfHwgdC5wYXJhbXMuY3NzTW9kZSkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IFwiY29udGFpbmVyXCIgPT09IHQucGFyYW1zLnRvdWNoRXZlbnRzVGFyZ2V0ID8gdC5lbCA6IHQud3JhcHBlckVsO1xyXG4gICAgICAgICAgICAgICAgcy5zdHlsZS5jdXJzb3IgPSBcIm1vdmVcIiwgcy5zdHlsZS5jdXJzb3IgPSBlID8gXCJncmFiYmluZ1wiIDogXCJncmFiXCJcclxuICAgICAgICAgICAgfSwgdW5zZXRHcmFiQ3Vyc29yOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGUuc3VwcG9ydC50b3VjaCB8fCBlLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIGUuaXNMb2NrZWQgfHwgZS5wYXJhbXMuY3NzTW9kZSB8fCAoZVtcImNvbnRhaW5lclwiID09PSBlLnBhcmFtcy50b3VjaEV2ZW50c1RhcmdldCA/IFwiZWxcIiA6IFwid3JhcHBlckVsXCJdLnN0eWxlLmN1cnNvciA9IFwiXCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBldmVudHM6IFgsIGJyZWFrcG9pbnRzOiB7XHJcbiAgICAgICAgICAgIHNldEJyZWFrcG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSB0aGlzLCB7YWN0aXZlSW5kZXg6IHQsIGluaXRpYWxpemVkOiBzLCBsb29wZWRTbGlkZXM6IGEgPSAwLCBwYXJhbXM6IGksICRlbDogcn0gPSBlLFxyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBpLmJyZWFrcG9pbnRzO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFuIHx8IG4gJiYgMCA9PT0gT2JqZWN0LmtleXMobikubGVuZ3RoKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsID0gZS5nZXRCcmVha3BvaW50KG4sIGUucGFyYW1zLmJyZWFrcG9pbnRzQmFzZSwgZS5lbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWwgfHwgZS5jdXJyZW50QnJlYWtwb2ludCA9PT0gbCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbyA9IChsIGluIG4gPyBuW2xdIDogdm9pZCAwKSB8fCBlLm9yaWdpbmFsUGFyYW1zLCBkID0gWShlLCBpKSwgYyA9IFkoZSwgbyksIHAgPSBpLmVuYWJsZWQ7XHJcbiAgICAgICAgICAgICAgICBkICYmICFjID8gKHIucmVtb3ZlQ2xhc3MoYCR7aS5jb250YWluZXJNb2RpZmllckNsYXNzfWdyaWQgJHtpLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9Z3JpZC1jb2x1bW5gKSwgZS5lbWl0Q29udGFpbmVyQ2xhc3NlcygpKSA6ICFkICYmIGMgJiYgKHIuYWRkQ2xhc3MoYCR7aS5jb250YWluZXJNb2RpZmllckNsYXNzfWdyaWRgKSwgKG8uZ3JpZC5maWxsICYmIFwiY29sdW1uXCIgPT09IG8uZ3JpZC5maWxsIHx8ICFvLmdyaWQuZmlsbCAmJiBcImNvbHVtblwiID09PSBpLmdyaWQuZmlsbCkgJiYgci5hZGRDbGFzcyhgJHtpLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9Z3JpZC1jb2x1bW5gKSwgZS5lbWl0Q29udGFpbmVyQ2xhc3NlcygpKSwgW1wibmF2aWdhdGlvblwiLCBcInBhZ2luYXRpb25cIiwgXCJzY3JvbGxiYXJcIl0uZm9yRWFjaCgodCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IGlbdF0gJiYgaVt0XS5lbmFibGVkLCBhID0gb1t0XSAmJiBvW3RdLmVuYWJsZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcyAmJiAhYSAmJiBlW3RdLmRpc2FibGUoKSwgIXMgJiYgYSAmJiBlW3RdLmVuYWJsZSgpXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB1ID0gby5kaXJlY3Rpb24gJiYgby5kaXJlY3Rpb24gIT09IGkuZGlyZWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGggPSBpLmxvb3AgJiYgKG8uc2xpZGVzUGVyVmlldyAhPT0gaS5zbGlkZXNQZXJWaWV3IHx8IHUpO1xyXG4gICAgICAgICAgICAgICAgdSAmJiBzICYmIGUuY2hhbmdlRGlyZWN0aW9uKCksIGcoZS5wYXJhbXMsIG8pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IGUucGFyYW1zLmVuYWJsZWQ7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGUsIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxvd1RvdWNoTW92ZTogZS5wYXJhbXMuYWxsb3dUb3VjaE1vdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dTbGlkZU5leHQ6IGUucGFyYW1zLmFsbG93U2xpZGVOZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIGFsbG93U2xpZGVQcmV2OiBlLnBhcmFtcy5hbGxvd1NsaWRlUHJldlxyXG4gICAgICAgICAgICAgICAgfSksIHAgJiYgIW0gPyBlLmRpc2FibGUoKSA6ICFwICYmIG0gJiYgZS5lbmFibGUoKSwgZS5jdXJyZW50QnJlYWtwb2ludCA9IGwsIGUuZW1pdChcIl9iZWZvcmVCcmVha3BvaW50XCIsIG8pLCBoICYmIHMgJiYgKGUubG9vcERlc3Ryb3koKSwgZS5sb29wQ3JlYXRlKCksIGUudXBkYXRlU2xpZGVzKCksIGUuc2xpZGVUbyh0IC0gYSArIGUubG9vcGVkU2xpZGVzLCAwLCAhMSkpLCBlLmVtaXQoXCJicmVha3BvaW50XCIsIG8pXHJcbiAgICAgICAgICAgIH0sIGdldEJyZWFrcG9pbnQ6IGZ1bmN0aW9uIChlLCB0LCBzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSB0ICYmICh0ID0gXCJ3aW5kb3dcIiksICFlIHx8IFwiY29udGFpbmVyXCIgPT09IHQgJiYgIXMpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGxldCBhID0gITE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gcigpLCBuID0gXCJ3aW5kb3dcIiA9PT0gdCA/IGkuaW5uZXJIZWlnaHQgOiBzLmNsaWVudEhlaWdodCwgbCA9IE9iamVjdC5rZXlzKGUpLm1hcCgoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgMCA9PT0gZS5pbmRleE9mKFwiQFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gcGFyc2VGbG9hdChlLnN1YnN0cigxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7dmFsdWU6IG4gKiB0LCBwb2ludDogZX1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt2YWx1ZTogZSwgcG9pbnQ6IGV9XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBsLnNvcnQoKChlLCB0KSA9PiBwYXJzZUludChlLnZhbHVlLCAxMCkgLSBwYXJzZUludCh0LnZhbHVlLCAxMCkpKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgbC5sZW5ndGg7IGUgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHtwb2ludDogciwgdmFsdWU6IG59ID0gbFtlXTtcclxuICAgICAgICAgICAgICAgICAgICBcIndpbmRvd1wiID09PSB0ID8gaS5tYXRjaE1lZGlhKGAobWluLXdpZHRoOiAke259cHgpYCkubWF0Y2hlcyAmJiAoYSA9IHIpIDogbiA8PSBzLmNsaWVudFdpZHRoICYmIChhID0gcilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhIHx8IFwibWF4XCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGNoZWNrT3ZlcmZsb3c6IHtcclxuICAgICAgICAgICAgY2hlY2tPdmVyZmxvdzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHRoaXMsIHtpc0xvY2tlZDogdCwgcGFyYW1zOiBzfSA9IGUsIHtzbGlkZXNPZmZzZXRCZWZvcmU6IGF9ID0gcztcclxuICAgICAgICAgICAgICAgIGlmIChhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGUuc2xpZGVzLmxlbmd0aCAtIDEsIHMgPSBlLnNsaWRlc0dyaWRbdF0gKyBlLnNsaWRlc1NpemVzR3JpZFt0XSArIDIgKiBhO1xyXG4gICAgICAgICAgICAgICAgICAgIGUuaXNMb2NrZWQgPSBlLnNpemUgPiBzXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgZS5pc0xvY2tlZCA9IDEgPT09IGUuc25hcEdyaWQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgITAgPT09IHMuYWxsb3dTbGlkZU5leHQgJiYgKGUuYWxsb3dTbGlkZU5leHQgPSAhZS5pc0xvY2tlZCksICEwID09PSBzLmFsbG93U2xpZGVQcmV2ICYmIChlLmFsbG93U2xpZGVQcmV2ID0gIWUuaXNMb2NrZWQpLCB0ICYmIHQgIT09IGUuaXNMb2NrZWQgJiYgKGUuaXNFbmQgPSAhMSksIHQgIT09IGUuaXNMb2NrZWQgJiYgZS5lbWl0KGUuaXNMb2NrZWQgPyBcImxvY2tcIiA6IFwidW5sb2NrXCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBjbGFzc2VzOiBSLCBpbWFnZXM6IHtcclxuICAgICAgICAgICAgbG9hZEltYWdlOiBmdW5jdGlvbiAoZSwgdCwgcywgYSwgaSwgbikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbCA9IHIoKTtcclxuICAgICAgICAgICAgICAgIGxldCBvO1xyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGMoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbiAmJiBuKClcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBkKGUpLnBhcmVudChcInBpY3R1cmVcIilbMF0gfHwgZS5jb21wbGV0ZSAmJiBpID8gYygpIDogdCA/IChvID0gbmV3IGwuSW1hZ2UsIG8ub25sb2FkID0gYywgby5vbmVycm9yID0gYywgYSAmJiAoby5zaXplcyA9IGEpLCBzICYmIChvLnNyY3NldCA9IHMpLCB0ICYmIChvLnNyYyA9IHQpKSA6IGMoKVxyXG4gICAgICAgICAgICB9LCBwcmVsb2FkSW1hZ2VzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB0KCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT0gZSAmJiBlICYmICFlLmRlc3Ryb3llZCAmJiAodm9pZCAwICE9PSBlLmltYWdlc0xvYWRlZCAmJiAoZS5pbWFnZXNMb2FkZWQgKz0gMSksIGUuaW1hZ2VzTG9hZGVkID09PSBlLmltYWdlc1RvTG9hZC5sZW5ndGggJiYgKGUucGFyYW1zLnVwZGF0ZU9uSW1hZ2VzUmVhZHkgJiYgZS51cGRhdGUoKSwgZS5lbWl0KFwiaW1hZ2VzUmVhZHlcIikpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGUuaW1hZ2VzVG9Mb2FkID0gZS4kZWwuZmluZChcImltZ1wiKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgZS5pbWFnZXNUb0xvYWQubGVuZ3RoOyBzICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gZS5pbWFnZXNUb0xvYWRbc107XHJcbiAgICAgICAgICAgICAgICAgICAgZS5sb2FkSW1hZ2UoYSwgYS5jdXJyZW50U3JjIHx8IGEuZ2V0QXR0cmlidXRlKFwic3JjXCIpLCBhLnNyY3NldCB8fCBhLmdldEF0dHJpYnV0ZShcInNyY3NldFwiKSwgYS5zaXplcyB8fCBhLmdldEF0dHJpYnV0ZShcInNpemVzXCIpLCAhMCwgdClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIF8gPSB7fTtcclxuXHJcbiAgICBjbGFzcyBWIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgbGV0IGUsIHQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHMgPSBhcmd1bWVudHMubGVuZ3RoLCBhID0gbmV3IEFycmF5KHMpLCBpID0gMDsgaSA8IHM7IGkrKykgYVtpXSA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgaWYgKDEgPT09IGEubGVuZ3RoICYmIGFbMF0uY29uc3RydWN0b3IgJiYgXCJPYmplY3RcIiA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFbMF0pLnNsaWNlKDgsIC0xKSA/IHQgPSBhWzBdIDogW2UsIHRdID0gYSwgdCB8fCAodCA9IHt9KSwgdCA9IGcoe30sIHQpLCBlICYmICF0LmVsICYmICh0LmVsID0gZSksIHQuZWwgJiYgZCh0LmVsKS5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gW107XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZCh0LmVsKS5lYWNoKChzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gZyh7fSwgdCwge2VsOiBzfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5wdXNoKG5ldyBWKGEpKVxyXG4gICAgICAgICAgICAgICAgfSkpLCBlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgciA9IHRoaXM7XHJcbiAgICAgICAgICAgIHIuX19zd2lwZXJfXyA9ICEwLCByLnN1cHBvcnQgPSBFKCksIHIuZGV2aWNlID0gQyh7dXNlckFnZW50OiB0LnVzZXJBZ2VudH0pLCByLmJyb3dzZXIgPSBUKCksIHIuZXZlbnRzTGlzdGVuZXJzID0ge30sIHIuZXZlbnRzQW55TGlzdGVuZXJzID0gW10sIHIubW9kdWxlcyA9IFsuLi5yLl9fbW9kdWxlc19fXSwgdC5tb2R1bGVzICYmIEFycmF5LmlzQXJyYXkodC5tb2R1bGVzKSAmJiByLm1vZHVsZXMucHVzaCguLi50Lm1vZHVsZXMpO1xyXG4gICAgICAgICAgICBjb25zdCBuID0ge307XHJcbiAgICAgICAgICAgIHIubW9kdWxlcy5mb3JFYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgIGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXBlcjogcixcclxuICAgICAgICAgICAgICAgICAgICBleHRlbmRQYXJhbXM6IHEodCwgbiksXHJcbiAgICAgICAgICAgICAgICAgICAgb246IHIub24uYmluZChyKSxcclxuICAgICAgICAgICAgICAgICAgICBvbmNlOiByLm9uY2UuYmluZChyKSxcclxuICAgICAgICAgICAgICAgICAgICBvZmY6IHIub2ZmLmJpbmQociksXHJcbiAgICAgICAgICAgICAgICAgICAgZW1pdDogci5lbWl0LmJpbmQocilcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgY29uc3QgbCA9IGcoe30sIFcsIG4pO1xyXG4gICAgICAgICAgICByZXR1cm4gci5wYXJhbXMgPSBnKHt9LCBsLCBfLCB0KSwgci5vcmlnaW5hbFBhcmFtcyA9IGcoe30sIHIucGFyYW1zKSwgci5wYXNzZWRQYXJhbXMgPSBnKHt9LCB0KSwgci5wYXJhbXMgJiYgci5wYXJhbXMub24gJiYgT2JqZWN0LmtleXMoci5wYXJhbXMub24pLmZvckVhY2goKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgci5vbihlLCByLnBhcmFtcy5vbltlXSlcclxuICAgICAgICAgICAgfSkpLCByLnBhcmFtcyAmJiByLnBhcmFtcy5vbkFueSAmJiByLm9uQW55KHIucGFyYW1zLm9uQW55KSwgci4kID0gZCwgT2JqZWN0LmFzc2lnbihyLCB7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiByLnBhcmFtcy5lbmFibGVkLFxyXG4gICAgICAgICAgICAgICAgZWw6IGUsXHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzOiBbXSxcclxuICAgICAgICAgICAgICAgIHNsaWRlczogZCgpLFxyXG4gICAgICAgICAgICAgICAgc2xpZGVzR3JpZDogW10sXHJcbiAgICAgICAgICAgICAgICBzbmFwR3JpZDogW10sXHJcbiAgICAgICAgICAgICAgICBzbGlkZXNTaXplc0dyaWQ6IFtdLFxyXG4gICAgICAgICAgICAgICAgaXNIb3Jpem9udGFsOiAoKSA9PiBcImhvcml6b250YWxcIiA9PT0gci5wYXJhbXMuZGlyZWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgaXNWZXJ0aWNhbDogKCkgPT4gXCJ2ZXJ0aWNhbFwiID09PSByLnBhcmFtcy5kaXJlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBhY3RpdmVJbmRleDogMCxcclxuICAgICAgICAgICAgICAgIHJlYWxJbmRleDogMCxcclxuICAgICAgICAgICAgICAgIGlzQmVnaW5uaW5nOiAhMCxcclxuICAgICAgICAgICAgICAgIGlzRW5kOiAhMSxcclxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZTogMCxcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzVHJhbnNsYXRlOiAwLFxyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IDAsXHJcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eTogMCxcclxuICAgICAgICAgICAgICAgIGFuaW1hdGluZzogITEsXHJcbiAgICAgICAgICAgICAgICBhbGxvd1NsaWRlTmV4dDogci5wYXJhbXMuYWxsb3dTbGlkZU5leHQsXHJcbiAgICAgICAgICAgICAgICBhbGxvd1NsaWRlUHJldjogci5wYXJhbXMuYWxsb3dTbGlkZVByZXYsXHJcbiAgICAgICAgICAgICAgICB0b3VjaEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBbXCJ0b3VjaHN0YXJ0XCIsIFwidG91Y2htb3ZlXCIsIFwidG91Y2hlbmRcIiwgXCJ0b3VjaGNhbmNlbFwiXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IFtcInBvaW50ZXJkb3duXCIsIFwicG9pbnRlcm1vdmVcIiwgXCJwb2ludGVydXBcIl07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHIudG91Y2hFdmVudHNUb3VjaCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGVbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmU6IGVbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZVsyXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBlWzNdXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgci50b3VjaEV2ZW50c0Rlc2t0b3AgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0WzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlOiB0WzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHRbMl1cclxuICAgICAgICAgICAgICAgICAgICB9LCByLnN1cHBvcnQudG91Y2ggfHwgIXIucGFyYW1zLnNpbXVsYXRlVG91Y2ggPyByLnRvdWNoRXZlbnRzVG91Y2ggOiByLnRvdWNoRXZlbnRzRGVza3RvcFxyXG4gICAgICAgICAgICAgICAgfSgpLFxyXG4gICAgICAgICAgICAgICAgdG91Y2hFdmVudHNEYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNUb3VjaGVkOiB2b2lkIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNNb3ZlZDogdm9pZCAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGFsbG93VG91Y2hDYWxsYmFja3M6IHZvaWQgMCxcclxuICAgICAgICAgICAgICAgICAgICB0b3VjaFN0YXJ0VGltZTogdm9pZCAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU2Nyb2xsaW5nOiB2b2lkIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyYW5zbGF0ZTogdm9pZCAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VHJhbnNsYXRlOiB2b2lkIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUaHJlc2hvbGRNb3ZlOiB2b2lkIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNhYmxlRWxlbWVudHM6IHIucGFyYW1zLmZvY3VzYWJsZUVsZW1lbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDbGlja1RpbWU6IHUoKSxcclxuICAgICAgICAgICAgICAgICAgICBjbGlja1RpbWVvdXQ6IHZvaWQgMCxcclxuICAgICAgICAgICAgICAgICAgICB2ZWxvY2l0aWVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBhbGxvd01vbWVudHVtQm91bmNlOiB2b2lkIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNUb3VjaEV2ZW50OiB2b2lkIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNb3Zpbmc6IHZvaWQgMFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGFsbG93Q2xpY2s6ICEwLFxyXG4gICAgICAgICAgICAgICAgYWxsb3dUb3VjaE1vdmU6IHIucGFyYW1zLmFsbG93VG91Y2hNb3ZlLFxyXG4gICAgICAgICAgICAgICAgdG91Y2hlczoge3N0YXJ0WDogMCwgc3RhcnRZOiAwLCBjdXJyZW50WDogMCwgY3VycmVudFk6IDAsIGRpZmY6IDB9LFxyXG4gICAgICAgICAgICAgICAgaW1hZ2VzVG9Mb2FkOiBbXSxcclxuICAgICAgICAgICAgICAgIGltYWdlc0xvYWRlZDogMFxyXG4gICAgICAgICAgICB9KSwgci5lbWl0KFwiX3N3aXBlclwiKSwgci5wYXJhbXMuaW5pdCAmJiByLmluaXQoKSwgclxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZW5hYmxlKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdGhpcztcclxuICAgICAgICAgICAgZS5lbmFibGVkIHx8IChlLmVuYWJsZWQgPSAhMCwgZS5wYXJhbXMuZ3JhYkN1cnNvciAmJiBlLnNldEdyYWJDdXJzb3IoKSwgZS5lbWl0KFwiZW5hYmxlXCIpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGlzYWJsZSgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGUuZW5hYmxlZCAmJiAoZS5lbmFibGVkID0gITEsIGUucGFyYW1zLmdyYWJDdXJzb3IgJiYgZS51bnNldEdyYWJDdXJzb3IoKSwgZS5lbWl0KFwiZGlzYWJsZVwiKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldFByb2dyZXNzKGUsIHQpIHtcclxuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGUgPSBNYXRoLm1pbihNYXRoLm1heChlLCAwKSwgMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSBzLm1pblRyYW5zbGF0ZSgpLCBpID0gKHMubWF4VHJhbnNsYXRlKCkgLSBhKSAqIGUgKyBhO1xyXG4gICAgICAgICAgICBzLnRyYW5zbGF0ZVRvKGksIHZvaWQgMCA9PT0gdCA/IDAgOiB0KSwgcy51cGRhdGVBY3RpdmVJbmRleCgpLCBzLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZW1pdENvbnRhaW5lckNsYXNzZXMoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoIWUucGFyYW1zLl9lbWl0Q2xhc3NlcyB8fCAhZS5lbCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gZS5lbC5jbGFzc05hbWUuc3BsaXQoXCIgXCIpLmZpbHRlcigodCA9PiAwID09PSB0LmluZGV4T2YoXCJzd2lwZXJcIikgfHwgMCA9PT0gdC5pbmRleE9mKGUucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3MpKSk7XHJcbiAgICAgICAgICAgIGUuZW1pdChcIl9jb250YWluZXJDbGFzc2VzXCIsIHQuam9pbihcIiBcIikpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnZXRTbGlkZUNsYXNzZXMoZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIHQuZGVzdHJveWVkID8gXCJcIiA6IGUuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5maWx0ZXIoKGUgPT4gMCA9PT0gZS5pbmRleE9mKFwic3dpcGVyLXNsaWRlXCIpIHx8IDAgPT09IGUuaW5kZXhPZih0LnBhcmFtcy5zbGlkZUNsYXNzKSkpLmpvaW4oXCIgXCIpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlbWl0U2xpZGVzQ2xhc3NlcygpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICghZS5wYXJhbXMuX2VtaXRDbGFzc2VzIHx8ICFlLmVsKSByZXR1cm47XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSBbXTtcclxuICAgICAgICAgICAgZS5zbGlkZXMuZWFjaCgocyA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gZS5nZXRTbGlkZUNsYXNzZXMocyk7XHJcbiAgICAgICAgICAgICAgICB0LnB1c2goe3NsaWRlRWw6IHMsIGNsYXNzTmFtZXM6IGF9KSwgZS5lbWl0KFwiX3NsaWRlQ2xhc3NcIiwgcywgYSlcclxuICAgICAgICAgICAgfSkpLCBlLmVtaXQoXCJfc2xpZGVDbGFzc2VzXCIsIHQpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzbGlkZXNQZXJWaWV3RHluYW1pYyhlLCB0KSB7XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IFwiY3VycmVudFwiKSwgdm9pZCAwID09PSB0ICYmICh0ID0gITEpO1xyXG4gICAgICAgICAgICBjb25zdCB7cGFyYW1zOiBzLCBzbGlkZXM6IGEsIHNsaWRlc0dyaWQ6IGksIHNsaWRlc1NpemVzR3JpZDogciwgc2l6ZTogbiwgYWN0aXZlSW5kZXg6IGx9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IG8gPSAxO1xyXG4gICAgICAgICAgICBpZiAocy5jZW50ZXJlZFNsaWRlcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGUsIHQgPSBhW2xdLnN3aXBlclNsaWRlU2l6ZTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHMgPSBsICsgMTsgcyA8IGEubGVuZ3RoOyBzICs9IDEpIGFbc10gJiYgIWUgJiYgKHQgKz0gYVtzXS5zd2lwZXJTbGlkZVNpemUsIG8gKz0gMSwgdCA+IG4gJiYgKGUgPSAhMCkpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcyA9IGwgLSAxOyBzID49IDA7IHMgLT0gMSkgYVtzXSAmJiAhZSAmJiAodCArPSBhW3NdLnN3aXBlclNsaWRlU2l6ZSwgbyArPSAxLCB0ID4gbiAmJiAoZSA9ICEwKSlcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChcImN1cnJlbnRcIiA9PT0gZSkgZm9yIChsZXQgZSA9IGwgKyAxOyBlIDwgYS5sZW5ndGg7IGUgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgKHQgPyBpW2VdICsgcltlXSAtIGlbbF0gPCBuIDogaVtlXSAtIGlbbF0gPCBuKSAmJiAobyArPSAxKVxyXG4gICAgICAgICAgICB9IGVsc2UgZm9yIChsZXQgZSA9IGwgLSAxOyBlID49IDA7IGUgLT0gMSkge1xyXG4gICAgICAgICAgICAgICAgaVtsXSAtIGlbZV0gPCBuICYmIChvICs9IDEpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICghZSB8fCBlLmRlc3Ryb3llZCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCB7c25hcEdyaWQ6IHQsIHBhcmFtczogc30gPSBlO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gYSgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlLnJ0bFRyYW5zbGF0ZSA/IC0xICogZS50cmFuc2xhdGUgOiBlLnRyYW5zbGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBzID0gTWF0aC5taW4oTWF0aC5tYXgodCwgZS5tYXhUcmFuc2xhdGUoKSksIGUubWluVHJhbnNsYXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgZS5zZXRUcmFuc2xhdGUocyksIGUudXBkYXRlQWN0aXZlSW5kZXgoKSwgZS51cGRhdGVTbGlkZXNDbGFzc2VzKClcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgICAgIHMuYnJlYWtwb2ludHMgJiYgZS5zZXRCcmVha3BvaW50KCksIGUudXBkYXRlU2l6ZSgpLCBlLnVwZGF0ZVNsaWRlcygpLCBlLnVwZGF0ZVByb2dyZXNzKCksIGUudXBkYXRlU2xpZGVzQ2xhc3NlcygpLCBlLnBhcmFtcy5mcmVlTW9kZSAmJiBlLnBhcmFtcy5mcmVlTW9kZS5lbmFibGVkID8gKGEoKSwgZS5wYXJhbXMuYXV0b0hlaWdodCAmJiBlLnVwZGF0ZUF1dG9IZWlnaHQoKSkgOiAoaSA9IChcImF1dG9cIiA9PT0gZS5wYXJhbXMuc2xpZGVzUGVyVmlldyB8fCBlLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID4gMSkgJiYgZS5pc0VuZCAmJiAhZS5wYXJhbXMuY2VudGVyZWRTbGlkZXMgPyBlLnNsaWRlVG8oZS5zbGlkZXMubGVuZ3RoIC0gMSwgMCwgITEsICEwKSA6IGUuc2xpZGVUbyhlLmFjdGl2ZUluZGV4LCAwLCAhMSwgITApLCBpIHx8IGEoKSksIHMud2F0Y2hPdmVyZmxvdyAmJiB0ICE9PSBlLnNuYXBHcmlkICYmIGUuY2hlY2tPdmVyZmxvdygpLCBlLmVtaXQoXCJ1cGRhdGVcIilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNoYW5nZURpcmVjdGlvbihlLCB0KSB7XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gdCAmJiAodCA9ICEwKTtcclxuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXMsIGEgPSBzLnBhcmFtcy5kaXJlY3Rpb247XHJcbiAgICAgICAgICAgIHJldHVybiBlIHx8IChlID0gXCJob3Jpem9udGFsXCIgPT09IGEgPyBcInZlcnRpY2FsXCIgOiBcImhvcml6b250YWxcIiksIGUgPT09IGEgfHwgXCJob3Jpem9udGFsXCIgIT09IGUgJiYgXCJ2ZXJ0aWNhbFwiICE9PSBlIHx8IChzLiRlbC5yZW1vdmVDbGFzcyhgJHtzLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfSR7YX1gKS5hZGRDbGFzcyhgJHtzLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfSR7ZX1gKSwgcy5lbWl0Q29udGFpbmVyQ2xhc3NlcygpLCBzLnBhcmFtcy5kaXJlY3Rpb24gPSBlLCBzLnNsaWRlcy5lYWNoKCh0ID0+IHtcclxuICAgICAgICAgICAgICAgIFwidmVydGljYWxcIiA9PT0gZSA/IHQuc3R5bGUud2lkdGggPSBcIlwiIDogdC5zdHlsZS5oZWlnaHQgPSBcIlwiXHJcbiAgICAgICAgICAgIH0pKSwgcy5lbWl0KFwiY2hhbmdlRGlyZWN0aW9uXCIpLCB0ICYmIHMudXBkYXRlKCkpLCBzXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjaGFuZ2VMYW5ndWFnZURpcmVjdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzO1xyXG4gICAgICAgICAgICB0LnJ0bCAmJiBcInJ0bFwiID09PSBlIHx8ICF0LnJ0bCAmJiBcImx0clwiID09PSBlIHx8ICh0LnJ0bCA9IFwicnRsXCIgPT09IGUsIHQucnRsVHJhbnNsYXRlID0gXCJob3Jpem9udGFsXCIgPT09IHQucGFyYW1zLmRpcmVjdGlvbiAmJiB0LnJ0bCwgdC5ydGwgPyAodC4kZWwuYWRkQ2xhc3MoYCR7dC5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ydGxgKSwgdC5lbC5kaXIgPSBcInJ0bFwiKSA6ICh0LiRlbC5yZW1vdmVDbGFzcyhgJHt0LnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfXJ0bGApLCB0LmVsLmRpciA9IFwibHRyXCIpLCB0LnVwZGF0ZSgpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbW91bnQoZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHQubW91bnRlZCkgcmV0dXJuICEwO1xyXG4gICAgICAgICAgICBjb25zdCBzID0gZChlIHx8IHQucGFyYW1zLmVsKTtcclxuICAgICAgICAgICAgaWYgKCEoZSA9IHNbMF0pKSByZXR1cm4gITE7XHJcbiAgICAgICAgICAgIGUuc3dpcGVyID0gdDtcclxuICAgICAgICAgICAgY29uc3QgaSA9ICgpID0+IGAuJHsodC5wYXJhbXMud3JhcHBlckNsYXNzIHx8IFwiXCIpLnRyaW0oKS5zcGxpdChcIiBcIikuam9pbihcIi5cIil9YDtcclxuICAgICAgICAgICAgbGV0IHIgPSAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUgJiYgZS5zaGFkb3dSb290ICYmIGUuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGQoZS5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoaSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQuY2hpbGRyZW4gPSBlID0+IHMuY2hpbGRyZW4oZSksIHRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzLmNoaWxkcmVuID8gcy5jaGlsZHJlbihpKCkpIDogZChzKS5jaGlsZHJlbihpKCkpXHJcbiAgICAgICAgICAgIH0pKCk7XHJcbiAgICAgICAgICAgIGlmICgwID09PSByLmxlbmd0aCAmJiB0LnBhcmFtcy5jcmVhdGVFbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IGEoKS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICAgICAgciA9IGQoZSksIGUuY2xhc3NOYW1lID0gdC5wYXJhbXMud3JhcHBlckNsYXNzLCBzLmFwcGVuZChlKSwgcy5jaGlsZHJlbihgLiR7dC5wYXJhbXMuc2xpZGVDbGFzc31gKS5lYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByLmFwcGVuZChlKVxyXG4gICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odCwge1xyXG4gICAgICAgICAgICAgICAgJGVsOiBzLFxyXG4gICAgICAgICAgICAgICAgZWw6IGUsXHJcbiAgICAgICAgICAgICAgICAkd3JhcHBlckVsOiByLFxyXG4gICAgICAgICAgICAgICAgd3JhcHBlckVsOiByWzBdLFxyXG4gICAgICAgICAgICAgICAgbW91bnRlZDogITAsXHJcbiAgICAgICAgICAgICAgICBydGw6IFwicnRsXCIgPT09IGUuZGlyLnRvTG93ZXJDYXNlKCkgfHwgXCJydGxcIiA9PT0gcy5jc3MoXCJkaXJlY3Rpb25cIiksXHJcbiAgICAgICAgICAgICAgICBydGxUcmFuc2xhdGU6IFwiaG9yaXpvbnRhbFwiID09PSB0LnBhcmFtcy5kaXJlY3Rpb24gJiYgKFwicnRsXCIgPT09IGUuZGlyLnRvTG93ZXJDYXNlKCkgfHwgXCJydGxcIiA9PT0gcy5jc3MoXCJkaXJlY3Rpb25cIikpLFxyXG4gICAgICAgICAgICAgICAgd3JvbmdSVEw6IFwiLXdlYmtpdC1ib3hcIiA9PT0gci5jc3MoXCJkaXNwbGF5XCIpXHJcbiAgICAgICAgICAgIH0pLCAhMFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5pdChlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAodC5pbml0aWFsaXplZCkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIHJldHVybiAhMSA9PT0gdC5tb3VudChlKSB8fCAodC5lbWl0KFwiYmVmb3JlSW5pdFwiKSwgdC5wYXJhbXMuYnJlYWtwb2ludHMgJiYgdC5zZXRCcmVha3BvaW50KCksIHQuYWRkQ2xhc3NlcygpLCB0LnBhcmFtcy5sb29wICYmIHQubG9vcENyZWF0ZSgpLCB0LnVwZGF0ZVNpemUoKSwgdC51cGRhdGVTbGlkZXMoKSwgdC5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiB0LmNoZWNrT3ZlcmZsb3coKSwgdC5wYXJhbXMuZ3JhYkN1cnNvciAmJiB0LmVuYWJsZWQgJiYgdC5zZXRHcmFiQ3Vyc29yKCksIHQucGFyYW1zLnByZWxvYWRJbWFnZXMgJiYgdC5wcmVsb2FkSW1hZ2VzKCksIHQucGFyYW1zLmxvb3AgPyB0LnNsaWRlVG8odC5wYXJhbXMuaW5pdGlhbFNsaWRlICsgdC5sb29wZWRTbGlkZXMsIDAsIHQucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCwgITEsICEwKSA6IHQuc2xpZGVUbyh0LnBhcmFtcy5pbml0aWFsU2xpZGUsIDAsIHQucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCwgITEsICEwKSwgdC5hdHRhY2hFdmVudHMoKSwgdC5pbml0aWFsaXplZCA9ICEwLCB0LmVtaXQoXCJpbml0XCIpLCB0LmVtaXQoXCJhZnRlckluaXRcIikpLCB0XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkZXN0cm95KGUsIHQpIHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBlICYmIChlID0gITApLCB2b2lkIDAgPT09IHQgJiYgKHQgPSAhMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLCB7cGFyYW1zOiBhLCAkZWw6IGksICR3cmFwcGVyRWw6IHIsIHNsaWRlczogbn0gPSBzO1xyXG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSBzLnBhcmFtcyB8fCBzLmRlc3Ryb3llZCB8fCAocy5lbWl0KFwiYmVmb3JlRGVzdHJveVwiKSwgcy5pbml0aWFsaXplZCA9ICExLCBzLmRldGFjaEV2ZW50cygpLCBhLmxvb3AgJiYgcy5sb29wRGVzdHJveSgpLCB0ICYmIChzLnJlbW92ZUNsYXNzZXMoKSwgaS5yZW1vdmVBdHRyKFwic3R5bGVcIiksIHIucmVtb3ZlQXR0cihcInN0eWxlXCIpLCBuICYmIG4ubGVuZ3RoICYmIG4ucmVtb3ZlQ2xhc3MoW2Euc2xpZGVWaXNpYmxlQ2xhc3MsIGEuc2xpZGVBY3RpdmVDbGFzcywgYS5zbGlkZU5leHRDbGFzcywgYS5zbGlkZVByZXZDbGFzc10uam9pbihcIiBcIikpLnJlbW92ZUF0dHIoXCJzdHlsZVwiKS5yZW1vdmVBdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIikpLCBzLmVtaXQoXCJkZXN0cm95XCIpLCBPYmplY3Qua2V5cyhzLmV2ZW50c0xpc3RlbmVycykuZm9yRWFjaCgoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzLm9mZihlKVxyXG4gICAgICAgICAgICB9KSksICExICE9PSBlICYmIChzLiRlbFswXS5zd2lwZXIgPSBudWxsLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IGU7XHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0KS5mb3JFYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0W2VdID0gbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRbZV1cclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgIH0ocykpLCBzLmRlc3Ryb3llZCA9ICEwKSwgbnVsbFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGljIGV4dGVuZERlZmF1bHRzKGUpIHtcclxuICAgICAgICAgICAgZyhfLCBlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGljIGdldCBleHRlbmRlZERlZmF1bHRzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGljIGdldCBkZWZhdWx0cygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFdcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRpYyBpbnN0YWxsTW9kdWxlKGUpIHtcclxuICAgICAgICAgICAgVi5wcm90b3R5cGUuX19tb2R1bGVzX18gfHwgKFYucHJvdG90eXBlLl9fbW9kdWxlc19fID0gW10pO1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gVi5wcm90b3R5cGUuX19tb2R1bGVzX187XHJcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSAmJiB0LmluZGV4T2YoZSkgPCAwICYmIHQucHVzaChlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGljIHVzZShlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGUpID8gKGUuZm9yRWFjaCgoZSA9PiBWLmluc3RhbGxNb2R1bGUoZSkpKSwgVikgOiAoVi5pbnN0YWxsTW9kdWxlKGUpLCBWKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBGKGUsIHQsIHMsIGkpIHtcclxuICAgICAgICBjb25zdCByID0gYSgpO1xyXG4gICAgICAgIHJldHVybiBlLnBhcmFtcy5jcmVhdGVFbGVtZW50cyAmJiBPYmplY3Qua2V5cyhpKS5mb3JFYWNoKChhID0+IHtcclxuICAgICAgICAgICAgaWYgKCFzW2FdICYmICEwID09PSBzLmF1dG8pIHtcclxuICAgICAgICAgICAgICAgIGxldCBuID0gZS4kZWwuY2hpbGRyZW4oYC4ke2lbYV19YClbMF07XHJcbiAgICAgICAgICAgICAgICBuIHx8IChuID0gci5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBuLmNsYXNzTmFtZSA9IGlbYV0sIGUuJGVsLmFwcGVuZChuKSksIHNbYV0gPSBuLCB0W2FdID0gblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpLCBzXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gVShlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gZSAmJiAoZSA9IFwiXCIpLCBgLiR7ZS50cmltKCkucmVwbGFjZSgvKFtcXC46IVxcL10pL2csIFwiXFxcXCQxXCIpLnJlcGxhY2UoLyAvZywgXCIuXCIpfWBcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBLKGUpIHtcclxuICAgICAgICBjb25zdCB0ID0gdGhpcywgeyR3cmFwcGVyRWw6IHMsIHBhcmFtczogYX0gPSB0O1xyXG4gICAgICAgIGlmIChhLmxvb3AgJiYgdC5sb29wRGVzdHJveSgpLCBcIm9iamVjdFwiID09IHR5cGVvZiBlICYmIFwibGVuZ3RoXCIgaW4gZSkgZm9yIChsZXQgdCA9IDA7IHQgPCBlLmxlbmd0aDsgdCArPSAxKSBlW3RdICYmIHMuYXBwZW5kKGVbdF0pOyBlbHNlIHMuYXBwZW5kKGUpO1xyXG4gICAgICAgIGEubG9vcCAmJiB0Lmxvb3BDcmVhdGUoKSwgYS5vYnNlcnZlciB8fCB0LnVwZGF0ZSgpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gWihlKSB7XHJcbiAgICAgICAgY29uc3QgdCA9IHRoaXMsIHtwYXJhbXM6IHMsICR3cmFwcGVyRWw6IGEsIGFjdGl2ZUluZGV4OiBpfSA9IHQ7XHJcbiAgICAgICAgcy5sb29wICYmIHQubG9vcERlc3Ryb3koKTtcclxuICAgICAgICBsZXQgciA9IGkgKyAxO1xyXG4gICAgICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBlICYmIFwibGVuZ3RoXCIgaW4gZSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0ICs9IDEpIGVbdF0gJiYgYS5wcmVwZW5kKGVbdF0pO1xyXG4gICAgICAgICAgICByID0gaSArIGUubGVuZ3RoXHJcbiAgICAgICAgfSBlbHNlIGEucHJlcGVuZChlKTtcclxuICAgICAgICBzLmxvb3AgJiYgdC5sb29wQ3JlYXRlKCksIHMub2JzZXJ2ZXIgfHwgdC51cGRhdGUoKSwgdC5zbGlkZVRvKHIsIDAsICExKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFEoZSwgdCkge1xyXG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLCB7JHdyYXBwZXJFbDogYSwgcGFyYW1zOiBpLCBhY3RpdmVJbmRleDogcn0gPSBzO1xyXG4gICAgICAgIGxldCBuID0gcjtcclxuICAgICAgICBpLmxvb3AgJiYgKG4gLT0gcy5sb29wZWRTbGlkZXMsIHMubG9vcERlc3Ryb3koKSwgcy5zbGlkZXMgPSBhLmNoaWxkcmVuKGAuJHtpLnNsaWRlQ2xhc3N9YCkpO1xyXG4gICAgICAgIGNvbnN0IGwgPSBzLnNsaWRlcy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGUgPD0gMCkgcmV0dXJuIHZvaWQgcy5wcmVwZW5kU2xpZGUodCk7XHJcbiAgICAgICAgaWYgKGUgPj0gbCkgcmV0dXJuIHZvaWQgcy5hcHBlbmRTbGlkZSh0KTtcclxuICAgICAgICBsZXQgbyA9IG4gPiBlID8gbiArIDEgOiBuO1xyXG4gICAgICAgIGNvbnN0IGQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCB0ID0gbCAtIDE7IHQgPj0gZTsgdCAtPSAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSBzLnNsaWRlcy5lcSh0KTtcclxuICAgICAgICAgICAgZS5yZW1vdmUoKSwgZC51bnNoaWZ0KGUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiB0ICYmIFwibGVuZ3RoXCIgaW4gdCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBlID0gMDsgZSA8IHQubGVuZ3RoOyBlICs9IDEpIHRbZV0gJiYgYS5hcHBlbmQodFtlXSk7XHJcbiAgICAgICAgICAgIG8gPSBuID4gZSA/IG4gKyB0Lmxlbmd0aCA6IG5cclxuICAgICAgICB9IGVsc2UgYS5hcHBlbmQodCk7XHJcbiAgICAgICAgZm9yIChsZXQgZSA9IDA7IGUgPCBkLmxlbmd0aDsgZSArPSAxKSBhLmFwcGVuZChkW2VdKTtcclxuICAgICAgICBpLmxvb3AgJiYgcy5sb29wQ3JlYXRlKCksIGkub2JzZXJ2ZXIgfHwgcy51cGRhdGUoKSwgaS5sb29wID8gcy5zbGlkZVRvKG8gKyBzLmxvb3BlZFNsaWRlcywgMCwgITEpIDogcy5zbGlkZVRvKG8sIDAsICExKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEooZSkge1xyXG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLCB7cGFyYW1zOiBzLCAkd3JhcHBlckVsOiBhLCBhY3RpdmVJbmRleDogaX0gPSB0O1xyXG4gICAgICAgIGxldCByID0gaTtcclxuICAgICAgICBzLmxvb3AgJiYgKHIgLT0gdC5sb29wZWRTbGlkZXMsIHQubG9vcERlc3Ryb3koKSwgdC5zbGlkZXMgPSBhLmNoaWxkcmVuKGAuJHtzLnNsaWRlQ2xhc3N9YCkpO1xyXG4gICAgICAgIGxldCBuLCBsID0gcjtcclxuICAgICAgICBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiBcImxlbmd0aFwiIGluIGUpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBlLmxlbmd0aDsgcyArPSAxKSBuID0gZVtzXSwgdC5zbGlkZXNbbl0gJiYgdC5zbGlkZXMuZXEobikucmVtb3ZlKCksIG4gPCBsICYmIChsIC09IDEpO1xyXG4gICAgICAgICAgICBsID0gTWF0aC5tYXgobCwgMClcclxuICAgICAgICB9IGVsc2UgbiA9IGUsIHQuc2xpZGVzW25dICYmIHQuc2xpZGVzLmVxKG4pLnJlbW92ZSgpLCBuIDwgbCAmJiAobCAtPSAxKSwgbCA9IE1hdGgubWF4KGwsIDApO1xyXG4gICAgICAgIHMubG9vcCAmJiB0Lmxvb3BDcmVhdGUoKSwgcy5vYnNlcnZlciB8fCB0LnVwZGF0ZSgpLCBzLmxvb3AgPyB0LnNsaWRlVG8obCArIHQubG9vcGVkU2xpZGVzLCAwLCAhMSkgOiB0LnNsaWRlVG8obCwgMCwgITEpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZWUoKSB7XHJcbiAgICAgICAgY29uc3QgZSA9IHRoaXMsIHQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IGUuc2xpZGVzLmxlbmd0aDsgcyArPSAxKSB0LnB1c2gocyk7XHJcbiAgICAgICAgZS5yZW1vdmVTbGlkZSh0KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlKGUpIHtcclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIGVmZmVjdDogdCxcclxuICAgICAgICAgICAgc3dpcGVyOiBzLFxyXG4gICAgICAgICAgICBvbjogYSxcclxuICAgICAgICAgICAgc2V0VHJhbnNsYXRlOiBpLFxyXG4gICAgICAgICAgICBzZXRUcmFuc2l0aW9uOiByLFxyXG4gICAgICAgICAgICBvdmVyd3JpdGVQYXJhbXM6IG4sXHJcbiAgICAgICAgICAgIHBlcnNwZWN0aXZlOiBsLFxyXG4gICAgICAgICAgICByZWNyZWF0ZVNoYWRvd3M6IG8sXHJcbiAgICAgICAgICAgIGdldEVmZmVjdFBhcmFtczogZFxyXG4gICAgICAgIH0gPSBlO1xyXG4gICAgICAgIGxldCBjO1xyXG4gICAgICAgIGEoXCJiZWZvcmVJbml0XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzLnBhcmFtcy5lZmZlY3QgIT09IHQpIHJldHVybjtcclxuICAgICAgICAgICAgcy5jbGFzc05hbWVzLnB1c2goYCR7cy5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc30ke3R9YCksIGwgJiYgbCgpICYmIHMuY2xhc3NOYW1lcy5wdXNoKGAke3MucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9M2RgKTtcclxuICAgICAgICAgICAgY29uc3QgZSA9IG4gPyBuKCkgOiB7fTtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzLnBhcmFtcywgZSksIE9iamVjdC5hc3NpZ24ocy5vcmlnaW5hbFBhcmFtcywgZSlcclxuICAgICAgICB9KSksIGEoXCJzZXRUcmFuc2xhdGVcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgcy5wYXJhbXMuZWZmZWN0ID09PSB0ICYmIGkoKVxyXG4gICAgICAgIH0pKSwgYShcInNldFRyYW5zaXRpb25cIiwgKChlLCBhKSA9PiB7XHJcbiAgICAgICAgICAgIHMucGFyYW1zLmVmZmVjdCA9PT0gdCAmJiByKGEpXHJcbiAgICAgICAgfSkpLCBhKFwidHJhbnNpdGlvbkVuZFwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocy5wYXJhbXMuZWZmZWN0ID09PSB0ICYmIG8pIHtcclxuICAgICAgICAgICAgICAgIGlmICghZCB8fCAhZCgpLnNsaWRlU2hhZG93cykgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgcy5zbGlkZXMuZWFjaCgoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcy4kKGUpLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3AsIC5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0LCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20sIC5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnRcIikucmVtb3ZlKClcclxuICAgICAgICAgICAgICAgIH0pKSwgbygpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSksIGEoXCJ2aXJ0dWFsVXBkYXRlXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHMucGFyYW1zLmVmZmVjdCA9PT0gdCAmJiAocy5zbGlkZXMubGVuZ3RoIHx8IChjID0gITApLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGMgJiYgcy5zbGlkZXMgJiYgcy5zbGlkZXMubGVuZ3RoICYmIChpKCksIGMgPSAhMSlcclxuICAgICAgICAgICAgfSkpKVxyXG4gICAgICAgIH0pKVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNlKGUsIHQpIHtcclxuICAgICAgICByZXR1cm4gZS50cmFuc2Zvcm1FbCA/IHQuZmluZChlLnRyYW5zZm9ybUVsKS5jc3Moe1xyXG4gICAgICAgICAgICBcImJhY2tmYWNlLXZpc2liaWxpdHlcIjogXCJoaWRkZW5cIixcclxuICAgICAgICAgICAgXCItd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHlcIjogXCJoaWRkZW5cIlxyXG4gICAgICAgIH0pIDogdFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFlKGUpIHtcclxuICAgICAgICBsZXQge3N3aXBlcjogdCwgZHVyYXRpb246IHMsIHRyYW5zZm9ybUVsOiBhLCBhbGxTbGlkZXM6IGl9ID0gZTtcclxuICAgICAgICBjb25zdCB7c2xpZGVzOiByLCBhY3RpdmVJbmRleDogbiwgJHdyYXBwZXJFbDogbH0gPSB0O1xyXG4gICAgICAgIGlmICh0LnBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlICYmIDAgIT09IHMpIHtcclxuICAgICAgICAgICAgbGV0IGUsIHMgPSAhMTtcclxuICAgICAgICAgICAgZSA9IGkgPyBhID8gci5maW5kKGEpIDogciA6IGEgPyByLmVxKG4pLmZpbmQoYSkgOiByLmVxKG4pLCBlLnRyYW5zaXRpb25FbmQoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChzKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBpZiAoIXQgfHwgdC5kZXN0cm95ZWQpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHMgPSAhMCwgdC5hbmltYXRpbmcgPSAhMTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBbXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIsIFwidHJhbnNpdGlvbmVuZFwiXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQgKz0gMSkgbC50cmlnZ2VyKGVbdF0pXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpZShlLCB0LCBzKSB7XHJcbiAgICAgICAgY29uc3QgYSA9IFwic3dpcGVyLXNsaWRlLXNoYWRvd1wiICsgKHMgPyBgLSR7c31gIDogXCJcIiksIGkgPSBlLnRyYW5zZm9ybUVsID8gdC5maW5kKGUudHJhbnNmb3JtRWwpIDogdDtcclxuICAgICAgICBsZXQgciA9IGkuY2hpbGRyZW4oYC4ke2F9YCk7XHJcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoIHx8IChyID0gZChgPGRpdiBjbGFzcz1cInN3aXBlci1zbGlkZS1zaGFkb3cke3MgPyBgLSR7c31gIDogXCJcIn1cIj48L2Rpdj5gKSwgaS5hcHBlbmQocikpLCByXHJcbiAgICB9XHJcblxyXG4gICAgT2JqZWN0LmtleXMoaikuZm9yRWFjaCgoZSA9PiB7XHJcbiAgICAgICAgT2JqZWN0LmtleXMoaltlXSkuZm9yRWFjaCgodCA9PiB7XHJcbiAgICAgICAgICAgIFYucHJvdG90eXBlW3RdID0galtlXVt0XVxyXG4gICAgICAgIH0pKVxyXG4gICAgfSkpLCBWLnVzZShbZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBsZXQge3N3aXBlcjogdCwgb246IHMsIGVtaXQ6IGF9ID0gZTtcclxuICAgICAgICBjb25zdCBpID0gcigpO1xyXG4gICAgICAgIGxldCBuID0gbnVsbCwgbCA9IG51bGw7XHJcbiAgICAgICAgY29uc3QgbyA9ICgpID0+IHtcclxuICAgICAgICAgICAgdCAmJiAhdC5kZXN0cm95ZWQgJiYgdC5pbml0aWFsaXplZCAmJiAoYShcImJlZm9yZVJlc2l6ZVwiKSwgYShcInJlc2l6ZVwiKSlcclxuICAgICAgICB9LCBkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0ICYmICF0LmRlc3Ryb3llZCAmJiB0LmluaXRpYWxpemVkICYmIGEoXCJvcmllbnRhdGlvbmNoYW5nZVwiKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcyhcImluaXRcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC5wYXJhbXMucmVzaXplT2JzZXJ2ZXIgJiYgdm9pZCAwICE9PSBpLlJlc2l6ZU9ic2VydmVyID8gdCAmJiAhdC5kZXN0cm95ZWQgJiYgdC5pbml0aWFsaXplZCAmJiAobiA9IG5ldyBSZXNpemVPYnNlcnZlcigoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsID0gaS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7d2lkdGg6IHMsIGhlaWdodDogYX0gPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gcywgciA9IGE7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5mb3JFYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHtjb250ZW50Qm94U2l6ZTogcywgY29udGVudFJlY3Q6IGEsIHRhcmdldDogbn0gPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuICYmIG4gIT09IHQuZWwgfHwgKGkgPSBhID8gYS53aWR0aCA6IChzWzBdIHx8IHMpLmlubGluZVNpemUsIHIgPSBhID8gYS5oZWlnaHQgOiAoc1swXSB8fCBzKS5ibG9ja1NpemUpXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpLCBpID09PSBzICYmIHIgPT09IGEgfHwgbygpXHJcbiAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgfSkpLCBuLm9ic2VydmUodC5lbCkpIDogKGkuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBvKSwgaS5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgZCkpXHJcbiAgICAgICAgfSkpLCBzKFwiZGVzdHJveVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBsICYmIGkuY2FuY2VsQW5pbWF0aW9uRnJhbWUobCksIG4gJiYgbi51bm9ic2VydmUgJiYgdC5lbCAmJiAobi51bm9ic2VydmUodC5lbCksIG4gPSBudWxsKSwgaS5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG8pLCBpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLCBkKVxyXG4gICAgICAgIH0pKVxyXG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBsZXQge3N3aXBlcjogdCwgZXh0ZW5kUGFyYW1zOiBzLCBvbjogYSwgZW1pdDogaX0gPSBlO1xyXG4gICAgICAgIGNvbnN0IG4gPSBbXSwgbCA9IHIoKSwgbyA9IGZ1bmN0aW9uIChlLCB0KSB7XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gdCAmJiAodCA9IHt9KTtcclxuICAgICAgICAgICAgY29uc3QgcyA9IG5ldyAobC5NdXRhdGlvbk9ic2VydmVyIHx8IGwuV2Via2l0TXV0YXRpb25PYnNlcnZlcikoKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKDEgPT09IGUubGVuZ3RoKSByZXR1cm4gdm9pZCBpKFwib2JzZXJ2ZXJVcGRhdGVcIiwgZVswXSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGkoXCJvYnNlcnZlclVwZGF0ZVwiLCBlWzBdKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodCkgOiBsLnNldFRpbWVvdXQodCwgMClcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBzLm9ic2VydmUoZSwge1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogdm9pZCAwID09PSB0LmF0dHJpYnV0ZXMgfHwgdC5hdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgICAgICAgY2hpbGRMaXN0OiB2b2lkIDAgPT09IHQuY2hpbGRMaXN0IHx8IHQuY2hpbGRMaXN0LFxyXG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogdm9pZCAwID09PSB0LmNoYXJhY3RlckRhdGEgfHwgdC5jaGFyYWN0ZXJEYXRhXHJcbiAgICAgICAgICAgIH0pLCBuLnB1c2gocylcclxuICAgICAgICB9O1xyXG4gICAgICAgIHMoe29ic2VydmVyOiAhMSwgb2JzZXJ2ZVBhcmVudHM6ICExLCBvYnNlcnZlU2xpZGVDaGlsZHJlbjogITF9KSwgYShcImluaXRcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHQucGFyYW1zLm9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodC5wYXJhbXMub2JzZXJ2ZVBhcmVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gdC4kZWwucGFyZW50cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQgKz0gMSkgbyhlW3RdKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbyh0LiRlbFswXSwge2NoaWxkTGlzdDogdC5wYXJhbXMub2JzZXJ2ZVNsaWRlQ2hpbGRyZW59KSwgbyh0LiR3cmFwcGVyRWxbMF0sIHthdHRyaWJ1dGVzOiAhMX0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSksIGEoXCJkZXN0cm95XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIG4uZm9yRWFjaCgoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBlLmRpc2Nvbm5lY3QoKVxyXG4gICAgICAgICAgICB9KSksIG4uc3BsaWNlKDAsIG4ubGVuZ3RoKVxyXG4gICAgICAgIH0pKVxyXG4gICAgfV0pO1xyXG4gICAgY29uc3QgcmUgPSBbZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBsZXQgdCwge3N3aXBlcjogcywgZXh0ZW5kUGFyYW1zOiBhLCBvbjogaSwgZW1pdDogcn0gPSBlO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBuKGUsIHQpIHtcclxuICAgICAgICAgICAgY29uc3QgYSA9IHMucGFyYW1zLnZpcnR1YWw7XHJcbiAgICAgICAgICAgIGlmIChhLmNhY2hlICYmIHMudmlydHVhbC5jYWNoZVt0XSkgcmV0dXJuIHMudmlydHVhbC5jYWNoZVt0XTtcclxuICAgICAgICAgICAgY29uc3QgaSA9IGEucmVuZGVyU2xpZGUgPyBkKGEucmVuZGVyU2xpZGUuY2FsbChzLCBlLCB0KSkgOiBkKGA8ZGl2IGNsYXNzPVwiJHtzLnBhcmFtcy5zbGlkZUNsYXNzfVwiIGRhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHt0fVwiPiR7ZX08L2Rpdj5gKTtcclxuICAgICAgICAgICAgcmV0dXJuIGkuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpIHx8IGkuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIsIHQpLCBhLmNhY2hlICYmIChzLnZpcnR1YWwuY2FjaGVbdF0gPSBpKSwgaVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbChlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHtzbGlkZXNQZXJWaWV3OiB0LCBzbGlkZXNQZXJHcm91cDogYSwgY2VudGVyZWRTbGlkZXM6IGl9ID0gcy5wYXJhbXMsIHtcclxuICAgICAgICAgICAgICAgIGFkZFNsaWRlc0JlZm9yZTogbCxcclxuICAgICAgICAgICAgICAgIGFkZFNsaWRlc0FmdGVyOiBvXHJcbiAgICAgICAgICAgIH0gPSBzLnBhcmFtcy52aXJ0dWFsLCB7ZnJvbTogZCwgdG86IGMsIHNsaWRlczogcCwgc2xpZGVzR3JpZDogdSwgb2Zmc2V0OiBofSA9IHMudmlydHVhbDtcclxuICAgICAgICAgICAgcy5wYXJhbXMuY3NzTW9kZSB8fCBzLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG0gPSBzLmFjdGl2ZUluZGV4IHx8IDA7XHJcbiAgICAgICAgICAgIGxldCBmLCBnLCB2O1xyXG4gICAgICAgICAgICBmID0gcy5ydGxUcmFuc2xhdGUgPyBcInJpZ2h0XCIgOiBzLmlzSG9yaXpvbnRhbCgpID8gXCJsZWZ0XCIgOiBcInRvcFwiLCBpID8gKGcgPSBNYXRoLmZsb29yKHQgLyAyKSArIGEgKyBvLCB2ID0gTWF0aC5mbG9vcih0IC8gMikgKyBhICsgbCkgOiAoZyA9IHQgKyAoYSAtIDEpICsgbywgdiA9IGEgKyBsKTtcclxuICAgICAgICAgICAgY29uc3QgdyA9IE1hdGgubWF4KChtIHx8IDApIC0gdiwgMCksIGIgPSBNYXRoLm1pbigobSB8fCAwKSArIGcsIHAubGVuZ3RoIC0gMSksXHJcbiAgICAgICAgICAgICAgICB4ID0gKHMuc2xpZGVzR3JpZFt3XSB8fCAwKSAtIChzLnNsaWRlc0dyaWRbMF0gfHwgMCk7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiB5KCkge1xyXG4gICAgICAgICAgICAgICAgcy51cGRhdGVTbGlkZXMoKSwgcy51cGRhdGVQcm9ncmVzcygpLCBzLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKSwgcy5sYXp5ICYmIHMucGFyYW1zLmxhenkuZW5hYmxlZCAmJiBzLmxhenkubG9hZCgpLCByKFwidmlydHVhbFVwZGF0ZVwiKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmFzc2lnbihzLnZpcnR1YWwsIHtcclxuICAgICAgICAgICAgICAgIGZyb206IHcsXHJcbiAgICAgICAgICAgICAgICB0bzogYixcclxuICAgICAgICAgICAgICAgIG9mZnNldDogeCxcclxuICAgICAgICAgICAgICAgIHNsaWRlc0dyaWQ6IHMuc2xpZGVzR3JpZFxyXG4gICAgICAgICAgICB9KSwgZCA9PT0gdyAmJiBjID09PSBiICYmICFlKSByZXR1cm4gcy5zbGlkZXNHcmlkICE9PSB1ICYmIHggIT09IGggJiYgcy5zbGlkZXMuY3NzKGYsIGAke3h9cHhgKSwgcy51cGRhdGVQcm9ncmVzcygpLCB2b2lkIHIoXCJ2aXJ0dWFsVXBkYXRlXCIpO1xyXG4gICAgICAgICAgICBpZiAocy5wYXJhbXMudmlydHVhbC5yZW5kZXJFeHRlcm5hbCkgcmV0dXJuIHMucGFyYW1zLnZpcnR1YWwucmVuZGVyRXh0ZXJuYWwuY2FsbChzLCB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHgsXHJcbiAgICAgICAgICAgICAgICBmcm9tOiB3LFxyXG4gICAgICAgICAgICAgICAgdG86IGIsXHJcbiAgICAgICAgICAgICAgICBzbGlkZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdCA9IHc7IHQgPD0gYjsgdCArPSAxKSBlLnB1c2gocFt0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVcclxuICAgICAgICAgICAgICAgIH0oKVxyXG4gICAgICAgICAgICB9KSwgdm9pZCAocy5wYXJhbXMudmlydHVhbC5yZW5kZXJFeHRlcm5hbFVwZGF0ZSA/IHkoKSA6IHIoXCJ2aXJ0dWFsVXBkYXRlXCIpKTtcclxuICAgICAgICAgICAgY29uc3QgRSA9IFtdLCBDID0gW107XHJcbiAgICAgICAgICAgIGlmIChlKSBzLiR3cmFwcGVyRWwuZmluZChgLiR7cy5wYXJhbXMuc2xpZGVDbGFzc31gKS5yZW1vdmUoKTsgZWxzZSBmb3IgKGxldCBlID0gZDsgZSA8PSBjOyBlICs9IDEpIChlIDwgdyB8fCBlID4gYikgJiYgcy4kd3JhcHBlckVsLmZpbmQoYC4ke3MucGFyYW1zLnNsaWRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtlfVwiXWApLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHAubGVuZ3RoOyB0ICs9IDEpIHQgPj0gdyAmJiB0IDw9IGIgJiYgKHZvaWQgMCA9PT0gYyB8fCBlID8gQy5wdXNoKHQpIDogKHQgPiBjICYmIEMucHVzaCh0KSwgdCA8IGQgJiYgRS5wdXNoKHQpKSk7XHJcbiAgICAgICAgICAgIEMuZm9yRWFjaCgoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzLiR3cmFwcGVyRWwuYXBwZW5kKG4ocFtlXSwgZSkpXHJcbiAgICAgICAgICAgIH0pKSwgRS5zb3J0KCgoZSwgdCkgPT4gdCAtIGUpKS5mb3JFYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgIHMuJHdyYXBwZXJFbC5wcmVwZW5kKG4ocFtlXSwgZSkpXHJcbiAgICAgICAgICAgIH0pKSwgcy4kd3JhcHBlckVsLmNoaWxkcmVuKFwiLnN3aXBlci1zbGlkZVwiKS5jc3MoZiwgYCR7eH1weGApLCB5KClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGEoe1xyXG4gICAgICAgICAgICB2aXJ0dWFsOiB7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiAhMSxcclxuICAgICAgICAgICAgICAgIHNsaWRlczogW10sXHJcbiAgICAgICAgICAgICAgICBjYWNoZTogITAsXHJcbiAgICAgICAgICAgICAgICByZW5kZXJTbGlkZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIHJlbmRlckV4dGVybmFsOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyRXh0ZXJuYWxVcGRhdGU6ICEwLFxyXG4gICAgICAgICAgICAgICAgYWRkU2xpZGVzQmVmb3JlOiAwLFxyXG4gICAgICAgICAgICAgICAgYWRkU2xpZGVzQWZ0ZXI6IDBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLCBzLnZpcnR1YWwgPSB7XHJcbiAgICAgICAgICAgIGNhY2hlOiB7fSxcclxuICAgICAgICAgICAgZnJvbTogdm9pZCAwLFxyXG4gICAgICAgICAgICB0bzogdm9pZCAwLFxyXG4gICAgICAgICAgICBzbGlkZXM6IFtdLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgICAgIHNsaWRlc0dyaWQ6IFtdXHJcbiAgICAgICAgfSwgaShcImJlZm9yZUluaXRcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgcy5wYXJhbXMudmlydHVhbC5lbmFibGVkICYmIChzLnZpcnR1YWwuc2xpZGVzID0gcy5wYXJhbXMudmlydHVhbC5zbGlkZXMsIHMuY2xhc3NOYW1lcy5wdXNoKGAke3MucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9dmlydHVhbGApLCBzLnBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gITAsIHMub3JpZ2luYWxQYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcyA9ICEwLCBzLnBhcmFtcy5pbml0aWFsU2xpZGUgfHwgbCgpKVxyXG4gICAgICAgIH0pKSwgaShcInNldFRyYW5zbGF0ZVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBzLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgJiYgKHMucGFyYW1zLmNzc01vZGUgJiYgIXMuX2ltbWVkaWF0ZVZpcnR1YWwgPyAoY2xlYXJUaW1lb3V0KHQpLCB0ID0gc2V0VGltZW91dCgoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbCgpXHJcbiAgICAgICAgICAgIH0pLCAxMDApKSA6IGwoKSlcclxuICAgICAgICB9KSksIGkoXCJpbml0IHVwZGF0ZSByZXNpemVcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgcy5wYXJhbXMudmlydHVhbC5lbmFibGVkICYmIHMucGFyYW1zLmNzc01vZGUgJiYgdihzLndyYXBwZXJFbCwgXCItLXN3aXBlci12aXJ0dWFsLXNpemVcIiwgYCR7cy52aXJ0dWFsU2l6ZX1weGApXHJcbiAgICAgICAgfSkpLCBPYmplY3QuYXNzaWduKHMudmlydHVhbCwge1xyXG4gICAgICAgICAgICBhcHBlbmRTbGlkZTogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBlICYmIFwibGVuZ3RoXCIgaW4gZSkgZm9yIChsZXQgdCA9IDA7IHQgPCBlLmxlbmd0aDsgdCArPSAxKSBlW3RdICYmIHMudmlydHVhbC5zbGlkZXMucHVzaChlW3RdKTsgZWxzZSBzLnZpcnR1YWwuc2xpZGVzLnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICBsKCEwKVxyXG4gICAgICAgICAgICB9LCBwcmVwZW5kU2xpZGU6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gcy5hY3RpdmVJbmRleDtcclxuICAgICAgICAgICAgICAgIGxldCBhID0gdCArIDEsIGkgPSAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0ICs9IDEpIGVbdF0gJiYgcy52aXJ0dWFsLnNsaWRlcy51bnNoaWZ0KGVbdF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSB0ICsgZS5sZW5ndGgsIGkgPSBlLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHMudmlydHVhbC5zbGlkZXMudW5zaGlmdChlKTtcclxuICAgICAgICAgICAgICAgIGlmIChzLnBhcmFtcy52aXJ0dWFsLmNhY2hlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IHMudmlydHVhbC5jYWNoZSwgdCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goKHMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gZVtzXSwgciA9IGEuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByICYmIGEuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIsIHBhcnNlSW50KHIsIDEwKSArIGkpLCB0W3BhcnNlSW50KHMsIDEwKSArIGldID0gYVxyXG4gICAgICAgICAgICAgICAgICAgIH0pKSwgcy52aXJ0dWFsLmNhY2hlID0gdFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbCghMCksIHMuc2xpZGVUbyhhLCAwKVxyXG4gICAgICAgICAgICB9LCByZW1vdmVTbGlkZTogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChudWxsID09IGUpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGxldCB0ID0gcy5hY3RpdmVJbmRleDtcclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSBmb3IgKGxldCBhID0gZS5sZW5ndGggLSAxOyBhID49IDA7IGEgLT0gMSkgcy52aXJ0dWFsLnNsaWRlcy5zcGxpY2UoZVthXSwgMSksIHMucGFyYW1zLnZpcnR1YWwuY2FjaGUgJiYgZGVsZXRlIHMudmlydHVhbC5jYWNoZVtlW2FdXSwgZVthXSA8IHQgJiYgKHQgLT0gMSksIHQgPSBNYXRoLm1heCh0LCAwKTsgZWxzZSBzLnZpcnR1YWwuc2xpZGVzLnNwbGljZShlLCAxKSwgcy5wYXJhbXMudmlydHVhbC5jYWNoZSAmJiBkZWxldGUgcy52aXJ0dWFsLmNhY2hlW2VdLCBlIDwgdCAmJiAodCAtPSAxKSwgdCA9IE1hdGgubWF4KHQsIDApO1xyXG4gICAgICAgICAgICAgICAgbCghMCksIHMuc2xpZGVUbyh0LCAwKVxyXG4gICAgICAgICAgICB9LCByZW1vdmVBbGxTbGlkZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHMudmlydHVhbC5zbGlkZXMgPSBbXSwgcy5wYXJhbXMudmlydHVhbC5jYWNoZSAmJiAocy52aXJ0dWFsLmNhY2hlID0ge30pLCBsKCEwKSwgcy5zbGlkZVRvKDAsIDApXHJcbiAgICAgICAgICAgIH0sIHVwZGF0ZTogbFxyXG4gICAgICAgIH0pXHJcbiAgICB9LCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGxldCB7c3dpcGVyOiB0LCBleHRlbmRQYXJhbXM6IHMsIG9uOiBpLCBlbWl0OiBufSA9IGU7XHJcbiAgICAgICAgY29uc3QgbCA9IGEoKSwgbyA9IHIoKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYyhlKSB7XHJcbiAgICAgICAgICAgIGlmICghdC5lbmFibGVkKSByZXR1cm47XHJcbiAgICAgICAgICAgIGNvbnN0IHtydGxUcmFuc2xhdGU6IHN9ID0gdDtcclxuICAgICAgICAgICAgbGV0IGEgPSBlO1xyXG4gICAgICAgICAgICBhLm9yaWdpbmFsRXZlbnQgJiYgKGEgPSBhLm9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBpID0gYS5rZXlDb2RlIHx8IGEuY2hhckNvZGUsIHIgPSB0LnBhcmFtcy5rZXlib2FyZC5wYWdlVXBEb3duLCBkID0gciAmJiAzMyA9PT0gaSwgYyA9IHIgJiYgMzQgPT09IGksXHJcbiAgICAgICAgICAgICAgICBwID0gMzcgPT09IGksIHUgPSAzOSA9PT0gaSwgaCA9IDM4ID09PSBpLCBtID0gNDAgPT09IGk7XHJcbiAgICAgICAgICAgIGlmICghdC5hbGxvd1NsaWRlTmV4dCAmJiAodC5pc0hvcml6b250YWwoKSAmJiB1IHx8IHQuaXNWZXJ0aWNhbCgpICYmIG0gfHwgYykpIHJldHVybiAhMTtcclxuICAgICAgICAgICAgaWYgKCF0LmFsbG93U2xpZGVQcmV2ICYmICh0LmlzSG9yaXpvbnRhbCgpICYmIHAgfHwgdC5pc1ZlcnRpY2FsKCkgJiYgaCB8fCBkKSkgcmV0dXJuICExO1xyXG4gICAgICAgICAgICBpZiAoIShhLnNoaWZ0S2V5IHx8IGEuYWx0S2V5IHx8IGEuY3RybEtleSB8fCBhLm1ldGFLZXkgfHwgbC5hY3RpdmVFbGVtZW50ICYmIGwuYWN0aXZlRWxlbWVudC5ub2RlTmFtZSAmJiAoXCJpbnB1dFwiID09PSBsLmFjdGl2ZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSB8fCBcInRleHRhcmVhXCIgPT09IGwuYWN0aXZlRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0LnBhcmFtcy5rZXlib2FyZC5vbmx5SW5WaWV3cG9ydCAmJiAoZCB8fCBjIHx8IHAgfHwgdSB8fCBoIHx8IG0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGUgPSAhMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodC4kZWwucGFyZW50cyhgLiR7dC5wYXJhbXMuc2xpZGVDbGFzc31gKS5sZW5ndGggPiAwICYmIDAgPT09IHQuJGVsLnBhcmVudHMoYC4ke3QucGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3N9YCkubGVuZ3RoKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYSA9IHQuJGVsLCBpID0gYVswXS5jbGllbnRXaWR0aCwgciA9IGFbMF0uY2xpZW50SGVpZ2h0LCBuID0gby5pbm5lcldpZHRoLCBsID0gby5pbm5lckhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHQuJGVsLm9mZnNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHMgJiYgKGQubGVmdCAtPSB0LiRlbFswXS5zY3JvbGxMZWZ0KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjID0gW1tkLmxlZnQsIGQudG9wXSwgW2QubGVmdCArIGksIGQudG9wXSwgW2QubGVmdCwgZC50b3AgKyByXSwgW2QubGVmdCArIGksIGQudG9wICsgcl1dO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgYy5sZW5ndGg7IHQgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gY1t0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNbMF0gPj0gMCAmJiBzWzBdIDw9IG4gJiYgc1sxXSA+PSAwICYmIHNbMV0gPD0gbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IHNbMF0gJiYgMCA9PT0gc1sxXSkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gITBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWUpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdC5pc0hvcml6b250YWwoKSA/ICgoZCB8fCBjIHx8IHAgfHwgdSkgJiYgKGEucHJldmVudERlZmF1bHQgPyBhLnByZXZlbnREZWZhdWx0KCkgOiBhLnJldHVyblZhbHVlID0gITEpLCAoKGMgfHwgdSkgJiYgIXMgfHwgKGQgfHwgcCkgJiYgcykgJiYgdC5zbGlkZU5leHQoKSwgKChkIHx8IHApICYmICFzIHx8IChjIHx8IHUpICYmIHMpICYmIHQuc2xpZGVQcmV2KCkpIDogKChkIHx8IGMgfHwgaCB8fCBtKSAmJiAoYS5wcmV2ZW50RGVmYXVsdCA/IGEucHJldmVudERlZmF1bHQoKSA6IGEucmV0dXJuVmFsdWUgPSAhMSksIChjIHx8IG0pICYmIHQuc2xpZGVOZXh0KCksIChkIHx8IGgpICYmIHQuc2xpZGVQcmV2KCkpLCBuKFwia2V5UHJlc3NcIiwgaSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcCgpIHtcclxuICAgICAgICAgICAgdC5rZXlib2FyZC5lbmFibGVkIHx8IChkKGwpLm9uKFwia2V5ZG93blwiLCBjKSwgdC5rZXlib2FyZC5lbmFibGVkID0gITApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB1KCkge1xyXG4gICAgICAgICAgICB0LmtleWJvYXJkLmVuYWJsZWQgJiYgKGQobCkub2ZmKFwia2V5ZG93blwiLCBjKSwgdC5rZXlib2FyZC5lbmFibGVkID0gITEpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LmtleWJvYXJkID0ge2VuYWJsZWQ6ICExfSwgcyh7a2V5Ym9hcmQ6IHtlbmFibGVkOiAhMSwgb25seUluVmlld3BvcnQ6ICEwLCBwYWdlVXBEb3duOiAhMH19KSwgaShcImluaXRcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC5wYXJhbXMua2V5Ym9hcmQuZW5hYmxlZCAmJiBwKClcclxuICAgICAgICB9KSksIGkoXCJkZXN0cm95XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHQua2V5Ym9hcmQuZW5hYmxlZCAmJiB1KClcclxuICAgICAgICB9KSksIE9iamVjdC5hc3NpZ24odC5rZXlib2FyZCwge2VuYWJsZTogcCwgZGlzYWJsZTogdX0pXHJcbiAgICB9LCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGxldCB7c3dpcGVyOiB0LCBleHRlbmRQYXJhbXM6IHMsIG9uOiBhLCBlbWl0OiBpfSA9IGU7XHJcbiAgICAgICAgY29uc3QgbiA9IHIoKTtcclxuICAgICAgICBsZXQgbDtcclxuICAgICAgICBzKHtcclxuICAgICAgICAgICAgbW91c2V3aGVlbDoge1xyXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogITEsXHJcbiAgICAgICAgICAgICAgICByZWxlYXNlT25FZGdlczogITEsXHJcbiAgICAgICAgICAgICAgICBpbnZlcnQ6ICExLFxyXG4gICAgICAgICAgICAgICAgZm9yY2VUb0F4aXM6ICExLFxyXG4gICAgICAgICAgICAgICAgc2Vuc2l0aXZpdHk6IDEsXHJcbiAgICAgICAgICAgICAgICBldmVudHNUYXJnZXQ6IFwiY29udGFpbmVyXCIsXHJcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGREZWx0YTogbnVsbCxcclxuICAgICAgICAgICAgICAgIHRocmVzaG9sZFRpbWU6IG51bGxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLCB0Lm1vdXNld2hlZWwgPSB7ZW5hYmxlZDogITF9O1xyXG4gICAgICAgIGxldCBvLCBjID0gdSgpO1xyXG4gICAgICAgIGNvbnN0IGggPSBbXTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbSgpIHtcclxuICAgICAgICAgICAgdC5lbmFibGVkICYmICh0Lm1vdXNlRW50ZXJlZCA9ICEwKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZigpIHtcclxuICAgICAgICAgICAgdC5lbmFibGVkICYmICh0Lm1vdXNlRW50ZXJlZCA9ICExKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZyhlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhKHQucGFyYW1zLm1vdXNld2hlZWwudGhyZXNob2xkRGVsdGEgJiYgZS5kZWx0YSA8IHQucGFyYW1zLm1vdXNld2hlZWwudGhyZXNob2xkRGVsdGEpICYmICghKHQucGFyYW1zLm1vdXNld2hlZWwudGhyZXNob2xkVGltZSAmJiB1KCkgLSBjIDwgdC5wYXJhbXMubW91c2V3aGVlbC50aHJlc2hvbGRUaW1lKSAmJiAoZS5kZWx0YSA+PSA2ICYmIHUoKSAtIGMgPCA2MCB8fCAoZS5kaXJlY3Rpb24gPCAwID8gdC5pc0VuZCAmJiAhdC5wYXJhbXMubG9vcCB8fCB0LmFuaW1hdGluZyB8fCAodC5zbGlkZU5leHQoKSwgaShcInNjcm9sbFwiLCBlLnJhdykpIDogdC5pc0JlZ2lubmluZyAmJiAhdC5wYXJhbXMubG9vcCB8fCB0LmFuaW1hdGluZyB8fCAodC5zbGlkZVByZXYoKSwgaShcInNjcm9sbFwiLCBlLnJhdykpLCBjID0gKG5ldyBuLkRhdGUpLmdldFRpbWUoKSwgITEpKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHYoZSkge1xyXG4gICAgICAgICAgICBsZXQgcyA9IGUsIGEgPSAhMDtcclxuICAgICAgICAgICAgaWYgKCF0LmVuYWJsZWQpIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgciA9IHQucGFyYW1zLm1vdXNld2hlZWw7XHJcbiAgICAgICAgICAgIHQucGFyYW1zLmNzc01vZGUgJiYgcy5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBsZXQgbiA9IHQuJGVsO1xyXG4gICAgICAgICAgICBpZiAoXCJjb250YWluZXJcIiAhPT0gdC5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZXQgJiYgKG4gPSBkKHQucGFyYW1zLm1vdXNld2hlZWwuZXZlbnRzVGFyZ2V0KSksICF0Lm1vdXNlRW50ZXJlZCAmJiAhblswXS5jb250YWlucyhzLnRhcmdldCkgJiYgIXIucmVsZWFzZU9uRWRnZXMpIHJldHVybiAhMDtcclxuICAgICAgICAgICAgcy5vcmlnaW5hbEV2ZW50ICYmIChzID0gcy5vcmlnaW5hbEV2ZW50KTtcclxuICAgICAgICAgICAgbGV0IGMgPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBtID0gdC5ydGxUcmFuc2xhdGUgPyAtMSA6IDEsIGYgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHQgPSAwLCBzID0gMCwgYSA9IDAsIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZGV0YWlsXCIgaW4gZSAmJiAocyA9IGUuZGV0YWlsKSwgXCJ3aGVlbERlbHRhXCIgaW4gZSAmJiAocyA9IC1lLndoZWVsRGVsdGEgLyAxMjApLCBcIndoZWVsRGVsdGFZXCIgaW4gZSAmJiAocyA9IC1lLndoZWVsRGVsdGFZIC8gMTIwKSwgXCJ3aGVlbERlbHRhWFwiIGluIGUgJiYgKHQgPSAtZS53aGVlbERlbHRhWCAvIDEyMCksIFwiYXhpc1wiIGluIGUgJiYgZS5heGlzID09PSBlLkhPUklaT05UQUxfQVhJUyAmJiAodCA9IHMsIHMgPSAwKSwgYSA9IDEwICogdCwgaSA9IDEwICogcywgXCJkZWx0YVlcIiBpbiBlICYmIChpID0gZS5kZWx0YVkpLCBcImRlbHRhWFwiIGluIGUgJiYgKGEgPSBlLmRlbHRhWCksIGUuc2hpZnRLZXkgJiYgIWEgJiYgKGEgPSBpLCBpID0gMCksIChhIHx8IGkpICYmIGUuZGVsdGFNb2RlICYmICgxID09PSBlLmRlbHRhTW9kZSA/IChhICo9IDQwLCBpICo9IDQwKSA6IChhICo9IDgwMCwgaSAqPSA4MDApKSwgYSAmJiAhdCAmJiAodCA9IGEgPCAxID8gLTEgOiAxKSwgaSAmJiAhcyAmJiAocyA9IGkgPCAxID8gLTEgOiAxKSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwaW5YOiB0LFxyXG4gICAgICAgICAgICAgICAgICAgIHNwaW5ZOiBzLFxyXG4gICAgICAgICAgICAgICAgICAgIHBpeGVsWDogYSxcclxuICAgICAgICAgICAgICAgICAgICBwaXhlbFk6IGlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfShzKTtcclxuICAgICAgICAgICAgaWYgKHIuZm9yY2VUb0F4aXMpIGlmICh0LmlzSG9yaXpvbnRhbCgpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShNYXRoLmFicyhmLnBpeGVsWCkgPiBNYXRoLmFicyhmLnBpeGVsWSkpKSByZXR1cm4gITA7XHJcbiAgICAgICAgICAgICAgICBjID0gLWYucGl4ZWxYICogbVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoTWF0aC5hYnMoZi5waXhlbFkpID4gTWF0aC5hYnMoZi5waXhlbFgpKSkgcmV0dXJuICEwO1xyXG4gICAgICAgICAgICAgICAgYyA9IC1mLnBpeGVsWVxyXG4gICAgICAgICAgICB9IGVsc2UgYyA9IE1hdGguYWJzKGYucGl4ZWxYKSA+IE1hdGguYWJzKGYucGl4ZWxZKSA/IC1mLnBpeGVsWCAqIG0gOiAtZi5waXhlbFk7XHJcbiAgICAgICAgICAgIGlmICgwID09PSBjKSByZXR1cm4gITA7XHJcbiAgICAgICAgICAgIHIuaW52ZXJ0ICYmIChjID0gLWMpO1xyXG4gICAgICAgICAgICBsZXQgdiA9IHQuZ2V0VHJhbnNsYXRlKCkgKyBjICogci5zZW5zaXRpdml0eTtcclxuICAgICAgICAgICAgaWYgKHYgPj0gdC5taW5UcmFuc2xhdGUoKSAmJiAodiA9IHQubWluVHJhbnNsYXRlKCkpLCB2IDw9IHQubWF4VHJhbnNsYXRlKCkgJiYgKHYgPSB0Lm1heFRyYW5zbGF0ZSgpKSwgYSA9ICEhdC5wYXJhbXMubG9vcCB8fCAhKHYgPT09IHQubWluVHJhbnNsYXRlKCkgfHwgdiA9PT0gdC5tYXhUcmFuc2xhdGUoKSksIGEgJiYgdC5wYXJhbXMubmVzdGVkICYmIHMuc3RvcFByb3BhZ2F0aW9uKCksIHQucGFyYW1zLmZyZWVNb2RlICYmIHQucGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSB7dGltZTogdSgpLCBkZWx0YTogTWF0aC5hYnMoYyksIGRpcmVjdGlvbjogTWF0aC5zaWduKGMpfSxcclxuICAgICAgICAgICAgICAgICAgICBhID0gbyAmJiBlLnRpbWUgPCBvLnRpbWUgKyA1MDAgJiYgZS5kZWx0YSA8PSBvLmRlbHRhICYmIGUuZGlyZWN0aW9uID09PSBvLmRpcmVjdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmICghYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG8gPSB2b2lkIDAsIHQucGFyYW1zLmxvb3AgJiYgdC5sb29wRml4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG4gPSB0LmdldFRyYW5zbGF0ZSgpICsgYyAqIHIuc2Vuc2l0aXZpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZCA9IHQuaXNCZWdpbm5pbmcsIHUgPSB0LmlzRW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuID49IHQubWluVHJhbnNsYXRlKCkgJiYgKG4gPSB0Lm1pblRyYW5zbGF0ZSgpKSwgbiA8PSB0Lm1heFRyYW5zbGF0ZSgpICYmIChuID0gdC5tYXhUcmFuc2xhdGUoKSksIHQuc2V0VHJhbnNpdGlvbigwKSwgdC5zZXRUcmFuc2xhdGUobiksIHQudXBkYXRlUHJvZ3Jlc3MoKSwgdC51cGRhdGVBY3RpdmVJbmRleCgpLCB0LnVwZGF0ZVNsaWRlc0NsYXNzZXMoKSwgKCFkICYmIHQuaXNCZWdpbm5pbmcgfHwgIXUgJiYgdC5pc0VuZCkgJiYgdC51cGRhdGVTbGlkZXNDbGFzc2VzKCksIHQucGFyYW1zLmZyZWVNb2RlLnN0aWNreSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQobCksIGwgPSB2b2lkIDAsIGgubGVuZ3RoID49IDE1ICYmIGguc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IGgubGVuZ3RoID8gaFtoLmxlbmd0aCAtIDFdIDogdm9pZCAwLCBhID0gaFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGgucHVzaChlKSwgcyAmJiAoZS5kZWx0YSA+IHMuZGVsdGEgfHwgZS5kaXJlY3Rpb24gIT09IHMuZGlyZWN0aW9uKSkgaC5zcGxpY2UoMCk7IGVsc2UgaWYgKGgubGVuZ3RoID49IDE1ICYmIGUudGltZSAtIGEudGltZSA8IDUwMCAmJiBhLmRlbHRhIC0gZS5kZWx0YSA+PSAxICYmIGUuZGVsdGEgPD0gNikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IGMgPiAwID8gLjggOiAuMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBlLCBoLnNwbGljZSgwKSwgbCA9IHAoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnNsaWRlVG9DbG9zZXN0KHQucGFyYW1zLnNwZWVkLCAhMCwgdm9pZCAwLCBzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbCB8fCAobCA9IHAoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBlLCBoLnNwbGljZSgwKSwgdC5zbGlkZVRvQ2xvc2VzdCh0LnBhcmFtcy5zcGVlZCwgITAsIHZvaWQgMCwgLjUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCA1MDApKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYSB8fCBpKFwic2Nyb2xsXCIsIHMpLCB0LnBhcmFtcy5hdXRvcGxheSAmJiB0LnBhcmFtcy5hdXRvcGxheURpc2FibGVPbkludGVyYWN0aW9uICYmIHQuYXV0b3BsYXkuc3RvcCgpLCBuID09PSB0Lm1pblRyYW5zbGF0ZSgpIHx8IG4gPT09IHQubWF4VHJhbnNsYXRlKCkpIHJldHVybiAhMFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IHt0aW1lOiB1KCksIGRlbHRhOiBNYXRoLmFicyhjKSwgZGlyZWN0aW9uOiBNYXRoLnNpZ24oYyksIHJhdzogZX07XHJcbiAgICAgICAgICAgICAgICBoLmxlbmd0aCA+PSAyICYmIGguc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBoLmxlbmd0aCA/IGhbaC5sZW5ndGggLSAxXSA6IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIGlmIChoLnB1c2gocyksIGEgPyAocy5kaXJlY3Rpb24gIT09IGEuZGlyZWN0aW9uIHx8IHMuZGVsdGEgPiBhLmRlbHRhIHx8IHMudGltZSA+IGEudGltZSArIDE1MCkgJiYgZyhzKSA6IGcocyksIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IHQucGFyYW1zLm1vdXNld2hlZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuZGlyZWN0aW9uIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5pc0VuZCAmJiAhdC5wYXJhbXMubG9vcCAmJiBzLnJlbGVhc2VPbkVkZ2VzKSByZXR1cm4gITBcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHQuaXNCZWdpbm5pbmcgJiYgIXQucGFyYW1zLmxvb3AgJiYgcy5yZWxlYXNlT25FZGdlcykgcmV0dXJuICEwO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhMVxyXG4gICAgICAgICAgICAgICAgfShzKSkgcmV0dXJuICEwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHMucHJldmVudERlZmF1bHQgPyBzLnByZXZlbnREZWZhdWx0KCkgOiBzLnJldHVyblZhbHVlID0gITEsICExXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB3KGUpIHtcclxuICAgICAgICAgICAgbGV0IHMgPSB0LiRlbDtcclxuICAgICAgICAgICAgXCJjb250YWluZXJcIiAhPT0gdC5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZXQgJiYgKHMgPSBkKHQucGFyYW1zLm1vdXNld2hlZWwuZXZlbnRzVGFyZ2V0KSksIHNbZV0oXCJtb3VzZWVudGVyXCIsIG0pLCBzW2VdKFwibW91c2VsZWF2ZVwiLCBmKSwgc1tlXShcIndoZWVsXCIsIHYpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBiKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdC5wYXJhbXMuY3NzTW9kZSA/ICh0LndyYXBwZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdiksICEwKSA6ICF0Lm1vdXNld2hlZWwuZW5hYmxlZCAmJiAodyhcIm9uXCIpLCB0Lm1vdXNld2hlZWwuZW5hYmxlZCA9ICEwLCAhMClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHgoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0LnBhcmFtcy5jc3NNb2RlID8gKHQud3JhcHBlckVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHYpLCAhMCkgOiAhIXQubW91c2V3aGVlbC5lbmFibGVkICYmICh3KFwib2ZmXCIpLCB0Lm1vdXNld2hlZWwuZW5hYmxlZCA9ICExLCAhMClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGEoXCJpbml0XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgICF0LnBhcmFtcy5tb3VzZXdoZWVsLmVuYWJsZWQgJiYgdC5wYXJhbXMuY3NzTW9kZSAmJiB4KCksIHQucGFyYW1zLm1vdXNld2hlZWwuZW5hYmxlZCAmJiBiKClcclxuICAgICAgICB9KSksIGEoXCJkZXN0cm95XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHQucGFyYW1zLmNzc01vZGUgJiYgYigpLCB0Lm1vdXNld2hlZWwuZW5hYmxlZCAmJiB4KClcclxuICAgICAgICB9KSksIE9iamVjdC5hc3NpZ24odC5tb3VzZXdoZWVsLCB7ZW5hYmxlOiBiLCBkaXNhYmxlOiB4fSlcclxuICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgbGV0IHtzd2lwZXI6IHQsIGV4dGVuZFBhcmFtczogcywgb246IGEsIGVtaXQ6IGl9ID0gZTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcihlKSB7XHJcbiAgICAgICAgICAgIGxldCBzO1xyXG4gICAgICAgICAgICByZXR1cm4gZSAmJiAocyA9IGQoZSksIHQucGFyYW1zLnVuaXF1ZU5hdkVsZW1lbnRzICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgcy5sZW5ndGggPiAxICYmIDEgPT09IHQuJGVsLmZpbmQoZSkubGVuZ3RoICYmIChzID0gdC4kZWwuZmluZChlKSkpLCBzXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBuKGUsIHMpIHtcclxuICAgICAgICAgICAgY29uc3QgYSA9IHQucGFyYW1zLm5hdmlnYXRpb247XHJcbiAgICAgICAgICAgIGUgJiYgZS5sZW5ndGggPiAwICYmIChlW3MgPyBcImFkZENsYXNzXCIgOiBcInJlbW92ZUNsYXNzXCJdKGEuZGlzYWJsZWRDbGFzcyksIGVbMF0gJiYgXCJCVVRUT05cIiA9PT0gZVswXS50YWdOYW1lICYmIChlWzBdLmRpc2FibGVkID0gcyksIHQucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgdC5lbmFibGVkICYmIGVbdC5pc0xvY2tlZCA/IFwiYWRkQ2xhc3NcIiA6IFwicmVtb3ZlQ2xhc3NcIl0oYS5sb2NrQ2xhc3MpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbCgpIHtcclxuICAgICAgICAgICAgaWYgKHQucGFyYW1zLmxvb3ApIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgeyRuZXh0RWw6IGUsICRwcmV2RWw6IHN9ID0gdC5uYXZpZ2F0aW9uO1xyXG4gICAgICAgICAgICBuKHMsIHQuaXNCZWdpbm5pbmcgJiYgIXQucGFyYW1zLnJld2luZCksIG4oZSwgdC5pc0VuZCAmJiAhdC5wYXJhbXMucmV3aW5kKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbyhlKSB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKSwgKCF0LmlzQmVnaW5uaW5nIHx8IHQucGFyYW1zLmxvb3AgfHwgdC5wYXJhbXMucmV3aW5kKSAmJiAodC5zbGlkZVByZXYoKSwgaShcIm5hdmlnYXRpb25QcmV2XCIpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYyhlKSB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKSwgKCF0LmlzRW5kIHx8IHQucGFyYW1zLmxvb3AgfHwgdC5wYXJhbXMucmV3aW5kKSAmJiAodC5zbGlkZU5leHQoKSwgaShcIm5hdmlnYXRpb25OZXh0XCIpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcCgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHQucGFyYW1zLm5hdmlnYXRpb247XHJcbiAgICAgICAgICAgIGlmICh0LnBhcmFtcy5uYXZpZ2F0aW9uID0gRih0LCB0Lm9yaWdpbmFsUGFyYW1zLm5hdmlnYXRpb24sIHQucGFyYW1zLm5hdmlnYXRpb24sIHtcclxuICAgICAgICAgICAgICAgIG5leHRFbDogXCJzd2lwZXItYnV0dG9uLW5leHRcIixcclxuICAgICAgICAgICAgICAgIHByZXZFbDogXCJzd2lwZXItYnV0dG9uLXByZXZcIlxyXG4gICAgICAgICAgICB9KSwgIWUubmV4dEVsICYmICFlLnByZXZFbCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCBzID0gcihlLm5leHRFbCksIGEgPSByKGUucHJldkVsKTtcclxuICAgICAgICAgICAgcyAmJiBzLmxlbmd0aCA+IDAgJiYgcy5vbihcImNsaWNrXCIsIGMpLCBhICYmIGEubGVuZ3RoID4gMCAmJiBhLm9uKFwiY2xpY2tcIiwgbyksIE9iamVjdC5hc3NpZ24odC5uYXZpZ2F0aW9uLCB7XHJcbiAgICAgICAgICAgICAgICAkbmV4dEVsOiBzLFxyXG4gICAgICAgICAgICAgICAgbmV4dEVsOiBzICYmIHNbMF0sXHJcbiAgICAgICAgICAgICAgICAkcHJldkVsOiBhLFxyXG4gICAgICAgICAgICAgICAgcHJldkVsOiBhICYmIGFbMF1cclxuICAgICAgICAgICAgfSksIHQuZW5hYmxlZCB8fCAocyAmJiBzLmFkZENsYXNzKGUubG9ja0NsYXNzKSwgYSAmJiBhLmFkZENsYXNzKGUubG9ja0NsYXNzKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHUoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHskbmV4dEVsOiBlLCAkcHJldkVsOiBzfSA9IHQubmF2aWdhdGlvbjtcclxuICAgICAgICAgICAgZSAmJiBlLmxlbmd0aCAmJiAoZS5vZmYoXCJjbGlja1wiLCBjKSwgZS5yZW1vdmVDbGFzcyh0LnBhcmFtcy5uYXZpZ2F0aW9uLmRpc2FibGVkQ2xhc3MpKSwgcyAmJiBzLmxlbmd0aCAmJiAocy5vZmYoXCJjbGlja1wiLCBvKSwgcy5yZW1vdmVDbGFzcyh0LnBhcmFtcy5uYXZpZ2F0aW9uLmRpc2FibGVkQ2xhc3MpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcyh7XHJcbiAgICAgICAgICAgIG5hdmlnYXRpb246IHtcclxuICAgICAgICAgICAgICAgIG5leHRFbDogbnVsbCxcclxuICAgICAgICAgICAgICAgIHByZXZFbDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGhpZGVPbkNsaWNrOiAhMSxcclxuICAgICAgICAgICAgICAgIGRpc2FibGVkQ2xhc3M6IFwic3dpcGVyLWJ1dHRvbi1kaXNhYmxlZFwiLFxyXG4gICAgICAgICAgICAgICAgaGlkZGVuQ2xhc3M6IFwic3dpcGVyLWJ1dHRvbi1oaWRkZW5cIixcclxuICAgICAgICAgICAgICAgIGxvY2tDbGFzczogXCJzd2lwZXItYnV0dG9uLWxvY2tcIixcclxuICAgICAgICAgICAgICAgIG5hdmlnYXRpb25EaXNhYmxlZENsYXNzOiBcInN3aXBlci1uYXZpZ2F0aW9uLWRpc2FibGVkXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLCB0Lm5hdmlnYXRpb24gPSB7bmV4dEVsOiBudWxsLCAkbmV4dEVsOiBudWxsLCBwcmV2RWw6IG51bGwsICRwcmV2RWw6IG51bGx9LCBhKFwiaW5pdFwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICAhMSA9PT0gdC5wYXJhbXMubmF2aWdhdGlvbi5lbmFibGVkID8gaCgpIDogKHAoKSwgbCgpKVxyXG4gICAgICAgIH0pKSwgYShcInRvRWRnZSBmcm9tRWRnZSBsb2NrIHVubG9ja1wiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBsKClcclxuICAgICAgICB9KSksIGEoXCJkZXN0cm95XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHUoKVxyXG4gICAgICAgIH0pKSwgYShcImVuYWJsZSBkaXNhYmxlXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHskbmV4dEVsOiBlLCAkcHJldkVsOiBzfSA9IHQubmF2aWdhdGlvbjtcclxuICAgICAgICAgICAgZSAmJiBlW3QuZW5hYmxlZCA/IFwicmVtb3ZlQ2xhc3NcIiA6IFwiYWRkQ2xhc3NcIl0odC5wYXJhbXMubmF2aWdhdGlvbi5sb2NrQ2xhc3MpLCBzICYmIHNbdC5lbmFibGVkID8gXCJyZW1vdmVDbGFzc1wiIDogXCJhZGRDbGFzc1wiXSh0LnBhcmFtcy5uYXZpZ2F0aW9uLmxvY2tDbGFzcylcclxuICAgICAgICB9KSksIGEoXCJjbGlja1wiLCAoKGUsIHMpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyRuZXh0RWw6IGEsICRwcmV2RWw6IHJ9ID0gdC5uYXZpZ2F0aW9uLCBuID0gcy50YXJnZXQ7XHJcbiAgICAgICAgICAgIGlmICh0LnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGVPbkNsaWNrICYmICFkKG4pLmlzKHIpICYmICFkKG4pLmlzKGEpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodC5wYWdpbmF0aW9uICYmIHQucGFyYW1zLnBhZ2luYXRpb24gJiYgdC5wYXJhbXMucGFnaW5hdGlvbi5jbGlja2FibGUgJiYgKHQucGFnaW5hdGlvbi5lbCA9PT0gbiB8fCB0LnBhZ2luYXRpb24uZWwuY29udGFpbnMobikpKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBsZXQgZTtcclxuICAgICAgICAgICAgICAgIGEgPyBlID0gYS5oYXNDbGFzcyh0LnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGRlbkNsYXNzKSA6IHIgJiYgKGUgPSByLmhhc0NsYXNzKHQucGFyYW1zLm5hdmlnYXRpb24uaGlkZGVuQ2xhc3MpKSwgaSghMCA9PT0gZSA/IFwibmF2aWdhdGlvblNob3dcIiA6IFwibmF2aWdhdGlvbkhpZGVcIiksIGEgJiYgYS50b2dnbGVDbGFzcyh0LnBhcmFtcy5uYXZpZ2F0aW9uLmhpZGRlbkNsYXNzKSwgciAmJiByLnRvZ2dsZUNsYXNzKHQucGFyYW1zLm5hdmlnYXRpb24uaGlkZGVuQ2xhc3MpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgY29uc3QgaCA9ICgpID0+IHtcclxuICAgICAgICAgICAgdC4kZWwuYWRkQ2xhc3ModC5wYXJhbXMubmF2aWdhdGlvbi5uYXZpZ2F0aW9uRGlzYWJsZWRDbGFzcyksIHUoKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0Lm5hdmlnYXRpb24sIHtcclxuICAgICAgICAgICAgZW5hYmxlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0LiRlbC5yZW1vdmVDbGFzcyh0LnBhcmFtcy5uYXZpZ2F0aW9uLm5hdmlnYXRpb25EaXNhYmxlZENsYXNzKSwgcCgpLCBsKClcclxuICAgICAgICAgICAgfSwgZGlzYWJsZTogaCwgdXBkYXRlOiBsLCBpbml0OiBwLCBkZXN0cm95OiB1XHJcbiAgICAgICAgfSlcclxuICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgbGV0IHtzd2lwZXI6IHQsIGV4dGVuZFBhcmFtczogcywgb246IGEsIGVtaXQ6IGl9ID0gZTtcclxuICAgICAgICBjb25zdCByID0gXCJzd2lwZXItcGFnaW5hdGlvblwiO1xyXG4gICAgICAgIGxldCBuO1xyXG4gICAgICAgIHMoe1xyXG4gICAgICAgICAgICBwYWdpbmF0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICBlbDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGJ1bGxldEVsZW1lbnQ6IFwic3BhblwiLFxyXG4gICAgICAgICAgICAgICAgY2xpY2thYmxlOiAhMSxcclxuICAgICAgICAgICAgICAgIGhpZGVPbkNsaWNrOiAhMSxcclxuICAgICAgICAgICAgICAgIHJlbmRlckJ1bGxldDogbnVsbCxcclxuICAgICAgICAgICAgICAgIHJlbmRlclByb2dyZXNzYmFyOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyRnJhY3Rpb246IG51bGwsXHJcbiAgICAgICAgICAgICAgICByZW5kZXJDdXN0b206IG51bGwsXHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2Jhck9wcG9zaXRlOiAhMSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYnVsbGV0c1wiLFxyXG4gICAgICAgICAgICAgICAgZHluYW1pY0J1bGxldHM6ICExLFxyXG4gICAgICAgICAgICAgICAgZHluYW1pY01haW5CdWxsZXRzOiAxLFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0RnJhY3Rpb25DdXJyZW50OiBlID0+IGUsXHJcbiAgICAgICAgICAgICAgICBmb3JtYXRGcmFjdGlvblRvdGFsOiBlID0+IGUsXHJcbiAgICAgICAgICAgICAgICBidWxsZXRDbGFzczogYCR7cn0tYnVsbGV0YCxcclxuICAgICAgICAgICAgICAgIGJ1bGxldEFjdGl2ZUNsYXNzOiBgJHtyfS1idWxsZXQtYWN0aXZlYCxcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVyQ2xhc3M6IGAke3J9LWAsXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2xhc3M6IGAke3J9LWN1cnJlbnRgLFxyXG4gICAgICAgICAgICAgICAgdG90YWxDbGFzczogYCR7cn0tdG90YWxgLFxyXG4gICAgICAgICAgICAgICAgaGlkZGVuQ2xhc3M6IGAke3J9LWhpZGRlbmAsXHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2JhckZpbGxDbGFzczogYCR7cn0tcHJvZ3Jlc3NiYXItZmlsbGAsXHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2Jhck9wcG9zaXRlQ2xhc3M6IGAke3J9LXByb2dyZXNzYmFyLW9wcG9zaXRlYCxcclxuICAgICAgICAgICAgICAgIGNsaWNrYWJsZUNsYXNzOiBgJHtyfS1jbGlja2FibGVgLFxyXG4gICAgICAgICAgICAgICAgbG9ja0NsYXNzOiBgJHtyfS1sb2NrYCxcclxuICAgICAgICAgICAgICAgIGhvcml6b250YWxDbGFzczogYCR7cn0taG9yaXpvbnRhbGAsXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbENsYXNzOiBgJHtyfS12ZXJ0aWNhbGAsXHJcbiAgICAgICAgICAgICAgICBwYWdpbmF0aW9uRGlzYWJsZWRDbGFzczogYCR7cn0tZGlzYWJsZWRgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSwgdC5wYWdpbmF0aW9uID0ge2VsOiBudWxsLCAkZWw6IG51bGwsIGJ1bGxldHM6IFtdfTtcclxuICAgICAgICBsZXQgbCA9IDA7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG8oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhdC5wYXJhbXMucGFnaW5hdGlvbi5lbCB8fCAhdC5wYWdpbmF0aW9uLmVsIHx8ICF0LnBhZ2luYXRpb24uJGVsIHx8IDAgPT09IHQucGFnaW5hdGlvbi4kZWwubGVuZ3RoXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjKGUsIHMpIHtcclxuICAgICAgICAgICAgY29uc3Qge2J1bGxldEFjdGl2ZUNsYXNzOiBhfSA9IHQucGFyYW1zLnBhZ2luYXRpb247XHJcbiAgICAgICAgICAgIGVbc10oKS5hZGRDbGFzcyhgJHthfS0ke3N9YClbc10oKS5hZGRDbGFzcyhgJHthfS0ke3N9LSR7c31gKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcCgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHQucnRsLCBzID0gdC5wYXJhbXMucGFnaW5hdGlvbjtcclxuICAgICAgICAgICAgaWYgKG8oKSkgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCBhID0gdC52aXJ0dWFsICYmIHQucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCA/IHQudmlydHVhbC5zbGlkZXMubGVuZ3RoIDogdC5zbGlkZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgciA9IHQucGFnaW5hdGlvbi4kZWw7XHJcbiAgICAgICAgICAgIGxldCBwO1xyXG4gICAgICAgICAgICBjb25zdCB1ID0gdC5wYXJhbXMubG9vcCA/IE1hdGguY2VpbCgoYSAtIDIgKiB0Lmxvb3BlZFNsaWRlcykgLyB0LnBhcmFtcy5zbGlkZXNQZXJHcm91cCkgOiB0LnNuYXBHcmlkLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHQucGFyYW1zLmxvb3AgPyAocCA9IE1hdGguY2VpbCgodC5hY3RpdmVJbmRleCAtIHQubG9vcGVkU2xpZGVzKSAvIHQucGFyYW1zLnNsaWRlc1Blckdyb3VwKSwgcCA+IGEgLSAxIC0gMiAqIHQubG9vcGVkU2xpZGVzICYmIChwIC09IGEgLSAyICogdC5sb29wZWRTbGlkZXMpLCBwID4gdSAtIDEgJiYgKHAgLT0gdSksIHAgPCAwICYmIFwiYnVsbGV0c1wiICE9PSB0LnBhcmFtcy5wYWdpbmF0aW9uVHlwZSAmJiAocCA9IHUgKyBwKSkgOiBwID0gdm9pZCAwICE9PSB0LnNuYXBJbmRleCA/IHQuc25hcEluZGV4IDogdC5hY3RpdmVJbmRleCB8fCAwLCBcImJ1bGxldHNcIiA9PT0gcy50eXBlICYmIHQucGFnaW5hdGlvbi5idWxsZXRzICYmIHQucGFnaW5hdGlvbi5idWxsZXRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSB0LnBhZ2luYXRpb24uYnVsbGV0cztcclxuICAgICAgICAgICAgICAgIGxldCBpLCBvLCB1O1xyXG4gICAgICAgICAgICAgICAgaWYgKHMuZHluYW1pY0J1bGxldHMgJiYgKG4gPSBhLmVxKDApW3QuaXNIb3Jpem9udGFsKCkgPyBcIm91dGVyV2lkdGhcIiA6IFwib3V0ZXJIZWlnaHRcIl0oITApLCByLmNzcyh0LmlzSG9yaXpvbnRhbCgpID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIiwgbiAqIChzLmR5bmFtaWNNYWluQnVsbGV0cyArIDQpICsgXCJweFwiKSwgcy5keW5hbWljTWFpbkJ1bGxldHMgPiAxICYmIHZvaWQgMCAhPT0gdC5wcmV2aW91c0luZGV4ICYmIChsICs9IHAgLSAodC5wcmV2aW91c0luZGV4IC0gdC5sb29wZWRTbGlkZXMgfHwgMCksIGwgPiBzLmR5bmFtaWNNYWluQnVsbGV0cyAtIDEgPyBsID0gcy5keW5hbWljTWFpbkJ1bGxldHMgLSAxIDogbCA8IDAgJiYgKGwgPSAwKSksIGkgPSBNYXRoLm1heChwIC0gbCwgMCksIG8gPSBpICsgKE1hdGgubWluKGEubGVuZ3RoLCBzLmR5bmFtaWNNYWluQnVsbGV0cykgLSAxKSwgdSA9IChvICsgaSkgLyAyKSwgYS5yZW1vdmVDbGFzcyhbXCJcIiwgXCItbmV4dFwiLCBcIi1uZXh0LW5leHRcIiwgXCItcHJldlwiLCBcIi1wcmV2LXByZXZcIiwgXCItbWFpblwiXS5tYXAoKGUgPT4gYCR7cy5idWxsZXRBY3RpdmVDbGFzc30ke2V9YCkpLmpvaW4oXCIgXCIpKSwgci5sZW5ndGggPiAxKSBhLmVhY2goKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBkKGUpLCBhID0gdC5pbmRleCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPT09IHAgJiYgdC5hZGRDbGFzcyhzLmJ1bGxldEFjdGl2ZUNsYXNzKSwgcy5keW5hbWljQnVsbGV0cyAmJiAoYSA+PSBpICYmIGEgPD0gbyAmJiB0LmFkZENsYXNzKGAke3MuYnVsbGV0QWN0aXZlQ2xhc3N9LW1haW5gKSwgYSA9PT0gaSAmJiBjKHQsIFwicHJldlwiKSwgYSA9PT0gbyAmJiBjKHQsIFwibmV4dFwiKSlcclxuICAgICAgICAgICAgICAgIH0pKTsgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGEuZXEocCksIHIgPSBlLmluZGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuYWRkQ2xhc3Mocy5idWxsZXRBY3RpdmVDbGFzcyksIHMuZHluYW1pY0J1bGxldHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGEuZXEoaSksIG4gPSBhLmVxKG8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBlID0gaTsgZSA8PSBvOyBlICs9IDEpIGEuZXEoZSkuYWRkQ2xhc3MoYCR7cy5idWxsZXRBY3RpdmVDbGFzc30tbWFpbmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodC5wYXJhbXMubG9vcCkgaWYgKHIgPj0gYS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGUgPSBzLmR5bmFtaWNNYWluQnVsbGV0czsgZSA+PSAwOyBlIC09IDEpIGEuZXEoYS5sZW5ndGggLSBlKS5hZGRDbGFzcyhgJHtzLmJ1bGxldEFjdGl2ZUNsYXNzfS1tYWluYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLmVxKGEubGVuZ3RoIC0gcy5keW5hbWljTWFpbkJ1bGxldHMgLSAxKS5hZGRDbGFzcyhgJHtzLmJ1bGxldEFjdGl2ZUNsYXNzfS1wcmV2YClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGMoZSwgXCJwcmV2XCIpLCBjKG4sIFwibmV4dFwiKTsgZWxzZSBjKGUsIFwicHJldlwiKSwgYyhuLCBcIm5leHRcIilcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocy5keW5hbWljQnVsbGV0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBNYXRoLm1pbihhLmxlbmd0aCwgcy5keW5hbWljTWFpbkJ1bGxldHMgKyA0KSwgciA9IChuICogaSAtIG4pIC8gMiAtIHUgKiBuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gZSA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuY3NzKHQuaXNIb3Jpem9udGFsKCkgPyBsIDogXCJ0b3BcIiwgYCR7cn1weGApXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKFwiZnJhY3Rpb25cIiA9PT0gcy50eXBlICYmIChyLmZpbmQoVShzLmN1cnJlbnRDbGFzcykpLnRleHQocy5mb3JtYXRGcmFjdGlvbkN1cnJlbnQocCArIDEpKSwgci5maW5kKFUocy50b3RhbENsYXNzKSkudGV4dChzLmZvcm1hdEZyYWN0aW9uVG90YWwodSkpKSwgXCJwcm9ncmVzc2JhclwiID09PSBzLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGxldCBlO1xyXG4gICAgICAgICAgICAgICAgZSA9IHMucHJvZ3Jlc3NiYXJPcHBvc2l0ZSA/IHQuaXNIb3Jpem9udGFsKCkgPyBcInZlcnRpY2FsXCIgOiBcImhvcml6b250YWxcIiA6IHQuaXNIb3Jpem9udGFsKCkgPyBcImhvcml6b250YWxcIiA6IFwidmVydGljYWxcIjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSAocCArIDEpIC8gdTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMSwgbiA9IDE7XHJcbiAgICAgICAgICAgICAgICBcImhvcml6b250YWxcIiA9PT0gZSA/IGkgPSBhIDogbiA9IGEsIHIuZmluZChVKHMucHJvZ3Jlc3NiYXJGaWxsQ2xhc3MpKS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZVgoJHtpfSkgc2NhbGVZKCR7bn0pYCkudHJhbnNpdGlvbih0LnBhcmFtcy5zcGVlZClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcImN1c3RvbVwiID09PSBzLnR5cGUgJiYgcy5yZW5kZXJDdXN0b20gPyAoci5odG1sKHMucmVuZGVyQ3VzdG9tKHQsIHAgKyAxLCB1KSksIGkoXCJwYWdpbmF0aW9uUmVuZGVyXCIsIHJbMF0pKSA6IGkoXCJwYWdpbmF0aW9uVXBkYXRlXCIsIHJbMF0pLCB0LnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHQuZW5hYmxlZCAmJiByW3QuaXNMb2NrZWQgPyBcImFkZENsYXNzXCIgOiBcInJlbW92ZUNsYXNzXCJdKHMubG9ja0NsYXNzKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdSgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHQucGFyYW1zLnBhZ2luYXRpb247XHJcbiAgICAgICAgICAgIGlmIChvKCkpIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgcyA9IHQudmlydHVhbCAmJiB0LnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgPyB0LnZpcnR1YWwuc2xpZGVzLmxlbmd0aCA6IHQuc2xpZGVzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGEgPSB0LnBhZ2luYXRpb24uJGVsO1xyXG4gICAgICAgICAgICBsZXQgciA9IFwiXCI7XHJcbiAgICAgICAgICAgIGlmIChcImJ1bGxldHNcIiA9PT0gZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IHQucGFyYW1zLmxvb3AgPyBNYXRoLmNlaWwoKHMgLSAyICogdC5sb29wZWRTbGlkZXMpIC8gdC5wYXJhbXMuc2xpZGVzUGVyR3JvdXApIDogdC5zbmFwR3JpZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB0LnBhcmFtcy5mcmVlTW9kZSAmJiB0LnBhcmFtcy5mcmVlTW9kZS5lbmFibGVkICYmICF0LnBhcmFtcy5sb29wICYmIGkgPiBzICYmIChpID0gcyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IGk7IHMgKz0gMSkgZS5yZW5kZXJCdWxsZXQgPyByICs9IGUucmVuZGVyQnVsbGV0LmNhbGwodCwgcywgZS5idWxsZXRDbGFzcykgOiByICs9IGA8JHtlLmJ1bGxldEVsZW1lbnR9IGNsYXNzPVwiJHtlLmJ1bGxldENsYXNzfVwiPjwvJHtlLmJ1bGxldEVsZW1lbnR9PmA7XHJcbiAgICAgICAgICAgICAgICBhLmh0bWwociksIHQucGFnaW5hdGlvbi5idWxsZXRzID0gYS5maW5kKFUoZS5idWxsZXRDbGFzcykpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXCJmcmFjdGlvblwiID09PSBlLnR5cGUgJiYgKHIgPSBlLnJlbmRlckZyYWN0aW9uID8gZS5yZW5kZXJGcmFjdGlvbi5jYWxsKHQsIGUuY3VycmVudENsYXNzLCBlLnRvdGFsQ2xhc3MpIDogYDxzcGFuIGNsYXNzPVwiJHtlLmN1cnJlbnRDbGFzc31cIj48L3NwYW4+IC8gPHNwYW4gY2xhc3M9XCIke2UudG90YWxDbGFzc31cIj48L3NwYW4+YCwgYS5odG1sKHIpKSwgXCJwcm9ncmVzc2JhclwiID09PSBlLnR5cGUgJiYgKHIgPSBlLnJlbmRlclByb2dyZXNzYmFyID8gZS5yZW5kZXJQcm9ncmVzc2Jhci5jYWxsKHQsIGUucHJvZ3Jlc3NiYXJGaWxsQ2xhc3MpIDogYDxzcGFuIGNsYXNzPVwiJHtlLnByb2dyZXNzYmFyRmlsbENsYXNzfVwiPjwvc3Bhbj5gLCBhLmh0bWwocikpLCBcImN1c3RvbVwiICE9PSBlLnR5cGUgJiYgaShcInBhZ2luYXRpb25SZW5kZXJcIiwgdC5wYWdpbmF0aW9uLiRlbFswXSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGgoKSB7XHJcbiAgICAgICAgICAgIHQucGFyYW1zLnBhZ2luYXRpb24gPSBGKHQsIHQub3JpZ2luYWxQYXJhbXMucGFnaW5hdGlvbiwgdC5wYXJhbXMucGFnaW5hdGlvbiwge2VsOiBcInN3aXBlci1wYWdpbmF0aW9uXCJ9KTtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHQucGFyYW1zLnBhZ2luYXRpb247XHJcbiAgICAgICAgICAgIGlmICghZS5lbCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBsZXQgcyA9IGQoZS5lbCk7XHJcbiAgICAgICAgICAgIDAgIT09IHMubGVuZ3RoICYmICh0LnBhcmFtcy51bmlxdWVOYXZFbGVtZW50cyAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBlLmVsICYmIHMubGVuZ3RoID4gMSAmJiAocyA9IHQuJGVsLmZpbmQoZS5lbCksIHMubGVuZ3RoID4gMSAmJiAocyA9IHMuZmlsdGVyKChlID0+IGQoZSkucGFyZW50cyhcIi5zd2lwZXJcIilbMF0gPT09IHQuZWwpKSkpLCBcImJ1bGxldHNcIiA9PT0gZS50eXBlICYmIGUuY2xpY2thYmxlICYmIHMuYWRkQ2xhc3MoZS5jbGlja2FibGVDbGFzcyksIHMuYWRkQ2xhc3MoZS5tb2RpZmllckNsYXNzICsgZS50eXBlKSwgcy5hZGRDbGFzcyh0LmlzSG9yaXpvbnRhbCgpID8gZS5ob3Jpem9udGFsQ2xhc3MgOiBlLnZlcnRpY2FsQ2xhc3MpLCBcImJ1bGxldHNcIiA9PT0gZS50eXBlICYmIGUuZHluYW1pY0J1bGxldHMgJiYgKHMuYWRkQ2xhc3MoYCR7ZS5tb2RpZmllckNsYXNzfSR7ZS50eXBlfS1keW5hbWljYCksIGwgPSAwLCBlLmR5bmFtaWNNYWluQnVsbGV0cyA8IDEgJiYgKGUuZHluYW1pY01haW5CdWxsZXRzID0gMSkpLCBcInByb2dyZXNzYmFyXCIgPT09IGUudHlwZSAmJiBlLnByb2dyZXNzYmFyT3Bwb3NpdGUgJiYgcy5hZGRDbGFzcyhlLnByb2dyZXNzYmFyT3Bwb3NpdGVDbGFzcyksIGUuY2xpY2thYmxlICYmIHMub24oXCJjbGlja1wiLCBVKGUuYnVsbGV0Q2xhc3MpLCAoZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGxldCBzID0gZCh0aGlzKS5pbmRleCgpICogdC5wYXJhbXMuc2xpZGVzUGVyR3JvdXA7XHJcbiAgICAgICAgICAgICAgICB0LnBhcmFtcy5sb29wICYmIChzICs9IHQubG9vcGVkU2xpZGVzKSwgdC5zbGlkZVRvKHMpXHJcbiAgICAgICAgICAgIH0pKSwgT2JqZWN0LmFzc2lnbih0LnBhZ2luYXRpb24sIHskZWw6IHMsIGVsOiBzWzBdfSksIHQuZW5hYmxlZCB8fCBzLmFkZENsYXNzKGUubG9ja0NsYXNzKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG0oKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0LnBhcmFtcy5wYWdpbmF0aW9uO1xyXG4gICAgICAgICAgICBpZiAobygpKSByZXR1cm47XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0LnBhZ2luYXRpb24uJGVsO1xyXG4gICAgICAgICAgICBzLnJlbW92ZUNsYXNzKGUuaGlkZGVuQ2xhc3MpLCBzLnJlbW92ZUNsYXNzKGUubW9kaWZpZXJDbGFzcyArIGUudHlwZSksIHMucmVtb3ZlQ2xhc3ModC5pc0hvcml6b250YWwoKSA/IGUuaG9yaXpvbnRhbENsYXNzIDogZS52ZXJ0aWNhbENsYXNzKSwgdC5wYWdpbmF0aW9uLmJ1bGxldHMgJiYgdC5wYWdpbmF0aW9uLmJ1bGxldHMucmVtb3ZlQ2xhc3MgJiYgdC5wYWdpbmF0aW9uLmJ1bGxldHMucmVtb3ZlQ2xhc3MoZS5idWxsZXRBY3RpdmVDbGFzcyksIGUuY2xpY2thYmxlICYmIHMub2ZmKFwiY2xpY2tcIiwgVShlLmJ1bGxldENsYXNzKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGEoXCJpbml0XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgICExID09PSB0LnBhcmFtcy5wYWdpbmF0aW9uLmVuYWJsZWQgPyBmKCkgOiAoaCgpLCB1KCksIHAoKSlcclxuICAgICAgICB9KSksIGEoXCJhY3RpdmVJbmRleENoYW5nZVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICAodC5wYXJhbXMubG9vcCB8fCB2b2lkIDAgPT09IHQuc25hcEluZGV4KSAmJiBwKClcclxuICAgICAgICB9KSksIGEoXCJzbmFwSW5kZXhDaGFuZ2VcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC5wYXJhbXMubG9vcCB8fCBwKClcclxuICAgICAgICB9KSksIGEoXCJzbGlkZXNMZW5ndGhDaGFuZ2VcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC5wYXJhbXMubG9vcCAmJiAodSgpLCBwKCkpXHJcbiAgICAgICAgfSkpLCBhKFwic25hcEdyaWRMZW5ndGhDaGFuZ2VcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC5wYXJhbXMubG9vcCB8fCAodSgpLCBwKCkpXHJcbiAgICAgICAgfSkpLCBhKFwiZGVzdHJveVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBtKClcclxuICAgICAgICB9KSksIGEoXCJlbmFibGUgZGlzYWJsZVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7JGVsOiBlfSA9IHQucGFnaW5hdGlvbjtcclxuICAgICAgICAgICAgZSAmJiBlW3QuZW5hYmxlZCA/IFwicmVtb3ZlQ2xhc3NcIiA6IFwiYWRkQ2xhc3NcIl0odC5wYXJhbXMucGFnaW5hdGlvbi5sb2NrQ2xhc3MpXHJcbiAgICAgICAgfSkpLCBhKFwibG9jayB1bmxvY2tcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgcCgpXHJcbiAgICAgICAgfSkpLCBhKFwiY2xpY2tcIiwgKChlLCBzKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSBzLnRhcmdldCwgeyRlbDogcn0gPSB0LnBhZ2luYXRpb247XHJcbiAgICAgICAgICAgIGlmICh0LnBhcmFtcy5wYWdpbmF0aW9uLmVsICYmIHQucGFyYW1zLnBhZ2luYXRpb24uaGlkZU9uQ2xpY2sgJiYgciAmJiByLmxlbmd0aCA+IDAgJiYgIWQoYSkuaGFzQ2xhc3ModC5wYXJhbXMucGFnaW5hdGlvbi5idWxsZXRDbGFzcykpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0Lm5hdmlnYXRpb24gJiYgKHQubmF2aWdhdGlvbi5uZXh0RWwgJiYgYSA9PT0gdC5uYXZpZ2F0aW9uLm5leHRFbCB8fCB0Lm5hdmlnYXRpb24ucHJldkVsICYmIGEgPT09IHQubmF2aWdhdGlvbi5wcmV2RWwpKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gci5oYXNDbGFzcyh0LnBhcmFtcy5wYWdpbmF0aW9uLmhpZGRlbkNsYXNzKTtcclxuICAgICAgICAgICAgICAgIGkoITAgPT09IGUgPyBcInBhZ2luYXRpb25TaG93XCIgOiBcInBhZ2luYXRpb25IaWRlXCIpLCByLnRvZ2dsZUNsYXNzKHQucGFyYW1zLnBhZ2luYXRpb24uaGlkZGVuQ2xhc3MpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgY29uc3QgZiA9ICgpID0+IHtcclxuICAgICAgICAgICAgdC4kZWwuYWRkQ2xhc3ModC5wYXJhbXMucGFnaW5hdGlvbi5wYWdpbmF0aW9uRGlzYWJsZWRDbGFzcyksIHQucGFnaW5hdGlvbi4kZWwgJiYgdC5wYWdpbmF0aW9uLiRlbC5hZGRDbGFzcyh0LnBhcmFtcy5wYWdpbmF0aW9uLnBhZ2luYXRpb25EaXNhYmxlZENsYXNzKSwgbSgpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHQucGFnaW5hdGlvbiwge1xyXG4gICAgICAgICAgICBlbmFibGU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHQuJGVsLnJlbW92ZUNsYXNzKHQucGFyYW1zLnBhZ2luYXRpb24ucGFnaW5hdGlvbkRpc2FibGVkQ2xhc3MpLCB0LnBhZ2luYXRpb24uJGVsICYmIHQucGFnaW5hdGlvbi4kZWwucmVtb3ZlQ2xhc3ModC5wYXJhbXMucGFnaW5hdGlvbi5wYWdpbmF0aW9uRGlzYWJsZWRDbGFzcyksIGgoKSwgdSgpLCBwKClcclxuICAgICAgICAgICAgfSwgZGlzYWJsZTogZiwgcmVuZGVyOiB1LCB1cGRhdGU6IHAsIGluaXQ6IGgsIGRlc3Ryb3k6IG1cclxuICAgICAgICB9KVxyXG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBsZXQge3N3aXBlcjogdCwgZXh0ZW5kUGFyYW1zOiBzLCBvbjogaSwgZW1pdDogcn0gPSBlO1xyXG4gICAgICAgIGNvbnN0IG4gPSBhKCk7XHJcbiAgICAgICAgbGV0IGwsIG8sIGMsIHUsIGggPSAhMSwgbSA9IG51bGwsIGYgPSBudWxsO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBnKCkge1xyXG4gICAgICAgICAgICBpZiAoIXQucGFyYW1zLnNjcm9sbGJhci5lbCB8fCAhdC5zY3JvbGxiYXIuZWwpIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3Qge3Njcm9sbGJhcjogZSwgcnRsVHJhbnNsYXRlOiBzLCBwcm9ncmVzczogYX0gPSB0LCB7JGRyYWdFbDogaSwgJGVsOiByfSA9IGUsIG4gPSB0LnBhcmFtcy5zY3JvbGxiYXI7XHJcbiAgICAgICAgICAgIGxldCBsID0gbywgZCA9IChjIC0gbykgKiBhO1xyXG4gICAgICAgICAgICBzID8gKGQgPSAtZCwgZCA+IDAgPyAobCA9IG8gLSBkLCBkID0gMCkgOiAtZCArIG8gPiBjICYmIChsID0gYyArIGQpKSA6IGQgPCAwID8gKGwgPSBvICsgZCwgZCA9IDApIDogZCArIG8gPiBjICYmIChsID0gYyAtIGQpLCB0LmlzSG9yaXpvbnRhbCgpID8gKGkudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke2R9cHgsIDAsIDApYCksIGlbMF0uc3R5bGUud2lkdGggPSBgJHtsfXB4YCkgOiAoaS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDBweCwgJHtkfXB4LCAwKWApLCBpWzBdLnN0eWxlLmhlaWdodCA9IGAke2x9cHhgKSwgbi5oaWRlICYmIChjbGVhclRpbWVvdXQobSksIHJbMF0uc3R5bGUub3BhY2l0eSA9IDEsIG0gPSBzZXRUaW1lb3V0KCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByWzBdLnN0eWxlLm9wYWNpdHkgPSAwLCByLnRyYW5zaXRpb24oNDAwKVxyXG4gICAgICAgICAgICB9KSwgMWUzKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHYoKSB7XHJcbiAgICAgICAgICAgIGlmICghdC5wYXJhbXMuc2Nyb2xsYmFyLmVsIHx8ICF0LnNjcm9sbGJhci5lbCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCB7c2Nyb2xsYmFyOiBlfSA9IHQsIHskZHJhZ0VsOiBzLCAkZWw6IGF9ID0gZTtcclxuICAgICAgICAgICAgc1swXS5zdHlsZS53aWR0aCA9IFwiXCIsIHNbMF0uc3R5bGUuaGVpZ2h0ID0gXCJcIiwgYyA9IHQuaXNIb3Jpem9udGFsKCkgPyBhWzBdLm9mZnNldFdpZHRoIDogYVswXS5vZmZzZXRIZWlnaHQsIHUgPSB0LnNpemUgLyAodC52aXJ0dWFsU2l6ZSArIHQucGFyYW1zLnNsaWRlc09mZnNldEJlZm9yZSAtICh0LnBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IHQuc25hcEdyaWRbMF0gOiAwKSksIG8gPSBcImF1dG9cIiA9PT0gdC5wYXJhbXMuc2Nyb2xsYmFyLmRyYWdTaXplID8gYyAqIHUgOiBwYXJzZUludCh0LnBhcmFtcy5zY3JvbGxiYXIuZHJhZ1NpemUsIDEwKSwgdC5pc0hvcml6b250YWwoKSA/IHNbMF0uc3R5bGUud2lkdGggPSBgJHtvfXB4YCA6IHNbMF0uc3R5bGUuaGVpZ2h0ID0gYCR7b31weGAsIGFbMF0uc3R5bGUuZGlzcGxheSA9IHUgPj0gMSA/IFwibm9uZVwiIDogXCJcIiwgdC5wYXJhbXMuc2Nyb2xsYmFyLmhpZGUgJiYgKGFbMF0uc3R5bGUub3BhY2l0eSA9IDApLCB0LnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHQuZW5hYmxlZCAmJiBlLiRlbFt0LmlzTG9ja2VkID8gXCJhZGRDbGFzc1wiIDogXCJyZW1vdmVDbGFzc1wiXSh0LnBhcmFtcy5zY3JvbGxiYXIubG9ja0NsYXNzKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdyhlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0LmlzSG9yaXpvbnRhbCgpID8gXCJ0b3VjaHN0YXJ0XCIgPT09IGUudHlwZSB8fCBcInRvdWNobW92ZVwiID09PSBlLnR5cGUgPyBlLnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WCA6IGUuY2xpZW50WCA6IFwidG91Y2hzdGFydFwiID09PSBlLnR5cGUgfHwgXCJ0b3VjaG1vdmVcIiA9PT0gZS50eXBlID8gZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFkgOiBlLmNsaWVudFlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGIoZSkge1xyXG4gICAgICAgICAgICBjb25zdCB7c2Nyb2xsYmFyOiBzLCBydGxUcmFuc2xhdGU6IGF9ID0gdCwgeyRlbDogaX0gPSBzO1xyXG4gICAgICAgICAgICBsZXQgcjtcclxuICAgICAgICAgICAgciA9ICh3KGUpIC0gaS5vZmZzZXQoKVt0LmlzSG9yaXpvbnRhbCgpID8gXCJsZWZ0XCIgOiBcInRvcFwiXSAtIChudWxsICE9PSBsID8gbCA6IG8gLyAyKSkgLyAoYyAtIG8pLCByID0gTWF0aC5tYXgoTWF0aC5taW4ociwgMSksIDApLCBhICYmIChyID0gMSAtIHIpO1xyXG4gICAgICAgICAgICBjb25zdCBuID0gdC5taW5UcmFuc2xhdGUoKSArICh0Lm1heFRyYW5zbGF0ZSgpIC0gdC5taW5UcmFuc2xhdGUoKSkgKiByO1xyXG4gICAgICAgICAgICB0LnVwZGF0ZVByb2dyZXNzKG4pLCB0LnNldFRyYW5zbGF0ZShuKSwgdC51cGRhdGVBY3RpdmVJbmRleCgpLCB0LnVwZGF0ZVNsaWRlc0NsYXNzZXMoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24geChlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0LnBhcmFtcy5zY3JvbGxiYXIsIHtzY3JvbGxiYXI6IGEsICR3cmFwcGVyRWw6IGl9ID0gdCwgeyRlbDogbiwgJGRyYWdFbDogb30gPSBhO1xyXG4gICAgICAgICAgICBoID0gITAsIGwgPSBlLnRhcmdldCA9PT0gb1swXSB8fCBlLnRhcmdldCA9PT0gbyA/IHcoZSkgLSBlLnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVt0LmlzSG9yaXpvbnRhbCgpID8gXCJsZWZ0XCIgOiBcInRvcFwiXSA6IG51bGwsIGUucHJldmVudERlZmF1bHQoKSwgZS5zdG9wUHJvcGFnYXRpb24oKSwgaS50cmFuc2l0aW9uKDEwMCksIG8udHJhbnNpdGlvbigxMDApLCBiKGUpLCBjbGVhclRpbWVvdXQoZiksIG4udHJhbnNpdGlvbigwKSwgcy5oaWRlICYmIG4uY3NzKFwib3BhY2l0eVwiLCAxKSwgdC5wYXJhbXMuY3NzTW9kZSAmJiB0LiR3cmFwcGVyRWwuY3NzKFwic2Nyb2xsLXNuYXAtdHlwZVwiLCBcIm5vbmVcIiksIHIoXCJzY3JvbGxiYXJEcmFnU3RhcnRcIiwgZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHkoZSkge1xyXG4gICAgICAgICAgICBjb25zdCB7c2Nyb2xsYmFyOiBzLCAkd3JhcHBlckVsOiBhfSA9IHQsIHskZWw6IGksICRkcmFnRWw6IG59ID0gcztcclxuICAgICAgICAgICAgaCAmJiAoZS5wcmV2ZW50RGVmYXVsdCA/IGUucHJldmVudERlZmF1bHQoKSA6IGUucmV0dXJuVmFsdWUgPSAhMSwgYihlKSwgYS50cmFuc2l0aW9uKDApLCBpLnRyYW5zaXRpb24oMCksIG4udHJhbnNpdGlvbigwKSwgcihcInNjcm9sbGJhckRyYWdNb3ZlXCIsIGUpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gRShlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0LnBhcmFtcy5zY3JvbGxiYXIsIHtzY3JvbGxiYXI6IGEsICR3cmFwcGVyRWw6IGl9ID0gdCwgeyRlbDogbn0gPSBhO1xyXG4gICAgICAgICAgICBoICYmIChoID0gITEsIHQucGFyYW1zLmNzc01vZGUgJiYgKHQuJHdyYXBwZXJFbC5jc3MoXCJzY3JvbGwtc25hcC10eXBlXCIsIFwiXCIpLCBpLnRyYW5zaXRpb24oXCJcIikpLCBzLmhpZGUgJiYgKGNsZWFyVGltZW91dChmKSwgZiA9IHAoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIG4uY3NzKFwib3BhY2l0eVwiLCAwKSwgbi50cmFuc2l0aW9uKDQwMClcclxuICAgICAgICAgICAgfSksIDFlMykpLCByKFwic2Nyb2xsYmFyRHJhZ0VuZFwiLCBlKSwgcy5zbmFwT25SZWxlYXNlICYmIHQuc2xpZGVUb0Nsb3Nlc3QoKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIEMoZSkge1xyXG4gICAgICAgICAgICBjb25zdCB7c2Nyb2xsYmFyOiBzLCB0b3VjaEV2ZW50c1RvdWNoOiBhLCB0b3VjaEV2ZW50c0Rlc2t0b3A6IGksIHBhcmFtczogciwgc3VwcG9ydDogbH0gPSB0LCBvID0gcy4kZWw7XHJcbiAgICAgICAgICAgIGlmICghbykgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCBkID0gb1swXSwgYyA9ICEoIWwucGFzc2l2ZUxpc3RlbmVyIHx8ICFyLnBhc3NpdmVMaXN0ZW5lcnMpICYmIHtwYXNzaXZlOiAhMSwgY2FwdHVyZTogITF9LFxyXG4gICAgICAgICAgICAgICAgcCA9ICEoIWwucGFzc2l2ZUxpc3RlbmVyIHx8ICFyLnBhc3NpdmVMaXN0ZW5lcnMpICYmIHtwYXNzaXZlOiAhMCwgY2FwdHVyZTogITF9O1xyXG4gICAgICAgICAgICBpZiAoIWQpIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgdSA9IFwib25cIiA9PT0gZSA/IFwiYWRkRXZlbnRMaXN0ZW5lclwiIDogXCJyZW1vdmVFdmVudExpc3RlbmVyXCI7XHJcbiAgICAgICAgICAgIGwudG91Y2ggPyAoZFt1XShhLnN0YXJ0LCB4LCBjKSwgZFt1XShhLm1vdmUsIHksIGMpLCBkW3VdKGEuZW5kLCBFLCBwKSkgOiAoZFt1XShpLnN0YXJ0LCB4LCBjKSwgblt1XShpLm1vdmUsIHksIGMpLCBuW3VdKGkuZW5kLCBFLCBwKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIFQoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHtzY3JvbGxiYXI6IGUsICRlbDogc30gPSB0O1xyXG4gICAgICAgICAgICB0LnBhcmFtcy5zY3JvbGxiYXIgPSBGKHQsIHQub3JpZ2luYWxQYXJhbXMuc2Nyb2xsYmFyLCB0LnBhcmFtcy5zY3JvbGxiYXIsIHtlbDogXCJzd2lwZXItc2Nyb2xsYmFyXCJ9KTtcclxuICAgICAgICAgICAgY29uc3QgYSA9IHQucGFyYW1zLnNjcm9sbGJhcjtcclxuICAgICAgICAgICAgaWYgKCFhLmVsKSByZXR1cm47XHJcbiAgICAgICAgICAgIGxldCBpID0gZChhLmVsKTtcclxuICAgICAgICAgICAgdC5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHMgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgYS5lbCAmJiBpLmxlbmd0aCA+IDEgJiYgMSA9PT0gcy5maW5kKGEuZWwpLmxlbmd0aCAmJiAoaSA9IHMuZmluZChhLmVsKSksIGkuYWRkQ2xhc3ModC5pc0hvcml6b250YWwoKSA/IGEuaG9yaXpvbnRhbENsYXNzIDogYS52ZXJ0aWNhbENsYXNzKTtcclxuICAgICAgICAgICAgbGV0IHIgPSBpLmZpbmQoYC4ke3QucGFyYW1zLnNjcm9sbGJhci5kcmFnQ2xhc3N9YCk7XHJcbiAgICAgICAgICAgIDAgPT09IHIubGVuZ3RoICYmIChyID0gZChgPGRpdiBjbGFzcz1cIiR7dC5wYXJhbXMuc2Nyb2xsYmFyLmRyYWdDbGFzc31cIj48L2Rpdj5gKSwgaS5hcHBlbmQocikpLCBPYmplY3QuYXNzaWduKGUsIHtcclxuICAgICAgICAgICAgICAgICRlbDogaSxcclxuICAgICAgICAgICAgICAgIGVsOiBpWzBdLFxyXG4gICAgICAgICAgICAgICAgJGRyYWdFbDogcixcclxuICAgICAgICAgICAgICAgIGRyYWdFbDogclswXVxyXG4gICAgICAgICAgICB9KSwgYS5kcmFnZ2FibGUgJiYgdC5wYXJhbXMuc2Nyb2xsYmFyLmVsICYmIHQuc2Nyb2xsYmFyLmVsICYmIEMoXCJvblwiKSwgaSAmJiBpW3QuZW5hYmxlZCA/IFwicmVtb3ZlQ2xhc3NcIiA6IFwiYWRkQ2xhc3NcIl0odC5wYXJhbXMuc2Nyb2xsYmFyLmxvY2tDbGFzcylcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uICQoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0LnBhcmFtcy5zY3JvbGxiYXIsIHMgPSB0LnNjcm9sbGJhci4kZWw7XHJcbiAgICAgICAgICAgIHMgJiYgcy5yZW1vdmVDbGFzcyh0LmlzSG9yaXpvbnRhbCgpID8gZS5ob3Jpem9udGFsQ2xhc3MgOiBlLnZlcnRpY2FsQ2xhc3MpLCB0LnBhcmFtcy5zY3JvbGxiYXIuZWwgJiYgdC5zY3JvbGxiYXIuZWwgJiYgQyhcIm9mZlwiKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcyh7XHJcbiAgICAgICAgICAgIHNjcm9sbGJhcjoge1xyXG4gICAgICAgICAgICAgICAgZWw6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBkcmFnU2l6ZTogXCJhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICBoaWRlOiAhMSxcclxuICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogITEsXHJcbiAgICAgICAgICAgICAgICBzbmFwT25SZWxlYXNlOiAhMCxcclxuICAgICAgICAgICAgICAgIGxvY2tDbGFzczogXCJzd2lwZXItc2Nyb2xsYmFyLWxvY2tcIixcclxuICAgICAgICAgICAgICAgIGRyYWdDbGFzczogXCJzd2lwZXItc2Nyb2xsYmFyLWRyYWdcIixcclxuICAgICAgICAgICAgICAgIHNjcm9sbGJhckRpc2FibGVkQ2xhc3M6IFwic3dpcGVyLXNjcm9sbGJhci1kaXNhYmxlZFwiLFxyXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbENsYXNzOiBcInN3aXBlci1zY3JvbGxiYXItaG9yaXpvbnRhbFwiLFxyXG4gICAgICAgICAgICAgICAgdmVydGljYWxDbGFzczogXCJzd2lwZXItc2Nyb2xsYmFyLXZlcnRpY2FsXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLCB0LnNjcm9sbGJhciA9IHtlbDogbnVsbCwgZHJhZ0VsOiBudWxsLCAkZWw6IG51bGwsICRkcmFnRWw6IG51bGx9LCBpKFwiaW5pdFwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICAhMSA9PT0gdC5wYXJhbXMuc2Nyb2xsYmFyLmVuYWJsZWQgPyBTKCkgOiAoVCgpLCB2KCksIGcoKSlcclxuICAgICAgICB9KSksIGkoXCJ1cGRhdGUgcmVzaXplIG9ic2VydmVyVXBkYXRlIGxvY2sgdW5sb2NrXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHYoKVxyXG4gICAgICAgIH0pKSwgaShcInNldFRyYW5zbGF0ZVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBnKClcclxuICAgICAgICB9KSksIGkoXCJzZXRUcmFuc2l0aW9uXCIsICgoZSwgcykgPT4ge1xyXG4gICAgICAgICAgICAhZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIHQucGFyYW1zLnNjcm9sbGJhci5lbCAmJiB0LnNjcm9sbGJhci5lbCAmJiB0LnNjcm9sbGJhci4kZHJhZ0VsLnRyYW5zaXRpb24oZSlcclxuICAgICAgICAgICAgfShzKVxyXG4gICAgICAgIH0pKSwgaShcImVuYWJsZSBkaXNhYmxlXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHskZWw6IGV9ID0gdC5zY3JvbGxiYXI7XHJcbiAgICAgICAgICAgIGUgJiYgZVt0LmVuYWJsZWQgPyBcInJlbW92ZUNsYXNzXCIgOiBcImFkZENsYXNzXCJdKHQucGFyYW1zLnNjcm9sbGJhci5sb2NrQ2xhc3MpXHJcbiAgICAgICAgfSkpLCBpKFwiZGVzdHJveVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICAkKClcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgY29uc3QgUyA9ICgpID0+IHtcclxuICAgICAgICAgICAgdC4kZWwuYWRkQ2xhc3ModC5wYXJhbXMuc2Nyb2xsYmFyLnNjcm9sbGJhckRpc2FibGVkQ2xhc3MpLCB0LnNjcm9sbGJhci4kZWwgJiYgdC5zY3JvbGxiYXIuJGVsLmFkZENsYXNzKHQucGFyYW1zLnNjcm9sbGJhci5zY3JvbGxiYXJEaXNhYmxlZENsYXNzKSwgJCgpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHQuc2Nyb2xsYmFyLCB7XHJcbiAgICAgICAgICAgIGVuYWJsZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdC4kZWwucmVtb3ZlQ2xhc3ModC5wYXJhbXMuc2Nyb2xsYmFyLnNjcm9sbGJhckRpc2FibGVkQ2xhc3MpLCB0LnNjcm9sbGJhci4kZWwgJiYgdC5zY3JvbGxiYXIuJGVsLnJlbW92ZUNsYXNzKHQucGFyYW1zLnNjcm9sbGJhci5zY3JvbGxiYXJEaXNhYmxlZENsYXNzKSwgVCgpLCB2KCksIGcoKVxyXG4gICAgICAgICAgICB9LCBkaXNhYmxlOiBTLCB1cGRhdGVTaXplOiB2LCBzZXRUcmFuc2xhdGU6IGcsIGluaXQ6IFQsIGRlc3Ryb3k6ICRcclxuICAgICAgICB9KVxyXG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBsZXQge3N3aXBlcjogdCwgZXh0ZW5kUGFyYW1zOiBzLCBvbjogYX0gPSBlO1xyXG4gICAgICAgIHMoe3BhcmFsbGF4OiB7ZW5hYmxlZDogITF9fSk7XHJcbiAgICAgICAgY29uc3QgaSA9IChlLCBzKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHtydGw6IGF9ID0gdCwgaSA9IGQoZSksIHIgPSBhID8gLTEgOiAxLCBuID0gaS5hdHRyKFwiZGF0YS1zd2lwZXItcGFyYWxsYXhcIikgfHwgXCIwXCI7XHJcbiAgICAgICAgICAgIGxldCBsID0gaS5hdHRyKFwiZGF0YS1zd2lwZXItcGFyYWxsYXgteFwiKSwgbyA9IGkuYXR0cihcImRhdGEtc3dpcGVyLXBhcmFsbGF4LXlcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBpLmF0dHIoXCJkYXRhLXN3aXBlci1wYXJhbGxheC1zY2FsZVwiKSwgcCA9IGkuYXR0cihcImRhdGEtc3dpcGVyLXBhcmFsbGF4LW9wYWNpdHlcIik7XHJcbiAgICAgICAgICAgIGlmIChsIHx8IG8gPyAobCA9IGwgfHwgXCIwXCIsIG8gPSBvIHx8IFwiMFwiKSA6IHQuaXNIb3Jpem9udGFsKCkgPyAobCA9IG4sIG8gPSBcIjBcIikgOiAobyA9IG4sIGwgPSBcIjBcIiksIGwgPSBsLmluZGV4T2YoXCIlXCIpID49IDAgPyBwYXJzZUludChsLCAxMCkgKiBzICogciArIFwiJVwiIDogbCAqIHMgKiByICsgXCJweFwiLCBvID0gby5pbmRleE9mKFwiJVwiKSA+PSAwID8gcGFyc2VJbnQobywgMTApICogcyArIFwiJVwiIDogbyAqIHMgKyBcInB4XCIsIG51bGwgIT0gcCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHAgLSAocCAtIDEpICogKDEgLSBNYXRoLmFicyhzKSk7XHJcbiAgICAgICAgICAgICAgICBpWzBdLnN0eWxlLm9wYWNpdHkgPSBlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG51bGwgPT0gYykgaS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7bH0sICR7b30sIDBweClgKTsgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gYyAtIChjIC0gMSkgKiAoMSAtIE1hdGguYWJzKHMpKTtcclxuICAgICAgICAgICAgICAgIGkudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke2x9LCAke299LCAwcHgpIHNjYWxlKCR7ZX0pYClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHskZWw6IGUsIHNsaWRlczogcywgcHJvZ3Jlc3M6IGEsIHNuYXBHcmlkOiByfSA9IHQ7XHJcbiAgICAgICAgICAgIGUuY2hpbGRyZW4oXCJbZGF0YS1zd2lwZXItcGFyYWxsYXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteF0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC15XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LW9wYWNpdHldLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgtc2NhbGVdXCIpLmVhY2goKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgaShlLCBhKVxyXG4gICAgICAgICAgICB9KSksIHMuZWFjaCgoKGUsIHMpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBuID0gZS5wcm9ncmVzcztcclxuICAgICAgICAgICAgICAgIHQucGFyYW1zLnNsaWRlc1Blckdyb3VwID4gMSAmJiBcImF1dG9cIiAhPT0gdC5wYXJhbXMuc2xpZGVzUGVyVmlldyAmJiAobiArPSBNYXRoLmNlaWwocyAvIDIpIC0gYSAqIChyLmxlbmd0aCAtIDEpKSwgbiA9IE1hdGgubWluKE1hdGgubWF4KG4sIC0xKSwgMSksIGQoZSkuZmluZChcIltkYXRhLXN3aXBlci1wYXJhbGxheF0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC14XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXldLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgtb3BhY2l0eV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1zY2FsZV1cIikuZWFjaCgoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaShlLCBuKVxyXG4gICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgYShcImJlZm9yZUluaXRcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC5wYXJhbXMucGFyYWxsYXguZW5hYmxlZCAmJiAodC5wYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcyA9ICEwLCB0Lm9yaWdpbmFsUGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgPSAhMClcclxuICAgICAgICB9KSksIGEoXCJpbml0XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHQucGFyYW1zLnBhcmFsbGF4LmVuYWJsZWQgJiYgcigpXHJcbiAgICAgICAgfSkpLCBhKFwic2V0VHJhbnNsYXRlXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHQucGFyYW1zLnBhcmFsbGF4LmVuYWJsZWQgJiYgcigpXHJcbiAgICAgICAgfSkpLCBhKFwic2V0VHJhbnNpdGlvblwiLCAoKGUsIHMpID0+IHtcclxuICAgICAgICAgICAgdC5wYXJhbXMucGFyYWxsYXguZW5hYmxlZCAmJiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSBlICYmIChlID0gdC5wYXJhbXMuc3BlZWQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyRlbDogc30gPSB0O1xyXG4gICAgICAgICAgICAgICAgcy5maW5kKFwiW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlXVwiKS5lYWNoKCh0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gZCh0KTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYSA9IHBhcnNlSW50KHMuYXR0cihcImRhdGEtc3dpcGVyLXBhcmFsbGF4LWR1cmF0aW9uXCIpLCAxMCkgfHwgZTtcclxuICAgICAgICAgICAgICAgICAgICAwID09PSBlICYmIChhID0gMCksIHMudHJhbnNpdGlvbihhKVxyXG4gICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgIH0ocylcclxuICAgICAgICB9KSlcclxuICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgbGV0IHtzd2lwZXI6IHQsIGV4dGVuZFBhcmFtczogcywgb246IGEsIGVtaXQ6IGl9ID0gZTtcclxuICAgICAgICBjb25zdCBuID0gcigpO1xyXG4gICAgICAgIHMoe1xyXG4gICAgICAgICAgICB6b29tOiB7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiAhMSxcclxuICAgICAgICAgICAgICAgIG1heFJhdGlvOiAzLFxyXG4gICAgICAgICAgICAgICAgbWluUmF0aW86IDEsXHJcbiAgICAgICAgICAgICAgICB0b2dnbGU6ICEwLFxyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyQ2xhc3M6IFwic3dpcGVyLXpvb20tY29udGFpbmVyXCIsXHJcbiAgICAgICAgICAgICAgICB6b29tZWRTbGlkZUNsYXNzOiBcInN3aXBlci1zbGlkZS16b29tZWRcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksIHQuem9vbSA9IHtlbmFibGVkOiAhMX07XHJcbiAgICAgICAgbGV0IGwsIG8sIGMsIHAgPSAxLCB1ID0gITE7XHJcbiAgICAgICAgY29uc3QgbSA9IHtcclxuICAgICAgICAgICAgJHNsaWRlRWw6IHZvaWQgMCxcclxuICAgICAgICAgICAgc2xpZGVXaWR0aDogdm9pZCAwLFxyXG4gICAgICAgICAgICBzbGlkZUhlaWdodDogdm9pZCAwLFxyXG4gICAgICAgICAgICAkaW1hZ2VFbDogdm9pZCAwLFxyXG4gICAgICAgICAgICAkaW1hZ2VXcmFwRWw6IHZvaWQgMCxcclxuICAgICAgICAgICAgbWF4UmF0aW86IDNcclxuICAgICAgICB9LCBmID0ge1xyXG4gICAgICAgICAgICBpc1RvdWNoZWQ6IHZvaWQgMCxcclxuICAgICAgICAgICAgaXNNb3ZlZDogdm9pZCAwLFxyXG4gICAgICAgICAgICBjdXJyZW50WDogdm9pZCAwLFxyXG4gICAgICAgICAgICBjdXJyZW50WTogdm9pZCAwLFxyXG4gICAgICAgICAgICBtaW5YOiB2b2lkIDAsXHJcbiAgICAgICAgICAgIG1pblk6IHZvaWQgMCxcclxuICAgICAgICAgICAgbWF4WDogdm9pZCAwLFxyXG4gICAgICAgICAgICBtYXhZOiB2b2lkIDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiB2b2lkIDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogdm9pZCAwLFxyXG4gICAgICAgICAgICBzdGFydFg6IHZvaWQgMCxcclxuICAgICAgICAgICAgc3RhcnRZOiB2b2lkIDAsXHJcbiAgICAgICAgICAgIHRvdWNoZXNTdGFydDoge30sXHJcbiAgICAgICAgICAgIHRvdWNoZXNDdXJyZW50OiB7fVxyXG4gICAgICAgIH0sIGcgPSB7eDogdm9pZCAwLCB5OiB2b2lkIDAsIHByZXZQb3NpdGlvblg6IHZvaWQgMCwgcHJldlBvc2l0aW9uWTogdm9pZCAwLCBwcmV2VGltZTogdm9pZCAwfTtcclxuICAgICAgICBsZXQgdiA9IDE7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHcoZSkge1xyXG4gICAgICAgICAgICBpZiAoZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA8IDIpIHJldHVybiAxO1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYLCBzID0gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZLCBhID0gZS50YXJnZXRUb3VjaGVzWzFdLnBhZ2VYLFxyXG4gICAgICAgICAgICAgICAgaSA9IGUudGFyZ2V0VG91Y2hlc1sxXS5wYWdlWTtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCgoYSAtIHQpICoqIDIgKyAoaSAtIHMpICoqIDIpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBiKGUpIHtcclxuICAgICAgICAgICAgY29uc3QgcyA9IHQuc3VwcG9ydCwgYSA9IHQucGFyYW1zLnpvb207XHJcbiAgICAgICAgICAgIGlmIChvID0gITEsIGMgPSAhMSwgIXMuZ2VzdHVyZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChcInRvdWNoc3RhcnRcIiAhPT0gZS50eXBlIHx8IFwidG91Y2hzdGFydFwiID09PSBlLnR5cGUgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA8IDIpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIG8gPSAhMCwgbS5zY2FsZVN0YXJ0ID0gdyhlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG0uJHNsaWRlRWwgJiYgbS4kc2xpZGVFbC5sZW5ndGggfHwgKG0uJHNsaWRlRWwgPSBkKGUudGFyZ2V0KS5jbG9zZXN0KGAuJHt0LnBhcmFtcy5zbGlkZUNsYXNzfWApLCAwID09PSBtLiRzbGlkZUVsLmxlbmd0aCAmJiAobS4kc2xpZGVFbCA9IHQuc2xpZGVzLmVxKHQuYWN0aXZlSW5kZXgpKSwgbS4kaW1hZ2VFbCA9IG0uJHNsaWRlRWwuZmluZChgLiR7YS5jb250YWluZXJDbGFzc31gKS5lcSgwKS5maW5kKFwicGljdHVyZSwgaW1nLCBzdmcsIGNhbnZhcywgLnN3aXBlci16b29tLXRhcmdldFwiKS5lcSgwKSwgbS4kaW1hZ2VXcmFwRWwgPSBtLiRpbWFnZUVsLnBhcmVudChgLiR7YS5jb250YWluZXJDbGFzc31gKSwgbS5tYXhSYXRpbyA9IG0uJGltYWdlV3JhcEVsLmF0dHIoXCJkYXRhLXN3aXBlci16b29tXCIpIHx8IGEubWF4UmF0aW8sIDAgIT09IG0uJGltYWdlV3JhcEVsLmxlbmd0aCkgPyAobS4kaW1hZ2VFbCAmJiBtLiRpbWFnZUVsLnRyYW5zaXRpb24oMCksIHUgPSAhMCkgOiBtLiRpbWFnZUVsID0gdm9pZCAwXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB4KGUpIHtcclxuICAgICAgICAgICAgY29uc3QgcyA9IHQuc3VwcG9ydCwgYSA9IHQucGFyYW1zLnpvb20sIGkgPSB0Lnpvb207XHJcbiAgICAgICAgICAgIGlmICghcy5nZXN0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKFwidG91Y2htb3ZlXCIgIT09IGUudHlwZSB8fCBcInRvdWNobW92ZVwiID09PSBlLnR5cGUgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA8IDIpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGMgPSAhMCwgbS5zY2FsZU1vdmUgPSB3KGUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbS4kaW1hZ2VFbCAmJiAwICE9PSBtLiRpbWFnZUVsLmxlbmd0aCA/IChzLmdlc3R1cmVzID8gaS5zY2FsZSA9IGUuc2NhbGUgKiBwIDogaS5zY2FsZSA9IG0uc2NhbGVNb3ZlIC8gbS5zY2FsZVN0YXJ0ICogcCwgaS5zY2FsZSA+IG0ubWF4UmF0aW8gJiYgKGkuc2NhbGUgPSBtLm1heFJhdGlvIC0gMSArIChpLnNjYWxlIC0gbS5tYXhSYXRpbyArIDEpICoqIC41KSwgaS5zY2FsZSA8IGEubWluUmF0aW8gJiYgKGkuc2NhbGUgPSBhLm1pblJhdGlvICsgMSAtIChhLm1pblJhdGlvIC0gaS5zY2FsZSArIDEpICoqIC41KSwgbS4kaW1hZ2VFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZSgke2kuc2NhbGV9KWApKSA6IFwiZ2VzdHVyZWNoYW5nZVwiID09PSBlLnR5cGUgJiYgYihlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24geShlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0LmRldmljZSwgYSA9IHQuc3VwcG9ydCwgaSA9IHQucGFyYW1zLnpvb20sIHIgPSB0Lnpvb207XHJcbiAgICAgICAgICAgIGlmICghYS5nZXN0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFvIHx8ICFjKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJ0b3VjaGVuZFwiICE9PSBlLnR5cGUgfHwgXCJ0b3VjaGVuZFwiID09PSBlLnR5cGUgJiYgZS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPCAyICYmICFzLmFuZHJvaWQpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIG8gPSAhMSwgYyA9ICExXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbS4kaW1hZ2VFbCAmJiAwICE9PSBtLiRpbWFnZUVsLmxlbmd0aCAmJiAoci5zY2FsZSA9IE1hdGgubWF4KE1hdGgubWluKHIuc2NhbGUsIG0ubWF4UmF0aW8pLCBpLm1pblJhdGlvKSwgbS4kaW1hZ2VFbC50cmFuc2l0aW9uKHQucGFyYW1zLnNwZWVkKS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZSgke3Iuc2NhbGV9KWApLCBwID0gci5zY2FsZSwgdSA9ICExLCAxID09PSByLnNjYWxlICYmIChtLiRzbGlkZUVsID0gdm9pZCAwKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIEUoZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzID0gdC56b29tO1xyXG4gICAgICAgICAgICBpZiAoIW0uJGltYWdlRWwgfHwgMCA9PT0gbS4kaW1hZ2VFbC5sZW5ndGgpIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKHQuYWxsb3dDbGljayA9ICExLCAhZi5pc1RvdWNoZWQgfHwgIW0uJHNsaWRlRWwpIHJldHVybjtcclxuICAgICAgICAgICAgZi5pc01vdmVkIHx8IChmLndpZHRoID0gbS4kaW1hZ2VFbFswXS5vZmZzZXRXaWR0aCwgZi5oZWlnaHQgPSBtLiRpbWFnZUVsWzBdLm9mZnNldEhlaWdodCwgZi5zdGFydFggPSBoKG0uJGltYWdlV3JhcEVsWzBdLCBcInhcIikgfHwgMCwgZi5zdGFydFkgPSBoKG0uJGltYWdlV3JhcEVsWzBdLCBcInlcIikgfHwgMCwgbS5zbGlkZVdpZHRoID0gbS4kc2xpZGVFbFswXS5vZmZzZXRXaWR0aCwgbS5zbGlkZUhlaWdodCA9IG0uJHNsaWRlRWxbMF0ub2Zmc2V0SGVpZ2h0LCBtLiRpbWFnZVdyYXBFbC50cmFuc2l0aW9uKDApKTtcclxuICAgICAgICAgICAgY29uc3QgYSA9IGYud2lkdGggKiBzLnNjYWxlLCBpID0gZi5oZWlnaHQgKiBzLnNjYWxlO1xyXG4gICAgICAgICAgICBpZiAoIShhIDwgbS5zbGlkZVdpZHRoICYmIGkgPCBtLnNsaWRlSGVpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGYubWluWCA9IE1hdGgubWluKG0uc2xpZGVXaWR0aCAvIDIgLSBhIC8gMiwgMCksIGYubWF4WCA9IC1mLm1pblgsIGYubWluWSA9IE1hdGgubWluKG0uc2xpZGVIZWlnaHQgLyAyIC0gaSAvIDIsIDApLCBmLm1heFkgPSAtZi5taW5ZLCBmLnRvdWNoZXNDdXJyZW50LnggPSBcInRvdWNobW92ZVwiID09PSBlLnR5cGUgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVggOiBlLnBhZ2VYLCBmLnRvdWNoZXNDdXJyZW50LnkgPSBcInRvdWNobW92ZVwiID09PSBlLnR5cGUgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZLCAhZi5pc01vdmVkICYmICF1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQuaXNIb3Jpem9udGFsKCkgJiYgKE1hdGguZmxvb3IoZi5taW5YKSA9PT0gTWF0aC5mbG9vcihmLnN0YXJ0WCkgJiYgZi50b3VjaGVzQ3VycmVudC54IDwgZi50b3VjaGVzU3RhcnQueCB8fCBNYXRoLmZsb29yKGYubWF4WCkgPT09IE1hdGguZmxvb3IoZi5zdGFydFgpICYmIGYudG91Y2hlc0N1cnJlbnQueCA+IGYudG91Y2hlc1N0YXJ0LngpKSByZXR1cm4gdm9pZCAoZi5pc1RvdWNoZWQgPSAhMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0LmlzSG9yaXpvbnRhbCgpICYmIChNYXRoLmZsb29yKGYubWluWSkgPT09IE1hdGguZmxvb3IoZi5zdGFydFkpICYmIGYudG91Y2hlc0N1cnJlbnQueSA8IGYudG91Y2hlc1N0YXJ0LnkgfHwgTWF0aC5mbG9vcihmLm1heFkpID09PSBNYXRoLmZsb29yKGYuc3RhcnRZKSAmJiBmLnRvdWNoZXNDdXJyZW50LnkgPiBmLnRvdWNoZXNTdGFydC55KSkgcmV0dXJuIHZvaWQgKGYuaXNUb3VjaGVkID0gITEpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlLmNhbmNlbGFibGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpLCBlLnN0b3BQcm9wYWdhdGlvbigpLCBmLmlzTW92ZWQgPSAhMCwgZi5jdXJyZW50WCA9IGYudG91Y2hlc0N1cnJlbnQueCAtIGYudG91Y2hlc1N0YXJ0LnggKyBmLnN0YXJ0WCwgZi5jdXJyZW50WSA9IGYudG91Y2hlc0N1cnJlbnQueSAtIGYudG91Y2hlc1N0YXJ0LnkgKyBmLnN0YXJ0WSwgZi5jdXJyZW50WCA8IGYubWluWCAmJiAoZi5jdXJyZW50WCA9IGYubWluWCArIDEgLSAoZi5taW5YIC0gZi5jdXJyZW50WCArIDEpICoqIC44KSwgZi5jdXJyZW50WCA+IGYubWF4WCAmJiAoZi5jdXJyZW50WCA9IGYubWF4WCAtIDEgKyAoZi5jdXJyZW50WCAtIGYubWF4WCArIDEpICoqIC44KSwgZi5jdXJyZW50WSA8IGYubWluWSAmJiAoZi5jdXJyZW50WSA9IGYubWluWSArIDEgLSAoZi5taW5ZIC0gZi5jdXJyZW50WSArIDEpICoqIC44KSwgZi5jdXJyZW50WSA+IGYubWF4WSAmJiAoZi5jdXJyZW50WSA9IGYubWF4WSAtIDEgKyAoZi5jdXJyZW50WSAtIGYubWF4WSArIDEpICoqIC44KSwgZy5wcmV2UG9zaXRpb25YIHx8IChnLnByZXZQb3NpdGlvblggPSBmLnRvdWNoZXNDdXJyZW50LngpLCBnLnByZXZQb3NpdGlvblkgfHwgKGcucHJldlBvc2l0aW9uWSA9IGYudG91Y2hlc0N1cnJlbnQueSksIGcucHJldlRpbWUgfHwgKGcucHJldlRpbWUgPSBEYXRlLm5vdygpKSwgZy54ID0gKGYudG91Y2hlc0N1cnJlbnQueCAtIGcucHJldlBvc2l0aW9uWCkgLyAoRGF0ZS5ub3coKSAtIGcucHJldlRpbWUpIC8gMiwgZy55ID0gKGYudG91Y2hlc0N1cnJlbnQueSAtIGcucHJldlBvc2l0aW9uWSkgLyAoRGF0ZS5ub3coKSAtIGcucHJldlRpbWUpIC8gMiwgTWF0aC5hYnMoZi50b3VjaGVzQ3VycmVudC54IC0gZy5wcmV2UG9zaXRpb25YKSA8IDIgJiYgKGcueCA9IDApLCBNYXRoLmFicyhmLnRvdWNoZXNDdXJyZW50LnkgLSBnLnByZXZQb3NpdGlvblkpIDwgMiAmJiAoZy55ID0gMCksIGcucHJldlBvc2l0aW9uWCA9IGYudG91Y2hlc0N1cnJlbnQueCwgZy5wcmV2UG9zaXRpb25ZID0gZi50b3VjaGVzQ3VycmVudC55LCBnLnByZXZUaW1lID0gRGF0ZS5ub3coKSwgbS4kaW1hZ2VXcmFwRWwudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke2YuY3VycmVudFh9cHgsICR7Zi5jdXJyZW50WX1weCwwKWApXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIEMoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0Lnpvb207XHJcbiAgICAgICAgICAgIG0uJHNsaWRlRWwgJiYgdC5wcmV2aW91c0luZGV4ICE9PSB0LmFjdGl2ZUluZGV4ICYmIChtLiRpbWFnZUVsICYmIG0uJGltYWdlRWwudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlKDEpXCIpLCBtLiRpbWFnZVdyYXBFbCAmJiBtLiRpbWFnZVdyYXBFbC50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZCgwLDAsMClcIiksIGUuc2NhbGUgPSAxLCBwID0gMSwgbS4kc2xpZGVFbCA9IHZvaWQgMCwgbS4kaW1hZ2VFbCA9IHZvaWQgMCwgbS4kaW1hZ2VXcmFwRWwgPSB2b2lkIDApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBUKGUpIHtcclxuICAgICAgICAgICAgY29uc3QgcyA9IHQuem9vbSwgYSA9IHQucGFyYW1zLnpvb207XHJcbiAgICAgICAgICAgIGlmIChtLiRzbGlkZUVsIHx8IChlICYmIGUudGFyZ2V0ICYmIChtLiRzbGlkZUVsID0gZChlLnRhcmdldCkuY2xvc2VzdChgLiR7dC5wYXJhbXMuc2xpZGVDbGFzc31gKSksIG0uJHNsaWRlRWwgfHwgKHQucGFyYW1zLnZpcnR1YWwgJiYgdC5wYXJhbXMudmlydHVhbC5lbmFibGVkICYmIHQudmlydHVhbCA/IG0uJHNsaWRlRWwgPSB0LiR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3QucGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3N9YCkgOiBtLiRzbGlkZUVsID0gdC5zbGlkZXMuZXEodC5hY3RpdmVJbmRleCkpLCBtLiRpbWFnZUVsID0gbS4kc2xpZGVFbC5maW5kKGAuJHthLmNvbnRhaW5lckNsYXNzfWApLmVxKDApLmZpbmQoXCJwaWN0dXJlLCBpbWcsIHN2ZywgY2FudmFzLCAuc3dpcGVyLXpvb20tdGFyZ2V0XCIpLmVxKDApLCBtLiRpbWFnZVdyYXBFbCA9IG0uJGltYWdlRWwucGFyZW50KGAuJHthLmNvbnRhaW5lckNsYXNzfWApKSwgIW0uJGltYWdlRWwgfHwgMCA9PT0gbS4kaW1hZ2VFbC5sZW5ndGggfHwgIW0uJGltYWdlV3JhcEVsIHx8IDAgPT09IG0uJGltYWdlV3JhcEVsLmxlbmd0aCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBsZXQgaSwgciwgbCwgbywgYywgdSwgaCwgZywgdiwgdywgYiwgeCwgeSwgRSwgQywgVCwgJCwgUztcclxuICAgICAgICAgICAgdC5wYXJhbXMuY3NzTW9kZSAmJiAodC53cmFwcGVyRWwuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiLCB0LndyYXBwZXJFbC5zdHlsZS50b3VjaEFjdGlvbiA9IFwibm9uZVwiKSwgbS4kc2xpZGVFbC5hZGRDbGFzcyhgJHthLnpvb21lZFNsaWRlQ2xhc3N9YCksIHZvaWQgMCA9PT0gZi50b3VjaGVzU3RhcnQueCAmJiBlID8gKGkgPSBcInRvdWNoZW5kXCIgPT09IGUudHlwZSA/IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggOiBlLnBhZ2VYLCByID0gXCJ0b3VjaGVuZFwiID09PSBlLnR5cGUgPyBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZIDogZS5wYWdlWSkgOiAoaSA9IGYudG91Y2hlc1N0YXJ0LngsIHIgPSBmLnRvdWNoZXNTdGFydC55KSwgcy5zY2FsZSA9IG0uJGltYWdlV3JhcEVsLmF0dHIoXCJkYXRhLXN3aXBlci16b29tXCIpIHx8IGEubWF4UmF0aW8sIHAgPSBtLiRpbWFnZVdyYXBFbC5hdHRyKFwiZGF0YS1zd2lwZXItem9vbVwiKSB8fCBhLm1heFJhdGlvLCBlID8gKCQgPSBtLiRzbGlkZUVsWzBdLm9mZnNldFdpZHRoLCBTID0gbS4kc2xpZGVFbFswXS5vZmZzZXRIZWlnaHQsIGwgPSBtLiRzbGlkZUVsLm9mZnNldCgpLmxlZnQgKyBuLnNjcm9sbFgsIG8gPSBtLiRzbGlkZUVsLm9mZnNldCgpLnRvcCArIG4uc2Nyb2xsWSwgYyA9IGwgKyAkIC8gMiAtIGksIHUgPSBvICsgUyAvIDIgLSByLCB2ID0gbS4kaW1hZ2VFbFswXS5vZmZzZXRXaWR0aCwgdyA9IG0uJGltYWdlRWxbMF0ub2Zmc2V0SGVpZ2h0LCBiID0gdiAqIHMuc2NhbGUsIHggPSB3ICogcy5zY2FsZSwgeSA9IE1hdGgubWluKCQgLyAyIC0gYiAvIDIsIDApLCBFID0gTWF0aC5taW4oUyAvIDIgLSB4IC8gMiwgMCksIEMgPSAteSwgVCA9IC1FLCBoID0gYyAqIHMuc2NhbGUsIGcgPSB1ICogcy5zY2FsZSwgaCA8IHkgJiYgKGggPSB5KSwgaCA+IEMgJiYgKGggPSBDKSwgZyA8IEUgJiYgKGcgPSBFKSwgZyA+IFQgJiYgKGcgPSBUKSkgOiAoaCA9IDAsIGcgPSAwKSwgbS4kaW1hZ2VXcmFwRWwudHJhbnNpdGlvbigzMDApLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtofXB4LCAke2d9cHgsMClgKSwgbS4kaW1hZ2VFbC50cmFuc2l0aW9uKDMwMCkudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGUoJHtzLnNjYWxlfSlgKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gJCgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHQuem9vbSwgcyA9IHQucGFyYW1zLnpvb207XHJcbiAgICAgICAgICAgIG0uJHNsaWRlRWwgfHwgKHQucGFyYW1zLnZpcnR1YWwgJiYgdC5wYXJhbXMudmlydHVhbC5lbmFibGVkICYmIHQudmlydHVhbCA/IG0uJHNsaWRlRWwgPSB0LiR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3QucGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3N9YCkgOiBtLiRzbGlkZUVsID0gdC5zbGlkZXMuZXEodC5hY3RpdmVJbmRleCksIG0uJGltYWdlRWwgPSBtLiRzbGlkZUVsLmZpbmQoYC4ke3MuY29udGFpbmVyQ2xhc3N9YCkuZXEoMCkuZmluZChcInBpY3R1cmUsIGltZywgc3ZnLCBjYW52YXMsIC5zd2lwZXItem9vbS10YXJnZXRcIikuZXEoMCksIG0uJGltYWdlV3JhcEVsID0gbS4kaW1hZ2VFbC5wYXJlbnQoYC4ke3MuY29udGFpbmVyQ2xhc3N9YCkpLCBtLiRpbWFnZUVsICYmIDAgIT09IG0uJGltYWdlRWwubGVuZ3RoICYmIG0uJGltYWdlV3JhcEVsICYmIDAgIT09IG0uJGltYWdlV3JhcEVsLmxlbmd0aCAmJiAodC5wYXJhbXMuY3NzTW9kZSAmJiAodC53cmFwcGVyRWwuc3R5bGUub3ZlcmZsb3cgPSBcIlwiLCB0LndyYXBwZXJFbC5zdHlsZS50b3VjaEFjdGlvbiA9IFwiXCIpLCBlLnNjYWxlID0gMSwgcCA9IDEsIG0uJGltYWdlV3JhcEVsLnRyYW5zaXRpb24oMzAwKS50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZCgwLDAsMClcIiksIG0uJGltYWdlRWwudHJhbnNpdGlvbigzMDApLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZSgxKVwiKSwgbS4kc2xpZGVFbC5yZW1vdmVDbGFzcyhgJHtzLnpvb21lZFNsaWRlQ2xhc3N9YCksIG0uJHNsaWRlRWwgPSB2b2lkIDApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBTKGUpIHtcclxuICAgICAgICAgICAgY29uc3QgcyA9IHQuem9vbTtcclxuICAgICAgICAgICAgcy5zY2FsZSAmJiAxICE9PSBzLnNjYWxlID8gJCgpIDogVChlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gTSgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHQuc3VwcG9ydDtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHBhc3NpdmVMaXN0ZW5lcjogIShcInRvdWNoc3RhcnRcIiAhPT0gdC50b3VjaEV2ZW50cy5zdGFydCB8fCAhZS5wYXNzaXZlTGlzdGVuZXIgfHwgIXQucGFyYW1zLnBhc3NpdmVMaXN0ZW5lcnMpICYmIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXNzaXZlOiAhMCxcclxuICAgICAgICAgICAgICAgICAgICBjYXB0dXJlOiAhMVxyXG4gICAgICAgICAgICAgICAgfSwgYWN0aXZlTGlzdGVuZXJXaXRoQ2FwdHVyZTogIWUucGFzc2l2ZUxpc3RlbmVyIHx8IHtwYXNzaXZlOiAhMSwgY2FwdHVyZTogITB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIFAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgLiR7dC5wYXJhbXMuc2xpZGVDbGFzc31gXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBrKGUpIHtcclxuICAgICAgICAgICAgY29uc3Qge3Bhc3NpdmVMaXN0ZW5lcjogc30gPSBNKCksIGEgPSBQKCk7XHJcbiAgICAgICAgICAgIHQuJHdyYXBwZXJFbFtlXShcImdlc3R1cmVzdGFydFwiLCBhLCBiLCBzKSwgdC4kd3JhcHBlckVsW2VdKFwiZ2VzdHVyZWNoYW5nZVwiLCBhLCB4LCBzKSwgdC4kd3JhcHBlckVsW2VdKFwiZ2VzdHVyZWVuZFwiLCBhLCB5LCBzKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24geigpIHtcclxuICAgICAgICAgICAgbCB8fCAobCA9ICEwLCBrKFwib25cIikpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBMKCkge1xyXG4gICAgICAgICAgICBsICYmIChsID0gITEsIGsoXCJvZmZcIikpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBPKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdC56b29tO1xyXG4gICAgICAgICAgICBpZiAoZS5lbmFibGVkKSByZXR1cm47XHJcbiAgICAgICAgICAgIGUuZW5hYmxlZCA9ICEwO1xyXG4gICAgICAgICAgICBjb25zdCBzID0gdC5zdXBwb3J0LCB7cGFzc2l2ZUxpc3RlbmVyOiBhLCBhY3RpdmVMaXN0ZW5lcldpdGhDYXB0dXJlOiBpfSA9IE0oKSwgciA9IFAoKTtcclxuICAgICAgICAgICAgcy5nZXN0dXJlcyA/ICh0LiR3cmFwcGVyRWwub24odC50b3VjaEV2ZW50cy5zdGFydCwgeiwgYSksIHQuJHdyYXBwZXJFbC5vbih0LnRvdWNoRXZlbnRzLmVuZCwgTCwgYSkpIDogXCJ0b3VjaHN0YXJ0XCIgPT09IHQudG91Y2hFdmVudHMuc3RhcnQgJiYgKHQuJHdyYXBwZXJFbC5vbih0LnRvdWNoRXZlbnRzLnN0YXJ0LCByLCBiLCBhKSwgdC4kd3JhcHBlckVsLm9uKHQudG91Y2hFdmVudHMubW92ZSwgciwgeCwgaSksIHQuJHdyYXBwZXJFbC5vbih0LnRvdWNoRXZlbnRzLmVuZCwgciwgeSwgYSksIHQudG91Y2hFdmVudHMuY2FuY2VsICYmIHQuJHdyYXBwZXJFbC5vbih0LnRvdWNoRXZlbnRzLmNhbmNlbCwgciwgeSwgYSkpLCB0LiR3cmFwcGVyRWwub24odC50b3VjaEV2ZW50cy5tb3ZlLCBgLiR7dC5wYXJhbXMuem9vbS5jb250YWluZXJDbGFzc31gLCBFLCBpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gSSgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHQuem9vbTtcclxuICAgICAgICAgICAgaWYgKCFlLmVuYWJsZWQpIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgcyA9IHQuc3VwcG9ydDtcclxuICAgICAgICAgICAgZS5lbmFibGVkID0gITE7XHJcbiAgICAgICAgICAgIGNvbnN0IHtwYXNzaXZlTGlzdGVuZXI6IGEsIGFjdGl2ZUxpc3RlbmVyV2l0aENhcHR1cmU6IGl9ID0gTSgpLCByID0gUCgpO1xyXG4gICAgICAgICAgICBzLmdlc3R1cmVzID8gKHQuJHdyYXBwZXJFbC5vZmYodC50b3VjaEV2ZW50cy5zdGFydCwgeiwgYSksIHQuJHdyYXBwZXJFbC5vZmYodC50b3VjaEV2ZW50cy5lbmQsIEwsIGEpKSA6IFwidG91Y2hzdGFydFwiID09PSB0LnRvdWNoRXZlbnRzLnN0YXJ0ICYmICh0LiR3cmFwcGVyRWwub2ZmKHQudG91Y2hFdmVudHMuc3RhcnQsIHIsIGIsIGEpLCB0LiR3cmFwcGVyRWwub2ZmKHQudG91Y2hFdmVudHMubW92ZSwgciwgeCwgaSksIHQuJHdyYXBwZXJFbC5vZmYodC50b3VjaEV2ZW50cy5lbmQsIHIsIHksIGEpLCB0LnRvdWNoRXZlbnRzLmNhbmNlbCAmJiB0LiR3cmFwcGVyRWwub2ZmKHQudG91Y2hFdmVudHMuY2FuY2VsLCByLCB5LCBhKSksIHQuJHdyYXBwZXJFbC5vZmYodC50b3VjaEV2ZW50cy5tb3ZlLCBgLiR7dC5wYXJhbXMuem9vbS5jb250YWluZXJDbGFzc31gLCBFLCBpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuem9vbSwgXCJzY2FsZVwiLCB7XHJcbiAgICAgICAgICAgIGdldDogKCkgPT4gdiwgc2V0KGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2ICE9PSBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IG0uJGltYWdlRWwgPyBtLiRpbWFnZUVsWzBdIDogdm9pZCAwLCBzID0gbS4kc2xpZGVFbCA/IG0uJHNsaWRlRWxbMF0gOiB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaShcInpvb21DaGFuZ2VcIiwgZSwgdCwgcylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHYgPSBlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSwgYShcImluaXRcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC5wYXJhbXMuem9vbS5lbmFibGVkICYmIE8oKVxyXG4gICAgICAgIH0pKSwgYShcImRlc3Ryb3lcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgSSgpXHJcbiAgICAgICAgfSkpLCBhKFwidG91Y2hTdGFydFwiLCAoKGUsIHMpID0+IHtcclxuICAgICAgICAgICAgdC56b29tLmVuYWJsZWQgJiYgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSB0LmRldmljZTtcclxuICAgICAgICAgICAgICAgIG0uJGltYWdlRWwgJiYgMCAhPT0gbS4kaW1hZ2VFbC5sZW5ndGggJiYgKGYuaXNUb3VjaGVkIHx8IChzLmFuZHJvaWQgJiYgZS5jYW5jZWxhYmxlICYmIGUucHJldmVudERlZmF1bHQoKSwgZi5pc1RvdWNoZWQgPSAhMCwgZi50b3VjaGVzU3RhcnQueCA9IFwidG91Y2hzdGFydFwiID09PSBlLnR5cGUgPyBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVggOiBlLnBhZ2VYLCBmLnRvdWNoZXNTdGFydC55ID0gXCJ0b3VjaHN0YXJ0XCIgPT09IGUudHlwZSA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSA6IGUucGFnZVkpKVxyXG4gICAgICAgICAgICB9KHMpXHJcbiAgICAgICAgfSkpLCBhKFwidG91Y2hFbmRcIiwgKChlLCBzKSA9PiB7XHJcbiAgICAgICAgICAgIHQuem9vbS5lbmFibGVkICYmIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSB0Lnpvb207XHJcbiAgICAgICAgICAgICAgICBpZiAoIW0uJGltYWdlRWwgfHwgMCA9PT0gbS4kaW1hZ2VFbC5sZW5ndGgpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGlmICghZi5pc1RvdWNoZWQgfHwgIWYuaXNNb3ZlZCkgcmV0dXJuIGYuaXNUb3VjaGVkID0gITEsIHZvaWQgKGYuaXNNb3ZlZCA9ICExKTtcclxuICAgICAgICAgICAgICAgIGYuaXNUb3VjaGVkID0gITEsIGYuaXNNb3ZlZCA9ICExO1xyXG4gICAgICAgICAgICAgICAgbGV0IHMgPSAzMDAsIGEgPSAzMDA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gZy54ICogcywgciA9IGYuY3VycmVudFggKyBpLCBuID0gZy55ICogYSwgbCA9IGYuY3VycmVudFkgKyBuO1xyXG4gICAgICAgICAgICAgICAgMCAhPT0gZy54ICYmIChzID0gTWF0aC5hYnMoKHIgLSBmLmN1cnJlbnRYKSAvIGcueCkpLCAwICE9PSBnLnkgJiYgKGEgPSBNYXRoLmFicygobCAtIGYuY3VycmVudFkpIC8gZy55KSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvID0gTWF0aC5tYXgocywgYSk7XHJcbiAgICAgICAgICAgICAgICBmLmN1cnJlbnRYID0gciwgZi5jdXJyZW50WSA9IGw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkID0gZi53aWR0aCAqIGUuc2NhbGUsIGMgPSBmLmhlaWdodCAqIGUuc2NhbGU7XHJcbiAgICAgICAgICAgICAgICBmLm1pblggPSBNYXRoLm1pbihtLnNsaWRlV2lkdGggLyAyIC0gZCAvIDIsIDApLCBmLm1heFggPSAtZi5taW5YLCBmLm1pblkgPSBNYXRoLm1pbihtLnNsaWRlSGVpZ2h0IC8gMiAtIGMgLyAyLCAwKSwgZi5tYXhZID0gLWYubWluWSwgZi5jdXJyZW50WCA9IE1hdGgubWF4KE1hdGgubWluKGYuY3VycmVudFgsIGYubWF4WCksIGYubWluWCksIGYuY3VycmVudFkgPSBNYXRoLm1heChNYXRoLm1pbihmLmN1cnJlbnRZLCBmLm1heFkpLCBmLm1pblkpLCBtLiRpbWFnZVdyYXBFbC50cmFuc2l0aW9uKG8pLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtmLmN1cnJlbnRYfXB4LCAke2YuY3VycmVudFl9cHgsMClgKVxyXG4gICAgICAgICAgICB9KClcclxuICAgICAgICB9KSksIGEoXCJkb3VibGVUYXBcIiwgKChlLCBzKSA9PiB7XHJcbiAgICAgICAgICAgICF0LmFuaW1hdGluZyAmJiB0LnBhcmFtcy56b29tLmVuYWJsZWQgJiYgdC56b29tLmVuYWJsZWQgJiYgdC5wYXJhbXMuem9vbS50b2dnbGUgJiYgUyhzKVxyXG4gICAgICAgIH0pKSwgYShcInRyYW5zaXRpb25FbmRcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC56b29tLmVuYWJsZWQgJiYgdC5wYXJhbXMuem9vbS5lbmFibGVkICYmIEMoKVxyXG4gICAgICAgIH0pKSwgYShcInNsaWRlQ2hhbmdlXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHQuem9vbS5lbmFibGVkICYmIHQucGFyYW1zLnpvb20uZW5hYmxlZCAmJiB0LnBhcmFtcy5jc3NNb2RlICYmIEMoKVxyXG4gICAgICAgIH0pKSwgT2JqZWN0LmFzc2lnbih0Lnpvb20sIHtlbmFibGU6IE8sIGRpc2FibGU6IEksIGluOiBULCBvdXQ6ICQsIHRvZ2dsZTogU30pXHJcbiAgICB9LCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGxldCB7c3dpcGVyOiB0LCBleHRlbmRQYXJhbXM6IHMsIG9uOiBhLCBlbWl0OiBpfSA9IGU7XHJcbiAgICAgICAgcyh7XHJcbiAgICAgICAgICAgIGxhenk6IHtcclxuICAgICAgICAgICAgICAgIGNoZWNrSW5WaWV3OiAhMSxcclxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6ICExLFxyXG4gICAgICAgICAgICAgICAgbG9hZFByZXZOZXh0OiAhMSxcclxuICAgICAgICAgICAgICAgIGxvYWRQcmV2TmV4dEFtb3VudDogMSxcclxuICAgICAgICAgICAgICAgIGxvYWRPblRyYW5zaXRpb25TdGFydDogITEsXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxpbmdFbGVtZW50OiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgZWxlbWVudENsYXNzOiBcInN3aXBlci1sYXp5XCIsXHJcbiAgICAgICAgICAgICAgICBsb2FkaW5nQ2xhc3M6IFwic3dpcGVyLWxhenktbG9hZGluZ1wiLFxyXG4gICAgICAgICAgICAgICAgbG9hZGVkQ2xhc3M6IFwic3dpcGVyLWxhenktbG9hZGVkXCIsXHJcbiAgICAgICAgICAgICAgICBwcmVsb2FkZXJDbGFzczogXCJzd2lwZXItbGF6eS1wcmVsb2FkZXJcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksIHQubGF6eSA9IHt9O1xyXG4gICAgICAgIGxldCBuID0gITEsIGwgPSAhMTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbyhlLCBzKSB7XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gcyAmJiAocyA9ICEwKTtcclxuICAgICAgICAgICAgY29uc3QgYSA9IHQucGFyYW1zLmxhenk7XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGUpIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKDAgPT09IHQuc2xpZGVzLmxlbmd0aCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCByID0gdC52aXJ0dWFsICYmIHQucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCA/IHQuJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7dC5wYXJhbXMuc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2V9XCJdYCkgOiB0LnNsaWRlcy5lcShlKSxcclxuICAgICAgICAgICAgICAgIG4gPSByLmZpbmQoYC4ke2EuZWxlbWVudENsYXNzfTpub3QoLiR7YS5sb2FkZWRDbGFzc30pOm5vdCguJHthLmxvYWRpbmdDbGFzc30pYCk7XHJcbiAgICAgICAgICAgICFyLmhhc0NsYXNzKGEuZWxlbWVudENsYXNzKSB8fCByLmhhc0NsYXNzKGEubG9hZGVkQ2xhc3MpIHx8IHIuaGFzQ2xhc3MoYS5sb2FkaW5nQ2xhc3MpIHx8IG4ucHVzaChyWzBdKSwgMCAhPT0gbi5sZW5ndGggJiYgbi5lYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBkKGUpO1xyXG4gICAgICAgICAgICAgICAgbi5hZGRDbGFzcyhhLmxvYWRpbmdDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsID0gbi5hdHRyKFwiZGF0YS1iYWNrZ3JvdW5kXCIpLCBjID0gbi5hdHRyKFwiZGF0YS1zcmNcIiksIHAgPSBuLmF0dHIoXCJkYXRhLXNyY3NldFwiKSxcclxuICAgICAgICAgICAgICAgICAgICB1ID0gbi5hdHRyKFwiZGF0YS1zaXplc1wiKSwgaCA9IG4ucGFyZW50KFwicGljdHVyZVwiKTtcclxuICAgICAgICAgICAgICAgIHQubG9hZEltYWdlKG5bMF0sIGMgfHwgbCwgcCwgdSwgITEsICgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gdCAmJiB0ICYmICghdCB8fCB0LnBhcmFtcykgJiYgIXQuZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsID8gKG4uY3NzKFwiYmFja2dyb3VuZC1pbWFnZVwiLCBgdXJsKFwiJHtsfVwiKWApLCBuLnJlbW92ZUF0dHIoXCJkYXRhLWJhY2tncm91bmRcIikpIDogKHAgJiYgKG4uYXR0cihcInNyY3NldFwiLCBwKSwgbi5yZW1vdmVBdHRyKFwiZGF0YS1zcmNzZXRcIikpLCB1ICYmIChuLmF0dHIoXCJzaXplc1wiLCB1KSwgbi5yZW1vdmVBdHRyKFwiZGF0YS1zaXplc1wiKSksIGgubGVuZ3RoICYmIGguY2hpbGRyZW4oXCJzb3VyY2VcIikuZWFjaCgoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gZChlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuYXR0cihcImRhdGEtc3Jjc2V0XCIpICYmICh0LmF0dHIoXCJzcmNzZXRcIiwgdC5hdHRyKFwiZGF0YS1zcmNzZXRcIikpLCB0LnJlbW92ZUF0dHIoXCJkYXRhLXNyY3NldFwiKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpLCBjICYmIChuLmF0dHIoXCJzcmNcIiwgYyksIG4ucmVtb3ZlQXR0cihcImRhdGEtc3JjXCIpKSksIG4uYWRkQ2xhc3MoYS5sb2FkZWRDbGFzcykucmVtb3ZlQ2xhc3MoYS5sb2FkaW5nQ2xhc3MpLCByLmZpbmQoYC4ke2EucHJlbG9hZGVyQ2xhc3N9YCkucmVtb3ZlKCksIHQucGFyYW1zLmxvb3AgJiYgcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IHIuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIuaGFzQ2xhc3ModC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvKHQuJHdyYXBwZXJFbC5jaGlsZHJlbihgW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtlfVwiXTpub3QoLiR7dC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzc30pYCkuaW5kZXgoKSwgITEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8odC4kd3JhcHBlckVsLmNoaWxkcmVuKGAuJHt0LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzfVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7ZX1cIl1gKS5pbmRleCgpLCAhMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpKFwibGF6eUltYWdlUmVhZHlcIiwgclswXSwgblswXSksIHQucGFyYW1zLmF1dG9IZWlnaHQgJiYgdC51cGRhdGVBdXRvSGVpZ2h0KClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KSksIGkoXCJsYXp5SW1hZ2VMb2FkXCIsIHJbMF0sIG5bMF0pXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYygpIHtcclxuICAgICAgICAgICAgY29uc3QgeyR3cmFwcGVyRWw6IGUsIHBhcmFtczogcywgc2xpZGVzOiBhLCBhY3RpdmVJbmRleDogaX0gPSB0LCByID0gdC52aXJ0dWFsICYmIHMudmlydHVhbC5lbmFibGVkLFxyXG4gICAgICAgICAgICAgICAgbiA9IHMubGF6eTtcclxuICAgICAgICAgICAgbGV0IGMgPSBzLnNsaWRlc1BlclZpZXc7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBwKHQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuY2hpbGRyZW4oYC4ke3Muc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3R9XCJdYCkubGVuZ3RoKSByZXR1cm4gITBcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYVt0XSkgcmV0dXJuICEwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICExXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHUoZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIgPyBkKGUpLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSA6IGQoZSkuaW5kZXgoKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoXCJhdXRvXCIgPT09IGMgJiYgKGMgPSAwKSwgbCB8fCAobCA9ICEwKSwgdC5wYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcykgZS5jaGlsZHJlbihgLiR7cy5zbGlkZVZpc2libGVDbGFzc31gKS5lYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgIG8ociA/IGQoZSkuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpIDogZChlKS5pbmRleCgpKVxyXG4gICAgICAgICAgICB9KSk7IGVsc2UgaWYgKGMgPiAxKSBmb3IgKGxldCBlID0gaTsgZSA8IGkgKyBjOyBlICs9IDEpIHAoZSkgJiYgbyhlKTsgZWxzZSBvKGkpO1xyXG4gICAgICAgICAgICBpZiAobi5sb2FkUHJldk5leHQpIGlmIChjID4gMSB8fCBuLmxvYWRQcmV2TmV4dEFtb3VudCAmJiBuLmxvYWRQcmV2TmV4dEFtb3VudCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBuLmxvYWRQcmV2TmV4dEFtb3VudCwgdCA9IE1hdGguY2VpbChjKSwgcyA9IE1hdGgubWluKGkgKyB0ICsgTWF0aC5tYXgoZSwgdCksIGEubGVuZ3RoKSxcclxuICAgICAgICAgICAgICAgICAgICByID0gTWF0aC5tYXgoaSAtIE1hdGgubWF4KHQsIGUpLCAwKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGUgPSBpICsgdDsgZSA8IHM7IGUgKz0gMSkgcChlKSAmJiBvKGUpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZSA9IHI7IGUgPCBpOyBlICs9IDEpIHAoZSkgJiYgbyhlKVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IGUuY2hpbGRyZW4oYC4ke3Muc2xpZGVOZXh0Q2xhc3N9YCk7XHJcbiAgICAgICAgICAgICAgICB0Lmxlbmd0aCA+IDAgJiYgbyh1KHQpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBlLmNoaWxkcmVuKGAuJHtzLnNsaWRlUHJldkNsYXNzfWApO1xyXG4gICAgICAgICAgICAgICAgYS5sZW5ndGggPiAwICYmIG8odShhKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcCgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHIoKTtcclxuICAgICAgICAgICAgaWYgKCF0IHx8IHQuZGVzdHJveWVkKSByZXR1cm47XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0LnBhcmFtcy5sYXp5LnNjcm9sbGluZ0VsZW1lbnQgPyBkKHQucGFyYW1zLmxhenkuc2Nyb2xsaW5nRWxlbWVudCkgOiBkKGUpLCBhID0gc1swXSA9PT0gZSxcclxuICAgICAgICAgICAgICAgIGkgPSBhID8gZS5pbm5lcldpZHRoIDogc1swXS5vZmZzZXRXaWR0aCwgbCA9IGEgPyBlLmlubmVySGVpZ2h0IDogc1swXS5vZmZzZXRIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBvID0gdC4kZWwub2Zmc2V0KCksIHtydGxUcmFuc2xhdGU6IHV9ID0gdDtcclxuICAgICAgICAgICAgbGV0IGggPSAhMTtcclxuICAgICAgICAgICAgdSAmJiAoby5sZWZ0IC09IHQuJGVsWzBdLnNjcm9sbExlZnQpO1xyXG4gICAgICAgICAgICBjb25zdCBtID0gW1tvLmxlZnQsIG8udG9wXSwgW28ubGVmdCArIHQud2lkdGgsIG8udG9wXSwgW28ubGVmdCwgby50b3AgKyB0LmhlaWdodF0sIFtvLmxlZnQgKyB0LndpZHRoLCBvLnRvcCArIHQuaGVpZ2h0XV07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgbS5sZW5ndGg7IGUgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IG1bZV07XHJcbiAgICAgICAgICAgICAgICBpZiAodFswXSA+PSAwICYmIHRbMF0gPD0gaSAmJiB0WzFdID49IDAgJiYgdFsxXSA8PSBsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IHRbMF0gJiYgMCA9PT0gdFsxXSkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaCA9ICEwXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZiA9ICEoXCJ0b3VjaHN0YXJ0XCIgIT09IHQudG91Y2hFdmVudHMuc3RhcnQgfHwgIXQuc3VwcG9ydC5wYXNzaXZlTGlzdGVuZXIgfHwgIXQucGFyYW1zLnBhc3NpdmVMaXN0ZW5lcnMpICYmIHtcclxuICAgICAgICAgICAgICAgIHBhc3NpdmU6ICEwLFxyXG4gICAgICAgICAgICAgICAgY2FwdHVyZTogITFcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaCA/IChjKCksIHMub2ZmKFwic2Nyb2xsXCIsIHAsIGYpKSA6IG4gfHwgKG4gPSAhMCwgcy5vbihcInNjcm9sbFwiLCBwLCBmKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGEoXCJiZWZvcmVJbml0XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHQucGFyYW1zLmxhenkuZW5hYmxlZCAmJiB0LnBhcmFtcy5wcmVsb2FkSW1hZ2VzICYmICh0LnBhcmFtcy5wcmVsb2FkSW1hZ2VzID0gITEpXHJcbiAgICAgICAgfSkpLCBhKFwiaW5pdFwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICB0LnBhcmFtcy5sYXp5LmVuYWJsZWQgJiYgKHQucGFyYW1zLmxhenkuY2hlY2tJblZpZXcgPyBwKCkgOiBjKCkpXHJcbiAgICAgICAgfSkpLCBhKFwic2Nyb2xsXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHQucGFyYW1zLmZyZWVNb2RlICYmIHQucGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQgJiYgIXQucGFyYW1zLmZyZWVNb2RlLnN0aWNreSAmJiBjKClcclxuICAgICAgICB9KSksIGEoXCJzY3JvbGxiYXJEcmFnTW92ZSByZXNpemUgX2ZyZWVNb2RlTm9Nb21lbnR1bVJlbGVhc2VcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC5wYXJhbXMubGF6eS5lbmFibGVkICYmICh0LnBhcmFtcy5sYXp5LmNoZWNrSW5WaWV3ID8gcCgpIDogYygpKVxyXG4gICAgICAgIH0pKSwgYShcInRyYW5zaXRpb25TdGFydFwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICB0LnBhcmFtcy5sYXp5LmVuYWJsZWQgJiYgKHQucGFyYW1zLmxhenkubG9hZE9uVHJhbnNpdGlvblN0YXJ0IHx8ICF0LnBhcmFtcy5sYXp5LmxvYWRPblRyYW5zaXRpb25TdGFydCAmJiAhbCkgJiYgKHQucGFyYW1zLmxhenkuY2hlY2tJblZpZXcgPyBwKCkgOiBjKCkpXHJcbiAgICAgICAgfSkpLCBhKFwidHJhbnNpdGlvbkVuZFwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICB0LnBhcmFtcy5sYXp5LmVuYWJsZWQgJiYgIXQucGFyYW1zLmxhenkubG9hZE9uVHJhbnNpdGlvblN0YXJ0ICYmICh0LnBhcmFtcy5sYXp5LmNoZWNrSW5WaWV3ID8gcCgpIDogYygpKVxyXG4gICAgICAgIH0pKSwgYShcInNsaWRlQ2hhbmdlXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHtsYXp5OiBlLCBjc3NNb2RlOiBzLCB3YXRjaFNsaWRlc1Byb2dyZXNzOiBhLCB0b3VjaFJlbGVhc2VPbkVkZ2VzOiBpLCByZXNpc3RhbmNlUmF0aW86IHJ9ID0gdC5wYXJhbXM7XHJcbiAgICAgICAgICAgIGUuZW5hYmxlZCAmJiAocyB8fCBhICYmIChpIHx8IDAgPT09IHIpKSAmJiBjKClcclxuICAgICAgICB9KSksIGEoXCJkZXN0cm95XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHQuJGVsICYmIHQuJGVsLmZpbmQoYC4ke3QucGFyYW1zLmxhenkubG9hZGluZ0NsYXNzfWApLnJlbW92ZUNsYXNzKHQucGFyYW1zLmxhenkubG9hZGluZ0NsYXNzKVxyXG4gICAgICAgIH0pKSwgT2JqZWN0LmFzc2lnbih0LmxhenksIHtsb2FkOiBjLCBsb2FkSW5TbGlkZTogb30pXHJcbiAgICB9LCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGxldCB7c3dpcGVyOiB0LCBleHRlbmRQYXJhbXM6IHMsIG9uOiBhfSA9IGU7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGkoZSwgdCkge1xyXG4gICAgICAgICAgICBjb25zdCBzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGUsIHQsIHM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGEsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHQgPSAtMSwgZSA9IGEubGVuZ3RoOyBlIC0gdCA+IDE7KSBzID0gZSArIHQgPj4gMSwgYVtzXSA8PSBpID8gdCA9IHMgOiBlID0gcztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KCk7XHJcbiAgICAgICAgICAgIGxldCBhLCBpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ID0gZSwgdGhpcy55ID0gdCwgdGhpcy5sYXN0SW5kZXggPSBlLmxlbmd0aCAtIDEsIHRoaXMuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUgPyAoaSA9IHModGhpcy54LCBlKSwgYSA9IGkgLSAxLCAoZSAtIHRoaXMueFthXSkgKiAodGhpcy55W2ldIC0gdGhpcy55W2FdKSAvICh0aGlzLnhbaV0gLSB0aGlzLnhbYV0pICsgdGhpcy55W2FdKSA6IDBcclxuICAgICAgICAgICAgfSwgdGhpc1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcigpIHtcclxuICAgICAgICAgICAgdC5jb250cm9sbGVyLmNvbnRyb2wgJiYgdC5jb250cm9sbGVyLnNwbGluZSAmJiAodC5jb250cm9sbGVyLnNwbGluZSA9IHZvaWQgMCwgZGVsZXRlIHQuY29udHJvbGxlci5zcGxpbmUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzKHtcclxuICAgICAgICAgICAgY29udHJvbGxlcjoge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbDogdm9pZCAwLFxyXG4gICAgICAgICAgICAgICAgaW52ZXJzZTogITEsXHJcbiAgICAgICAgICAgICAgICBieTogXCJzbGlkZVwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSwgdC5jb250cm9sbGVyID0ge2NvbnRyb2w6IHZvaWQgMH0sIGEoXCJiZWZvcmVJbml0XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHQuY29udHJvbGxlci5jb250cm9sID0gdC5wYXJhbXMuY29udHJvbGxlci5jb250cm9sXHJcbiAgICAgICAgfSkpLCBhKFwidXBkYXRlXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHIoKVxyXG4gICAgICAgIH0pKSwgYShcInJlc2l6ZVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICByKClcclxuICAgICAgICB9KSksIGEoXCJvYnNlcnZlclVwZGF0ZVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICByKClcclxuICAgICAgICB9KSksIGEoXCJzZXRUcmFuc2xhdGVcIiwgKChlLCBzLCBhKSA9PiB7XHJcbiAgICAgICAgICAgIHQuY29udHJvbGxlci5jb250cm9sICYmIHQuY29udHJvbGxlci5zZXRUcmFuc2xhdGUocywgYSlcclxuICAgICAgICB9KSksIGEoXCJzZXRUcmFuc2l0aW9uXCIsICgoZSwgcywgYSkgPT4ge1xyXG4gICAgICAgICAgICB0LmNvbnRyb2xsZXIuY29udHJvbCAmJiB0LmNvbnRyb2xsZXIuc2V0VHJhbnNpdGlvbihzLCBhKVxyXG4gICAgICAgIH0pKSwgT2JqZWN0LmFzc2lnbih0LmNvbnRyb2xsZXIsIHtcclxuICAgICAgICAgICAgc2V0VHJhbnNsYXRlOiBmdW5jdGlvbiAoZSwgcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IHQuY29udHJvbGxlci5jb250cm9sO1xyXG4gICAgICAgICAgICAgICAgbGV0IHIsIG47XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsID0gdC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBvKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gdC5ydGxUcmFuc2xhdGUgPyAtdC50cmFuc2xhdGUgOiB0LnRyYW5zbGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICBcInNsaWRlXCIgPT09IHQucGFyYW1zLmNvbnRyb2xsZXIuYnkgJiYgKCFmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0LmNvbnRyb2xsZXIuc3BsaW5lIHx8ICh0LmNvbnRyb2xsZXIuc3BsaW5lID0gdC5wYXJhbXMubG9vcCA/IG5ldyBpKHQuc2xpZGVzR3JpZCwgZS5zbGlkZXNHcmlkKSA6IG5ldyBpKHQuc25hcEdyaWQsIGUuc25hcEdyaWQpKVxyXG4gICAgICAgICAgICAgICAgICAgIH0oZSksIG4gPSAtdC5jb250cm9sbGVyLnNwbGluZS5pbnRlcnBvbGF0ZSgtcykpLCBuICYmIFwiY29udGFpbmVyXCIgIT09IHQucGFyYW1zLmNvbnRyb2xsZXIuYnkgfHwgKHIgPSAoZS5tYXhUcmFuc2xhdGUoKSAtIGUubWluVHJhbnNsYXRlKCkpIC8gKHQubWF4VHJhbnNsYXRlKCkgLSB0Lm1pblRyYW5zbGF0ZSgpKSwgbiA9IChzIC0gdC5taW5UcmFuc2xhdGUoKSkgKiByICsgZS5taW5UcmFuc2xhdGUoKSksIHQucGFyYW1zLmNvbnRyb2xsZXIuaW52ZXJzZSAmJiAobiA9IGUubWF4VHJhbnNsYXRlKCkgLSBuKSwgZS51cGRhdGVQcm9ncmVzcyhuKSwgZS5zZXRUcmFuc2xhdGUobiwgdCksIGUudXBkYXRlQWN0aXZlSW5kZXgoKSwgZS51cGRhdGVTbGlkZXNDbGFzc2VzKClcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkgZm9yIChsZXQgZSA9IDA7IGUgPCBhLmxlbmd0aDsgZSArPSAxKSBhW2VdICE9PSBzICYmIGFbZV0gaW5zdGFuY2VvZiBsICYmIG8oYVtlXSk7IGVsc2UgYSBpbnN0YW5jZW9mIGwgJiYgcyAhPT0gYSAmJiBvKGEpXHJcbiAgICAgICAgICAgIH0sIHNldFRyYW5zaXRpb246IGZ1bmN0aW9uIChlLCBzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gdC5jb25zdHJ1Y3RvciwgaSA9IHQuY29udHJvbGxlci5jb250cm9sO1xyXG4gICAgICAgICAgICAgICAgbGV0IHI7XHJcblxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbihzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcy5zZXRUcmFuc2l0aW9uKGUsIHQpLCAwICE9PSBlICYmIChzLnRyYW5zaXRpb25TdGFydCgpLCBzLnBhcmFtcy5hdXRvSGVpZ2h0ICYmIHAoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcy51cGRhdGVBdXRvSGVpZ2h0KClcclxuICAgICAgICAgICAgICAgICAgICB9KSksIHMuJHdyYXBwZXJFbC50cmFuc2l0aW9uRW5kKCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgJiYgKHMucGFyYW1zLmxvb3AgJiYgXCJzbGlkZVwiID09PSB0LnBhcmFtcy5jb250cm9sbGVyLmJ5ICYmIHMubG9vcEZpeCgpLCBzLnRyYW5zaXRpb25FbmQoKSlcclxuICAgICAgICAgICAgICAgICAgICB9KSkpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaSkpIGZvciAociA9IDA7IHIgPCBpLmxlbmd0aDsgciArPSAxKSBpW3JdICE9PSBzICYmIGlbcl0gaW5zdGFuY2VvZiBhICYmIG4oaVtyXSk7IGVsc2UgaSBpbnN0YW5jZW9mIGEgJiYgcyAhPT0gaSAmJiBuKGkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBsZXQge3N3aXBlcjogdCwgZXh0ZW5kUGFyYW1zOiBzLCBvbjogYX0gPSBlO1xyXG4gICAgICAgIHMoe1xyXG4gICAgICAgICAgICBhMTF5OiB7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiAhMCxcclxuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkNsYXNzOiBcInN3aXBlci1ub3RpZmljYXRpb25cIixcclxuICAgICAgICAgICAgICAgIHByZXZTbGlkZU1lc3NhZ2U6IFwiUHJldmlvdXMgc2xpZGVcIixcclxuICAgICAgICAgICAgICAgIG5leHRTbGlkZU1lc3NhZ2U6IFwiTmV4dCBzbGlkZVwiLFxyXG4gICAgICAgICAgICAgICAgZmlyc3RTbGlkZU1lc3NhZ2U6IFwiVGhpcyBpcyB0aGUgZmlyc3Qgc2xpZGVcIixcclxuICAgICAgICAgICAgICAgIGxhc3RTbGlkZU1lc3NhZ2U6IFwiVGhpcyBpcyB0aGUgbGFzdCBzbGlkZVwiLFxyXG4gICAgICAgICAgICAgICAgcGFnaW5hdGlvbkJ1bGxldE1lc3NhZ2U6IFwiR28gdG8gc2xpZGUge3tpbmRleH19XCIsXHJcbiAgICAgICAgICAgICAgICBzbGlkZUxhYmVsTWVzc2FnZTogXCJ7e2luZGV4fX0gLyB7e3NsaWRlc0xlbmd0aH19XCIsXHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJNZXNzYWdlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyUm9sZURlc2NyaXB0aW9uTWVzc2FnZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIGl0ZW1Sb2xlRGVzY3JpcHRpb25NZXNzYWdlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgc2xpZGVSb2xlOiBcImdyb3VwXCIsXHJcbiAgICAgICAgICAgICAgICBpZDogbnVsbFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksIHQuYTExeSA9IHtjbGlja2VkOiAhMX07XHJcbiAgICAgICAgbGV0IGkgPSBudWxsO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByKGUpIHtcclxuICAgICAgICAgICAgY29uc3QgdCA9IGk7XHJcbiAgICAgICAgICAgIDAgIT09IHQubGVuZ3RoICYmICh0Lmh0bWwoXCJcIiksIHQuaHRtbChlKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG4oZSkge1xyXG4gICAgICAgICAgICBlLmF0dHIoXCJ0YWJJbmRleFwiLCBcIjBcIilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGwoZSkge1xyXG4gICAgICAgICAgICBlLmF0dHIoXCJ0YWJJbmRleFwiLCBcIi0xXCIpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBvKGUsIHQpIHtcclxuICAgICAgICAgICAgZS5hdHRyKFwicm9sZVwiLCB0KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYyhlLCB0KSB7XHJcbiAgICAgICAgICAgIGUuYXR0cihcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCIsIHQpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBwKGUsIHQpIHtcclxuICAgICAgICAgICAgZS5hdHRyKFwiYXJpYS1sYWJlbFwiLCB0KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdShlKSB7XHJcbiAgICAgICAgICAgIGUuYXR0cihcImFyaWEtZGlzYWJsZWRcIiwgITApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBoKGUpIHtcclxuICAgICAgICAgICAgZS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLCAhMSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG0oZSkge1xyXG4gICAgICAgICAgICBpZiAoMTMgIT09IGUua2V5Q29kZSAmJiAzMiAhPT0gZS5rZXlDb2RlKSByZXR1cm47XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0LnBhcmFtcy5hMTF5LCBhID0gZChlLnRhcmdldCk7XHJcbiAgICAgICAgICAgIHQubmF2aWdhdGlvbiAmJiB0Lm5hdmlnYXRpb24uJG5leHRFbCAmJiBhLmlzKHQubmF2aWdhdGlvbi4kbmV4dEVsKSAmJiAodC5pc0VuZCAmJiAhdC5wYXJhbXMubG9vcCB8fCB0LnNsaWRlTmV4dCgpLCB0LmlzRW5kID8gcihzLmxhc3RTbGlkZU1lc3NhZ2UpIDogcihzLm5leHRTbGlkZU1lc3NhZ2UpKSwgdC5uYXZpZ2F0aW9uICYmIHQubmF2aWdhdGlvbi4kcHJldkVsICYmIGEuaXModC5uYXZpZ2F0aW9uLiRwcmV2RWwpICYmICh0LmlzQmVnaW5uaW5nICYmICF0LnBhcmFtcy5sb29wIHx8IHQuc2xpZGVQcmV2KCksIHQuaXNCZWdpbm5pbmcgPyByKHMuZmlyc3RTbGlkZU1lc3NhZ2UpIDogcihzLnByZXZTbGlkZU1lc3NhZ2UpKSwgdC5wYWdpbmF0aW9uICYmIGEuaXMoVSh0LnBhcmFtcy5wYWdpbmF0aW9uLmJ1bGxldENsYXNzKSkgJiYgYVswXS5jbGljaygpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBmKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdC5wYWdpbmF0aW9uICYmIHQucGFnaW5hdGlvbi5idWxsZXRzICYmIHQucGFnaW5hdGlvbi5idWxsZXRzLmxlbmd0aFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGYoKSAmJiB0LnBhcmFtcy5wYWdpbmF0aW9uLmNsaWNrYWJsZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdiA9IChlLCB0LCBzKSA9PiB7XHJcbiAgICAgICAgICAgIG4oZSksIFwiQlVUVE9OXCIgIT09IGVbMF0udGFnTmFtZSAmJiAobyhlLCBcImJ1dHRvblwiKSwgZS5vbihcImtleWRvd25cIiwgbSkpLCBwKGUsIHMpLCBmdW5jdGlvbiAoZSwgdCkge1xyXG4gICAgICAgICAgICAgICAgZS5hdHRyKFwiYXJpYS1jb250cm9sc1wiLCB0KVxyXG4gICAgICAgICAgICB9KGUsIHQpXHJcbiAgICAgICAgfSwgdyA9ICgpID0+IHtcclxuICAgICAgICAgICAgdC5hMTF5LmNsaWNrZWQgPSAhMFxyXG4gICAgICAgIH0sIGIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdC5kZXN0cm95ZWQgfHwgKHQuYTExeS5jbGlja2VkID0gITEpXHJcbiAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgfSwgeCA9IGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAodC5hMTF5LmNsaWNrZWQpIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgcyA9IGUudGFyZ2V0LmNsb3Nlc3QoYC4ke3QucGFyYW1zLnNsaWRlQ2xhc3N9YCk7XHJcbiAgICAgICAgICAgIGlmICghcyB8fCAhdC5zbGlkZXMuaW5jbHVkZXMocykpIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgYSA9IHQuc2xpZGVzLmluZGV4T2YocykgPT09IHQuYWN0aXZlSW5kZXgsXHJcbiAgICAgICAgICAgICAgICBpID0gdC5wYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcyAmJiB0LnZpc2libGVTbGlkZXMgJiYgdC52aXNpYmxlU2xpZGVzLmluY2x1ZGVzKHMpO1xyXG4gICAgICAgICAgICBhIHx8IGkgfHwgZS5zb3VyY2VDYXBhYmlsaXRpZXMgJiYgZS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cyB8fCAodC5pc0hvcml6b250YWwoKSA/IHQuZWwuc2Nyb2xsTGVmdCA9IDAgOiB0LmVsLnNjcm9sbFRvcCA9IDAsIHQuc2xpZGVUbyh0LnNsaWRlcy5pbmRleE9mKHMpLCAwKSlcclxuICAgICAgICB9LCB5ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdC5wYXJhbXMuYTExeTtcclxuICAgICAgICAgICAgZS5pdGVtUm9sZURlc2NyaXB0aW9uTWVzc2FnZSAmJiBjKGQodC5zbGlkZXMpLCBlLml0ZW1Sb2xlRGVzY3JpcHRpb25NZXNzYWdlKSwgZS5zbGlkZVJvbGUgJiYgbyhkKHQuc2xpZGVzKSwgZS5zbGlkZVJvbGUpO1xyXG4gICAgICAgICAgICBjb25zdCBzID0gdC5wYXJhbXMubG9vcCA/IHQuc2xpZGVzLmZpbHRlcigoZSA9PiAhZS5jbGFzc0xpc3QuY29udGFpbnModC5wYXJhbXMuc2xpZGVEdXBsaWNhdGVDbGFzcykpKS5sZW5ndGggOiB0LnNsaWRlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGUuc2xpZGVMYWJlbE1lc3NhZ2UgJiYgdC5zbGlkZXMuZWFjaCgoKGEsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBkKGEpLCBuID0gdC5wYXJhbXMubG9vcCA/IHBhcnNlSW50KHIuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpLCAxMCkgOiBpO1xyXG4gICAgICAgICAgICAgICAgcChyLCBlLnNsaWRlTGFiZWxNZXNzYWdlLnJlcGxhY2UoL1xce1xce2luZGV4XFx9XFx9LywgbiArIDEpLnJlcGxhY2UoL1xce1xce3NsaWRlc0xlbmd0aFxcfVxcfS8sIHMpKVxyXG4gICAgICAgICAgICB9KSlcclxuICAgICAgICB9LCBFID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdC5wYXJhbXMuYTExeTtcclxuICAgICAgICAgICAgdC4kZWwuYXBwZW5kKGkpO1xyXG4gICAgICAgICAgICBjb25zdCBzID0gdC4kZWw7XHJcbiAgICAgICAgICAgIGUuY29udGFpbmVyUm9sZURlc2NyaXB0aW9uTWVzc2FnZSAmJiBjKHMsIGUuY29udGFpbmVyUm9sZURlc2NyaXB0aW9uTWVzc2FnZSksIGUuY29udGFpbmVyTWVzc2FnZSAmJiBwKHMsIGUuY29udGFpbmVyTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSB0LiR3cmFwcGVyRWwsXHJcbiAgICAgICAgICAgICAgICByID0gZS5pZCB8fCBhLmF0dHIoXCJpZFwiKSB8fCBgc3dpcGVyLXdyYXBwZXItJHtuID0gMTYsIHZvaWQgMCA9PT0gbiAmJiAobiA9IDE2KSwgXCJ4XCIucmVwZWF0KG4pLnJlcGxhY2UoL3gvZywgKCgpID0+IE1hdGgucm91bmQoMTYgKiBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygxNikpKX1gO1xyXG4gICAgICAgICAgICB2YXIgbjtcclxuICAgICAgICAgICAgY29uc3QgbCA9IHQucGFyYW1zLmF1dG9wbGF5ICYmIHQucGFyYW1zLmF1dG9wbGF5LmVuYWJsZWQgPyBcIm9mZlwiIDogXCJwb2xpdGVcIjtcclxuICAgICAgICAgICAgdmFyIG87XHJcbiAgICAgICAgICAgIGxldCBkLCB1O1xyXG4gICAgICAgICAgICBvID0gciwgYS5hdHRyKFwiaWRcIiwgbyksIGZ1bmN0aW9uIChlLCB0KSB7XHJcbiAgICAgICAgICAgICAgICBlLmF0dHIoXCJhcmlhLWxpdmVcIiwgdClcclxuICAgICAgICAgICAgfShhLCBsKSwgeSgpLCB0Lm5hdmlnYXRpb24gJiYgdC5uYXZpZ2F0aW9uLiRuZXh0RWwgJiYgKGQgPSB0Lm5hdmlnYXRpb24uJG5leHRFbCksIHQubmF2aWdhdGlvbiAmJiB0Lm5hdmlnYXRpb24uJHByZXZFbCAmJiAodSA9IHQubmF2aWdhdGlvbi4kcHJldkVsKSwgZCAmJiBkLmxlbmd0aCAmJiB2KGQsIHIsIGUubmV4dFNsaWRlTWVzc2FnZSksIHUgJiYgdS5sZW5ndGggJiYgdih1LCByLCBlLnByZXZTbGlkZU1lc3NhZ2UpLCBnKCkgJiYgdC5wYWdpbmF0aW9uLiRlbC5vbihcImtleWRvd25cIiwgVSh0LnBhcmFtcy5wYWdpbmF0aW9uLmJ1bGxldENsYXNzKSwgbSksIHQuJGVsLm9uKFwiZm9jdXNcIiwgeCwgITApLCB0LiRlbC5vbihcInBvaW50ZXJkb3duXCIsIHcsICEwKSwgdC4kZWwub24oXCJwb2ludGVydXBcIiwgYiwgITApXHJcbiAgICAgICAgfTtcclxuICAgICAgICBhKFwiYmVmb3JlSW5pdFwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBpID0gZChgPHNwYW4gY2xhc3M9XCIke3QucGFyYW1zLmExMXkubm90aWZpY2F0aW9uQ2xhc3N9XCIgYXJpYS1saXZlPVwiYXNzZXJ0aXZlXCIgYXJpYS1hdG9taWM9XCJ0cnVlXCI+PC9zcGFuPmApXHJcbiAgICAgICAgfSkpLCBhKFwiYWZ0ZXJJbml0XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHQucGFyYW1zLmExMXkuZW5hYmxlZCAmJiBFKClcclxuICAgICAgICB9KSksIGEoXCJzbGlkZXNMZW5ndGhDaGFuZ2Ugc25hcEdyaWRMZW5ndGhDaGFuZ2Ugc2xpZGVzR3JpZExlbmd0aENoYW5nZVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICB0LnBhcmFtcy5hMTF5LmVuYWJsZWQgJiYgeSgpXHJcbiAgICAgICAgfSkpLCBhKFwiZnJvbUVkZ2UgdG9FZGdlIGFmdGVySW5pdCBsb2NrIHVubG9ja1wiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICB0LnBhcmFtcy5hMTF5LmVuYWJsZWQgJiYgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHQucGFyYW1zLmxvb3AgfHwgdC5wYXJhbXMucmV3aW5kIHx8ICF0Lm5hdmlnYXRpb24pIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHskbmV4dEVsOiBlLCAkcHJldkVsOiBzfSA9IHQubmF2aWdhdGlvbjtcclxuICAgICAgICAgICAgICAgIHMgJiYgcy5sZW5ndGggPiAwICYmICh0LmlzQmVnaW5uaW5nID8gKHUocyksIGwocykpIDogKGgocyksIG4ocykpKSwgZSAmJiBlLmxlbmd0aCA+IDAgJiYgKHQuaXNFbmQgPyAodShlKSwgbChlKSkgOiAoaChlKSwgbihlKSkpXHJcbiAgICAgICAgICAgIH0oKVxyXG4gICAgICAgIH0pKSwgYShcInBhZ2luYXRpb25VcGRhdGVcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC5wYXJhbXMuYTExeS5lbmFibGVkICYmIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSB0LnBhcmFtcy5hMTF5O1xyXG4gICAgICAgICAgICAgICAgZigpICYmIHQucGFnaW5hdGlvbi5idWxsZXRzLmVhY2goKHMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBkKHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHQucGFyYW1zLnBhZ2luYXRpb24uY2xpY2thYmxlICYmIChuKGEpLCB0LnBhcmFtcy5wYWdpbmF0aW9uLnJlbmRlckJ1bGxldCB8fCAobyhhLCBcImJ1dHRvblwiKSwgcChhLCBlLnBhZ2luYXRpb25CdWxsZXRNZXNzYWdlLnJlcGxhY2UoL1xce1xce2luZGV4XFx9XFx9LywgYS5pbmRleCgpICsgMSkpKSksIGEuaXMoYC4ke3QucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0QWN0aXZlQ2xhc3N9YCkgPyBhLmF0dHIoXCJhcmlhLWN1cnJlbnRcIiwgXCJ0cnVlXCIpIDogYS5yZW1vdmVBdHRyKFwiYXJpYS1jdXJyZW50XCIpXHJcbiAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgfSgpXHJcbiAgICAgICAgfSkpLCBhKFwiZGVzdHJveVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICB0LnBhcmFtcy5hMTF5LmVuYWJsZWQgJiYgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGUsIHM7XHJcbiAgICAgICAgICAgICAgICBpICYmIGkubGVuZ3RoID4gMCAmJiBpLnJlbW92ZSgpLCB0Lm5hdmlnYXRpb24gJiYgdC5uYXZpZ2F0aW9uLiRuZXh0RWwgJiYgKGUgPSB0Lm5hdmlnYXRpb24uJG5leHRFbCksIHQubmF2aWdhdGlvbiAmJiB0Lm5hdmlnYXRpb24uJHByZXZFbCAmJiAocyA9IHQubmF2aWdhdGlvbi4kcHJldkVsKSwgZSAmJiBlLm9mZihcImtleWRvd25cIiwgbSksIHMgJiYgcy5vZmYoXCJrZXlkb3duXCIsIG0pLCBnKCkgJiYgdC5wYWdpbmF0aW9uLiRlbC5vZmYoXCJrZXlkb3duXCIsIFUodC5wYXJhbXMucGFnaW5hdGlvbi5idWxsZXRDbGFzcyksIG0pLCB0LiRlbC5vZmYoXCJmb2N1c1wiLCB4LCAhMCksIHQuJGVsLm9mZihcInBvaW50ZXJkb3duXCIsIHcsICEwKSwgdC4kZWwub2ZmKFwicG9pbnRlcnVwXCIsIGIsICEwKVxyXG4gICAgICAgICAgICB9KClcclxuICAgICAgICB9KSlcclxuICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgbGV0IHtzd2lwZXI6IHQsIGV4dGVuZFBhcmFtczogcywgb246IGF9ID0gZTtcclxuICAgICAgICBzKHtoaXN0b3J5OiB7ZW5hYmxlZDogITEsIHJvb3Q6IFwiXCIsIHJlcGxhY2VTdGF0ZTogITEsIGtleTogXCJzbGlkZXNcIiwga2VlcFF1ZXJ5OiAhMX19KTtcclxuICAgICAgICBsZXQgaSA9ICExLCBuID0ge307XHJcbiAgICAgICAgY29uc3QgbCA9IGUgPT4gZS50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgXCItXCIpLnJlcGxhY2UoL1teXFx3LV0rL2csIFwiXCIpLnJlcGxhY2UoLy0tKy9nLCBcIi1cIikucmVwbGFjZSgvXi0rLywgXCJcIikucmVwbGFjZSgvLSskLywgXCJcIiksXHJcbiAgICAgICAgICAgIG8gPSBlID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSByKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcztcclxuICAgICAgICAgICAgICAgIHMgPSBlID8gbmV3IFVSTChlKSA6IHQubG9jYXRpb247XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gcy5wYXRobmFtZS5zbGljZSgxKS5zcGxpdChcIi9cIikuZmlsdGVyKChlID0+IFwiXCIgIT09IGUpKSwgaSA9IGEubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtrZXk6IGFbaSAtIDJdLCB2YWx1ZTogYVtpIC0gMV19XHJcbiAgICAgICAgICAgIH0sIGQgPSAoZSwgcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IHIoKTtcclxuICAgICAgICAgICAgICAgIGlmICghaSB8fCAhdC5wYXJhbXMuaGlzdG9yeS5lbmFibGVkKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBsZXQgbjtcclxuICAgICAgICAgICAgICAgIG4gPSB0LnBhcmFtcy51cmwgPyBuZXcgVVJMKHQucGFyYW1zLnVybCkgOiBhLmxvY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbyA9IHQuc2xpZGVzLmVxKHMpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGQgPSBsKG8uYXR0cihcImRhdGEtaGlzdG9yeVwiKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodC5wYXJhbXMuaGlzdG9yeS5yb290Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IHQucGFyYW1zLmhpc3Rvcnkucm9vdDtcclxuICAgICAgICAgICAgICAgICAgICBcIi9cIiA9PT0gc1tzLmxlbmd0aCAtIDFdICYmIChzID0gcy5zbGljZSgwLCBzLmxlbmd0aCAtIDEpKSwgZCA9IGAke3N9LyR7ZX0vJHtkfWBcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBuLnBhdGhuYW1lLmluY2x1ZGVzKGUpIHx8IChkID0gYCR7ZX0vJHtkfWApO1xyXG4gICAgICAgICAgICAgICAgdC5wYXJhbXMuaGlzdG9yeS5rZWVwUXVlcnkgJiYgKGQgKz0gbi5zZWFyY2gpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGEuaGlzdG9yeS5zdGF0ZTtcclxuICAgICAgICAgICAgICAgIGMgJiYgYy52YWx1ZSA9PT0gZCB8fCAodC5wYXJhbXMuaGlzdG9yeS5yZXBsYWNlU3RhdGUgPyBhLmhpc3RvcnkucmVwbGFjZVN0YXRlKHt2YWx1ZTogZH0sIG51bGwsIGQpIDogYS5oaXN0b3J5LnB1c2hTdGF0ZSh7dmFsdWU6IGR9LCBudWxsLCBkKSlcclxuICAgICAgICAgICAgfSwgYyA9IChlLCBzLCBhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocykgZm9yIChsZXQgaSA9IDAsIHIgPSB0LnNsaWRlcy5sZW5ndGg7IGkgPCByOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gdC5zbGlkZXMuZXEoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwoci5hdHRyKFwiZGF0YS1oaXN0b3J5XCIpKSA9PT0gcyAmJiAhci5oYXNDbGFzcyh0LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gci5pbmRleCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0LnNsaWRlVG8ocywgZSwgYSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgdC5zbGlkZVRvKDAsIGUsIGEpXHJcbiAgICAgICAgICAgIH0sIHAgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBuID0gbyh0LnBhcmFtcy51cmwpLCBjKHQucGFyYW1zLnNwZWVkLCBuLnZhbHVlLCAhMSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBhKFwiaW5pdFwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICB0LnBhcmFtcy5oaXN0b3J5LmVuYWJsZWQgJiYgKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSByKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodC5wYXJhbXMuaGlzdG9yeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZS5oaXN0b3J5IHx8ICFlLmhpc3RvcnkucHVzaFN0YXRlKSByZXR1cm4gdC5wYXJhbXMuaGlzdG9yeS5lbmFibGVkID0gITEsIHZvaWQgKHQucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWQgPSAhMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaSA9ICEwLCBuID0gbyh0LnBhcmFtcy51cmwpLCAobi5rZXkgfHwgbi52YWx1ZSkgJiYgKGMoMCwgbi52YWx1ZSwgdC5wYXJhbXMucnVuQ2FsbGJhY2tzT25Jbml0KSwgdC5wYXJhbXMuaGlzdG9yeS5yZXBsYWNlU3RhdGUgfHwgZS5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgcCkpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKClcclxuICAgICAgICB9KSksIGEoXCJkZXN0cm95XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHQucGFyYW1zLmhpc3RvcnkuZW5hYmxlZCAmJiAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHIoKTtcclxuICAgICAgICAgICAgICAgIHQucGFyYW1zLmhpc3RvcnkucmVwbGFjZVN0YXRlIHx8IGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHApXHJcbiAgICAgICAgICAgIH0pKClcclxuICAgICAgICB9KSksIGEoXCJ0cmFuc2l0aW9uRW5kIF9mcmVlTW9kZU5vTW9tZW50dW1SZWxlYXNlXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGkgJiYgZCh0LnBhcmFtcy5oaXN0b3J5LmtleSwgdC5hY3RpdmVJbmRleClcclxuICAgICAgICB9KSksIGEoXCJzbGlkZUNoYW5nZVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBpICYmIHQucGFyYW1zLmNzc01vZGUgJiYgZCh0LnBhcmFtcy5oaXN0b3J5LmtleSwgdC5hY3RpdmVJbmRleClcclxuICAgICAgICB9KSlcclxuICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgbGV0IHtzd2lwZXI6IHQsIGV4dGVuZFBhcmFtczogcywgZW1pdDogaSwgb246IG59ID0gZSwgbCA9ICExO1xyXG4gICAgICAgIGNvbnN0IG8gPSBhKCksIGMgPSByKCk7XHJcbiAgICAgICAgcyh7aGFzaE5hdmlnYXRpb246IHtlbmFibGVkOiAhMSwgcmVwbGFjZVN0YXRlOiAhMSwgd2F0Y2hTdGF0ZTogITF9fSk7XHJcbiAgICAgICAgY29uc3QgcCA9ICgpID0+IHtcclxuICAgICAgICAgICAgaShcImhhc2hDaGFuZ2VcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSBvLmxvY2F0aW9uLmhhc2gucmVwbGFjZShcIiNcIiwgXCJcIik7XHJcbiAgICAgICAgICAgIGlmIChlICE9PSB0LnNsaWRlcy5lcSh0LmFjdGl2ZUluZGV4KS5hdHRyKFwiZGF0YS1oYXNoXCIpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gdC4kd3JhcHBlckVsLmNoaWxkcmVuKGAuJHt0LnBhcmFtcy5zbGlkZUNsYXNzfVtkYXRhLWhhc2g9XCIke2V9XCJdYCkuaW5kZXgoKTtcclxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHMpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHQuc2xpZGVUbyhzKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgdSA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGwgJiYgdC5wYXJhbXMuaGFzaE5hdmlnYXRpb24uZW5hYmxlZCkgaWYgKHQucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLnJlcGxhY2VTdGF0ZSAmJiBjLmhpc3RvcnkgJiYgYy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSkgYy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShudWxsLCBudWxsLCBgIyR7dC5zbGlkZXMuZXEodC5hY3RpdmVJbmRleCkuYXR0cihcImRhdGEtaGFzaFwiKX1gIHx8IFwiXCIpLCBpKFwiaGFzaFNldFwiKTsgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gdC5zbGlkZXMuZXEodC5hY3RpdmVJbmRleCksIHMgPSBlLmF0dHIoXCJkYXRhLWhhc2hcIikgfHwgZS5hdHRyKFwiZGF0YS1oaXN0b3J5XCIpO1xyXG4gICAgICAgICAgICAgICAgby5sb2NhdGlvbi5oYXNoID0gcyB8fCBcIlwiLCBpKFwiaGFzaFNldFwiKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBuKFwiaW5pdFwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICB0LnBhcmFtcy5oYXNoTmF2aWdhdGlvbi5lbmFibGVkICYmICgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXQucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWQgfHwgdC5wYXJhbXMuaGlzdG9yeSAmJiB0LnBhcmFtcy5oaXN0b3J5LmVuYWJsZWQpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGwgPSAhMDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBvLmxvY2F0aW9uLmhhc2gucmVwbGFjZShcIiNcIiwgXCJcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGEgPSAwLCBpID0gdC5zbGlkZXMubGVuZ3RoOyBhIDwgaTsgYSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGkgPSB0LnNsaWRlcy5lcShhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChpLmF0dHIoXCJkYXRhLWhhc2hcIikgfHwgaS5hdHRyKFwiZGF0YS1oaXN0b3J5XCIpKSA9PT0gZSAmJiAhaS5oYXNDbGFzcyh0LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGkuaW5kZXgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuc2xpZGVUbyhlLCBzLCB0LnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQsICEwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdC5wYXJhbXMuaGFzaE5hdmlnYXRpb24ud2F0Y2hTdGF0ZSAmJiBkKGMpLm9uKFwiaGFzaGNoYW5nZVwiLCBwKVxyXG4gICAgICAgICAgICB9KSgpXHJcbiAgICAgICAgfSkpLCBuKFwiZGVzdHJveVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICB0LnBhcmFtcy5oYXNoTmF2aWdhdGlvbi5lbmFibGVkICYmIHQucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLndhdGNoU3RhdGUgJiYgZChjKS5vZmYoXCJoYXNoY2hhbmdlXCIsIHApXHJcbiAgICAgICAgfSkpLCBuKFwidHJhbnNpdGlvbkVuZCBfZnJlZU1vZGVOb01vbWVudHVtUmVsZWFzZVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBsICYmIHUoKVxyXG4gICAgICAgIH0pKSwgbihcInNsaWRlQ2hhbmdlXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGwgJiYgdC5wYXJhbXMuY3NzTW9kZSAmJiB1KClcclxuICAgICAgICB9KSlcclxuICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgbGV0IHQsIHtzd2lwZXI6IHMsIGV4dGVuZFBhcmFtczogaSwgb246IHIsIGVtaXQ6IG59ID0gZTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbCgpIHtcclxuICAgICAgICAgICAgaWYgKCFzLnNpemUpIHJldHVybiBzLmF1dG9wbGF5LnJ1bm5pbmcgPSAhMSwgdm9pZCAocy5hdXRvcGxheS5wYXVzZWQgPSAhMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSBzLnNsaWRlcy5lcShzLmFjdGl2ZUluZGV4KTtcclxuICAgICAgICAgICAgbGV0IGEgPSBzLnBhcmFtcy5hdXRvcGxheS5kZWxheTtcclxuICAgICAgICAgICAgZS5hdHRyKFwiZGF0YS1zd2lwZXItYXV0b3BsYXlcIikgJiYgKGEgPSBlLmF0dHIoXCJkYXRhLXN3aXBlci1hdXRvcGxheVwiKSB8fCBzLnBhcmFtcy5hdXRvcGxheS5kZWxheSksIGNsZWFyVGltZW91dCh0KSwgdCA9IHAoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBlO1xyXG4gICAgICAgICAgICAgICAgcy5wYXJhbXMuYXV0b3BsYXkucmV2ZXJzZURpcmVjdGlvbiA/IHMucGFyYW1zLmxvb3AgPyAocy5sb29wRml4KCksIGUgPSBzLnNsaWRlUHJldihzLnBhcmFtcy5zcGVlZCwgITAsICEwKSwgbihcImF1dG9wbGF5XCIpKSA6IHMuaXNCZWdpbm5pbmcgPyBzLnBhcmFtcy5hdXRvcGxheS5zdG9wT25MYXN0U2xpZGUgPyBkKCkgOiAoZSA9IHMuc2xpZGVUbyhzLnNsaWRlcy5sZW5ndGggLSAxLCBzLnBhcmFtcy5zcGVlZCwgITAsICEwKSwgbihcImF1dG9wbGF5XCIpKSA6IChlID0gcy5zbGlkZVByZXYocy5wYXJhbXMuc3BlZWQsICEwLCAhMCksIG4oXCJhdXRvcGxheVwiKSkgOiBzLnBhcmFtcy5sb29wID8gKHMubG9vcEZpeCgpLCBlID0gcy5zbGlkZU5leHQocy5wYXJhbXMuc3BlZWQsICEwLCAhMCksIG4oXCJhdXRvcGxheVwiKSkgOiBzLmlzRW5kID8gcy5wYXJhbXMuYXV0b3BsYXkuc3RvcE9uTGFzdFNsaWRlID8gZCgpIDogKGUgPSBzLnNsaWRlVG8oMCwgcy5wYXJhbXMuc3BlZWQsICEwLCAhMCksIG4oXCJhdXRvcGxheVwiKSkgOiAoZSA9IHMuc2xpZGVOZXh0KHMucGFyYW1zLnNwZWVkLCAhMCwgITApLCBuKFwiYXV0b3BsYXlcIikpLCAocy5wYXJhbXMuY3NzTW9kZSAmJiBzLmF1dG9wbGF5LnJ1bm5pbmcgfHwgITEgPT09IGUpICYmIGwoKVxyXG4gICAgICAgICAgICB9KSwgYSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG8oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IHQgJiYgKCFzLmF1dG9wbGF5LnJ1bm5pbmcgJiYgKHMuYXV0b3BsYXkucnVubmluZyA9ICEwLCBuKFwiYXV0b3BsYXlTdGFydFwiKSwgbCgpLCAhMCkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBkKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gISFzLmF1dG9wbGF5LnJ1bm5pbmcgJiYgKHZvaWQgMCAhPT0gdCAmJiAodCAmJiAoY2xlYXJUaW1lb3V0KHQpLCB0ID0gdm9pZCAwKSwgcy5hdXRvcGxheS5ydW5uaW5nID0gITEsIG4oXCJhdXRvcGxheVN0b3BcIiksICEwKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGMoZSkge1xyXG4gICAgICAgICAgICBzLmF1dG9wbGF5LnJ1bm5pbmcgJiYgKHMuYXV0b3BsYXkucGF1c2VkIHx8ICh0ICYmIGNsZWFyVGltZW91dCh0KSwgcy5hdXRvcGxheS5wYXVzZWQgPSAhMCwgMCAhPT0gZSAmJiBzLnBhcmFtcy5hdXRvcGxheS53YWl0Rm9yVHJhbnNpdGlvbiA/IFtcInRyYW5zaXRpb25lbmRcIiwgXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCJdLmZvckVhY2goKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgcy4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoZSwgaClcclxuICAgICAgICAgICAgfSkpIDogKHMuYXV0b3BsYXkucGF1c2VkID0gITEsIGwoKSkpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdSgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IGEoKTtcclxuICAgICAgICAgICAgXCJoaWRkZW5cIiA9PT0gZS52aXNpYmlsaXR5U3RhdGUgJiYgcy5hdXRvcGxheS5ydW5uaW5nICYmIGMoKSwgXCJ2aXNpYmxlXCIgPT09IGUudmlzaWJpbGl0eVN0YXRlICYmIHMuYXV0b3BsYXkucGF1c2VkICYmIChsKCksIHMuYXV0b3BsYXkucGF1c2VkID0gITEpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBoKGUpIHtcclxuICAgICAgICAgICAgcyAmJiAhcy5kZXN0cm95ZWQgJiYgcy4kd3JhcHBlckVsICYmIGUudGFyZ2V0ID09PSBzLiR3cmFwcGVyRWxbMF0gJiYgKFtcInRyYW5zaXRpb25lbmRcIiwgXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCJdLmZvckVhY2goKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgcy4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgaClcclxuICAgICAgICAgICAgfSkpLCBzLmF1dG9wbGF5LnBhdXNlZCA9ICExLCBzLmF1dG9wbGF5LnJ1bm5pbmcgPyBsKCkgOiBkKCkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBtKCkge1xyXG4gICAgICAgICAgICBzLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbiA/IGQoKSA6IChuKFwiYXV0b3BsYXlQYXVzZVwiKSwgYygpKSwgW1widHJhbnNpdGlvbmVuZFwiLCBcIndlYmtpdFRyYW5zaXRpb25FbmRcIl0uZm9yRWFjaCgoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCBoKVxyXG4gICAgICAgICAgICB9KSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGYoKSB7XHJcbiAgICAgICAgICAgIHMucGFyYW1zLmF1dG9wbGF5LmRpc2FibGVPbkludGVyYWN0aW9uIHx8IChzLmF1dG9wbGF5LnBhdXNlZCA9ICExLCBuKFwiYXV0b3BsYXlSZXN1bWVcIiksIGwoKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHMuYXV0b3BsYXkgPSB7cnVubmluZzogITEsIHBhdXNlZDogITF9LCBpKHtcclxuICAgICAgICAgICAgYXV0b3BsYXk6IHtcclxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6ICExLFxyXG4gICAgICAgICAgICAgICAgZGVsYXk6IDNlMyxcclxuICAgICAgICAgICAgICAgIHdhaXRGb3JUcmFuc2l0aW9uOiAhMCxcclxuICAgICAgICAgICAgICAgIGRpc2FibGVPbkludGVyYWN0aW9uOiAhMCxcclxuICAgICAgICAgICAgICAgIHN0b3BPbkxhc3RTbGlkZTogITEsXHJcbiAgICAgICAgICAgICAgICByZXZlcnNlRGlyZWN0aW9uOiAhMSxcclxuICAgICAgICAgICAgICAgIHBhdXNlT25Nb3VzZUVudGVyOiAhMVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksIHIoXCJpbml0XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzLnBhcmFtcy5hdXRvcGxheS5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBvKCk7XHJcbiAgICAgICAgICAgICAgICBhKCkuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgdSksIHMucGFyYW1zLmF1dG9wbGF5LnBhdXNlT25Nb3VzZUVudGVyICYmIChzLiRlbC5vbihcIm1vdXNlZW50ZXJcIiwgbSksIHMuJGVsLm9uKFwibW91c2VsZWF2ZVwiLCBmKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKSwgcihcImJlZm9yZVRyYW5zaXRpb25TdGFydFwiLCAoKGUsIHQsIGEpID0+IHtcclxuICAgICAgICAgICAgcy5hdXRvcGxheS5ydW5uaW5nICYmIChhIHx8ICFzLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbiA/IHMuYXV0b3BsYXkucGF1c2UodCkgOiBkKCkpXHJcbiAgICAgICAgfSkpLCByKFwic2xpZGVyRmlyc3RNb3ZlXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHMuYXV0b3BsYXkucnVubmluZyAmJiAocy5wYXJhbXMuYXV0b3BsYXkuZGlzYWJsZU9uSW50ZXJhY3Rpb24gPyBkKCkgOiBjKCkpXHJcbiAgICAgICAgfSkpLCByKFwidG91Y2hFbmRcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgcy5wYXJhbXMuY3NzTW9kZSAmJiBzLmF1dG9wbGF5LnBhdXNlZCAmJiAhcy5wYXJhbXMuYXV0b3BsYXkuZGlzYWJsZU9uSW50ZXJhY3Rpb24gJiYgbCgpXHJcbiAgICAgICAgfSkpLCByKFwiZGVzdHJveVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBzLiRlbC5vZmYoXCJtb3VzZWVudGVyXCIsIG0pLCBzLiRlbC5vZmYoXCJtb3VzZWxlYXZlXCIsIGYpLCBzLmF1dG9wbGF5LnJ1bm5pbmcgJiYgZCgpO1xyXG4gICAgICAgICAgICBhKCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgdSlcclxuICAgICAgICB9KSksIE9iamVjdC5hc3NpZ24ocy5hdXRvcGxheSwge3BhdXNlOiBjLCBydW46IGwsIHN0YXJ0OiBvLCBzdG9wOiBkfSlcclxuICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgbGV0IHtzd2lwZXI6IHQsIGV4dGVuZFBhcmFtczogcywgb246IGF9ID0gZTtcclxuICAgICAgICBzKHtcclxuICAgICAgICAgICAgdGh1bWJzOiB7XHJcbiAgICAgICAgICAgICAgICBzd2lwZXI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBtdWx0aXBsZUFjdGl2ZVRodW1iczogITAsXHJcbiAgICAgICAgICAgICAgICBhdXRvU2Nyb2xsT2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICAgICAgc2xpZGVUaHVtYkFjdGl2ZUNsYXNzOiBcInN3aXBlci1zbGlkZS10aHVtYi1hY3RpdmVcIixcclxuICAgICAgICAgICAgICAgIHRodW1ic0NvbnRhaW5lckNsYXNzOiBcInN3aXBlci10aHVtYnNcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IGkgPSAhMSwgciA9ICExO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBuKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdC50aHVtYnMuc3dpcGVyO1xyXG4gICAgICAgICAgICBpZiAoIWUgfHwgZS5kZXN0cm95ZWQpIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgcyA9IGUuY2xpY2tlZEluZGV4LCBhID0gZS5jbGlja2VkU2xpZGU7XHJcbiAgICAgICAgICAgIGlmIChhICYmIGQoYSkuaGFzQ2xhc3ModC5wYXJhbXMudGh1bWJzLnNsaWRlVGh1bWJBY3RpdmVDbGFzcykpIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKG51bGwgPT0gcykgcmV0dXJuO1xyXG4gICAgICAgICAgICBsZXQgaTtcclxuICAgICAgICAgICAgaWYgKGkgPSBlLnBhcmFtcy5sb29wID8gcGFyc2VJbnQoZChlLmNsaWNrZWRTbGlkZSkuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpLCAxMCkgOiBzLCB0LnBhcmFtcy5sb29wKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZSA9IHQuYWN0aXZlSW5kZXg7XHJcbiAgICAgICAgICAgICAgICB0LnNsaWRlcy5lcShlKS5oYXNDbGFzcyh0LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSAmJiAodC5sb29wRml4KCksIHQuX2NsaWVudExlZnQgPSB0LiR3cmFwcGVyRWxbMF0uY2xpZW50TGVmdCwgZSA9IHQuYWN0aXZlSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IHQuc2xpZGVzLmVxKGUpLnByZXZBbGwoYFtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7aX1cIl1gKS5lcSgwKS5pbmRleCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGEgPSB0LnNsaWRlcy5lcShlKS5uZXh0QWxsKGBbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2l9XCJdYCkuZXEoMCkuaW5kZXgoKTtcclxuICAgICAgICAgICAgICAgIGkgPSB2b2lkIDAgPT09IHMgPyBhIDogdm9pZCAwID09PSBhID8gcyA6IGEgLSBlIDwgZSAtIHMgPyBhIDogc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHQuc2xpZGVUbyhpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbCgpIHtcclxuICAgICAgICAgICAgY29uc3Qge3RodW1iczogZX0gPSB0LnBhcmFtcztcclxuICAgICAgICAgICAgaWYgKGkpIHJldHVybiAhMTtcclxuICAgICAgICAgICAgaSA9ICEwO1xyXG4gICAgICAgICAgICBjb25zdCBzID0gdC5jb25zdHJ1Y3RvcjtcclxuICAgICAgICAgICAgaWYgKGUuc3dpcGVyIGluc3RhbmNlb2YgcykgdC50aHVtYnMuc3dpcGVyID0gZS5zd2lwZXIsIE9iamVjdC5hc3NpZ24odC50aHVtYnMuc3dpcGVyLm9yaWdpbmFsUGFyYW1zLCB7XHJcbiAgICAgICAgICAgICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiAhMCxcclxuICAgICAgICAgICAgICAgIHNsaWRlVG9DbGlja2VkU2xpZGU6ICExXHJcbiAgICAgICAgICAgIH0pLCBPYmplY3QuYXNzaWduKHQudGh1bWJzLnN3aXBlci5wYXJhbXMsIHtcclxuICAgICAgICAgICAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6ICEwLFxyXG4gICAgICAgICAgICAgICAgc2xpZGVUb0NsaWNrZWRTbGlkZTogITFcclxuICAgICAgICAgICAgfSk7IGVsc2UgaWYgKG0oZS5zd2lwZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gT2JqZWN0LmFzc2lnbih7fSwgZS5zd2lwZXIpO1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihhLCB7d2F0Y2hTbGlkZXNQcm9ncmVzczogITAsIHNsaWRlVG9DbGlja2VkU2xpZGU6ICExfSksIHQudGh1bWJzLnN3aXBlciA9IG5ldyBzKGEpLCByID0gITBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdC50aHVtYnMuc3dpcGVyLiRlbC5hZGRDbGFzcyh0LnBhcmFtcy50aHVtYnMudGh1bWJzQ29udGFpbmVyQ2xhc3MpLCB0LnRodW1icy5zd2lwZXIub24oXCJ0YXBcIiwgbiksICEwXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBvKGUpIHtcclxuICAgICAgICAgICAgY29uc3QgcyA9IHQudGh1bWJzLnN3aXBlcjtcclxuICAgICAgICAgICAgaWYgKCFzIHx8IHMuZGVzdHJveWVkKSByZXR1cm47XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSBcImF1dG9cIiA9PT0gcy5wYXJhbXMuc2xpZGVzUGVyVmlldyA/IHMuc2xpZGVzUGVyVmlld0R5bmFtaWMoKSA6IHMucGFyYW1zLnNsaWRlc1BlclZpZXc7XHJcbiAgICAgICAgICAgIGxldCBpID0gMTtcclxuICAgICAgICAgICAgY29uc3QgciA9IHQucGFyYW1zLnRodW1icy5zbGlkZVRodW1iQWN0aXZlQ2xhc3M7XHJcbiAgICAgICAgICAgIGlmICh0LnBhcmFtcy5zbGlkZXNQZXJWaWV3ID4gMSAmJiAhdC5wYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgKGkgPSB0LnBhcmFtcy5zbGlkZXNQZXJWaWV3KSwgdC5wYXJhbXMudGh1bWJzLm11bHRpcGxlQWN0aXZlVGh1bWJzIHx8IChpID0gMSksIGkgPSBNYXRoLmZsb29yKGkpLCBzLnNsaWRlcy5yZW1vdmVDbGFzcyhyKSwgcy5wYXJhbXMubG9vcCB8fCBzLnBhcmFtcy52aXJ0dWFsICYmIHMucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkgZm9yIChsZXQgZSA9IDA7IGUgPCBpOyBlICs9IDEpIHMuJHdyYXBwZXJFbC5jaGlsZHJlbihgW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHt0LnJlYWxJbmRleCArIGV9XCJdYCkuYWRkQ2xhc3Mocik7IGVsc2UgZm9yIChsZXQgZSA9IDA7IGUgPCBpOyBlICs9IDEpIHMuc2xpZGVzLmVxKHQucmVhbEluZGV4ICsgZSkuYWRkQ2xhc3Mocik7XHJcbiAgICAgICAgICAgIGNvbnN0IG4gPSB0LnBhcmFtcy50aHVtYnMuYXV0b1Njcm9sbE9mZnNldCwgbCA9IG4gJiYgIXMucGFyYW1zLmxvb3A7XHJcbiAgICAgICAgICAgIGlmICh0LnJlYWxJbmRleCAhPT0gcy5yZWFsSW5kZXggfHwgbCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGksIHIsIG8gPSBzLmFjdGl2ZUluZGV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKHMucGFyYW1zLmxvb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICBzLnNsaWRlcy5lcShvKS5oYXNDbGFzcyhzLnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSAmJiAocy5sb29wRml4KCksIHMuX2NsaWVudExlZnQgPSBzLiR3cmFwcGVyRWxbMF0uY2xpZW50TGVmdCwgbyA9IHMuYWN0aXZlSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBzLnNsaWRlcy5lcShvKS5wcmV2QWxsKGBbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3QucmVhbEluZGV4fVwiXWApLmVxKDApLmluZGV4KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBzLnNsaWRlcy5lcShvKS5uZXh0QWxsKGBbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3QucmVhbEluZGV4fVwiXWApLmVxKDApLmluZGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IHZvaWQgMCA9PT0gZSA/IGEgOiB2b2lkIDAgPT09IGEgPyBlIDogYSAtIG8gPT0gbyAtIGUgPyBzLnBhcmFtcy5zbGlkZXNQZXJHcm91cCA+IDEgPyBhIDogbyA6IGEgLSBvIDwgbyAtIGUgPyBhIDogZSwgciA9IHQuYWN0aXZlSW5kZXggPiB0LnByZXZpb3VzSW5kZXggPyBcIm5leHRcIiA6IFwicHJldlwiXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaSA9IHQucmVhbEluZGV4LCByID0gaSA+IHQucHJldmlvdXNJbmRleCA/IFwibmV4dFwiIDogXCJwcmV2XCI7XHJcbiAgICAgICAgICAgICAgICBsICYmIChpICs9IFwibmV4dFwiID09PSByID8gbiA6IC0xICogbiksIHMudmlzaWJsZVNsaWRlc0luZGV4ZXMgJiYgcy52aXNpYmxlU2xpZGVzSW5kZXhlcy5pbmRleE9mKGkpIDwgMCAmJiAocy5wYXJhbXMuY2VudGVyZWRTbGlkZXMgPyBpID0gaSA+IG8gPyBpIC0gTWF0aC5mbG9vcihhIC8gMikgKyAxIDogaSArIE1hdGguZmxvb3IoYSAvIDIpIC0gMSA6IGkgPiBvICYmIHMucGFyYW1zLnNsaWRlc1Blckdyb3VwLCBzLnNsaWRlVG8oaSwgZSA/IDAgOiB2b2lkIDApKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnRodW1icyA9IHtzd2lwZXI6IG51bGx9LCBhKFwiYmVmb3JlSW5pdFwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7dGh1bWJzOiBlfSA9IHQucGFyYW1zO1xyXG4gICAgICAgICAgICBlICYmIGUuc3dpcGVyICYmIChsKCksIG8oITApKVxyXG4gICAgICAgIH0pKSwgYShcInNsaWRlQ2hhbmdlIHVwZGF0ZSByZXNpemUgb2JzZXJ2ZXJVcGRhdGVcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgbygpXHJcbiAgICAgICAgfSkpLCBhKFwic2V0VHJhbnNpdGlvblwiLCAoKGUsIHMpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYSA9IHQudGh1bWJzLnN3aXBlcjtcclxuICAgICAgICAgICAgYSAmJiAhYS5kZXN0cm95ZWQgJiYgYS5zZXRUcmFuc2l0aW9uKHMpXHJcbiAgICAgICAgfSkpLCBhKFwiYmVmb3JlRGVzdHJveVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdC50aHVtYnMuc3dpcGVyO1xyXG4gICAgICAgICAgICBlICYmICFlLmRlc3Ryb3llZCAmJiByICYmIGUuZGVzdHJveSgpXHJcbiAgICAgICAgfSkpLCBPYmplY3QuYXNzaWduKHQudGh1bWJzLCB7aW5pdDogbCwgdXBkYXRlOiBvfSlcclxuICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgbGV0IHtzd2lwZXI6IHQsIGV4dGVuZFBhcmFtczogcywgZW1pdDogYSwgb25jZTogaX0gPSBlO1xyXG4gICAgICAgIHMoe1xyXG4gICAgICAgICAgICBmcmVlTW9kZToge1xyXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogITEsXHJcbiAgICAgICAgICAgICAgICBtb21lbnR1bTogITAsXHJcbiAgICAgICAgICAgICAgICBtb21lbnR1bVJhdGlvOiAxLFxyXG4gICAgICAgICAgICAgICAgbW9tZW50dW1Cb3VuY2U6ICEwLFxyXG4gICAgICAgICAgICAgICAgbW9tZW50dW1Cb3VuY2VSYXRpbzogMSxcclxuICAgICAgICAgICAgICAgIG1vbWVudHVtVmVsb2NpdHlSYXRpbzogMSxcclxuICAgICAgICAgICAgICAgIHN0aWNreTogITEsXHJcbiAgICAgICAgICAgICAgICBtaW5pbXVtVmVsb2NpdHk6IC4wMlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksIE9iamVjdC5hc3NpZ24odCwge1xyXG4gICAgICAgICAgICBmcmVlTW9kZToge1xyXG4gICAgICAgICAgICAgICAgb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IHQuZ2V0VHJhbnNsYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdC5zZXRUcmFuc2xhdGUoZSksIHQuc2V0VHJhbnNpdGlvbigwKSwgdC50b3VjaEV2ZW50c0RhdGEudmVsb2NpdGllcy5sZW5ndGggPSAwLCB0LmZyZWVNb2RlLm9uVG91Y2hFbmQoe2N1cnJlbnRQb3M6IHQucnRsID8gdC50cmFuc2xhdGUgOiAtdC50cmFuc2xhdGV9KVxyXG4gICAgICAgICAgICAgICAgfSwgb25Ub3VjaE1vdmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7dG91Y2hFdmVudHNEYXRhOiBlLCB0b3VjaGVzOiBzfSA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gZS52ZWxvY2l0aWVzLmxlbmd0aCAmJiBlLnZlbG9jaXRpZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzW3QuaXNIb3Jpem9udGFsKCkgPyBcInN0YXJ0WFwiIDogXCJzdGFydFlcIl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IGUudG91Y2hTdGFydFRpbWVcclxuICAgICAgICAgICAgICAgICAgICB9KSwgZS52ZWxvY2l0aWVzLnB1c2goe3Bvc2l0aW9uOiBzW3QuaXNIb3Jpem9udGFsKCkgPyBcImN1cnJlbnRYXCIgOiBcImN1cnJlbnRZXCJdLCB0aW1lOiB1KCl9KVxyXG4gICAgICAgICAgICAgICAgfSwgb25Ub3VjaEVuZDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQge2N1cnJlbnRQb3M6IHN9ID0gZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7cGFyYW1zOiByLCAkd3JhcHBlckVsOiBuLCBydGxUcmFuc2xhdGU6IGwsIHNuYXBHcmlkOiBvLCB0b3VjaEV2ZW50c0RhdGE6IGR9ID0gdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHUoKSAtIGQudG91Y2hTdGFydFRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgPCAtdC5taW5UcmFuc2xhdGUoKSkgdC5zbGlkZVRvKHQuYWN0aXZlSW5kZXgpOyBlbHNlIGlmIChzID4gLXQubWF4VHJhbnNsYXRlKCkpIHQuc2xpZGVzLmxlbmd0aCA8IG8ubGVuZ3RoID8gdC5zbGlkZVRvKG8ubGVuZ3RoIC0gMSkgOiB0LnNsaWRlVG8odC5zbGlkZXMubGVuZ3RoIC0gMSk7IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5mcmVlTW9kZS5tb21lbnR1bSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQudmVsb2NpdGllcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGQudmVsb2NpdGllcy5wb3AoKSwgcyA9IGQudmVsb2NpdGllcy5wb3AoKSwgYSA9IGUucG9zaXRpb24gLSBzLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gZS50aW1lIC0gcy50aW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQudmVsb2NpdHkgPSBhIC8gaSwgdC52ZWxvY2l0eSAvPSAyLCBNYXRoLmFicyh0LnZlbG9jaXR5KSA8IHIuZnJlZU1vZGUubWluaW11bVZlbG9jaXR5ICYmICh0LnZlbG9jaXR5ID0gMCksIChpID4gMTUwIHx8IHUoKSAtIGUudGltZSA+IDMwMCkgJiYgKHQudmVsb2NpdHkgPSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHQudmVsb2NpdHkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC52ZWxvY2l0eSAqPSByLmZyZWVNb2RlLm1vbWVudHVtVmVsb2NpdHlSYXRpbywgZC52ZWxvY2l0aWVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZSA9IDFlMyAqIHIuZnJlZU1vZGUubW9tZW50dW1SYXRpbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSB0LnZlbG9jaXR5ICogZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjID0gdC50cmFuc2xhdGUgKyBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbCAmJiAoYyA9IC1jKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwLCBoID0gITE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtID0gMjAgKiBNYXRoLmFicyh0LnZlbG9jaXR5KSAqIHIuZnJlZU1vZGUubW9tZW50dW1Cb3VuY2VSYXRpbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPCB0Lm1heFRyYW5zbGF0ZSgpKSByLmZyZWVNb2RlLm1vbWVudHVtQm91bmNlID8gKGMgKyB0Lm1heFRyYW5zbGF0ZSgpIDwgLW0gJiYgKGMgPSB0Lm1heFRyYW5zbGF0ZSgpIC0gbSksIHAgPSB0Lm1heFRyYW5zbGF0ZSgpLCBoID0gITAsIGQuYWxsb3dNb21lbnR1bUJvdW5jZSA9ICEwKSA6IGMgPSB0Lm1heFRyYW5zbGF0ZSgpLCByLmxvb3AgJiYgci5jZW50ZXJlZFNsaWRlcyAmJiAoZiA9ICEwKTsgZWxzZSBpZiAoYyA+IHQubWluVHJhbnNsYXRlKCkpIHIuZnJlZU1vZGUubW9tZW50dW1Cb3VuY2UgPyAoYyAtIHQubWluVHJhbnNsYXRlKCkgPiBtICYmIChjID0gdC5taW5UcmFuc2xhdGUoKSArIG0pLCBwID0gdC5taW5UcmFuc2xhdGUoKSwgaCA9ICEwLCBkLmFsbG93TW9tZW50dW1Cb3VuY2UgPSAhMCkgOiBjID0gdC5taW5UcmFuc2xhdGUoKSwgci5sb29wICYmIHIuY2VudGVyZWRTbGlkZXMgJiYgKGYgPSAhMCk7IGVsc2UgaWYgKHIuZnJlZU1vZGUuc3RpY2t5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCBvLmxlbmd0aDsgdCArPSAxKSBpZiAob1t0XSA+IC1jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gTWF0aC5hYnMob1tlXSAtIGMpIDwgTWF0aC5hYnMob1tlIC0gMV0gLSBjKSB8fCBcIm5leHRcIiA9PT0gdC5zd2lwZURpcmVjdGlvbiA/IG9bZV0gOiBvW2UgLSAxXSwgYyA9IC1jXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZiAmJiBpKFwidHJhbnNpdGlvbkVuZFwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQubG9vcEZpeCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSksIDAgIT09IHQudmVsb2NpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSA9IGwgPyBNYXRoLmFicygoLWMgLSB0LnRyYW5zbGF0ZSkgLyB0LnZlbG9jaXR5KSA6IE1hdGguYWJzKChjIC0gdC50cmFuc2xhdGUpIC8gdC52ZWxvY2l0eSksIHIuZnJlZU1vZGUuc3RpY2t5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBNYXRoLmFicygobCA/IC1jIDogYykgLSB0LnRyYW5zbGF0ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gdC5zbGlkZXNTaXplc0dyaWRbdC5hY3RpdmVJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBzIDwgYSA/IHIuc3BlZWQgOiBzIDwgMiAqIGEgPyAxLjUgKiByLnNwZWVkIDogMi41ICogci5zcGVlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoci5mcmVlTW9kZS5zdGlja3kpIHJldHVybiB2b2lkIHQuc2xpZGVUb0Nsb3Nlc3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIuZnJlZU1vZGUubW9tZW50dW1Cb3VuY2UgJiYgaCA/ICh0LnVwZGF0ZVByb2dyZXNzKHApLCB0LnNldFRyYW5zaXRpb24oZSksIHQuc2V0VHJhbnNsYXRlKGMpLCB0LnRyYW5zaXRpb25TdGFydCghMCwgdC5zd2lwZURpcmVjdGlvbiksIHQuYW5pbWF0aW5nID0gITAsIG4udHJhbnNpdGlvbkVuZCgoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgJiYgIXQuZGVzdHJveWVkICYmIGQuYWxsb3dNb21lbnR1bUJvdW5jZSAmJiAoYShcIm1vbWVudHVtQm91bmNlXCIpLCB0LnNldFRyYW5zaXRpb24oci5zcGVlZCksIHNldFRpbWVvdXQoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5zZXRUcmFuc2xhdGUocCksIG4udHJhbnNpdGlvbkVuZCgoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCAmJiAhdC5kZXN0cm95ZWQgJiYgdC50cmFuc2l0aW9uRW5kKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKSA6IHQudmVsb2NpdHkgPyAoYShcIl9mcmVlTW9kZU5vTW9tZW50dW1SZWxlYXNlXCIpLCB0LnVwZGF0ZVByb2dyZXNzKGMpLCB0LnNldFRyYW5zaXRpb24oZSksIHQuc2V0VHJhbnNsYXRlKGMpLCB0LnRyYW5zaXRpb25TdGFydCghMCwgdC5zd2lwZURpcmVjdGlvbiksIHQuYW5pbWF0aW5nIHx8ICh0LmFuaW1hdGluZyA9ICEwLCBuLnRyYW5zaXRpb25FbmQoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICYmICF0LmRlc3Ryb3llZCAmJiB0LnRyYW5zaXRpb25FbmQoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKSkgOiB0LnVwZGF0ZVByb2dyZXNzKGMpLCB0LnVwZGF0ZUFjdGl2ZUluZGV4KCksIHQudXBkYXRlU2xpZGVzQ2xhc3NlcygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5mcmVlTW9kZS5zdGlja3kpIHJldHVybiB2b2lkIHQuc2xpZGVUb0Nsb3Nlc3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIuZnJlZU1vZGUgJiYgYShcIl9mcmVlTW9kZU5vTW9tZW50dW1SZWxlYXNlXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKCFyLmZyZWVNb2RlLm1vbWVudHVtIHx8IGMgPj0gci5sb25nU3dpcGVzTXMpICYmICh0LnVwZGF0ZVByb2dyZXNzKCksIHQudXBkYXRlQWN0aXZlSW5kZXgoKSwgdC51cGRhdGVTbGlkZXNDbGFzc2VzKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgbGV0IHQsIHMsIGEsIHtzd2lwZXI6IGksIGV4dGVuZFBhcmFtczogcn0gPSBlO1xyXG4gICAgICAgIHIoe2dyaWQ6IHtyb3dzOiAxLCBmaWxsOiBcImNvbHVtblwifX0pLCBpLmdyaWQgPSB7XHJcbiAgICAgICAgICAgIGluaXRTbGlkZXM6IGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qge3NsaWRlc1BlclZpZXc6IHJ9ID0gaS5wYXJhbXMsIHtyb3dzOiBuLCBmaWxsOiBsfSA9IGkucGFyYW1zLmdyaWQ7XHJcbiAgICAgICAgICAgICAgICBzID0gdCAvIG4sIGEgPSBNYXRoLmZsb29yKGUgLyBuKSwgdCA9IE1hdGguZmxvb3IoZSAvIG4pID09PSBlIC8gbiA/IGUgOiBNYXRoLmNlaWwoZSAvIG4pICogbiwgXCJhdXRvXCIgIT09IHIgJiYgXCJyb3dcIiA9PT0gbCAmJiAodCA9IE1hdGgubWF4KHQsIHIgKiBuKSlcclxuICAgICAgICAgICAgfSwgdXBkYXRlU2xpZGU6IChlLCByLCBuLCBsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7c2xpZGVzUGVyR3JvdXA6IG8sIHNwYWNlQmV0d2VlbjogZH0gPSBpLnBhcmFtcywge3Jvd3M6IGMsIGZpbGw6IHB9ID0gaS5wYXJhbXMuZ3JpZDtcclxuICAgICAgICAgICAgICAgIGxldCB1LCBoLCBtO1xyXG4gICAgICAgICAgICAgICAgaWYgKFwicm93XCIgPT09IHAgJiYgbyA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gTWF0aC5mbG9vcihlIC8gKG8gKiBjKSksIGEgPSBlIC0gYyAqIG8gKiBzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gMCA9PT0gcyA/IG8gOiBNYXRoLm1pbihNYXRoLmNlaWwoKG4gLSBzICogYyAqIG8pIC8gYyksIG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSBNYXRoLmZsb29yKGEgLyBpKSwgaCA9IGEgLSBtICogaSArIHMgKiBvLCB1ID0gaCArIG0gKiB0IC8gYywgci5jc3Moe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIi13ZWJraXQtb3JkZXJcIjogdSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXI6IHVcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIFwiY29sdW1uXCIgPT09IHAgPyAoaCA9IE1hdGguZmxvb3IoZSAvIGMpLCBtID0gZSAtIGggKiBjLCAoaCA+IGEgfHwgaCA9PT0gYSAmJiBtID09PSBjIC0gMSkgJiYgKG0gKz0gMSwgbSA+PSBjICYmIChtID0gMCwgaCArPSAxKSkpIDogKG0gPSBNYXRoLmZsb29yKGUgLyBzKSwgaCA9IGUgLSBtICogcyk7XHJcbiAgICAgICAgICAgICAgICByLmNzcyhsKFwibWFyZ2luLXRvcFwiKSwgMCAhPT0gbSA/IGQgJiYgYCR7ZH1weGAgOiBcIlwiKVxyXG4gICAgICAgICAgICB9LCB1cGRhdGVXcmFwcGVyU2l6ZTogKGUsIHMsIGEpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHtzcGFjZUJldHdlZW46IHIsIGNlbnRlcmVkU2xpZGVzOiBuLCByb3VuZExlbmd0aHM6IGx9ID0gaS5wYXJhbXMsIHtyb3dzOiBvfSA9IGkucGFyYW1zLmdyaWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaS52aXJ0dWFsU2l6ZSA9IChlICsgcikgKiB0LCBpLnZpcnR1YWxTaXplID0gTWF0aC5jZWlsKGkudmlydHVhbFNpemUgLyBvKSAtIHIsIGkuJHdyYXBwZXJFbC5jc3Moe1thKFwid2lkdGhcIildOiBgJHtpLnZpcnR1YWxTaXplICsgcn1weGB9KSwgbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHMuc3BsaWNlKDAsIHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCBzLmxlbmd0aDsgdCArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhID0gc1t0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbCAmJiAoYSA9IE1hdGguZmxvb3IoYSkpLCBzW3RdIDwgaS52aXJ0dWFsU2l6ZSArIHNbMF0gJiYgZS5wdXNoKGEpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHMucHVzaCguLi5lKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBsZXQge3N3aXBlcjogdH0gPSBlO1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24odCwge1xyXG4gICAgICAgICAgICBhcHBlbmRTbGlkZTogSy5iaW5kKHQpLFxyXG4gICAgICAgICAgICBwcmVwZW5kU2xpZGU6IFouYmluZCh0KSxcclxuICAgICAgICAgICAgYWRkU2xpZGU6IFEuYmluZCh0KSxcclxuICAgICAgICAgICAgcmVtb3ZlU2xpZGU6IEouYmluZCh0KSxcclxuICAgICAgICAgICAgcmVtb3ZlQWxsU2xpZGVzOiBlZS5iaW5kKHQpXHJcbiAgICAgICAgfSlcclxuICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgbGV0IHtzd2lwZXI6IHQsIGV4dGVuZFBhcmFtczogcywgb246IGF9ID0gZTtcclxuICAgICAgICBzKHtmYWRlRWZmZWN0OiB7Y3Jvc3NGYWRlOiAhMSwgdHJhbnNmb3JtRWw6IG51bGx9fSksIHRlKHtcclxuICAgICAgICAgICAgZWZmZWN0OiBcImZhZGVcIixcclxuICAgICAgICAgICAgc3dpcGVyOiB0LFxyXG4gICAgICAgICAgICBvbjogYSxcclxuICAgICAgICAgICAgc2V0VHJhbnNsYXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7c2xpZGVzOiBlfSA9IHQsIHMgPSB0LnBhcmFtcy5mYWRlRWZmZWN0O1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCBlLmxlbmd0aDsgYSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IHQuc2xpZGVzLmVxKGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gLWVbMF0uc3dpcGVyU2xpZGVPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdC5wYXJhbXMudmlydHVhbFRyYW5zbGF0ZSB8fCAoaSAtPSB0LnRyYW5zbGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHQuaXNIb3Jpem9udGFsKCkgfHwgKHIgPSBpLCBpID0gMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbiA9IHQucGFyYW1zLmZhZGVFZmZlY3QuY3Jvc3NGYWRlID8gTWF0aC5tYXgoMSAtIE1hdGguYWJzKGVbMF0ucHJvZ3Jlc3MpLCAwKSA6IDEgKyBNYXRoLm1pbihNYXRoLm1heChlWzBdLnByb2dyZXNzLCAtMSksIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlKHMsIGUpLmNzcyh7b3BhY2l0eTogbn0pLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtpfXB4LCAke3J9cHgsIDBweClgKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXRUcmFuc2l0aW9uOiBlID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHt0cmFuc2Zvcm1FbDogc30gPSB0LnBhcmFtcy5mYWRlRWZmZWN0O1xyXG4gICAgICAgICAgICAgICAgKHMgPyB0LnNsaWRlcy5maW5kKHMpIDogdC5zbGlkZXMpLnRyYW5zaXRpb24oZSksIGFlKHtcclxuICAgICAgICAgICAgICAgICAgICBzd2lwZXI6IHQsXHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGUsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtRWw6IHMsXHJcbiAgICAgICAgICAgICAgICAgICAgYWxsU2xpZGVzOiAhMFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb3ZlcndyaXRlUGFyYW1zOiAoKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgc2xpZGVzUGVyVmlldzogMSxcclxuICAgICAgICAgICAgICAgIHNsaWRlc1Blckdyb3VwOiAxLFxyXG4gICAgICAgICAgICAgICAgd2F0Y2hTbGlkZXNQcm9ncmVzczogITAsXHJcbiAgICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDAsXHJcbiAgICAgICAgICAgICAgICB2aXJ0dWFsVHJhbnNsYXRlOiAhdC5wYXJhbXMuY3NzTW9kZVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICB9LCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGxldCB7c3dpcGVyOiB0LCBleHRlbmRQYXJhbXM6IHMsIG9uOiBhfSA9IGU7XHJcbiAgICAgICAgcyh7Y3ViZUVmZmVjdDoge3NsaWRlU2hhZG93czogITAsIHNoYWRvdzogITAsIHNoYWRvd09mZnNldDogMjAsIHNoYWRvd1NjYWxlOiAuOTR9fSk7XHJcbiAgICAgICAgY29uc3QgaSA9IChlLCB0LCBzKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBhID0gcyA/IGUuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnRcIikgOiBlLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3BcIiksXHJcbiAgICAgICAgICAgICAgICBpID0gcyA/IGUuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0XCIpIDogZS5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tXCIpO1xyXG4gICAgICAgICAgICAwID09PSBhLmxlbmd0aCAmJiAoYSA9IGQoYDxkaXYgY2xhc3M9XCJzd2lwZXItc2xpZGUtc2hhZG93LSR7cyA/IFwibGVmdFwiIDogXCJ0b3BcIn1cIj48L2Rpdj5gKSwgZS5hcHBlbmQoYSkpLCAwID09PSBpLmxlbmd0aCAmJiAoaSA9IGQoYDxkaXYgY2xhc3M9XCJzd2lwZXItc2xpZGUtc2hhZG93LSR7cyA/IFwicmlnaHRcIiA6IFwiYm90dG9tXCJ9XCI+PC9kaXY+YCksIGUuYXBwZW5kKGkpKSwgYS5sZW5ndGggJiYgKGFbMF0uc3R5bGUub3BhY2l0eSA9IE1hdGgubWF4KC10LCAwKSksIGkubGVuZ3RoICYmIChpWzBdLnN0eWxlLm9wYWNpdHkgPSBNYXRoLm1heCh0LCAwKSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRlKHtcclxuICAgICAgICAgICAgZWZmZWN0OiBcImN1YmVcIixcclxuICAgICAgICAgICAgc3dpcGVyOiB0LFxyXG4gICAgICAgICAgICBvbjogYSxcclxuICAgICAgICAgICAgc2V0VHJhbnNsYXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7JGVsOiBlLCAkd3JhcHBlckVsOiBzLCBzbGlkZXM6IGEsIHdpZHRoOiByLCBoZWlnaHQ6IG4sIHJ0bFRyYW5zbGF0ZTogbCwgc2l6ZTogbywgYnJvd3NlcjogY30gPSB0LFxyXG4gICAgICAgICAgICAgICAgICAgIHAgPSB0LnBhcmFtcy5jdWJlRWZmZWN0LCB1ID0gdC5pc0hvcml6b250YWwoKSwgaCA9IHQudmlydHVhbCAmJiB0LnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgbSwgZiA9IDA7XHJcbiAgICAgICAgICAgICAgICBwLnNoYWRvdyAmJiAodSA/IChtID0gcy5maW5kKFwiLnN3aXBlci1jdWJlLXNoYWRvd1wiKSwgMCA9PT0gbS5sZW5ndGggJiYgKG0gPSBkKCc8ZGl2IGNsYXNzPVwic3dpcGVyLWN1YmUtc2hhZG93XCI+PC9kaXY+JyksIHMuYXBwZW5kKG0pKSwgbS5jc3Moe2hlaWdodDogYCR7cn1weGB9KSkgOiAobSA9IGUuZmluZChcIi5zd2lwZXItY3ViZS1zaGFkb3dcIiksIDAgPT09IG0ubGVuZ3RoICYmIChtID0gZCgnPGRpdiBjbGFzcz1cInN3aXBlci1jdWJlLXNoYWRvd1wiPjwvZGl2PicpLCBlLmFwcGVuZChtKSkpKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgYS5sZW5ndGg7IGUgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBhLmVxKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzID0gZTtcclxuICAgICAgICAgICAgICAgICAgICBoICYmIChzID0gcGFyc2VJbnQodC5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIiksIDEwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHIgPSA5MCAqIHMsIG4gPSBNYXRoLmZsb29yKHIgLyAzNjApO1xyXG4gICAgICAgICAgICAgICAgICAgIGwgJiYgKHIgPSAtciwgbiA9IE1hdGguZmxvb3IoLXIgLyAzNjApKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkID0gTWF0aC5tYXgoTWF0aC5taW4odFswXS5wcm9ncmVzcywgMSksIC0xKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYyA9IDAsIG0gPSAwLCBnID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBzICUgNCA9PSAwID8gKGMgPSA0ICogLW4gKiBvLCBnID0gMCkgOiAocyAtIDEpICUgNCA9PSAwID8gKGMgPSAwLCBnID0gNCAqIC1uICogbykgOiAocyAtIDIpICUgNCA9PSAwID8gKGMgPSBvICsgNCAqIG4gKiBvLCBnID0gbykgOiAocyAtIDMpICUgNCA9PSAwICYmIChjID0gLW8sIGcgPSAzICogbyArIDQgKiBvICogbiksIGwgJiYgKGMgPSAtYyksIHUgfHwgKG0gPSBjLCBjID0gMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IGByb3RhdGVYKCR7dSA/IDAgOiAtcn1kZWcpIHJvdGF0ZVkoJHt1ID8gciA6IDB9ZGVnKSB0cmFuc2xhdGUzZCgke2N9cHgsICR7bX1weCwgJHtnfXB4KWA7XHJcbiAgICAgICAgICAgICAgICAgICAgZCA8PSAxICYmIGQgPiAtMSAmJiAoZiA9IDkwICogcyArIDkwICogZCwgbCAmJiAoZiA9IDkwICogLXMgLSA5MCAqIGQpKSwgdC50cmFuc2Zvcm0odiksIHAuc2xpZGVTaGFkb3dzICYmIGkodCwgZCwgdSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzLmNzcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgXCItd2Via2l0LXRyYW5zZm9ybS1vcmlnaW5cIjogYDUwJSA1MCUgLSR7byAvIDJ9cHhgLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgNTAlIDUwJSAtJHtvIC8gMn1weGBcclxuICAgICAgICAgICAgICAgIH0pLCBwLnNoYWRvdykgaWYgKHUpIG0udHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgwcHgsICR7ciAvIDIgKyBwLnNoYWRvd09mZnNldH1weCwgJHstciAvIDJ9cHgpIHJvdGF0ZVgoOTBkZWcpIHJvdGF0ZVooMGRlZykgc2NhbGUoJHtwLnNoYWRvd1NjYWxlfSlgKTsgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IE1hdGguYWJzKGYpIC0gOTAgKiBNYXRoLmZsb29yKE1hdGguYWJzKGYpIC8gOTApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gMS41IC0gKE1hdGguc2luKDIgKiBlICogTWF0aC5QSSAvIDM2MCkgLyAyICsgTWF0aC5jb3MoMiAqIGUgKiBNYXRoLlBJIC8gMzYwKSAvIDIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gcC5zaGFkb3dTY2FsZSwgYSA9IHAuc2hhZG93U2NhbGUgLyB0LCBpID0gcC5zaGFkb3dPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbS50cmFuc2Zvcm0oYHNjYWxlM2QoJHtzfSwgMSwgJHthfSkgdHJhbnNsYXRlM2QoMHB4LCAke24gLyAyICsgaX1weCwgJHstbiAvIDIgLyBhfXB4KSByb3RhdGVYKC05MGRlZylgKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZyA9IGMuaXNTYWZhcmkgfHwgYy5pc1dlYlZpZXcgPyAtbyAvIDIgOiAwO1xyXG4gICAgICAgICAgICAgICAgcy50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDBweCwwLCR7Z31weCkgcm90YXRlWCgke3QuaXNIb3Jpem9udGFsKCkgPyAwIDogZn1kZWcpIHJvdGF0ZVkoJHt0LmlzSG9yaXpvbnRhbCgpID8gLWYgOiAwfWRlZylgKSwgc1swXS5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tc3dpcGVyLWN1YmUtdHJhbnNsYXRlLXpcIiwgYCR7Z31weGApXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb246IGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyRlbDogcywgc2xpZGVzOiBhfSA9IHQ7XHJcbiAgICAgICAgICAgICAgICBhLnRyYW5zaXRpb24oZSkuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQsIC5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbSwgLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdFwiKS50cmFuc2l0aW9uKGUpLCB0LnBhcmFtcy5jdWJlRWZmZWN0LnNoYWRvdyAmJiAhdC5pc0hvcml6b250YWwoKSAmJiBzLmZpbmQoXCIuc3dpcGVyLWN1YmUtc2hhZG93XCIpLnRyYW5zaXRpb24oZSlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVjcmVhdGVTaGFkb3dzOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gdC5pc0hvcml6b250YWwoKTtcclxuICAgICAgICAgICAgICAgIHQuc2xpZGVzLmVhY2goKHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBNYXRoLm1heChNYXRoLm1pbih0LnByb2dyZXNzLCAxKSwgLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGkoZCh0KSwgcywgZSlcclxuICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXRFZmZlY3RQYXJhbXM6ICgpID0+IHQucGFyYW1zLmN1YmVFZmZlY3QsXHJcbiAgICAgICAgICAgIHBlcnNwZWN0aXZlOiAoKSA9PiAhMCxcclxuICAgICAgICAgICAgb3ZlcndyaXRlUGFyYW1zOiAoKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgc2xpZGVzUGVyVmlldzogMSxcclxuICAgICAgICAgICAgICAgIHNsaWRlc1Blckdyb3VwOiAxLFxyXG4gICAgICAgICAgICAgICAgd2F0Y2hTbGlkZXNQcm9ncmVzczogITAsXHJcbiAgICAgICAgICAgICAgICByZXNpc3RhbmNlUmF0aW86IDAsXHJcbiAgICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDAsXHJcbiAgICAgICAgICAgICAgICBjZW50ZXJlZFNsaWRlczogITEsXHJcbiAgICAgICAgICAgICAgICB2aXJ0dWFsVHJhbnNsYXRlOiAhMFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICB9LCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGxldCB7c3dpcGVyOiB0LCBleHRlbmRQYXJhbXM6IHMsIG9uOiBhfSA9IGU7XHJcbiAgICAgICAgcyh7ZmxpcEVmZmVjdDoge3NsaWRlU2hhZG93czogITAsIGxpbWl0Um90YXRpb246ICEwLCB0cmFuc2Zvcm1FbDogbnVsbH19KTtcclxuICAgICAgICBjb25zdCBpID0gKGUsIHMsIGEpID0+IHtcclxuICAgICAgICAgICAgbGV0IGkgPSB0LmlzSG9yaXpvbnRhbCgpID8gZS5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdFwiKSA6IGUuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXRvcFwiKSxcclxuICAgICAgICAgICAgICAgIHIgPSB0LmlzSG9yaXpvbnRhbCgpID8gZS5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHRcIikgOiBlLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b21cIik7XHJcbiAgICAgICAgICAgIDAgPT09IGkubGVuZ3RoICYmIChpID0gaWUoYSwgZSwgdC5pc0hvcml6b250YWwoKSA/IFwibGVmdFwiIDogXCJ0b3BcIikpLCAwID09PSByLmxlbmd0aCAmJiAociA9IGllKGEsIGUsIHQuaXNIb3Jpem9udGFsKCkgPyBcInJpZ2h0XCIgOiBcImJvdHRvbVwiKSksIGkubGVuZ3RoICYmIChpWzBdLnN0eWxlLm9wYWNpdHkgPSBNYXRoLm1heCgtcywgMCkpLCByLmxlbmd0aCAmJiAoclswXS5zdHlsZS5vcGFjaXR5ID0gTWF0aC5tYXgocywgMCkpXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0ZSh7XHJcbiAgICAgICAgICAgIGVmZmVjdDogXCJmbGlwXCIsXHJcbiAgICAgICAgICAgIHN3aXBlcjogdCxcclxuICAgICAgICAgICAgb246IGEsXHJcbiAgICAgICAgICAgIHNldFRyYW5zbGF0ZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qge3NsaWRlczogZSwgcnRsVHJhbnNsYXRlOiBzfSA9IHQsIGEgPSB0LnBhcmFtcy5mbGlwRWZmZWN0O1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCBlLmxlbmd0aDsgciArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbiA9IGUuZXEocik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGwgPSBuWzBdLnByb2dyZXNzO1xyXG4gICAgICAgICAgICAgICAgICAgIHQucGFyYW1zLmZsaXBFZmZlY3QubGltaXRSb3RhdGlvbiAmJiAobCA9IE1hdGgubWF4KE1hdGgubWluKG5bMF0ucHJvZ3Jlc3MsIDEpLCAtMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG8gPSBuWzBdLnN3aXBlclNsaWRlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkID0gLTE4MCAqIGwsIGMgPSAwLCBwID0gdC5wYXJhbXMuY3NzTW9kZSA/IC1vIC0gdC50cmFuc2xhdGUgOiAtbywgdSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdC5pc0hvcml6b250YWwoKSA/IHMgJiYgKGQgPSAtZCkgOiAodSA9IHAsIHAgPSAwLCBjID0gLWQsIGQgPSAwKSwgblswXS5zdHlsZS56SW5kZXggPSAtTWF0aC5hYnMoTWF0aC5yb3VuZChsKSkgKyBlLmxlbmd0aCwgYS5zbGlkZVNoYWRvd3MgJiYgaShuLCBsLCBhKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoID0gYHRyYW5zbGF0ZTNkKCR7cH1weCwgJHt1fXB4LCAwcHgpIHJvdGF0ZVgoJHtjfWRlZykgcm90YXRlWSgke2R9ZGVnKWA7XHJcbiAgICAgICAgICAgICAgICAgICAgc2UoYSwgbikudHJhbnNmb3JtKGgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb246IGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qge3RyYW5zZm9ybUVsOiBzfSA9IHQucGFyYW1zLmZsaXBFZmZlY3Q7XHJcbiAgICAgICAgICAgICAgICAocyA/IHQuc2xpZGVzLmZpbmQocykgOiB0LnNsaWRlcykudHJhbnNpdGlvbihlKS5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0XCIpLnRyYW5zaXRpb24oZSksIGFlKHtcclxuICAgICAgICAgICAgICAgICAgICBzd2lwZXI6IHQsXHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGUsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtRWw6IHNcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlY3JlYXRlU2hhZG93czogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHQucGFyYW1zLmZsaXBFZmZlY3Q7XHJcbiAgICAgICAgICAgICAgICB0LnNsaWRlcy5lYWNoKChzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gZChzKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgciA9IGFbMF0ucHJvZ3Jlc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgdC5wYXJhbXMuZmxpcEVmZmVjdC5saW1pdFJvdGF0aW9uICYmIChyID0gTWF0aC5tYXgoTWF0aC5taW4ocy5wcm9ncmVzcywgMSksIC0xKSksIGkoYSwgciwgZSlcclxuICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXRFZmZlY3RQYXJhbXM6ICgpID0+IHQucGFyYW1zLmZsaXBFZmZlY3QsXHJcbiAgICAgICAgICAgIHBlcnNwZWN0aXZlOiAoKSA9PiAhMCxcclxuICAgICAgICAgICAgb3ZlcndyaXRlUGFyYW1zOiAoKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgc2xpZGVzUGVyVmlldzogMSxcclxuICAgICAgICAgICAgICAgIHNsaWRlc1Blckdyb3VwOiAxLFxyXG4gICAgICAgICAgICAgICAgd2F0Y2hTbGlkZXNQcm9ncmVzczogITAsXHJcbiAgICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDAsXHJcbiAgICAgICAgICAgICAgICB2aXJ0dWFsVHJhbnNsYXRlOiAhdC5wYXJhbXMuY3NzTW9kZVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICB9LCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGxldCB7c3dpcGVyOiB0LCBleHRlbmRQYXJhbXM6IHMsIG9uOiBhfSA9IGU7XHJcbiAgICAgICAgcyh7XHJcbiAgICAgICAgICAgIGNvdmVyZmxvd0VmZmVjdDoge1xyXG4gICAgICAgICAgICAgICAgcm90YXRlOiA1MCxcclxuICAgICAgICAgICAgICAgIHN0cmV0Y2g6IDAsXHJcbiAgICAgICAgICAgICAgICBkZXB0aDogMTAwLFxyXG4gICAgICAgICAgICAgICAgc2NhbGU6IDEsXHJcbiAgICAgICAgICAgICAgICBtb2RpZmllcjogMSxcclxuICAgICAgICAgICAgICAgIHNsaWRlU2hhZG93czogITAsXHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1FbDogbnVsbFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksIHRlKHtcclxuICAgICAgICAgICAgZWZmZWN0OiBcImNvdmVyZmxvd1wiLCBzd2lwZXI6IHQsIG9uOiBhLCBzZXRUcmFuc2xhdGU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHt3aWR0aDogZSwgaGVpZ2h0OiBzLCBzbGlkZXM6IGEsIHNsaWRlc1NpemVzR3JpZDogaX0gPSB0LCByID0gdC5wYXJhbXMuY292ZXJmbG93RWZmZWN0LFxyXG4gICAgICAgICAgICAgICAgICAgIG4gPSB0LmlzSG9yaXpvbnRhbCgpLCBsID0gdC50cmFuc2xhdGUsIG8gPSBuID8gZSAvIDIgLSBsIDogcyAvIDIgLSBsLCBkID0gbiA/IHIucm90YXRlIDogLXIucm90YXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIGMgPSByLmRlcHRoO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZSA9IDAsIHQgPSBhLmxlbmd0aDsgZSA8IHQ7IGUgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBhLmVxKGUpLCBzID0gaVtlXSwgbCA9IChvIC0gdFswXS5zd2lwZXJTbGlkZU9mZnNldCAtIHMgLyAyKSAvIHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHIubW9kaWZpZXIgPyByLm1vZGlmaWVyKGwpIDogbCAqIHIubW9kaWZpZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSBuID8gZCAqIHAgOiAwLCBoID0gbiA/IDAgOiBkICogcCwgbSA9IC1jICogTWF0aC5hYnMocCksIGYgPSByLnN0cmV0Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZiAmJiAtMSAhPT0gZi5pbmRleE9mKFwiJVwiKSAmJiAoZiA9IHBhcnNlRmxvYXQoci5zdHJldGNoKSAvIDEwMCAqIHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBnID0gbiA/IDAgOiBmICogcCwgdiA9IG4gPyBmICogcCA6IDAsIHcgPSAxIC0gKDEgLSByLnNjYWxlKSAqIE1hdGguYWJzKHApO1xyXG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKHYpIDwgLjAwMSAmJiAodiA9IDApLCBNYXRoLmFicyhnKSA8IC4wMDEgJiYgKGcgPSAwKSwgTWF0aC5hYnMobSkgPCAuMDAxICYmIChtID0gMCksIE1hdGguYWJzKHUpIDwgLjAwMSAmJiAodSA9IDApLCBNYXRoLmFicyhoKSA8IC4wMDEgJiYgKGggPSAwKSwgTWF0aC5hYnModykgPCAuMDAxICYmICh3ID0gMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IGB0cmFuc2xhdGUzZCgke3Z9cHgsJHtnfXB4LCR7bX1weCkgIHJvdGF0ZVgoJHtofWRlZykgcm90YXRlWSgke3V9ZGVnKSBzY2FsZSgke3d9KWA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlKHIsIHQpLnRyYW5zZm9ybShiKSwgdFswXS5zdHlsZS56SW5kZXggPSAxIC0gTWF0aC5hYnMoTWF0aC5yb3VuZChwKSksIHIuc2xpZGVTaGFkb3dzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlID0gbiA/IHQuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnRcIikgOiB0LmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3BcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gbiA/IHQuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0XCIpIDogdC5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAwID09PSBlLmxlbmd0aCAmJiAoZSA9IGllKHIsIHQsIG4gPyBcImxlZnRcIiA6IFwidG9wXCIpKSwgMCA9PT0gcy5sZW5ndGggJiYgKHMgPSBpZShyLCB0LCBuID8gXCJyaWdodFwiIDogXCJib3R0b21cIikpLCBlLmxlbmd0aCAmJiAoZVswXS5zdHlsZS5vcGFjaXR5ID0gcCA+IDAgPyBwIDogMCksIHMubGVuZ3RoICYmIChzWzBdLnN0eWxlLm9wYWNpdHkgPSAtcCA+IDAgPyAtcCA6IDApXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBzZXRUcmFuc2l0aW9uOiBlID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHt0cmFuc2Zvcm1FbDogc30gPSB0LnBhcmFtcy5jb3ZlcmZsb3dFZmZlY3Q7XHJcbiAgICAgICAgICAgICAgICAocyA/IHQuc2xpZGVzLmZpbmQocykgOiB0LnNsaWRlcykudHJhbnNpdGlvbihlKS5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0XCIpLnRyYW5zaXRpb24oZSlcclxuICAgICAgICAgICAgfSwgcGVyc3BlY3RpdmU6ICgpID0+ICEwLCBvdmVyd3JpdGVQYXJhbXM6ICgpID0+ICh7d2F0Y2hTbGlkZXNQcm9ncmVzczogITB9KVxyXG4gICAgICAgIH0pXHJcbiAgICB9LCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGxldCB7c3dpcGVyOiB0LCBleHRlbmRQYXJhbXM6IHMsIG9uOiBhfSA9IGU7XHJcbiAgICAgICAgcyh7XHJcbiAgICAgICAgICAgIGNyZWF0aXZlRWZmZWN0OiB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1FbDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGxpbWl0UHJvZ3Jlc3M6IDEsXHJcbiAgICAgICAgICAgICAgICBzaGFkb3dQZXJQcm9ncmVzczogITEsXHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzc011bHRpcGxpZXI6IDEsXHJcbiAgICAgICAgICAgICAgICBwZXJzcGVjdGl2ZTogITAsXHJcbiAgICAgICAgICAgICAgICBwcmV2OiB7dHJhbnNsYXRlOiBbMCwgMCwgMF0sIHJvdGF0ZTogWzAsIDAsIDBdLCBvcGFjaXR5OiAxLCBzY2FsZTogMX0sXHJcbiAgICAgICAgICAgICAgICBuZXh0OiB7dHJhbnNsYXRlOiBbMCwgMCwgMF0sIHJvdGF0ZTogWzAsIDAsIDBdLCBvcGFjaXR5OiAxLCBzY2FsZTogMX1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGkgPSBlID0+IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgPyBlIDogYCR7ZX1weGA7XHJcbiAgICAgICAgdGUoe1xyXG4gICAgICAgICAgICBlZmZlY3Q6IFwiY3JlYXRpdmVcIixcclxuICAgICAgICAgICAgc3dpcGVyOiB0LFxyXG4gICAgICAgICAgICBvbjogYSxcclxuICAgICAgICAgICAgc2V0VHJhbnNsYXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7c2xpZGVzOiBlLCAkd3JhcHBlckVsOiBzLCBzbGlkZXNTaXplc0dyaWQ6IGF9ID0gdCxcclxuICAgICAgICAgICAgICAgICAgICByID0gdC5wYXJhbXMuY3JlYXRpdmVFZmZlY3QsIHtwcm9ncmVzc011bHRpcGxpZXI6IG59ID0gciwgbCA9IHQucGFyYW1zLmNlbnRlcmVkU2xpZGVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gYVswXSAvIDIgLSB0LnBhcmFtcy5zbGlkZXNPZmZzZXRCZWZvcmUgfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICBzLnRyYW5zZm9ybShgdHJhbnNsYXRlWChjYWxjKDUwJSAtICR7ZX1weCkpYClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgZS5sZW5ndGg7IHMgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBlLmVxKHMpLCBvID0gYVswXS5wcm9ncmVzcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IE1hdGgubWluKE1hdGgubWF4KGFbMF0ucHJvZ3Jlc3MsIC1yLmxpbWl0UHJvZ3Jlc3MpLCByLmxpbWl0UHJvZ3Jlc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjID0gZDtcclxuICAgICAgICAgICAgICAgICAgICBsIHx8IChjID0gTWF0aC5taW4oTWF0aC5tYXgoYVswXS5vcmlnaW5hbFByb2dyZXNzLCAtci5saW1pdFByb2dyZXNzKSwgci5saW1pdFByb2dyZXNzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IGFbMF0uc3dpcGVyU2xpZGVPZmZzZXQsIHUgPSBbdC5wYXJhbXMuY3NzTW9kZSA/IC1wIC0gdC50cmFuc2xhdGUgOiAtcCwgMCwgMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSBbMCwgMCwgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSAhMTtcclxuICAgICAgICAgICAgICAgICAgICB0LmlzSG9yaXpvbnRhbCgpIHx8ICh1WzFdID0gdVswXSwgdVswXSA9IDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmID0ge3RyYW5zbGF0ZTogWzAsIDAsIDBdLCByb3RhdGU6IFswLCAwLCAwXSwgc2NhbGU6IDEsIG9wYWNpdHk6IDF9O1xyXG4gICAgICAgICAgICAgICAgICAgIGQgPCAwID8gKGYgPSByLm5leHQsIG0gPSAhMCkgOiBkID4gMCAmJiAoZiA9IHIucHJldiwgbSA9ICEwKSwgdS5mb3JFYWNoKCgoZSwgdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1W3RdID0gYGNhbGMoJHtlfXB4ICsgKCR7aShmLnRyYW5zbGF0ZVt0XSl9ICogJHtNYXRoLmFicyhkICogbil9KSlgXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpLCBoLmZvckVhY2goKChlLCB0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhbdF0gPSBmLnJvdGF0ZVt0XSAqIE1hdGguYWJzKGQgKiBuKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pKSwgYVswXS5zdHlsZS56SW5kZXggPSAtTWF0aC5hYnMoTWF0aC5yb3VuZChvKSkgKyBlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBnID0gdS5qb2luKFwiLCBcIiksIHYgPSBgcm90YXRlWCgke2hbMF19ZGVnKSByb3RhdGVZKCR7aFsxXX1kZWcpIHJvdGF0ZVooJHtoWzJdfWRlZylgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ID0gYyA8IDAgPyBgc2NhbGUoJHsxICsgKDEgLSBmLnNjYWxlKSAqIGMgKiBufSlgIDogYHNjYWxlKCR7MSAtICgxIC0gZi5zY2FsZSkgKiBjICogbn0pYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGMgPCAwID8gMSArICgxIC0gZi5vcGFjaXR5KSAqIGMgKiBuIDogMSAtICgxIC0gZi5vcGFjaXR5KSAqIGMgKiBuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYHRyYW5zbGF0ZTNkKCR7Z30pICR7dn0gJHt3fWA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0gJiYgZi5zaGFkb3cgfHwgIW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGUgPSBhLmNoaWxkcmVuKFwiLnN3aXBlci1zbGlkZS1zaGFkb3dcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBlLmxlbmd0aCAmJiBmLnNoYWRvdyAmJiAoZSA9IGllKHIsIGEpKSwgZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSByLnNoYWRvd1BlclByb2dyZXNzID8gZCAqICgxIC8gci5saW1pdFByb2dyZXNzKSA6IGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlWzBdLnN0eWxlLm9wYWNpdHkgPSBNYXRoLm1pbihNYXRoLm1heChNYXRoLmFicyh0KSwgMCksIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IHNlKHIsIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHkudHJhbnNmb3JtKHgpLmNzcyh7b3BhY2l0eTogYn0pLCBmLm9yaWdpbiAmJiB5LmNzcyhcInRyYW5zZm9ybS1vcmlnaW5cIiwgZi5vcmlnaW4pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb246IGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qge3RyYW5zZm9ybUVsOiBzfSA9IHQucGFyYW1zLmNyZWF0aXZlRWZmZWN0O1xyXG4gICAgICAgICAgICAgICAgKHMgPyB0LnNsaWRlcy5maW5kKHMpIDogdC5zbGlkZXMpLnRyYW5zaXRpb24oZSkuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93XCIpLnRyYW5zaXRpb24oZSksIGFlKHtcclxuICAgICAgICAgICAgICAgICAgICBzd2lwZXI6IHQsXHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGUsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtRWw6IHMsXHJcbiAgICAgICAgICAgICAgICAgICAgYWxsU2xpZGVzOiAhMFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcGVyc3BlY3RpdmU6ICgpID0+IHQucGFyYW1zLmNyZWF0aXZlRWZmZWN0LnBlcnNwZWN0aXZlLFxyXG4gICAgICAgICAgICBvdmVyd3JpdGVQYXJhbXM6ICgpID0+ICh7d2F0Y2hTbGlkZXNQcm9ncmVzczogITAsIHZpcnR1YWxUcmFuc2xhdGU6ICF0LnBhcmFtcy5jc3NNb2RlfSlcclxuICAgICAgICB9KVxyXG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBsZXQge3N3aXBlcjogdCwgZXh0ZW5kUGFyYW1zOiBzLCBvbjogYX0gPSBlO1xyXG4gICAgICAgIHMoe2NhcmRzRWZmZWN0OiB7c2xpZGVTaGFkb3dzOiAhMCwgdHJhbnNmb3JtRWw6IG51bGwsIHJvdGF0ZTogITAsIHBlclNsaWRlUm90YXRlOiAyLCBwZXJTbGlkZU9mZnNldDogOH19KSwgdGUoe1xyXG4gICAgICAgICAgICBlZmZlY3Q6IFwiY2FyZHNcIixcclxuICAgICAgICAgICAgc3dpcGVyOiB0LFxyXG4gICAgICAgICAgICBvbjogYSxcclxuICAgICAgICAgICAgc2V0VHJhbnNsYXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7c2xpZGVzOiBlLCBhY3RpdmVJbmRleDogc30gPSB0LCBhID0gdC5wYXJhbXMuY2FyZHNFZmZlY3QsIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFRyYW5zbGF0ZTogaSxcclxuICAgICAgICAgICAgICAgICAgICBpc1RvdWNoZWQ6IHJcclxuICAgICAgICAgICAgICAgIH0gPSB0LnRvdWNoRXZlbnRzRGF0YSwgbiA9IHQudHJhbnNsYXRlO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbCA9IDA7IGwgPCBlLmxlbmd0aDsgbCArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbyA9IGUuZXEobCksIGQgPSBvWzBdLnByb2dyZXNzLCBjID0gTWF0aC5taW4oTWF0aC5tYXgoZCwgLTQpLCA0KTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcCA9IG9bMF0uc3dpcGVyU2xpZGVPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdC5wYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgIXQucGFyYW1zLmNzc01vZGUgJiYgdC4kd3JhcHBlckVsLnRyYW5zZm9ybShgdHJhbnNsYXRlWCgke3QubWluVHJhbnNsYXRlKCl9cHgpYCksIHQucGFyYW1zLmNlbnRlcmVkU2xpZGVzICYmIHQucGFyYW1zLmNzc01vZGUgJiYgKHAgLT0gZVswXS5zd2lwZXJTbGlkZU9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHUgPSB0LnBhcmFtcy5jc3NNb2RlID8gLXAgLSB0LnRyYW5zbGF0ZSA6IC1wLCBoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtID0gLTEwMCAqIE1hdGguYWJzKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmID0gMSwgZyA9IC1hLnBlclNsaWRlUm90YXRlICogYywgdiA9IGEucGVyU2xpZGVPZmZzZXQgLSAuNzUgKiBNYXRoLmFicyhjKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB3ID0gdC52aXJ0dWFsICYmIHQucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCA/IHQudmlydHVhbC5mcm9tICsgbCA6IGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSAodyA9PT0gcyB8fCB3ID09PSBzIC0gMSkgJiYgYyA+IDAgJiYgYyA8IDEgJiYgKHIgfHwgdC5wYXJhbXMuY3NzTW9kZSkgJiYgbiA8IGksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSAodyA9PT0gcyB8fCB3ID09PSBzICsgMSkgJiYgYyA8IDAgJiYgYyA+IC0xICYmIChyIHx8IHQucGFyYW1zLmNzc01vZGUpICYmIG4gPiBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiIHx8IHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9ICgxIC0gTWF0aC5hYnMoKE1hdGguYWJzKGMpIC0gLjUpIC8gLjUpKSAqKiAuNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyArPSAtMjggKiBjICogZSwgZiArPSAtLjUgKiBlLCB2ICs9IDk2ICogZSwgaCA9IC0yNSAqIGUgKiBNYXRoLmFicyhjKSArIFwiJVwiXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID0gYyA8IDAgPyBgY2FsYygke3V9cHggKyAoJHt2ICogTWF0aC5hYnMoYyl9JSkpYCA6IGMgPiAwID8gYGNhbGMoJHt1fXB4ICsgKC0ke3YgKiBNYXRoLmFicyhjKX0lKSlgIDogYCR7dX1weGAsICF0LmlzSG9yaXpvbnRhbCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gdSwgdSA9IGVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IGMgPCAwID8gXCJcIiArICgxICsgKDEgLSBmKSAqIGMpIDogXCJcIiArICgxIC0gKDEgLSBmKSAqIGMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBFID0gYFxcbiAgICAgICAgdHJhbnNsYXRlM2QoJHt1fSwgJHtofSwgJHttfXB4KVxcbiAgICAgICAgcm90YXRlWigke2Eucm90YXRlID8gZyA6IDB9ZGVnKVxcbiAgICAgICAgc2NhbGUoJHt5fSlcXG4gICAgICBgO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhLnNsaWRlU2hhZG93cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZSA9IG8uZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAwID09PSBlLmxlbmd0aCAmJiAoZSA9IGllKGEsIG8pKSwgZS5sZW5ndGggJiYgKGVbMF0uc3R5bGUub3BhY2l0eSA9IE1hdGgubWluKE1hdGgubWF4KChNYXRoLmFicyhjKSAtIC41KSAvIC41LCAwKSwgMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG9bMF0uc3R5bGUuekluZGV4ID0gLU1hdGguYWJzKE1hdGgucm91bmQoZCkpICsgZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgc2UoYSwgbykudHJhbnNmb3JtKEUpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb246IGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qge3RyYW5zZm9ybUVsOiBzfSA9IHQucGFyYW1zLmNhcmRzRWZmZWN0O1xyXG4gICAgICAgICAgICAgICAgKHMgPyB0LnNsaWRlcy5maW5kKHMpIDogdC5zbGlkZXMpLnRyYW5zaXRpb24oZSkuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93XCIpLnRyYW5zaXRpb24oZSksIGFlKHtcclxuICAgICAgICAgICAgICAgICAgICBzd2lwZXI6IHQsXHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGUsXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtRWw6IHNcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBlcnNwZWN0aXZlOiAoKSA9PiAhMCxcclxuICAgICAgICAgICAgb3ZlcndyaXRlUGFyYW1zOiAoKSA9PiAoe3dhdGNoU2xpZGVzUHJvZ3Jlc3M6ICEwLCB2aXJ0dWFsVHJhbnNsYXRlOiAhdC5wYXJhbXMuY3NzTW9kZX0pXHJcbiAgICAgICAgfSlcclxuICAgIH1dO1xyXG4gICAgcmV0dXJuIFYudXNlKHJlKSwgVlxyXG59KSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXBlci1idW5kbGUubWluLmpzLm1hcCIsIi8qIVxuICogYmFndWV0dGVCb3guanNcbiAqIEBhdXRob3IgIGZlaW1vc2lcbiAqIEB2ZXJzaW9uIDEuMTEuMVxuICogQHVybCBodHRwczovL2dpdGh1Yi5jb20vZmVpbW9zaS9iYWd1ZXR0ZUJveC5qc1xuICovXG4hZnVuY3Rpb24oZSx0KXtcInVzZSBzdHJpY3RcIjtcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP21vZHVsZS5leHBvcnRzPXQoKTplLmJhZ3VldHRlQm94PXQoKX0odGhpcyxmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciByLGwsdSxjLGQsZj0nPHN2ZyB3aWR0aD1cIjQ0XCIgaGVpZ2h0PVwiNjBcIj48cG9seWxpbmUgcG9pbnRzPVwiMzAgMTAgMTAgMzAgMzAgNTBcIiBzdHJva2U9XCJyZ2JhKDI1NSwyNTUsMjU1LDAuNSlcIiBzdHJva2Utd2lkdGg9XCI0XCJzdHJva2UtbGluZWNhcD1cImJ1dHRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIvPjwvc3ZnPicsZz0nPHN2ZyB3aWR0aD1cIjQ0XCIgaGVpZ2h0PVwiNjBcIj48cG9seWxpbmUgcG9pbnRzPVwiMTQgMTAgMzQgMzAgMTQgNTBcIiBzdHJva2U9XCJyZ2JhKDI1NSwyNTUsMjU1LDAuNSlcIiBzdHJva2Utd2lkdGg9XCI0XCJzdHJva2UtbGluZWNhcD1cImJ1dHRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIvPjwvc3ZnPicscD0nPHN2ZyB3aWR0aD1cIjMwXCIgaGVpZ2h0PVwiMzBcIj48ZyBzdHJva2U9XCJyZ2IoMTYwLDE2MCwxNjApXCIgc3Ryb2tlLXdpZHRoPVwiNFwiPjxsaW5lIHgxPVwiNVwiIHkxPVwiNVwiIHgyPVwiMjVcIiB5Mj1cIjI1XCIvPjxsaW5lIHgxPVwiNVwiIHkxPVwiMjVcIiB4Mj1cIjI1XCIgeTI9XCI1XCIvPjwvZz48L3N2Zz4nLGI9e30sdj17Y2FwdGlvbnM6ITAsYnV0dG9uczpcImF1dG9cIixmdWxsU2NyZWVuOiExLG5vU2Nyb2xsYmFyczohMSxib2R5Q2xhc3M6XCJiYWd1ZXR0ZUJveC1vcGVuXCIsdGl0bGVUYWc6ITEsYXN5bmM6ITEscHJlbG9hZDoyLGFuaW1hdGlvbjpcInNsaWRlSW5cIixhZnRlclNob3c6bnVsbCxhZnRlckhpZGU6bnVsbCxvbkNoYW5nZTpudWxsLG92ZXJsYXlCYWNrZ3JvdW5kQ29sb3I6XCJyZ2JhKDAsMCwwLC44KVwifSxtPXt9LGg9W10sbz0wLG49ITEsaT17fSxhPSExLHk9Ly4rXFwuKGdpZnxqcGU/Z3xwbmd8d2VicCkvaSx3PXt9LGs9W10scz1udWxsLHg9ZnVuY3Rpb24oZSl7LTEhPT1lLnRhcmdldC5pZC5pbmRleE9mKFwiYmFndWV0dGUtaW1nXCIpJiZqKCl9LEU9ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24/ZS5zdG9wUHJvcGFnYXRpb24oKTplLmNhbmNlbEJ1YmJsZT0hMCxEKCl9LEM9ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24/ZS5zdG9wUHJvcGFnYXRpb24oKTplLmNhbmNlbEJ1YmJsZT0hMCxYKCl9LEI9ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24/ZS5zdG9wUHJvcGFnYXRpb24oKTplLmNhbmNlbEJ1YmJsZT0hMCxqKCl9LFQ9ZnVuY3Rpb24oZSl7aS5jb3VudCsrLDE8aS5jb3VudCYmKGkubXVsdGl0b3VjaD0hMCksaS5zdGFydFg9ZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCxpLnN0YXJ0WT1lLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZfSxOPWZ1bmN0aW9uKGUpe2lmKCFhJiYhaS5tdWx0aXRvdWNoKXtlLnByZXZlbnREZWZhdWx0P2UucHJldmVudERlZmF1bHQoKTplLnJldHVyblZhbHVlPSExO3ZhciB0PWUudG91Y2hlc1swXXx8ZS5jaGFuZ2VkVG91Y2hlc1swXTs0MDx0LnBhZ2VYLWkuc3RhcnRYPyhhPSEwLEQoKSk6dC5wYWdlWC1pLnN0YXJ0WDwtNDA/KGE9ITAsWCgpKToxMDA8aS5zdGFydFktdC5wYWdlWSYmaigpfX0sTD1mdW5jdGlvbigpe2kuY291bnQtLSxpLmNvdW50PD0wJiYoaS5tdWx0aXRvdWNoPSExKSxhPSExfSxBPWZ1bmN0aW9uKCl7TCgpfSxQPWZ1bmN0aW9uKGUpe1wiYmxvY2tcIj09PXIuc3R5bGUuZGlzcGxheSYmci5jb250YWlucyYmIXIuY29udGFpbnMoZS50YXJnZXQpJiYoZS5zdG9wUHJvcGFnYXRpb24oKSxZKCkpfTtmdW5jdGlvbiBTKGUpe2lmKHcuaGFzT3duUHJvcGVydHkoZSkpe3ZhciB0PXdbZV0uZ2FsbGVyaWVzO1tdLmZvckVhY2guY2FsbCh0LGZ1bmN0aW9uKGUpe1tdLmZvckVhY2guY2FsbChlLGZ1bmN0aW9uKGUpe1coZS5pbWFnZUVsZW1lbnQsXCJjbGlja1wiLGUuZXZlbnRIYW5kbGVyKX0pLGg9PT1lJiYoaD1bXSl9KSxkZWxldGUgd1tlXX19ZnVuY3Rpb24gRihlKXtzd2l0Y2goZS5rZXlDb2RlKXtjYXNlIDM3OkQoKTticmVhaztjYXNlIDM5OlgoKTticmVhaztjYXNlIDI3OmooKTticmVhaztjYXNlIDM2OiFmdW5jdGlvbiB0KGUpe2UmJmUucHJldmVudERlZmF1bHQoKTtyZXR1cm4gTSgwKX0oZSk7YnJlYWs7Y2FzZSAzNTohZnVuY3Rpb24gbihlKXtlJiZlLnByZXZlbnREZWZhdWx0KCk7cmV0dXJuIE0oaC5sZW5ndGgtMSl9KGUpfX1mdW5jdGlvbiBIKGUsdCl7aWYoaCE9PWUpe2ZvcihoPWUsZnVuY3Rpb24gcyhlKXtlPWV8fHt9O2Zvcih2YXIgdCBpbiB2KWJbdF09dlt0XSxcInVuZGVmaW5lZFwiIT10eXBlb2YgZVt0XSYmKGJbdF09ZVt0XSk7bC5zdHlsZS50cmFuc2l0aW9uPWwuc3R5bGUud2Via2l0VHJhbnNpdGlvbj1cImZhZGVJblwiPT09Yi5hbmltYXRpb24/XCJvcGFjaXR5IC40cyBlYXNlXCI6XCJzbGlkZUluXCI9PT1iLmFuaW1hdGlvbj9cIlwiOlwibm9uZVwiLFwiYXV0b1wiPT09Yi5idXR0b25zJiYoXCJvbnRvdWNoc3RhcnRcImluIHdpbmRvd3x8MT09PWgubGVuZ3RoKSYmKGIuYnV0dG9ucz0hMSk7dS5zdHlsZS5kaXNwbGF5PWMuc3R5bGUuZGlzcGxheT1iLmJ1dHRvbnM/XCJcIjpcIm5vbmVcIjt0cnl7ci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9Yi5vdmVybGF5QmFja2dyb3VuZENvbG9yfWNhdGNoKG4pe319KHQpO2wuZmlyc3RDaGlsZDspbC5yZW1vdmVDaGlsZChsLmZpcnN0Q2hpbGQpO2Zvcih2YXIgbixvPVtdLGk9W10sYT1rLmxlbmd0aD0wO2E8ZS5sZW5ndGg7YSsrKShuPUooXCJkaXZcIikpLmNsYXNzTmFtZT1cImZ1bGwtaW1hZ2VcIixuLmlkPVwiYmFndWV0dGUtaW1nLVwiK2Esay5wdXNoKG4pLG8ucHVzaChcImJhZ3VldHRlQm94LWZpZ3VyZS1cIithKSxpLnB1c2goXCJiYWd1ZXR0ZUJveC1maWdjYXB0aW9uLVwiK2EpLGwuYXBwZW5kQ2hpbGQoa1thXSk7ci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsbGVkYnlcIixvLmpvaW4oXCIgXCIpKSxyLnNldEF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIixpLmpvaW4oXCIgXCIpKX19ZnVuY3Rpb24gSShlKXtiLm5vU2Nyb2xsYmFycyYmKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvd1k9XCJoaWRkZW5cIixkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93WT1cInNjcm9sbFwiKSxcImJsb2NrXCIhPT1yLnN0eWxlLmRpc3BsYXkmJihVKGRvY3VtZW50LFwia2V5ZG93blwiLEYpLGk9e2NvdW50OjAsc3RhcnRYOm51bGwsc3RhcnRZOm51bGx9LHEobz1lLGZ1bmN0aW9uKCl7eihvKSxWKG8pfSksUigpLHIuc3R5bGUuZGlzcGxheT1cImJsb2NrXCIsYi5mdWxsU2NyZWVuJiZmdW5jdGlvbiB0KCl7ci5yZXF1ZXN0RnVsbHNjcmVlbj9yLnJlcXVlc3RGdWxsc2NyZWVuKCk6ci53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbj9yLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKCk6ci5tb3pSZXF1ZXN0RnVsbFNjcmVlbiYmci5tb3pSZXF1ZXN0RnVsbFNjcmVlbigpfSgpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtyLmNsYXNzTmFtZT1cInZpc2libGVcIixiLmJvZHlDbGFzcyYmZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QmJmRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChiLmJvZHlDbGFzcyksYi5hZnRlclNob3cmJmIuYWZ0ZXJTaG93KCl9LDUwKSxiLm9uQ2hhbmdlJiZiLm9uQ2hhbmdlKG8say5sZW5ndGgpLHM9ZG9jdW1lbnQuYWN0aXZlRWxlbWVudCxZKCksbj0hMCl9ZnVuY3Rpb24gWSgpe2IuYnV0dG9ucz91LmZvY3VzKCk6ZC5mb2N1cygpfWZ1bmN0aW9uIGooKXtiLm5vU2Nyb2xsYmFycyYmKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvd1k9XCJhdXRvXCIsZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvd1k9XCJhdXRvXCIpLFwibm9uZVwiIT09ci5zdHlsZS5kaXNwbGF5JiYoVyhkb2N1bWVudCxcImtleWRvd25cIixGKSxyLmNsYXNzTmFtZT1cIlwiLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtyLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsZG9jdW1lbnQuZnVsbHNjcmVlbiYmZnVuY3Rpb24gZSgpe2RvY3VtZW50LmV4aXRGdWxsc2NyZWVuP2RvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCk6ZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbj9kb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKCk6ZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4mJmRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKCl9KCksYi5ib2R5Q2xhc3MmJmRvY3VtZW50LmJvZHkuY2xhc3NMaXN0JiZkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoYi5ib2R5Q2xhc3MpLGIuYWZ0ZXJIaWRlJiZiLmFmdGVySGlkZSgpLHMmJnMuZm9jdXMoKSxuPSExfSw1MDApKX1mdW5jdGlvbiBxKHQsbil7dmFyIGU9a1t0XSxvPWhbdF07aWYodm9pZCAwIT09ZSYmdm9pZCAwIT09bylpZihlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW1nXCIpWzBdKW4mJm4oKTtlbHNle3ZhciBpPW8uaW1hZ2VFbGVtZW50LGE9aS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImltZ1wiKVswXSxzPVwiZnVuY3Rpb25cIj09dHlwZW9mIGIuY2FwdGlvbnM/Yi5jYXB0aW9ucy5jYWxsKGgsaSk6aS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNhcHRpb25cIil8fGkudGl0bGUscj1mdW5jdGlvbiBkKGUpe3ZhciB0PWUuaHJlZjtpZihlLmRhdGFzZXQpe3ZhciBuPVtdO2Zvcih2YXIgbyBpbiBlLmRhdGFzZXQpXCJhdC1cIiE9PW8uc3Vic3RyaW5nKDAsMyl8fGlzTmFOKG8uc3Vic3RyaW5nKDMpKXx8KG5bby5yZXBsYWNlKFwiYXQtXCIsXCJcIildPWUuZGF0YXNldFtvXSk7Zm9yKHZhciBpPU9iamVjdC5rZXlzKG4pLnNvcnQoZnVuY3Rpb24oZSx0KXtyZXR1cm4gcGFyc2VJbnQoZSwxMCk8cGFyc2VJbnQodCwxMCk/LTE6MX0pLGE9d2luZG93LmlubmVyV2lkdGgqd2luZG93LmRldmljZVBpeGVsUmF0aW8scz0wO3M8aS5sZW5ndGgtMSYmaVtzXTxhOylzKys7dD1uW2lbc11dfHx0fXJldHVybiB0fShpKSxsPUooXCJmaWd1cmVcIik7aWYobC5pZD1cImJhZ3VldHRlQm94LWZpZ3VyZS1cIit0LGwuaW5uZXJIVE1MPSc8ZGl2IGNsYXNzPVwiYmFndWV0dGVCb3gtc3Bpbm5lclwiPjxkaXYgY2xhc3M9XCJiYWd1ZXR0ZUJveC1kb3VibGUtYm91bmNlMVwiPjwvZGl2PjxkaXYgY2xhc3M9XCJiYWd1ZXR0ZUJveC1kb3VibGUtYm91bmNlMlwiPjwvZGl2PjwvZGl2PicsYi5jYXB0aW9ucyYmcyl7dmFyIHU9SihcImZpZ2NhcHRpb25cIik7dS5pZD1cImJhZ3VldHRlQm94LWZpZ2NhcHRpb24tXCIrdCx1LmlubmVySFRNTD1zLGwuYXBwZW5kQ2hpbGQodSl9ZS5hcHBlbmRDaGlsZChsKTt2YXIgYz1KKFwiaW1nXCIpO2Mub25sb2FkPWZ1bmN0aW9uKCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNiYWd1ZXR0ZS1pbWctXCIrdCtcIiAuYmFndWV0dGVCb3gtc3Bpbm5lclwiKTtsLnJlbW92ZUNoaWxkKGUpLCFiLmFzeW5jJiZuJiZuKCl9LGMuc2V0QXR0cmlidXRlKFwic3JjXCIsciksYy5hbHQ9YSYmYS5hbHR8fFwiXCIsYi50aXRsZVRhZyYmcyYmKGMudGl0bGU9cyksbC5hcHBlbmRDaGlsZChjKSxiLmFzeW5jJiZuJiZuKCl9fWZ1bmN0aW9uIFgoKXtyZXR1cm4gTShvKzEpfWZ1bmN0aW9uIEQoKXtyZXR1cm4gTShvLTEpfWZ1bmN0aW9uIE0oZSx0KXtyZXR1cm4hbiYmMDw9ZSYmZTx0Lmxlbmd0aD8oSCh0LGIpLEkoZSksITApOmU8MD8oYi5hbmltYXRpb24mJk8oXCJsZWZ0XCIpLCExKTplPj1rLmxlbmd0aD8oYi5hbmltYXRpb24mJk8oXCJyaWdodFwiKSwhMSk6KHEobz1lLGZ1bmN0aW9uKCl7eihvKSxWKG8pfSksUigpLGIub25DaGFuZ2UmJmIub25DaGFuZ2UobyxrLmxlbmd0aCksITApfWZ1bmN0aW9uIE8oZSl7bC5jbGFzc05hbWU9XCJib3VuY2UtZnJvbS1cIitlLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtsLmNsYXNzTmFtZT1cIlwifSw0MDApfWZ1bmN0aW9uIFIoKXt2YXIgZT0xMDAqLW8rXCIlXCI7XCJmYWRlSW5cIj09PWIuYW5pbWF0aW9uPyhsLnN0eWxlLm9wYWNpdHk9MCxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bS50cmFuc2Zvcm1zP2wuc3R5bGUudHJhbnNmb3JtPWwuc3R5bGUud2Via2l0VHJhbnNmb3JtPVwidHJhbnNsYXRlM2QoXCIrZStcIiwwLDApXCI6bC5zdHlsZS5sZWZ0PWUsbC5zdHlsZS5vcGFjaXR5PTF9LDQwMCkpOm0udHJhbnNmb3Jtcz9sLnN0eWxlLnRyYW5zZm9ybT1sLnN0eWxlLndlYmtpdFRyYW5zZm9ybT1cInRyYW5zbGF0ZTNkKFwiK2UrXCIsMCwwKVwiOmwuc3R5bGUubGVmdD1lfWZ1bmN0aW9uIHooZSl7ZS1vPj1iLnByZWxvYWR8fHEoZSsxLGZ1bmN0aW9uKCl7eihlKzEpfSl9ZnVuY3Rpb24gVihlKXtvLWU+PWIucHJlbG9hZHx8cShlLTEsZnVuY3Rpb24oKXtWKGUtMSl9KX1mdW5jdGlvbiBVKGUsdCxuLG8pe2UuYWRkRXZlbnRMaXN0ZW5lcj9lLmFkZEV2ZW50TGlzdGVuZXIodCxuLG8pOmUuYXR0YWNoRXZlbnQoXCJvblwiK3QsZnVuY3Rpb24oZSl7KGU9ZXx8d2luZG93LmV2ZW50KS50YXJnZXQ9ZS50YXJnZXR8fGUuc3JjRWxlbWVudCxuKGUpfSl9ZnVuY3Rpb24gVyhlLHQsbixvKXtlLnJlbW92ZUV2ZW50TGlzdGVuZXI/ZS5yZW1vdmVFdmVudExpc3RlbmVyKHQsbixvKTplLmRldGFjaEV2ZW50KFwib25cIit0LG4pfWZ1bmN0aW9uIEcoZSl7cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUpfWZ1bmN0aW9uIEooZSl7cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZSl9cmV0dXJuW10uZm9yRWFjaHx8KEFycmF5LnByb3RvdHlwZS5mb3JFYWNoPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPTA7bjx0aGlzLmxlbmd0aDtuKyspZS5jYWxsKHQsdGhpc1tuXSxuLHRoaXMpfSksW10uZmlsdGVyfHwoQXJyYXkucHJvdG90eXBlLmZpbHRlcj1mdW5jdGlvbihlLHQsbixvLGkpe2ZvcihuPXRoaXMsbz1bXSxpPTA7aTxuLmxlbmd0aDtpKyspZS5jYWxsKHQsbltpXSxpLG4pJiZvLnB1c2gobltpXSk7cmV0dXJuIG99KSx7cnVuOmZ1bmN0aW9uIEsoZSx0KXtyZXR1cm4gbS50cmFuc2Zvcm1zPWZ1bmN0aW9uIG4oKXt2YXIgZT1KKFwiZGl2XCIpO3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBlLnN0eWxlLnBlcnNwZWN0aXZlfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgZS5zdHlsZS53ZWJraXRQZXJzcGVjdGl2ZX0oKSxtLnN2Zz1mdW5jdGlvbiBvKCl7dmFyIGU9SihcImRpdlwiKTtyZXR1cm4gZS5pbm5lckhUTUw9XCI8c3ZnLz5cIixcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI9PT0oZS5maXJzdENoaWxkJiZlLmZpcnN0Q2hpbGQubmFtZXNwYWNlVVJJKX0oKSxtLnBhc3NpdmVFdmVudHM9ZnVuY3Rpb24gaSgpe3ZhciBlPSExO3RyeXt2YXIgdD1PYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJwYXNzaXZlXCIse2dldDpmdW5jdGlvbigpe2U9ITB9fSk7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsbnVsbCx0KX1jYXRjaChuKXt9cmV0dXJuIGV9KCksZnVuY3Rpb24gYSgpe2lmKHI9RyhcImJhZ3VldHRlQm94LW92ZXJsYXlcIikpcmV0dXJuIGw9RyhcImJhZ3VldHRlQm94LXNsaWRlclwiKSx1PUcoXCJwcmV2aW91cy1idXR0b25cIiksYz1HKFwibmV4dC1idXR0b25cIiksdm9pZChkPUcoXCJjbG9zZS1idXR0b25cIikpOyhyPUooXCJkaXZcIikpLnNldEF0dHJpYnV0ZShcInJvbGVcIixcImRpYWxvZ1wiKSxyLmlkPVwiYmFndWV0dGVCb3gtb3ZlcmxheVwiLGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXS5hcHBlbmRDaGlsZChyKSwobD1KKFwiZGl2XCIpKS5pZD1cImJhZ3VldHRlQm94LXNsaWRlclwiLHIuYXBwZW5kQ2hpbGQobCksKHU9SihcImJ1dHRvblwiKSkuc2V0QXR0cmlidXRlKFwidHlwZVwiLFwiYnV0dG9uXCIpLHUuaWQ9XCJwcmV2aW91cy1idXR0b25cIix1LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIixcIlByZXZpb3VzXCIpLHUuaW5uZXJIVE1MPW0uc3ZnP2Y6XCImbHQ7XCIsci5hcHBlbmRDaGlsZCh1KSwoYz1KKFwiYnV0dG9uXCIpKS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJidXR0b25cIiksYy5pZD1cIm5leHQtYnV0dG9uXCIsYy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsXCJOZXh0XCIpLGMuaW5uZXJIVE1MPW0uc3ZnP2c6XCImZ3Q7XCIsci5hcHBlbmRDaGlsZChjKSwoZD1KKFwiYnV0dG9uXCIpKS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJidXR0b25cIiksZC5pZD1cImNsb3NlLWJ1dHRvblwiLGQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLFwiQ2xvc2VcIiksZC5pbm5lckhUTUw9bS5zdmc/cDpcIiZ0aW1lcztcIixyLmFwcGVuZENoaWxkKGQpLHUuY2xhc3NOYW1lPWMuY2xhc3NOYW1lPWQuY2xhc3NOYW1lPVwiYmFndWV0dGVCb3gtYnV0dG9uXCIsZnVuY3Rpb24gbigpe3ZhciBlPW0ucGFzc2l2ZUV2ZW50cz97cGFzc2l2ZTohMX06bnVsbCx0PW0ucGFzc2l2ZUV2ZW50cz97cGFzc2l2ZTohMH06bnVsbDtVKHIsXCJjbGlja1wiLHgpLFUodSxcImNsaWNrXCIsRSksVShjLFwiY2xpY2tcIixDKSxVKGQsXCJjbGlja1wiLEIpLFUobCxcImNvbnRleHRtZW51XCIsQSksVShyLFwidG91Y2hzdGFydFwiLFQsdCksVShyLFwidG91Y2htb3ZlXCIsTixlKSxVKHIsXCJ0b3VjaGVuZFwiLEwpLFUoZG9jdW1lbnQsXCJmb2N1c1wiLFAsITApfSgpfSgpLFMoZSksZnVuY3Rpb24gcyhlLGEpe3ZhciB0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZSksbj17Z2FsbGVyaWVzOltdLG5vZGVMaXN0OnR9O3JldHVybiB3W2VdPW4sW10uZm9yRWFjaC5jYWxsKHQsZnVuY3Rpb24oZSl7YSYmYS5maWx0ZXImJih5PWEuZmlsdGVyKTt2YXIgdD1bXTtpZih0PVwiQVwiPT09ZS50YWdOYW1lP1tlXTplLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYVwiKSwwIT09KHQ9W10uZmlsdGVyLmNhbGwodCxmdW5jdGlvbihlKXtpZigtMT09PWUuY2xhc3NOYW1lLmluZGV4T2YoYSYmYS5pZ25vcmVDbGFzcykpcmV0dXJuIHkudGVzdChlLmhyZWYpfSkpLmxlbmd0aCl7dmFyIGk9W107W10uZm9yRWFjaC5jYWxsKHQsZnVuY3Rpb24oZSx0KXt2YXIgbj1mdW5jdGlvbihlKXtlLnByZXZlbnREZWZhdWx0P2UucHJldmVudERlZmF1bHQoKTplLnJldHVyblZhbHVlPSExLEgoaSxhKSxJKHQpfSxvPXtldmVudEhhbmRsZXI6bixpbWFnZUVsZW1lbnQ6ZX07VShlLFwiY2xpY2tcIixuKSxpLnB1c2gobyl9KSxuLmdhbGxlcmllcy5wdXNoKGkpfX0pLG4uZ2FsbGVyaWVzfShlLHQpfSxzaG93Ok0sc2hvd05leHQ6WCxzaG93UHJldmlvdXM6RCxoaWRlOmosZGVzdHJveTpmdW5jdGlvbiBlKCl7IWZ1bmN0aW9uIG4oKXt2YXIgZT1tLnBhc3NpdmVFdmVudHM/e3Bhc3NpdmU6ITF9Om51bGwsdD1tLnBhc3NpdmVFdmVudHM/e3Bhc3NpdmU6ITB9Om51bGw7VyhyLFwiY2xpY2tcIix4KSxXKHUsXCJjbGlja1wiLEUpLFcoYyxcImNsaWNrXCIsQyksVyhkLFwiY2xpY2tcIixCKSxXKGwsXCJjb250ZXh0bWVudVwiLEEpLFcocixcInRvdWNoc3RhcnRcIixULHQpLFcocixcInRvdWNobW92ZVwiLE4sZSksVyhyLFwidG91Y2hlbmRcIixMKSxXKGRvY3VtZW50LFwiZm9jdXNcIixQLCEwKX0oKSxmdW5jdGlvbiB0KCl7Zm9yKHZhciBlIGluIHcpdy5oYXNPd25Qcm9wZXJ0eShlKSYmUyhlKX0oKSxXKGRvY3VtZW50LFwia2V5ZG93blwiLEYpLGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXS5yZW1vdmVDaGlsZChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImJhZ3VldHRlQm94LW92ZXJsYXlcIikpLHc9e30saD1bXSxvPTB9fX0pOyJdfQ==
