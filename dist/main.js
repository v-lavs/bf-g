/*
* to include js file write: `//= include ./path-to-file`
* */

/*! jQuery v3.6.1 | (c) OpenJS Foundation and other contributors | jquery.org/license */

!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,y=n.hasOwnProperty,a=y.toString,l=a.call(Object),v={},m=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType&&"function"!=typeof e.item},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement("script");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[o.call(e)]||"object":typeof e}var f="3.6.1",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&"length"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}S.fn=S.prototype={jquery:f,constructor:S,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=S.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return S.each(this,e)},map:function(n){return this.pushStack(S.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(S.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(S.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},S.extend=S.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(S.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||S.isPlainObject(n)?n:{},i=!1,a[t]=S.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},S.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==o.call(e))&&(!(t=r(e))||"function"==typeof(n=y.call(t,"constructor")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){b(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(p(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},makeArray:function(e,t){var n=t||[];return null!=e&&(p(Object(e))?S.merge(n,"string"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(p(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:v}),"function"==typeof Symbol&&(S.fn[Symbol.iterator]=t[Symbol.iterator]),S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var d=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,y,s,c,v,S="sizzle"+1*new Date,p=n.document,k=0,r=0,m=ue(),x=ue(),A=ue(),N=ue(),j=function(e,t){return e===t&&(l=!0),0},D={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",I="(?:\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",W="\\["+M+"*("+I+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+I+"))|)"+M+"*\\]",F=":("+I+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+W+")*)|.*)\\)|)",$=new RegExp(M+"+","g"),B=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),_=new RegExp("^"+M+"*,"+M+"*"),z=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp(M+"|>"),X=new RegExp(F),V=new RegExp("^"+I+"$"),G={ID:new RegExp("^#("+I+")"),CLASS:new RegExp("^\\.("+I+")"),TAG:new RegExp("^("+I+"|[*])"),ATTR:new RegExp("^"+W),PSEUDO:new RegExp("^"+F),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+R+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/HTML$/i,Q=/^(?:input|select|textarea|button)$/i,J=/^h\d$/i,K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\([^\\r\\n\\f])","g"),ne=function(e,t){var n="0x"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{H.apply(t=O.call(p.childNodes),p.childNodes),t[p.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&v(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!N[t+" "]&&(!y||!y.test(t))&&(1!==p||"object"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&(U.test(t)||z.test(t))){(f=ee.test(t)&&ve(e.parentNode)||e)===e&&d.scope||((s=e.getAttribute("id"))?s=s.replace(re,ie):e.setAttribute("id",s=S)),o=(l=h(t)).length;while(o--)l[o]=(s?"#"+s:":scope")+" "+xe(l[o]);c=l.join(",")}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){N(t,!0)}finally{s===S&&e.removeAttribute("id")}}}return g(t.replace(B,"$1"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function le(e){return e[S]=!0,e}function ce(e){var t=C.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split("|"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return"input"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return("input"===t||"button"===t)&&e.type===n}}function ge(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function ye(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ve(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e&&e.namespaceURI,n=e&&(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||"HTML")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:p;return r!=C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),p!=C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",oe,!1):n.attachEvent&&n.attachEvent("onunload",oe)),d.scope=ce(function(e){return a.appendChild(e).appendChild(C.createElement("div")),"undefined"!=typeof e.querySelectorAll&&!e.querySelectorAll(":scope fieldset div").length}),d.attributes=ce(function(e){return e.className="i",!e.getAttribute("className")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment("")),!e.getElementsByTagName("*").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=S,!C.getElementsByName||!C.getElementsByName(S).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],y=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){var t;a.appendChild(e).innerHTML="<a id='"+S+"'></a><select id='"+S+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&y.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||y.push("\\["+M+"*(?:value|"+R+")"),e.querySelectorAll("[id~="+S+"-]").length||y.push("~="),(t=C.createElement("input")).setAttribute("name",""),e.appendChild(t),e.querySelectorAll("[name='']").length||y.push("\\["+M+"*name"+M+"*="+M+"*(?:''|\"\")"),e.querySelectorAll(":checked").length||y.push(":checked"),e.querySelectorAll("a#"+S+"+*").length||y.push(".#.+[+~]"),e.querySelectorAll("\\\f"),y.push("[\\r\\n\\f]")}),ce(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=C.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&y.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&y.push(":enabled",":disabled"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&y.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),y.push(",.*:")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,"*"),c.call(e,"[s!='']:x"),s.push("!=",F)}),y=y.length&&new RegExp(y.join("|")),s=s.length&&new RegExp(s.join("|")),t=K.test(a.compareDocumentPosition),v=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},j=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e==C||e.ownerDocument==p&&v(p,e)?-1:t==C||t.ownerDocument==p&&v(p,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e==C?-1:t==C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]==p?-1:s[r]==p?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if(T(e),d.matchesSelector&&E&&!N[t+" "]&&(!s||!s.test(t))&&(!y||!y.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){N(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!=C&&T(e),v(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!=C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&D.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+"").replace(re,ie)},se.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(j),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=m[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&m(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace($," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(h,e,t,g,y){var v="nth"!==h.slice(0,3),m="last"!==h.slice(-4),x="of-type"===e;return 1===g&&0===y?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=v!==m?"nextSibling":"previousSibling",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(v){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l="only"===h&&!u&&"nextSibling"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[k,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[k,d]),a===e))break;return(d-=y)===g||d%g==0&&0<=d/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error("unsupported pseudo: "+e);return a[S]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace(B,"$1"));return s[S]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||"")||se.error("unsupported lang: "+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:ye(function(){return[0]}),last:ye(function(e,t){return[t-1]}),eq:ye(function(e,t,n){return[n<0?n+t:n]}),even:ye(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ye(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ye(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ye(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&"parentNode"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[k,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[S]||(e[S]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===k&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,y,v,e){return y&&!y[S]&&(y=Ce(y)),v&&!v[S]&&(v=Ce(v,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?v||(e?d:l||y)?[]:t:f;if(g&&g(f,p,n,r),y){i=Te(p,u),y(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(v||d){if(v){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);v(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=v?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),v?v(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace(B,"$1"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace(B," ")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,y,v,m,x,r,i=[],o=[],a=A[e+" "];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[S]?i.push(a):o.push(a);(a=A(e,(y=o,m=0<(v=i).length,x=0<y.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=k+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==C||(T(o),n=!E);while(s=y[a++])if(s(o,t||C,n)){r.push(o);break}i&&(k=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=v[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+v.length&&se.uniqueSort(r)}return i&&(k=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ve(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ve(t.parentNode)||t),n},d.sortStable=S.split("").sort(j).join("")===S,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement("fieldset"))}),ce(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||fe("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||fe("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute("disabled")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);S.find=d,S.expr=d.selectors,S.expr[":"]=S.expr.pseudos,S.uniqueSort=S.unique=d.uniqueSort,S.text=d.getText,S.isXMLDoc=d.isXML,S.contains=d.contains,S.escapeSelector=d.escape;var h=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&S(e).is(n))break;r.push(e)}return r},T=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},k=S.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var N=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function j(e,n,r){return m(n)?S.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?S.grep(e,function(e){return e===n!==r}):"string"!=typeof n?S.grep(e,function(e){return-1<i.call(n,e)!==r}):S.filter(n,e,r)}S.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?S.find.matchesSelector(r,e)?[r]:[]:S.find.matches(e,S.grep(t,function(e){return 1===e.nodeType}))},S.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(S(e).filter(function(){for(t=0;t<r;t++)if(S.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)S.find(e,i[t],n);return 1<r?S.uniqueSort(n):n},filter:function(e){return this.pushStack(j(this,e||[],!1))},not:function(e){return this.pushStack(j(this,e||[],!0))},is:function(e){return!!j(this,"string"==typeof e&&k.test(e)?S(e):e||[],!1).length}});var D,q=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(S.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||D,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:q.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof S?t[0]:t,S.merge(this,S.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),N.test(r[1])&&S.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(S):S.makeArray(e,this)}).prototype=S.fn,D=S(E);var L=/^(?:parents|prev(?:Until|All))/,H={children:!0,contents:!0,next:!0,prev:!0};function O(e,t){while((e=e[t])&&1!==e.nodeType);return e}S.fn.extend({has:function(e){var t=S(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(S.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&S(e);if(!k.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&S.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?S.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?i.call(S(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(S.uniqueSort(S.merge(this.get(),S(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),S.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return h(e,"parentNode")},parentsUntil:function(e,t,n){return h(e,"parentNode",n)},next:function(e){return O(e,"nextSibling")},prev:function(e){return O(e,"previousSibling")},nextAll:function(e){return h(e,"nextSibling")},prevAll:function(e){return h(e,"previousSibling")},nextUntil:function(e,t,n){return h(e,"nextSibling",n)},prevUntil:function(e,t,n){return h(e,"previousSibling",n)},siblings:function(e){return T((e.parentNode||{}).firstChild,e)},children:function(e){return T(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(A(e,"template")&&(e=e.content||e),S.merge([],e.childNodes))}},function(r,i){S.fn[r]=function(e,t){var n=S.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=S.filter(t,n)),1<this.length&&(H[r]||S.uniqueSort(n),L.test(r)&&n.reverse()),this.pushStack(n)}});var P=/[^\x20\t\r\n\f]+/g;function R(e){return e}function M(e){throw e}function I(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}S.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},S.each(e.match(P)||[],function(e,t){n[t]=!0}),n):S.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){S.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return S.each(arguments,function(e,t){var n;while(-1<(n=S.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<S.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},S.extend({Deferred:function(e){var o=[["notify","progress",S.Callbacks("memory"),S.Callbacks("memory"),2],["resolve","done",S.Callbacks("once memory"),S.Callbacks("once memory"),0,"resolved"],["reject","fail",S.Callbacks("once memory"),S.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return S.Deferred(function(r){S.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,R,s),l(u,o,M,s)):(u++,t.call(e,l(u,o,R,s),l(u,o,M,s),l(u,o,R,o.notifyWith))):(a!==R&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){S.Deferred.exceptionHook&&S.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==M&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(S.Deferred.getStackHook&&(t.stackTrace=S.Deferred.getStackHook()),C.setTimeout(t))}}return S.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:R,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:R)),o[2][3].add(l(0,e,m(n)?n:M))}).promise()},promise:function(e){return null!=e?S.extend(e,a):a}},s={};return S.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=S.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(I(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)I(i[t],a(t),o.reject);return o.promise()}});var W=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;S.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&W.test(e.name)&&C.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},S.readyException=function(e){C.setTimeout(function(){throw e})};var F=S.Deferred();function $(){E.removeEventListener("DOMContentLoaded",$),C.removeEventListener("load",$),S.ready()}S.fn.ready=function(e){return F.then(e)["catch"](function(e){S.readyException(e)}),this},S.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--S.readyWait:S.isReady)||(S.isReady=!0)!==e&&0<--S.readyWait||F.resolveWith(E,[S])}}),S.ready.then=F.then,"complete"===E.readyState||"loading"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(S.ready):(E.addEventListener("DOMContentLoaded",$),C.addEventListener("load",$));var B=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===w(n))for(s in i=!0,n)B(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(S(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},_=/^-ms-/,z=/-([a-z])/g;function U(e,t){return t.toUpperCase()}function X(e){return e.replace(_,"ms-").replace(z,U)}var V=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function G(){this.expando=S.expando+G.uid++}G.uid=1,G.prototype={cache:function(e){var t=e[this.expando];return t||(t={},V(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[X(t)]=n;else for(r in t)i[X(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][X(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(X):(t=X(t))in r?[t]:t.match(P)||[]).length;while(n--)delete r[t[n]]}(void 0===t||S.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!S.isEmptyObject(t)}};var Y=new G,Q=new G,J=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,K=/[A-Z]/g;function Z(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(K,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:J.test(i)?JSON.parse(i):i)}catch(e){}Q.set(e,t,n)}else n=void 0;return n}S.extend({hasData:function(e){return Q.hasData(e)||Y.hasData(e)},data:function(e,t,n){return Q.access(e,t,n)},removeData:function(e,t){Q.remove(e,t)},_data:function(e,t,n){return Y.access(e,t,n)},_removeData:function(e,t){Y.remove(e,t)}}),S.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=Q.get(o),1===o.nodeType&&!Y.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=X(r.slice(5)),Z(o,r,i[r]));Y.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){Q.set(this,n)}):B(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=Q.get(o,n))?t:void 0!==(t=Z(o,n))?t:void 0;this.each(function(){Q.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){Q.remove(this,e)})}}),S.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=Y.get(e,t),n&&(!r||Array.isArray(n)?r=Y.access(e,t,S.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=S.queue(e,t),r=n.length,i=n.shift(),o=S._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){S.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Y.get(e,n)||Y.access(e,n,{empty:S.Callbacks("once memory").add(function(){Y.remove(e,[t+"queue",n])})})}}),S.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?S.queue(this[0],t):void 0===n?this:this.each(function(){var e=S.queue(this,t,n);S._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&S.dequeue(this,t)})},dequeue:function(e){return this.each(function(){S.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=S.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=Y.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var ee=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,te=new RegExp("^(?:([+-])=|)("+ee+")([a-z%]*)$","i"),ne=["Top","Right","Bottom","Left"],re=E.documentElement,ie=function(e){return S.contains(e.ownerDocument,e)},oe={composed:!0};re.getRootNode&&(ie=function(e){return S.contains(e.ownerDocument,e)||e.getRootNode(oe)===e.ownerDocument});var ae=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&ie(e)&&"none"===S.css(e,"display")};function se(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return S.css(e,t,"")},u=s(),l=n&&n[3]||(S.cssNumber[t]?"":"px"),c=e.nodeType&&(S.cssNumber[t]||"px"!==l&&+u)&&te.exec(S.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)S.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,S.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ue={};function le(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=Y.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&ae(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ue[s])||(o=a.body.appendChild(a.createElement(s)),u=S.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ue[s]=u)))):"none"!==n&&(l[c]="none",Y.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}S.fn.extend({show:function(){return le(this,!0)},hide:function(){return le(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){ae(this)?S(this).show():S(this).hide()})}});var ce,fe,pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,he=/^$|^module$|\/(?:java|ecma)script/i;ce=E.createDocumentFragment().appendChild(E.createElement("div")),(fe=E.createElement("input")).setAttribute("type","radio"),fe.setAttribute("checked","checked"),fe.setAttribute("name","t"),ce.appendChild(fe),v.checkClone=ce.cloneNode(!0).cloneNode(!0).lastChild.checked,ce.innerHTML="<textarea>x</textarea>",v.noCloneChecked=!!ce.cloneNode(!0).lastChild.defaultValue,ce.innerHTML="<option></option>",v.option=!!ce.lastChild;var ge={thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function ye(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&A(e,t)?S.merge([e],n):n}function ve(e,t){for(var n=0,r=e.length;n<r;n++)Y.set(e[n],"globalEval",!t||Y.get(t[n],"globalEval"))}ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td,v.option||(ge.optgroup=ge.option=[1,"<select multiple='multiple'>","</select>"]);var me=/<|&#?\w+;/;function xe(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===w(o))S.merge(p,o.nodeType?[o]:o);else if(me.test(o)){a=a||f.appendChild(t.createElement("div")),s=(de.exec(o)||["",""])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+S.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;S.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<S.inArray(o,r))i&&i.push(o);else if(l=ie(o),a=ye(f.appendChild(o),"script"),l&&ve(a),n){c=0;while(o=a[c++])he.test(o.type||"")&&n.push(o)}return f}var be=/^([^.]*)(?:\.(.+)|)/;function we(){return!0}function Te(){return!1}function Ce(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==("focus"===t)}function Ee(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)Ee(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Te;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return S().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=S.guid++)),e.each(function(){S.event.add(this,t,i,r,n)})}function Se(e,i,o){o?(Y.set(e,i,!1),S.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Y.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(S.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Y.set(this,i,r),t=o(this,i),this[i](),r!==(n=Y.get(this,i))||t?Y.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n&&n.value}else r.length&&(Y.set(this,i,{value:S.event.trigger(S.extend(r[0],S.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Y.get(e,i)&&S.event.add(e,i,we)}S.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,y=Y.get(t);if(V(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&S.find.matchesSelector(re,i),n.guid||(n.guid=S.guid++),(u=y.events)||(u=y.events=Object.create(null)),(a=y.handle)||(a=y.handle=function(e){return"undefined"!=typeof S&&S.event.triggered!==e.type?S.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(P)||[""]).length;while(l--)d=g=(s=be.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=S.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=S.event.special[d]||{},c=S.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&S.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),S.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,y=Y.hasData(e)&&Y.get(e);if(y&&(u=y.events)){l=(t=(t||"").match(P)||[""]).length;while(l--)if(d=g=(s=be.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=S.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,y.handle)||S.removeEvent(e,d,y.handle),delete u[d])}else for(d in u)S.event.remove(e,d+t[l],n,r,!0);S.isEmptyObject(u)&&Y.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=S.event.fix(e),l=(Y.get(this,"events")||Object.create(null))[u.type]||[],c=S.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=S.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((S.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<S(i,this).index(l):S.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(S.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[S.expando]?e:new S.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&Se(t,"click",we),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&Se(t,"click"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,"input")&&Y.get(t,"click")||A(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},S.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},S.Event=function(e,t){if(!(this instanceof S.Event))return new S.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?we:Te,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&S.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[S.expando]=!0},S.Event.prototype={constructor:S.Event,isDefaultPrevented:Te,isPropagationStopped:Te,isImmediatePropagationStopped:Te,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=we,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=we,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=we,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},S.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:!0},S.event.addProp),S.each({focus:"focusin",blur:"focusout"},function(t,e){S.event.special[t]={setup:function(){return Se(this,t,Ce),!1},trigger:function(){return Se(this,t),!0},_default:function(e){return Y.get(e.target,t)},delegateType:e}}),S.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){S.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||S.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),S.fn.extend({on:function(e,t,n,r){return Ee(this,e,t,n,r)},one:function(e,t,n,r){return Ee(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,S(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=Te),this.each(function(){S.event.remove(this,e,n,t)})}});var ke=/<script|<style|<link/i,Ae=/checked\s*(?:[^=]|=\s*.checked.)/i,Ne=/^\s*<!\[CDATA\[|\]\]>\s*$/g;function je(e,t){return A(e,"table")&&A(11!==t.nodeType?t:t.firstChild,"tr")&&S(e).children("tbody")[0]||e}function De(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function qe(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Le(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(Y.hasData(e)&&(s=Y.get(e).events))for(i in Y.remove(t,"handle events"),s)for(n=0,r=s[i].length;n<r;n++)S.event.add(t,i,s[i][n]);Q.hasData(e)&&(o=Q.access(e),a=S.extend({},o),Q.set(t,a))}}function He(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&"string"==typeof d&&!v.checkClone&&Ae.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),He(t,r,i,o)});if(f&&(t=(e=xe(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=S.map(ye(e,"script"),De)).length;c<f;c++)u=e,c!==p&&(u=S.clone(u,!0,!0),s&&S.merge(a,ye(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,S.map(a,qe),c=0;c<s;c++)u=a[c],he.test(u.type||"")&&!Y.access(u,"globalEval")&&S.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?S._evalUrl&&!u.noModule&&S._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")},l):b(u.textContent.replace(Ne,""),u,l))}return n}function Oe(e,t,n){for(var r,i=t?S.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||S.cleanData(ye(r)),r.parentNode&&(n&&ie(r)&&ve(ye(r,"script")),r.parentNode.removeChild(r));return e}S.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=ie(e);if(!(v.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||S.isXMLDoc(e)))for(a=ye(c),r=0,i=(o=ye(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ye(e),a=a||ye(c),r=0,i=o.length;r<i;r++)Le(o[r],a[r]);else Le(e,c);return 0<(a=ye(c,"script")).length&&ve(a,!f&&ye(e,"script")),c},cleanData:function(e){for(var t,n,r,i=S.event.special,o=0;void 0!==(n=e[o]);o++)if(V(n)){if(t=n[Y.expando]){if(t.events)for(r in t.events)i[r]?S.event.remove(n,r):S.removeEvent(n,r,t.handle);n[Y.expando]=void 0}n[Q.expando]&&(n[Q.expando]=void 0)}}}),S.fn.extend({detach:function(e){return Oe(this,e,!0)},remove:function(e){return Oe(this,e)},text:function(e){return B(this,function(e){return void 0===e?S.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return He(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||je(this,e).appendChild(e)})},prepend:function(){return He(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=je(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return He(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return He(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(S.cleanData(ye(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return S.clone(this,e,t)})},html:function(e){return B(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!ke.test(e)&&!ge[(de.exec(e)||["",""])[1].toLowerCase()]){e=S.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(S.cleanData(ye(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return He(this,arguments,function(e){var t=this.parentNode;S.inArray(this,n)<0&&(S.cleanData(ye(this)),t&&t.replaceChild(e,this))},n)}}),S.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){S.fn[e]=function(e){for(var t,n=[],r=S(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),S(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var Pe=new RegExp("^("+ee+")(?!px)[a-z%]+$","i"),Re=/^--/,Me=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},Ie=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},We=new RegExp(ne.join("|"),"i"),Fe="[\\x20\\t\\r\\n\\f]",$e=new RegExp("^"+Fe+"+|((?:^|[^\\\\])(?:\\\\.)*)"+Fe+"+$","g");function Be(e,t,n){var r,i,o,a,s=Re.test(t),u=e.style;return(n=n||Me(e))&&(a=n.getPropertyValue(t)||n[t],s&&(a=a.replace($e,"$1")),""!==a||ie(e)||(a=S.style(e,t)),!v.pixelBoxStyles()&&Pe.test(a)&&We.test(t)&&(r=u.width,i=u.minWidth,o=u.maxWidth,u.minWidth=u.maxWidth=u.width=a,a=n.width,u.width=r,u.minWidth=i,u.maxWidth=o)),void 0!==a?a+"":a}function _e(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",l.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",re.appendChild(u).appendChild(l);var e=C.getComputedStyle(l);n="1%"!==e.top,s=12===t(e.marginLeft),l.style.right="60%",o=36===t(e.right),r=36===t(e.width),l.style.position="absolute",i=12===t(l.offsetWidth/3),re.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=E.createElement("div"),l=E.createElement("div");l.style&&(l.style.backgroundClip="content-box",l.cloneNode(!0).style.backgroundClip="",v.clearCloneStyle="content-box"===l.style.backgroundClip,S.extend(v,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=E.createElement("table"),t=E.createElement("tr"),n=E.createElement("div"),e.style.cssText="position:absolute;left:-11111px;border-collapse:separate",t.style.cssText="border:1px solid",t.style.height="1px",n.style.height="9px",n.style.display="block",re.appendChild(e).appendChild(t).appendChild(n),r=C.getComputedStyle(t),a=parseInt(r.height,10)+parseInt(r.borderTopWidth,10)+parseInt(r.borderBottomWidth,10)===t.offsetHeight,re.removeChild(e)),a}}))}();var ze=["Webkit","Moz","ms"],Ue=E.createElement("div").style,Xe={};function Ve(e){var t=S.cssProps[e]||Xe[e];return t||(e in Ue?e:Xe[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=ze.length;while(n--)if((e=ze[n]+t)in Ue)return e}(e)||e)}var Ge=/^(none|table(?!-c[ea]).+)/,Ye={position:"absolute",visibility:"hidden",display:"block"},Qe={letterSpacing:"0",fontWeight:"400"};function Je(e,t,n){var r=te.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function Ke(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(u+=S.css(e,n+ne[a],!0,i)),r?("content"===n&&(u-=S.css(e,"padding"+ne[a],!0,i)),"margin"!==n&&(u-=S.css(e,"border"+ne[a]+"Width",!0,i))):(u+=S.css(e,"padding"+ne[a],!0,i),"padding"!==n?u+=S.css(e,"border"+ne[a]+"Width",!0,i):s+=S.css(e,"border"+ne[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function Ze(e,t,n){var r=Me(e),i=(!v.boxSizingReliable()||n)&&"border-box"===S.css(e,"boxSizing",!1,r),o=i,a=Be(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if(Pe.test(a)){if(!n)return a;a="auto"}return(!v.boxSizingReliable()&&i||!v.reliableTrDimensions()&&A(e,"tr")||"auto"===a||!parseFloat(a)&&"inline"===S.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===S.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+Ke(e,t,n||(i?"border":"content"),o,r,a)+"px"}function et(e,t,n,r,i){return new et.prototype.init(e,t,n,r,i)}S.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Be(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=X(t),u=Re.test(t),l=e.style;if(u||(t=Ve(s)),a=S.cssHooks[t]||S.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=te.exec(n))&&i[1]&&(n=se(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(S.cssNumber[s]?"":"px")),v.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=X(t);return Re.test(t)||(t=Ve(s)),(a=S.cssHooks[t]||S.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=Be(e,t,r)),"normal"===i&&t in Qe&&(i=Qe[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),S.each(["height","width"],function(e,u){S.cssHooks[u]={get:function(e,t,n){if(t)return!Ge.test(S.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?Ze(e,u,n):Ie(e,Ye,function(){return Ze(e,u,n)})},set:function(e,t,n){var r,i=Me(e),o=!v.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===S.css(e,"boxSizing",!1,i),s=n?Ke(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-Ke(e,u,"border",!1,i)-.5)),s&&(r=te.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=S.css(e,u)),Je(0,t,s)}}}),S.cssHooks.marginLeft=_e(v.reliableMarginLeft,function(e,t){if(t)return(parseFloat(Be(e,"marginLeft"))||e.getBoundingClientRect().left-Ie(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),S.each({margin:"",padding:"",border:"Width"},function(i,o){S.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+ne[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(S.cssHooks[i+o].set=Je)}),S.fn.extend({css:function(e,t){return B(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Me(e),i=t.length;a<i;a++)o[t[a]]=S.css(e,t[a],!1,r);return o}return void 0!==n?S.style(e,t,n):S.css(e,t)},e,t,1<arguments.length)}}),((S.Tween=et).prototype={constructor:et,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||S.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(S.cssNumber[n]?"":"px")},cur:function(){var e=et.propHooks[this.prop];return e&&e.get?e.get(this):et.propHooks._default.get(this)},run:function(e){var t,n=et.propHooks[this.prop];return this.options.duration?this.pos=t=S.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):et.propHooks._default.set(this),this}}).init.prototype=et.prototype,(et.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=S.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){S.fx.step[e.prop]?S.fx.step[e.prop](e):1!==e.elem.nodeType||!S.cssHooks[e.prop]&&null==e.elem.style[Ve(e.prop)]?e.elem[e.prop]=e.now:S.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=et.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},S.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},S.fx=et.prototype.init,S.fx.step={};var tt,nt,rt,it,ot=/^(?:toggle|show|hide)$/,at=/queueHooks$/;function st(){nt&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(st):C.setTimeout(st,S.fx.interval),S.fx.tick())}function ut(){return C.setTimeout(function(){tt=void 0}),tt=Date.now()}function lt(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=ne[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function ct(e,t,n){for(var r,i=(ft.tweeners[t]||[]).concat(ft.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function ft(o,e,t){var n,a,r=0,i=ft.prefilters.length,s=S.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=tt||ut(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:S.extend({},e),opts:S.extend(!0,{specialEasing:{},easing:S.easing._default},t),originalProperties:e,originalOptions:t,startTime:tt||ut(),duration:t.duration,tweens:[],createTween:function(e,t){var n=S.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=X(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=S.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=ft.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(S._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return S.map(c,ct,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),S.fx.timer(S.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}S.Animation=S.extend(ft,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return se(n.elem,e,te.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=["*"]):e=e.match(P);for(var n,r=0,i=e.length;r<i;r++)n=e[r],ft.tweeners[n]=ft.tweeners[n]||[],ft.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&ae(e),y=Y.get(e,"fxshow");for(r in n.queue||(null==(a=S._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,S.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],ot.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!y||void 0===y[r])continue;g=!0}d[r]=y&&y[r]||S.style(e,r)}if((u=!S.isEmptyObject(t))||!S.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=y&&y.display)&&(l=Y.get(e,"display")),"none"===(c=S.css(e,"display"))&&(l?c=l:(le([e],!0),l=e.style.display||l,c=S.css(e,"display"),le([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===S.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(y?"hidden"in y&&(g=y.hidden):y=Y.access(e,"fxshow",{display:l}),o&&(y.hidden=!g),g&&le([e],!0),p.done(function(){for(r in g||le([e]),Y.remove(e,"fxshow"),d)S.style(e,r,d[r])})),u=ct(g?y[r]:0,r,p),r in y||(y[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?ft.prefilters.unshift(e):ft.prefilters.push(e)}}),S.speed=function(e,t,n){var r=e&&"object"==typeof e?S.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return S.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in S.fx.speeds?r.duration=S.fx.speeds[r.duration]:r.duration=S.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&S.dequeue(this,r.queue)},r},S.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ae).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=S.isEmptyObject(t),o=S.speed(e,n,r),a=function(){var e=ft(this,S.extend({},t),o);(i||Y.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=S.timers,r=Y.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&at.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||S.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=Y.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=S.timers,o=n?n.length:0;for(t.finish=!0,S.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),S.each(["toggle","show","hide"],function(e,r){var i=S.fn[r];S.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(lt(r,!0),e,t,n)}}),S.each({slideDown:lt("show"),slideUp:lt("hide"),slideToggle:lt("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){S.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),S.timers=[],S.fx.tick=function(){var e,t=0,n=S.timers;for(tt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||S.fx.stop(),tt=void 0},S.fx.timer=function(e){S.timers.push(e),S.fx.start()},S.fx.interval=13,S.fx.start=function(){nt||(nt=!0,st())},S.fx.stop=function(){nt=null},S.fx.speeds={slow:600,fast:200,_default:400},S.fn.delay=function(r,e){return r=S.fx&&S.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},rt=E.createElement("input"),it=E.createElement("select").appendChild(E.createElement("option")),rt.type="checkbox",v.checkOn=""!==rt.value,v.optSelected=it.selected,(rt=E.createElement("input")).value="t",rt.type="radio",v.radioValue="t"===rt.value;var pt,dt=S.expr.attrHandle;S.fn.extend({attr:function(e,t){return B(this,S.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){S.removeAttr(this,e)})}}),S.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?S.prop(e,t,n):(1===o&&S.isXMLDoc(e)||(i=S.attrHooks[t.toLowerCase()]||(S.expr.match.bool.test(t)?pt:void 0)),void 0!==n?null===n?void S.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=S.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!v.radioValue&&"radio"===t&&A(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(P);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),pt={set:function(e,t,n){return!1===t?S.removeAttr(e,n):e.setAttribute(n,n),n}},S.each(S.expr.match.bool.source.match(/\w+/g),function(e,t){var a=dt[t]||S.find.attr;dt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=dt[o],dt[o]=r,r=null!=a(e,t,n)?o:null,dt[o]=i),r}});var ht=/^(?:input|select|textarea|button)$/i,gt=/^(?:a|area)$/i;function yt(e){return(e.match(P)||[]).join(" ")}function vt(e){return e.getAttribute&&e.getAttribute("class")||""}function mt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(P)||[]}S.fn.extend({prop:function(e,t){return B(this,S.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[S.propFix[e]||e]})}}),S.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&S.isXMLDoc(e)||(t=S.propFix[t]||t,i=S.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=S.find.attr(e,"tabindex");return t?parseInt(t,10):ht.test(e.nodeName)||gt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),v.optSelected||(S.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),S.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){S.propFix[this.toLowerCase()]=this}),S.fn.extend({addClass:function(t){var e,n,r,i,o,a;return m(t)?this.each(function(e){S(this).addClass(t.call(this,e,vt(this)))}):(e=mt(t)).length?this.each(function(){if(r=vt(this),n=1===this.nodeType&&" "+yt(r)+" "){for(o=0;o<e.length;o++)i=e[o],n.indexOf(" "+i+" ")<0&&(n+=i+" ");a=yt(n),r!==a&&this.setAttribute("class",a)}}):this},removeClass:function(t){var e,n,r,i,o,a;return m(t)?this.each(function(e){S(this).removeClass(t.call(this,e,vt(this)))}):arguments.length?(e=mt(t)).length?this.each(function(){if(r=vt(this),n=1===this.nodeType&&" "+yt(r)+" "){for(o=0;o<e.length;o++){i=e[o];while(-1<n.indexOf(" "+i+" "))n=n.replace(" "+i+" "," ")}a=yt(n),r!==a&&this.setAttribute("class",a)}}):this:this.attr("class","")},toggleClass:function(t,n){var e,r,i,o,a=typeof t,s="string"===a||Array.isArray(t);return m(t)?this.each(function(e){S(this).toggleClass(t.call(this,e,vt(this),n),n)}):"boolean"==typeof n&&s?n?this.addClass(t):this.removeClass(t):(e=mt(t),this.each(function(){if(s)for(o=S(this),i=0;i<e.length;i++)r=e[i],o.hasClass(r)?o.removeClass(r):o.addClass(r);else void 0!==t&&"boolean"!==a||((r=vt(this))&&Y.set(this,"__className__",r),this.setAttribute&&this.setAttribute("class",r||!1===t?"":Y.get(this,"__className__")||""))}))},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+yt(vt(n))+" ").indexOf(t))return!0;return!1}});var xt=/\r/g;S.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,S(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=S.map(t,function(e){return null==e?"":e+""})),(r=S.valHooks[this.type]||S.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=S.valHooks[t.type]||S.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(xt,""):null==e?"":e:void 0}}),S.extend({valHooks:{option:{get:function(e){var t=S.find.attr(e,"value");return null!=t?t:yt(S.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,"optgroup"))){if(t=S(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=S.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<S.inArray(S.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),S.each(["radio","checkbox"],function(){S.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<S.inArray(S(e).val(),t)}},v.checkOn||(S.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),v.focusin="onfocusin"in C;var bt=/^(?:focusinfocus|focusoutblur)$/,wt=function(e){e.stopPropagation()};S.extend(S.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=y.call(e,"type")?e.type:e,h=y.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!bt.test(d+S.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[S.expando]?e:new S.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:S.makeArray(t,[e]),c=S.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,bt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Y.get(o,"events")||Object.create(null))[e.type]&&Y.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&V(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!V(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),S.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,wt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,wt),S.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=S.extend(new S.Event,n,{type:e,isSimulated:!0});S.event.trigger(r,null,t)}}),S.fn.extend({trigger:function(e,t){return this.each(function(){S.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return S.event.trigger(e,t,n,!0)}}),v.focusin||S.each({focus:"focusin",blur:"focusout"},function(n,r){var i=function(e){S.event.simulate(r,e.target,S.event.fix(e))};S.event.special[r]={setup:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r);t||e.addEventListener(n,i,!0),Y.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r)-1;t?Y.access(e,r,t):(e.removeEventListener(n,i,!0),Y.remove(e,r))}}});var Tt=C.location,Ct={guid:Date.now()},Et=/\?/;S.parseXML=function(e){var t,n;if(!e||"string"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,"text/xml")}catch(e){}return n=t&&t.getElementsByTagName("parsererror")[0],t&&!n||S.error("Invalid XML: "+(n?S.map(n.childNodes,function(e){return e.textContent}).join("\n"):e)),t};var St=/\[\]$/,kt=/\r?\n/g,At=/^(?:submit|button|image|reset|file)$/i,Nt=/^(?:input|select|textarea|keygen)/i;function jt(n,e,r,i){var t;if(Array.isArray(e))S.each(e,function(e,t){r||St.test(n)?i(n,t):jt(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==w(e))i(n,e);else for(t in e)jt(n+"["+t+"]",e[t],r,i)}S.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!S.isPlainObject(e))S.each(e,function(){i(this.name,this.value)});else for(n in e)jt(n,e[n],t,i);return r.join("&")},S.fn.extend({serialize:function(){return S.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=S.prop(this,"elements");return e?S.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!S(this).is(":disabled")&&Nt.test(this.nodeName)&&!At.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=S(this).val();return null==n?null:Array.isArray(n)?S.map(n,function(e){return{name:t.name,value:e.replace(kt,"\r\n")}}):{name:t.name,value:n.replace(kt,"\r\n")}}).get()}});var Dt=/%20/g,qt=/#.*$/,Lt=/([?&])_=[^&]*/,Ht=/^(.*?):[ \t]*([^\r\n]*)$/gm,Ot=/^(?:GET|HEAD)$/,Pt=/^\/\//,Rt={},Mt={},It="*/".concat("*"),Wt=E.createElement("a");function Ft(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(P)||[];if(m(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function $t(t,i,o,a){var s={},u=t===Mt;function l(e){var r;return s[e]=!0,S.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function Bt(e,t){var n,r,i=S.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&S.extend(!0,e,r),e}Wt.href=Tt.href,S.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Tt.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Tt.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":It,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":S.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?Bt(Bt(e,S.ajaxSettings),t):Bt(S.ajaxSettings,e)},ajaxPrefilter:Ft(Rt),ajaxTransport:Ft(Mt),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,y=S.ajaxSetup({},t),v=y.context||y,m=y.context&&(v.nodeType||v.jquery)?S(v):S.event,x=S.Deferred(),b=S.Callbacks("once memory"),w=y.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Ht.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(y.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),y.url=((e||y.url||Tt.href)+"").replace(Pt,Tt.protocol+"//"),y.type=t.method||t.type||y.method||y.type,y.dataTypes=(y.dataType||"*").toLowerCase().match(P)||[""],null==y.crossDomain){r=E.createElement("a");try{r.href=y.url,r.href=r.href,y.crossDomain=Wt.protocol+"//"+Wt.host!=r.protocol+"//"+r.host}catch(e){y.crossDomain=!0}}if(y.data&&y.processData&&"string"!=typeof y.data&&(y.data=S.param(y.data,y.traditional)),$t(Rt,y,t,T),h)return T;for(i in(g=S.event&&y.global)&&0==S.active++&&S.event.trigger("ajaxStart"),y.type=y.type.toUpperCase(),y.hasContent=!Ot.test(y.type),f=y.url.replace(qt,""),y.hasContent?y.data&&y.processData&&0===(y.contentType||"").indexOf("application/x-www-form-urlencoded")&&(y.data=y.data.replace(Dt,"+")):(o=y.url.slice(f.length),y.data&&(y.processData||"string"==typeof y.data)&&(f+=(Et.test(f)?"&":"?")+y.data,delete y.data),!1===y.cache&&(f=f.replace(Lt,"$1"),o=(Et.test(f)?"&":"?")+"_="+Ct.guid+++o),y.url=f+o),y.ifModified&&(S.lastModified[f]&&T.setRequestHeader("If-Modified-Since",S.lastModified[f]),S.etag[f]&&T.setRequestHeader("If-None-Match",S.etag[f])),(y.data&&y.hasContent&&!1!==y.contentType||t.contentType)&&T.setRequestHeader("Content-Type",y.contentType),T.setRequestHeader("Accept",y.dataTypes[0]&&y.accepts[y.dataTypes[0]]?y.accepts[y.dataTypes[0]]+("*"!==y.dataTypes[0]?", "+It+"; q=0.01":""):y.accepts["*"]),y.headers)T.setRequestHeader(i,y.headers[i]);if(y.beforeSend&&(!1===y.beforeSend.call(v,T,y)||h))return T.abort();if(u="abort",b.add(y.complete),T.done(y.success),T.fail(y.error),c=$t(Mt,y,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,y]),h)return T;y.async&&0<y.timeout&&(d=C.setTimeout(function(){T.abort("timeout")},y.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(y,T,n)),!i&&-1<S.inArray("script",y.dataTypes)&&S.inArray("json",y.dataTypes)<0&&(y.converters["text script"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(y,s,T,i),i?(y.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(S.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(S.etag[f]=u)),204===e||"HEAD"===y.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(v,[o,l,T]):x.rejectWith(v,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,y,i?o:a]),b.fireWith(v,[T,l]),g&&(m.trigger("ajaxComplete",[T,y]),--S.active||S.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return S.get(e,t,n,"json")},getScript:function(e,t){return S.get(e,void 0,t,"script")}}),S.each(["get","post"],function(e,i){S[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),S.ajax(S.extend({url:e,type:i,dataType:r,data:t,success:n},S.isPlainObject(e)&&e))}}),S.ajaxPrefilter(function(e){var t;for(t in e.headers)"content-type"===t.toLowerCase()&&(e.contentType=e.headers[t]||"")}),S._evalUrl=function(e,t,n){return S.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){S.globalEval(e,t,n)}})},S.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=S(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){S(this).wrapInner(n.call(this,e))}):this.each(function(){var e=S(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){S(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){S(this).replaceWith(this.childNodes)}),this}}),S.expr.pseudos.hidden=function(e){return!S.expr.pseudos.visible(e)},S.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},S.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var _t={0:200,1223:204},zt=S.ajaxSettings.xhr();v.cors=!!zt&&"withCredentials"in zt,v.ajax=zt=!!zt,S.ajaxTransport(function(i){var o,a;if(v.cors||zt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(_t[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),S.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),S.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return S.globalEval(e),e}}}),S.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),S.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=S("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var Ut,Xt=[],Vt=/(=)\?(?=&|$)|\?\?/;S.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Xt.pop()||S.expando+"_"+Ct.guid++;return this[e]=!0,e}}),S.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Vt.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Vt.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Vt,"$1"+r):!1!==e.jsonp&&(e.url+=(Et.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||S.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?S(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Xt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),"script"}),v.createHTMLDocument=((Ut=E.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Ut.childNodes.length),S.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(v.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument("")).createElement("base")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=N.exec(e))?[t.createElement(i[1])]:(i=xe([e],t,o),o&&o.length&&S(o).remove(),S.merge([],i.childNodes)));var r,i,o},S.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=yt(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&S.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?S("<div>").append(S.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},S.expr.pseudos.animated=function(t){return S.grep(S.timers,function(e){return t===e.elem}).length},S.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=S.css(e,"position"),c=S(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=S.css(e,"top"),u=S.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,S.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):c.css(f)}},S.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){S.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===S.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===S.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=S(e).offset()).top+=S.css(e,"borderTopWidth",!0),i.left+=S.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-S.css(r,"marginTop",!0),left:t.left-i.left-S.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===S.css(e,"position"))e=e.offsetParent;return e||re})}}),S.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;S.fn[t]=function(e){return B(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),S.each(["top","left"],function(e,n){S.cssHooks[n]=_e(v.pixelPosition,function(e,t){if(t)return t=Be(e,n),Pe.test(t)?S(e).position()[n]+"px":t})}),S.each({Height:"height",Width:"width"},function(a,s){S.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){S.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return B(this,function(e,t,n){var r;return x(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?S.css(e,t,i):S.style(e,t,n,i)},s,n?e:void 0,n)}})}),S.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){S.fn[t]=function(e){return this.on(t,e)}}),S.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){S.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var Gt=/^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;S.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||S.guid++,i},S.holdReady=function(e){e?S.readyWait++:S.ready(!0)},S.isArray=Array.isArray,S.parseJSON=JSON.parse,S.nodeName=A,S.isFunction=m,S.isWindow=x,S.camelCase=X,S.type=w,S.now=Date.now,S.isNumeric=function(e){var t=S.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},S.trim=function(e){return null==e?"":(e+"").replace(Gt,"$1")},"function"==typeof define&&define.amd&&define("jquery",[],function(){return S});var Yt=C.jQuery,Qt=C.$;return S.noConflict=function(e){return C.$===S&&(C.$=Qt),e&&C.jQuery===S&&(C.jQuery=Yt),S},"undefined"==typeof e&&(C.jQuery=C.$=S),S});
/**
 * Swiper 8.4.7
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2023 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: January 30, 2023
 */

!function (e, t) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).Swiper = t()
}(this, (function () {
    "use strict";

    function e(e) {
        return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object
    }

    function t(s, a) {
        void 0 === s && (s = {}), void 0 === a && (a = {}), Object.keys(a).forEach((i => {
            void 0 === s[i] ? s[i] = a[i] : e(a[i]) && e(s[i]) && Object.keys(a[i]).length > 0 && t(s[i], a[i])
        }))
    }

    const s = {
        body: {},
        addEventListener() {
        },
        removeEventListener() {
        },
        activeElement: {
            blur() {
            }, nodeName: ""
        },
        querySelector: () => null,
        querySelectorAll: () => [],
        getElementById: () => null,
        createEvent: () => ({
            initEvent() {
            }
        }),
        createElement: () => ({
            children: [], childNodes: [], style: {}, setAttribute() {
            }, getElementsByTagName: () => []
        }),
        createElementNS: () => ({}),
        importNode: () => null,
        location: {hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: ""}
    };

    function a() {
        const e = "undefined" != typeof document ? document : {};
        return t(e, s), e
    }

    const i = {
        document: s,
        navigator: {userAgent: ""},
        location: {hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: ""},
        history: {
            replaceState() {
            }, pushState() {
            }, go() {
            }, back() {
            }
        },
        CustomEvent: function () {
            return this
        },
        addEventListener() {
        },
        removeEventListener() {
        },
        getComputedStyle: () => ({getPropertyValue: () => ""}),
        Image() {
        },
        Date() {
        },
        screen: {},
        setTimeout() {
        },
        clearTimeout() {
        },
        matchMedia: () => ({}),
        requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0),
        cancelAnimationFrame(e) {
            "undefined" != typeof setTimeout && clearTimeout(e)
        }
    };

    function r() {
        const e = "undefined" != typeof window ? window : {};
        return t(e, i), e
    }

    class n extends Array {
        constructor(e) {
            "number" == typeof e ? super(e) : (super(...e || []), function (e) {
                const t = e.__proto__;
                Object.defineProperty(e, "__proto__", {
                    get: () => t, set(e) {
                        t.__proto__ = e
                    }
                })
            }(this))
        }
    }

    function l(e) {
        void 0 === e && (e = []);
        const t = [];
        return e.forEach((e => {
            Array.isArray(e) ? t.push(...l(e)) : t.push(e)
        })), t
    }

    function o(e, t) {
        return Array.prototype.filter.call(e, t)
    }

    function d(e, t) {
        const s = r(), i = a();
        let l = [];
        if (!t && e instanceof n) return e;
        if (!e) return new n(l);
        if ("string" == typeof e) {
            const s = e.trim();
            if (s.indexOf("<") >= 0 && s.indexOf(">") >= 0) {
                let e = "div";
                0 === s.indexOf("<li") && (e = "ul"), 0 === s.indexOf("<tr") && (e = "tbody"), 0 !== s.indexOf("<td") && 0 !== s.indexOf("<th") || (e = "tr"), 0 === s.indexOf("<tbody") && (e = "table"), 0 === s.indexOf("<option") && (e = "select");
                const t = i.createElement(e);
                t.innerHTML = s;
                for (let e = 0; e < t.childNodes.length; e += 1) l.push(t.childNodes[e])
            } else l = function (e, t) {
                if ("string" != typeof e) return [e];
                const s = [], a = t.querySelectorAll(e);
                for (let e = 0; e < a.length; e += 1) s.push(a[e]);
                return s
            }(e.trim(), t || i)
        } else if (e.nodeType || e === s || e === i) l.push(e); else if (Array.isArray(e)) {
            if (e instanceof n) return e;
            l = e
        }
        return new n(function (e) {
            const t = [];
            for (let s = 0; s < e.length; s += 1) -1 === t.indexOf(e[s]) && t.push(e[s]);
            return t
        }(l))
    }

    d.fn = n.prototype;
    const c = {
        addClass: function () {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];
            const a = l(t.map((e => e.split(" "))));
            return this.forEach((e => {
                e.classList.add(...a)
            })), this
        }, removeClass: function () {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];
            const a = l(t.map((e => e.split(" "))));
            return this.forEach((e => {
                e.classList.remove(...a)
            })), this
        }, hasClass: function () {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];
            const a = l(t.map((e => e.split(" "))));
            return o(this, (e => a.filter((t => e.classList.contains(t))).length > 0)).length > 0
        }, toggleClass: function () {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];
            const a = l(t.map((e => e.split(" "))));
            this.forEach((e => {
                a.forEach((t => {
                    e.classList.toggle(t)
                }))
            }))
        }, attr: function (e, t) {
            if (1 === arguments.length && "string" == typeof e) return this[0] ? this[0].getAttribute(e) : void 0;
            for (let s = 0; s < this.length; s += 1) if (2 === arguments.length) this[s].setAttribute(e, t); else for (const t in e) this[s][t] = e[t], this[s].setAttribute(t, e[t]);
            return this
        }, removeAttr: function (e) {
            for (let t = 0; t < this.length; t += 1) this[t].removeAttribute(e);
            return this
        }, transform: function (e) {
            for (let t = 0; t < this.length; t += 1) this[t].style.transform = e;
            return this
        }, transition: function (e) {
            for (let t = 0; t < this.length; t += 1) this[t].style.transitionDuration = "string" != typeof e ? `${e}ms` : e;
            return this
        }, on: function () {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];
            let [a, i, r, n] = t;

            function l(e) {
                const t = e.target;
                if (!t) return;
                const s = e.target.dom7EventData || [];
                if (s.indexOf(e) < 0 && s.unshift(e), d(t).is(i)) r.apply(t, s); else {
                    const e = d(t).parents();
                    for (let t = 0; t < e.length; t += 1) d(e[t]).is(i) && r.apply(e[t], s)
                }
            }

            function o(e) {
                const t = e && e.target && e.target.dom7EventData || [];
                t.indexOf(e) < 0 && t.unshift(e), r.apply(this, t)
            }

            "function" == typeof t[1] && ([a, r, n] = t, i = void 0), n || (n = !1);
            const c = a.split(" ");
            let p;
            for (let e = 0; e < this.length; e += 1) {
                const t = this[e];
                if (i) for (p = 0; p < c.length; p += 1) {
                    const e = c[p];
                    t.dom7LiveListeners || (t.dom7LiveListeners = {}), t.dom7LiveListeners[e] || (t.dom7LiveListeners[e] = []), t.dom7LiveListeners[e].push({
                        listener: r,
                        proxyListener: l
                    }), t.addEventListener(e, l, n)
                } else for (p = 0; p < c.length; p += 1) {
                    const e = c[p];
                    t.dom7Listeners || (t.dom7Listeners = {}), t.dom7Listeners[e] || (t.dom7Listeners[e] = []), t.dom7Listeners[e].push({
                        listener: r,
                        proxyListener: o
                    }), t.addEventListener(e, o, n)
                }
            }
            return this
        }, off: function () {
            for (var e = arguments.length, t = new Array(e), s = 0; s < e; s++) t[s] = arguments[s];
            let [a, i, r, n] = t;
            "function" == typeof t[1] && ([a, r, n] = t, i = void 0), n || (n = !1);
            const l = a.split(" ");
            for (let e = 0; e < l.length; e += 1) {
                const t = l[e];
                for (let e = 0; e < this.length; e += 1) {
                    const s = this[e];
                    let a;
                    if (!i && s.dom7Listeners ? a = s.dom7Listeners[t] : i && s.dom7LiveListeners && (a = s.dom7LiveListeners[t]), a && a.length) for (let e = a.length - 1; e >= 0; e -= 1) {
                        const i = a[e];
                        r && i.listener === r || r && i.listener && i.listener.dom7proxy && i.listener.dom7proxy === r ? (s.removeEventListener(t, i.proxyListener, n), a.splice(e, 1)) : r || (s.removeEventListener(t, i.proxyListener, n), a.splice(e, 1))
                    }
                }
            }
            return this
        }, trigger: function () {
            const e = r();
            for (var t = arguments.length, s = new Array(t), a = 0; a < t; a++) s[a] = arguments[a];
            const i = s[0].split(" "), n = s[1];
            for (let t = 0; t < i.length; t += 1) {
                const a = i[t];
                for (let t = 0; t < this.length; t += 1) {
                    const i = this[t];
                    if (e.CustomEvent) {
                        const t = new e.CustomEvent(a, {detail: n, bubbles: !0, cancelable: !0});
                        i.dom7EventData = s.filter(((e, t) => t > 0)), i.dispatchEvent(t), i.dom7EventData = [], delete i.dom7EventData
                    }
                }
            }
            return this
        }, transitionEnd: function (e) {
            const t = this;
            return e && t.on("transitionend", (function s(a) {
                a.target === this && (e.call(this, a), t.off("transitionend", s))
            })), this
        }, outerWidth: function (e) {
            if (this.length > 0) {
                if (e) {
                    const e = this.styles();
                    return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left"))
                }
                return this[0].offsetWidth
            }
            return null
        }, outerHeight: function (e) {
            if (this.length > 0) {
                if (e) {
                    const e = this.styles();
                    return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom"))
                }
                return this[0].offsetHeight
            }
            return null
        }, styles: function () {
            const e = r();
            return this[0] ? e.getComputedStyle(this[0], null) : {}
        }, offset: function () {
            if (this.length > 0) {
                const e = r(), t = a(), s = this[0], i = s.getBoundingClientRect(), n = t.body,
                    l = s.clientTop || n.clientTop || 0, o = s.clientLeft || n.clientLeft || 0,
                    d = s === e ? e.scrollY : s.scrollTop, c = s === e ? e.scrollX : s.scrollLeft;
                return {top: i.top + d - l, left: i.left + c - o}
            }
            return null
        }, css: function (e, t) {
            const s = r();
            let a;
            if (1 === arguments.length) {
                if ("string" != typeof e) {
                    for (a = 0; a < this.length; a += 1) for (const t in e) this[a].style[t] = e[t];
                    return this
                }
                if (this[0]) return s.getComputedStyle(this[0], null).getPropertyValue(e)
            }
            if (2 === arguments.length && "string" == typeof e) {
                for (a = 0; a < this.length; a += 1) this[a].style[e] = t;
                return this
            }
            return this
        }, each: function (e) {
            return e ? (this.forEach(((t, s) => {
                e.apply(t, [t, s])
            })), this) : this
        }, html: function (e) {
            if (void 0 === e) return this[0] ? this[0].innerHTML : null;
            for (let t = 0; t < this.length; t += 1) this[t].innerHTML = e;
            return this
        }, text: function (e) {
            if (void 0 === e) return this[0] ? this[0].textContent.trim() : null;
            for (let t = 0; t < this.length; t += 1) this[t].textContent = e;
            return this
        }, is: function (e) {
            const t = r(), s = a(), i = this[0];
            let l, o;
            if (!i || void 0 === e) return !1;
            if ("string" == typeof e) {
                if (i.matches) return i.matches(e);
                if (i.webkitMatchesSelector) return i.webkitMatchesSelector(e);
                if (i.msMatchesSelector) return i.msMatchesSelector(e);
                for (l = d(e), o = 0; o < l.length; o += 1) if (l[o] === i) return !0;
                return !1
            }
            if (e === s) return i === s;
            if (e === t) return i === t;
            if (e.nodeType || e instanceof n) {
                for (l = e.nodeType ? [e] : e, o = 0; o < l.length; o += 1) if (l[o] === i) return !0;
                return !1
            }
            return !1
        }, index: function () {
            let e, t = this[0];
            if (t) {
                for (e = 0; null !== (t = t.previousSibling);) 1 === t.nodeType && (e += 1);
                return e
            }
        }, eq: function (e) {
            if (void 0 === e) return this;
            const t = this.length;
            if (e > t - 1) return d([]);
            if (e < 0) {
                const s = t + e;
                return d(s < 0 ? [] : [this[s]])
            }
            return d([this[e]])
        }, append: function () {
            let e;
            const t = a();
            for (let s = 0; s < arguments.length; s += 1) {
                e = s < 0 || arguments.length <= s ? void 0 : arguments[s];
                for (let s = 0; s < this.length; s += 1) if ("string" == typeof e) {
                    const a = t.createElement("div");
                    for (a.innerHTML = e; a.firstChild;) this[s].appendChild(a.firstChild)
                } else if (e instanceof n) for (let t = 0; t < e.length; t += 1) this[s].appendChild(e[t]); else this[s].appendChild(e)
            }
            return this
        }, prepend: function (e) {
            const t = a();
            let s, i;
            for (s = 0; s < this.length; s += 1) if ("string" == typeof e) {
                const a = t.createElement("div");
                for (a.innerHTML = e, i = a.childNodes.length - 1; i >= 0; i -= 1) this[s].insertBefore(a.childNodes[i], this[s].childNodes[0])
            } else if (e instanceof n) for (i = 0; i < e.length; i += 1) this[s].insertBefore(e[i], this[s].childNodes[0]); else this[s].insertBefore(e, this[s].childNodes[0]);
            return this
        }, next: function (e) {
            return this.length > 0 ? e ? this[0].nextElementSibling && d(this[0].nextElementSibling).is(e) ? d([this[0].nextElementSibling]) : d([]) : this[0].nextElementSibling ? d([this[0].nextElementSibling]) : d([]) : d([])
        }, nextAll: function (e) {
            const t = [];
            let s = this[0];
            if (!s) return d([]);
            for (; s.nextElementSibling;) {
                const a = s.nextElementSibling;
                e ? d(a).is(e) && t.push(a) : t.push(a), s = a
            }
            return d(t)
        }, prev: function (e) {
            if (this.length > 0) {
                const t = this[0];
                return e ? t.previousElementSibling && d(t.previousElementSibling).is(e) ? d([t.previousElementSibling]) : d([]) : t.previousElementSibling ? d([t.previousElementSibling]) : d([])
            }
            return d([])
        }, prevAll: function (e) {
            const t = [];
            let s = this[0];
            if (!s) return d([]);
            for (; s.previousElementSibling;) {
                const a = s.previousElementSibling;
                e ? d(a).is(e) && t.push(a) : t.push(a), s = a
            }
            return d(t)
        }, parent: function (e) {
            const t = [];
            for (let s = 0; s < this.length; s += 1) null !== this[s].parentNode && (e ? d(this[s].parentNode).is(e) && t.push(this[s].parentNode) : t.push(this[s].parentNode));
            return d(t)
        }, parents: function (e) {
            const t = [];
            for (let s = 0; s < this.length; s += 1) {
                let a = this[s].parentNode;
                for (; a;) e ? d(a).is(e) && t.push(a) : t.push(a), a = a.parentNode
            }
            return d(t)
        }, closest: function (e) {
            let t = this;
            return void 0 === e ? d([]) : (t.is(e) || (t = t.parents(e).eq(0)), t)
        }, find: function (e) {
            const t = [];
            for (let s = 0; s < this.length; s += 1) {
                const a = this[s].querySelectorAll(e);
                for (let e = 0; e < a.length; e += 1) t.push(a[e])
            }
            return d(t)
        }, children: function (e) {
            const t = [];
            for (let s = 0; s < this.length; s += 1) {
                const a = this[s].children;
                for (let s = 0; s < a.length; s += 1) e && !d(a[s]).is(e) || t.push(a[s])
            }
            return d(t)
        }, filter: function (e) {
            return d(o(this, e))
        }, remove: function () {
            for (let e = 0; e < this.length; e += 1) this[e].parentNode && this[e].parentNode.removeChild(this[e]);
            return this
        }
    };

    function p(e, t) {
        return void 0 === t && (t = 0), setTimeout(e, t)
    }

    function u() {
        return Date.now()
    }

    function h(e, t) {
        void 0 === t && (t = "x");
        const s = r();
        let a, i, n;
        const l = function (e) {
            const t = r();
            let s;
            return t.getComputedStyle && (s = t.getComputedStyle(e, null)), !s && e.currentStyle && (s = e.currentStyle), s || (s = e.style), s
        }(e);
        return s.WebKitCSSMatrix ? (i = l.transform || l.webkitTransform, i.split(",").length > 6 && (i = i.split(", ").map((e => e.replace(",", "."))).join(", ")), n = new s.WebKitCSSMatrix("none" === i ? "" : i)) : (n = l.MozTransform || l.OTransform || l.MsTransform || l.msTransform || l.transform || l.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), a = n.toString().split(",")), "x" === t && (i = s.WebKitCSSMatrix ? n.m41 : 16 === a.length ? parseFloat(a[12]) : parseFloat(a[4])), "y" === t && (i = s.WebKitCSSMatrix ? n.m42 : 16 === a.length ? parseFloat(a[13]) : parseFloat(a[5])), i || 0
    }

    function m(e) {
        return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1)
    }

    function f(e) {
        return "undefined" != typeof window && void 0 !== window.HTMLElement ? e instanceof HTMLElement : e && (1 === e.nodeType || 11 === e.nodeType)
    }

    function g() {
        const e = Object(arguments.length <= 0 ? void 0 : arguments[0]), t = ["__proto__", "constructor", "prototype"];
        for (let s = 1; s < arguments.length; s += 1) {
            const a = s < 0 || arguments.length <= s ? void 0 : arguments[s];
            if (null != a && !f(a)) {
                const s = Object.keys(Object(a)).filter((e => t.indexOf(e) < 0));
                for (let t = 0, i = s.length; t < i; t += 1) {
                    const i = s[t], r = Object.getOwnPropertyDescriptor(a, i);
                    void 0 !== r && r.enumerable && (m(e[i]) && m(a[i]) ? a[i].__swiper__ ? e[i] = a[i] : g(e[i], a[i]) : !m(e[i]) && m(a[i]) ? (e[i] = {}, a[i].__swiper__ ? e[i] = a[i] : g(e[i], a[i])) : e[i] = a[i])
                }
            }
        }
        return e
    }

    function v(e, t, s) {
        e.style.setProperty(t, s)
    }

    function w(e) {
        let {swiper: t, targetPosition: s, side: a} = e;
        const i = r(), n = -t.translate;
        let l, o = null;
        const d = t.params.speed;
        t.wrapperEl.style.scrollSnapType = "none", i.cancelAnimationFrame(t.cssModeFrameID);
        const c = s > n ? "next" : "prev", p = (e, t) => "next" === c && e >= t || "prev" === c && e <= t, u = () => {
            l = (new Date).getTime(), null === o && (o = l);
            const e = Math.max(Math.min((l - o) / d, 1), 0), r = .5 - Math.cos(e * Math.PI) / 2;
            let c = n + r * (s - n);
            if (p(c, s) && (c = s), t.wrapperEl.scrollTo({[a]: c}), p(c, s)) return t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout((() => {
                t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({[a]: c})
            })), void i.cancelAnimationFrame(t.cssModeFrameID);
            t.cssModeFrameID = i.requestAnimationFrame(u)
        };
        u()
    }

    let b, x, y;

    function E() {
        return b || (b = function () {
            const e = r(), t = a();
            return {
                smoothScroll: t.documentElement && "scrollBehavior" in t.documentElement.style,
                touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch),
                passiveListener: function () {
                    let t = !1;
                    try {
                        const s = Object.defineProperty({}, "passive", {
                            get() {
                                t = !0
                            }
                        });
                        e.addEventListener("testPassiveListener", null, s)
                    } catch (e) {
                    }
                    return t
                }(),
                gestures: "ongesturestart" in e
            }
        }()), b
    }

    function C(e) {
        return void 0 === e && (e = {}), x || (x = function (e) {
            let {userAgent: t} = void 0 === e ? {} : e;
            const s = E(), a = r(), i = a.navigator.platform, n = t || a.navigator.userAgent,
                l = {ios: !1, android: !1}, o = a.screen.width, d = a.screen.height,
                c = n.match(/(Android);?[\s\/]+([\d.]+)?/);
            let p = n.match(/(iPad).*OS\s([\d_]+)/);
            const u = n.match(/(iPod)(.*OS\s([\d_]+))?/), h = !p && n.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
                m = "Win32" === i;
            let f = "MacIntel" === i;
            return !p && f && s.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${o}x${d}`) >= 0 && (p = n.match(/(Version)\/([\d.]+)/), p || (p = [0, 1, "13_0_0"]), f = !1), c && !m && (l.os = "android", l.android = !0), (p || h || u) && (l.os = "ios", l.ios = !0), l
        }(e)), x
    }

    function T() {
        return y || (y = function () {
            const e = r();
            return {
                isSafari: function () {
                    const t = e.navigator.userAgent.toLowerCase();
                    return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0
                }(), isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent)
            }
        }()), y
    }

    Object.keys(c).forEach((e => {
        Object.defineProperty(d.fn, e, {value: c[e], writable: !0})
    }));
    var $ = {
        on(e, t, s) {
            const a = this;
            if (!a.eventsListeners || a.destroyed) return a;
            if ("function" != typeof t) return a;
            const i = s ? "unshift" : "push";
            return e.split(" ").forEach((e => {
                a.eventsListeners[e] || (a.eventsListeners[e] = []), a.eventsListeners[e][i](t)
            })), a
        }, once(e, t, s) {
            const a = this;
            if (!a.eventsListeners || a.destroyed) return a;
            if ("function" != typeof t) return a;

            function i() {
                a.off(e, i), i.__emitterProxy && delete i.__emitterProxy;
                for (var s = arguments.length, r = new Array(s), n = 0; n < s; n++) r[n] = arguments[n];
                t.apply(a, r)
            }

            return i.__emitterProxy = t, a.on(e, i, s)
        }, onAny(e, t) {
            const s = this;
            if (!s.eventsListeners || s.destroyed) return s;
            if ("function" != typeof e) return s;
            const a = t ? "unshift" : "push";
            return s.eventsAnyListeners.indexOf(e) < 0 && s.eventsAnyListeners[a](e), s
        }, offAny(e) {
            const t = this;
            if (!t.eventsListeners || t.destroyed) return t;
            if (!t.eventsAnyListeners) return t;
            const s = t.eventsAnyListeners.indexOf(e);
            return s >= 0 && t.eventsAnyListeners.splice(s, 1), t
        }, off(e, t) {
            const s = this;
            return !s.eventsListeners || s.destroyed ? s : s.eventsListeners ? (e.split(" ").forEach((e => {
                void 0 === t ? s.eventsListeners[e] = [] : s.eventsListeners[e] && s.eventsListeners[e].forEach(((a, i) => {
                    (a === t || a.__emitterProxy && a.__emitterProxy === t) && s.eventsListeners[e].splice(i, 1)
                }))
            })), s) : s
        }, emit() {
            const e = this;
            if (!e.eventsListeners || e.destroyed) return e;
            if (!e.eventsListeners) return e;
            let t, s, a;
            for (var i = arguments.length, r = new Array(i), n = 0; n < i; n++) r[n] = arguments[n];
            "string" == typeof r[0] || Array.isArray(r[0]) ? (t = r[0], s = r.slice(1, r.length), a = e) : (t = r[0].events, s = r[0].data, a = r[0].context || e), s.unshift(a);
            return (Array.isArray(t) ? t : t.split(" ")).forEach((t => {
                e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach((e => {
                    e.apply(a, [t, ...s])
                })), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach((e => {
                    e.apply(a, s)
                }))
            })), e
        }
    };
    var S = {
        updateSize: function () {
            const e = this;
            let t, s;
            const a = e.$el;
            t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : a[0].clientWidth, s = void 0 !== e.params.height && null !== e.params.height ? e.params.height : a[0].clientHeight, 0 === t && e.isHorizontal() || 0 === s && e.isVertical() || (t = t - parseInt(a.css("padding-left") || 0, 10) - parseInt(a.css("padding-right") || 0, 10), s = s - parseInt(a.css("padding-top") || 0, 10) - parseInt(a.css("padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(s) && (s = 0), Object.assign(e, {
                width: t,
                height: s,
                size: e.isHorizontal() ? t : s
            }))
        }, updateSlides: function () {
            const e = this;

            function t(t) {
                return e.isHorizontal() ? t : {
                    width: "height",
                    "margin-top": "margin-left",
                    "margin-bottom ": "margin-right",
                    "margin-left": "margin-top",
                    "margin-right": "margin-bottom",
                    "padding-left": "padding-top",
                    "padding-right": "padding-bottom",
                    marginRight: "marginBottom"
                }[t]
            }

            function s(e, s) {
                return parseFloat(e.getPropertyValue(t(s)) || 0)
            }

            const a = e.params, {$wrapperEl: i, size: r, rtlTranslate: n, wrongRTL: l} = e,
                o = e.virtual && a.virtual.enabled, d = o ? e.virtual.slides.length : e.slides.length,
                c = i.children(`.${e.params.slideClass}`), p = o ? e.virtual.slides.length : c.length;
            let u = [];
            const h = [], m = [];
            let f = a.slidesOffsetBefore;
            "function" == typeof f && (f = a.slidesOffsetBefore.call(e));
            let g = a.slidesOffsetAfter;
            "function" == typeof g && (g = a.slidesOffsetAfter.call(e));
            const w = e.snapGrid.length, b = e.slidesGrid.length;
            let x = a.spaceBetween, y = -f, E = 0, C = 0;
            if (void 0 === r) return;
            "string" == typeof x && x.indexOf("%") >= 0 && (x = parseFloat(x.replace("%", "")) / 100 * r), e.virtualSize = -x, n ? c.css({
                marginLeft: "",
                marginBottom: "",
                marginTop: ""
            }) : c.css({
                marginRight: "",
                marginBottom: "",
                marginTop: ""
            }), a.centeredSlides && a.cssMode && (v(e.wrapperEl, "--swiper-centered-offset-before", ""), v(e.wrapperEl, "--swiper-centered-offset-after", ""));
            const T = a.grid && a.grid.rows > 1 && e.grid;
            let $;
            T && e.grid.initSlides(p);
            const S = "auto" === a.slidesPerView && a.breakpoints && Object.keys(a.breakpoints).filter((e => void 0 !== a.breakpoints[e].slidesPerView)).length > 0;
            for (let i = 0; i < p; i += 1) {
                $ = 0;
                const n = c.eq(i);
                if (T && e.grid.updateSlide(i, n, p, t), "none" !== n.css("display")) {
                    if ("auto" === a.slidesPerView) {
                        S && (c[i].style[t("width")] = "");
                        const r = getComputedStyle(n[0]), l = n[0].style.transform, o = n[0].style.webkitTransform;
                        if (l && (n[0].style.transform = "none"), o && (n[0].style.webkitTransform = "none"), a.roundLengths) $ = e.isHorizontal() ? n.outerWidth(!0) : n.outerHeight(!0); else {
                            const e = s(r, "width"), t = s(r, "padding-left"), a = s(r, "padding-right"),
                                i = s(r, "margin-left"), l = s(r, "margin-right"), o = r.getPropertyValue("box-sizing");
                            if (o && "border-box" === o) $ = e + i + l; else {
                                const {clientWidth: s, offsetWidth: r} = n[0];
                                $ = e + t + a + i + l + (r - s)
                            }
                        }
                        l && (n[0].style.transform = l), o && (n[0].style.webkitTransform = o), a.roundLengths && ($ = Math.floor($))
                    } else $ = (r - (a.slidesPerView - 1) * x) / a.slidesPerView, a.roundLengths && ($ = Math.floor($)), c[i] && (c[i].style[t("width")] = `${$}px`);
                    c[i] && (c[i].swiperSlideSize = $), m.push($), a.centeredSlides ? (y = y + $ / 2 + E / 2 + x, 0 === E && 0 !== i && (y = y - r / 2 - x), 0 === i && (y = y - r / 2 - x), Math.abs(y) < .001 && (y = 0), a.roundLengths && (y = Math.floor(y)), C % a.slidesPerGroup == 0 && u.push(y), h.push(y)) : (a.roundLengths && (y = Math.floor(y)), (C - Math.min(e.params.slidesPerGroupSkip, C)) % e.params.slidesPerGroup == 0 && u.push(y), h.push(y), y = y + $ + x), e.virtualSize += $ + x, E = $, C += 1
                }
            }
            if (e.virtualSize = Math.max(e.virtualSize, r) + g, n && l && ("slide" === a.effect || "coverflow" === a.effect) && i.css({width: `${e.virtualSize + a.spaceBetween}px`}), a.setWrapperSize && i.css({[t("width")]: `${e.virtualSize + a.spaceBetween}px`}), T && e.grid.updateWrapperSize($, u, t), !a.centeredSlides) {
                const t = [];
                for (let s = 0; s < u.length; s += 1) {
                    let i = u[s];
                    a.roundLengths && (i = Math.floor(i)), u[s] <= e.virtualSize - r && t.push(i)
                }
                u = t, Math.floor(e.virtualSize - r) - Math.floor(u[u.length - 1]) > 1 && u.push(e.virtualSize - r)
            }
            if (0 === u.length && (u = [0]), 0 !== a.spaceBetween) {
                const s = e.isHorizontal() && n ? "marginLeft" : t("marginRight");
                c.filter(((e, t) => !a.cssMode || t !== c.length - 1)).css({[s]: `${x}px`})
            }
            if (a.centeredSlides && a.centeredSlidesBounds) {
                let e = 0;
                m.forEach((t => {
                    e += t + (a.spaceBetween ? a.spaceBetween : 0)
                })), e -= a.spaceBetween;
                const t = e - r;
                u = u.map((e => e < 0 ? -f : e > t ? t + g : e))
            }
            if (a.centerInsufficientSlides) {
                let e = 0;
                if (m.forEach((t => {
                    e += t + (a.spaceBetween ? a.spaceBetween : 0)
                })), e -= a.spaceBetween, e < r) {
                    const t = (r - e) / 2;
                    u.forEach(((e, s) => {
                        u[s] = e - t
                    })), h.forEach(((e, s) => {
                        h[s] = e + t
                    }))
                }
            }
            if (Object.assign(e, {
                slides: c,
                snapGrid: u,
                slidesGrid: h,
                slidesSizesGrid: m
            }), a.centeredSlides && a.cssMode && !a.centeredSlidesBounds) {
                v(e.wrapperEl, "--swiper-centered-offset-before", -u[0] + "px"), v(e.wrapperEl, "--swiper-centered-offset-after", e.size / 2 - m[m.length - 1] / 2 + "px");
                const t = -e.snapGrid[0], s = -e.slidesGrid[0];
                e.snapGrid = e.snapGrid.map((e => e + t)), e.slidesGrid = e.slidesGrid.map((e => e + s))
            }
            if (p !== d && e.emit("slidesLengthChange"), u.length !== w && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), h.length !== b && e.emit("slidesGridLengthChange"), a.watchSlidesProgress && e.updateSlidesOffset(), !(o || a.cssMode || "slide" !== a.effect && "fade" !== a.effect)) {
                const t = `${a.containerModifierClass}backface-hidden`, s = e.$el.hasClass(t);
                p <= a.maxBackfaceHiddenSlides ? s || e.$el.addClass(t) : s && e.$el.removeClass(t)
            }
        }, updateAutoHeight: function (e) {
            const t = this, s = [], a = t.virtual && t.params.virtual.enabled;
            let i, r = 0;
            "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed);
            const n = e => a ? t.slides.filter((t => parseInt(t.getAttribute("data-swiper-slide-index"), 10) === e))[0] : t.slides.eq(e)[0];
            if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1) if (t.params.centeredSlides) (t.visibleSlides || d([])).each((e => {
                s.push(e)
            })); else for (i = 0; i < Math.ceil(t.params.slidesPerView); i += 1) {
                const e = t.activeIndex + i;
                if (e > t.slides.length && !a) break;
                s.push(n(e))
            } else s.push(n(t.activeIndex));
            for (i = 0; i < s.length; i += 1) if (void 0 !== s[i]) {
                const e = s[i].offsetHeight;
                r = e > r ? e : r
            }
            (r || 0 === r) && t.$wrapperEl.css("height", `${r}px`)
        }, updateSlidesOffset: function () {
            const e = this, t = e.slides;
            for (let s = 0; s < t.length; s += 1) t[s].swiperSlideOffset = e.isHorizontal() ? t[s].offsetLeft : t[s].offsetTop
        }, updateSlidesProgress: function (e) {
            void 0 === e && (e = this && this.translate || 0);
            const t = this, s = t.params, {slides: a, rtlTranslate: i, snapGrid: r} = t;
            if (0 === a.length) return;
            void 0 === a[0].swiperSlideOffset && t.updateSlidesOffset();
            let n = -e;
            i && (n = e), a.removeClass(s.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = [];
            for (let e = 0; e < a.length; e += 1) {
                const l = a[e];
                let o = l.swiperSlideOffset;
                s.cssMode && s.centeredSlides && (o -= a[0].swiperSlideOffset);
                const d = (n + (s.centeredSlides ? t.minTranslate() : 0) - o) / (l.swiperSlideSize + s.spaceBetween),
                    c = (n - r[0] + (s.centeredSlides ? t.minTranslate() : 0) - o) / (l.swiperSlideSize + s.spaceBetween),
                    p = -(n - o), u = p + t.slidesSizesGrid[e];
                (p >= 0 && p < t.size - 1 || u > 1 && u <= t.size || p <= 0 && u >= t.size) && (t.visibleSlides.push(l), t.visibleSlidesIndexes.push(e), a.eq(e).addClass(s.slideVisibleClass)), l.progress = i ? -d : d, l.originalProgress = i ? -c : c
            }
            t.visibleSlides = d(t.visibleSlides)
        }, updateProgress: function (e) {
            const t = this;
            if (void 0 === e) {
                const s = t.rtlTranslate ? -1 : 1;
                e = t && t.translate && t.translate * s || 0
            }
            const s = t.params, a = t.maxTranslate() - t.minTranslate();
            let {progress: i, isBeginning: r, isEnd: n} = t;
            const l = r, o = n;
            0 === a ? (i = 0, r = !0, n = !0) : (i = (e - t.minTranslate()) / a, r = i <= 0, n = i >= 1), Object.assign(t, {
                progress: i,
                isBeginning: r,
                isEnd: n
            }), (s.watchSlidesProgress || s.centeredSlides && s.autoHeight) && t.updateSlidesProgress(e), r && !l && t.emit("reachBeginning toEdge"), n && !o && t.emit("reachEnd toEdge"), (l && !r || o && !n) && t.emit("fromEdge"), t.emit("progress", i)
        }, updateSlidesClasses: function () {
            const e = this, {slides: t, params: s, $wrapperEl: a, activeIndex: i, realIndex: r} = e,
                n = e.virtual && s.virtual.enabled;
            let l;
            t.removeClass(`${s.slideActiveClass} ${s.slideNextClass} ${s.slidePrevClass} ${s.slideDuplicateActiveClass} ${s.slideDuplicateNextClass} ${s.slideDuplicatePrevClass}`), l = n ? e.$wrapperEl.find(`.${s.slideClass}[data-swiper-slide-index="${i}"]`) : t.eq(i), l.addClass(s.slideActiveClass), s.loop && (l.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${r}"]`).addClass(s.slideDuplicateActiveClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${r}"]`).addClass(s.slideDuplicateActiveClass));
            let o = l.nextAll(`.${s.slideClass}`).eq(0).addClass(s.slideNextClass);
            s.loop && 0 === o.length && (o = t.eq(0), o.addClass(s.slideNextClass));
            let d = l.prevAll(`.${s.slideClass}`).eq(0).addClass(s.slidePrevClass);
            s.loop && 0 === d.length && (d = t.eq(-1), d.addClass(s.slidePrevClass)), s.loop && (o.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${o.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicateNextClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${o.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicateNextClass), d.hasClass(s.slideDuplicateClass) ? a.children(`.${s.slideClass}:not(.${s.slideDuplicateClass})[data-swiper-slide-index="${d.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicatePrevClass) : a.children(`.${s.slideClass}.${s.slideDuplicateClass}[data-swiper-slide-index="${d.attr("data-swiper-slide-index")}"]`).addClass(s.slideDuplicatePrevClass)), e.emitSlidesClasses()
        }, updateActiveIndex: function (e) {
            const t = this, s = t.rtlTranslate ? t.translate : -t.translate, {
                slidesGrid: a,
                snapGrid: i,
                params: r,
                activeIndex: n,
                realIndex: l,
                snapIndex: o
            } = t;
            let d, c = e;
            if (void 0 === c) {
                for (let e = 0; e < a.length; e += 1) void 0 !== a[e + 1] ? s >= a[e] && s < a[e + 1] - (a[e + 1] - a[e]) / 2 ? c = e : s >= a[e] && s < a[e + 1] && (c = e + 1) : s >= a[e] && (c = e);
                r.normalizeSlideIndex && (c < 0 || void 0 === c) && (c = 0)
            }
            if (i.indexOf(s) >= 0) d = i.indexOf(s); else {
                const e = Math.min(r.slidesPerGroupSkip, c);
                d = e + Math.floor((c - e) / r.slidesPerGroup)
            }
            if (d >= i.length && (d = i.length - 1), c === n) return void (d !== o && (t.snapIndex = d, t.emit("snapIndexChange")));
            const p = parseInt(t.slides.eq(c).attr("data-swiper-slide-index") || c, 10);
            Object.assign(t, {
                snapIndex: d,
                realIndex: p,
                previousIndex: n,
                activeIndex: c
            }), t.emit("activeIndexChange"), t.emit("snapIndexChange"), l !== p && t.emit("realIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange")
        }, updateClickedSlide: function (e) {
            const t = this, s = t.params, a = d(e).closest(`.${s.slideClass}`)[0];
            let i, r = !1;
            if (a) for (let e = 0; e < t.slides.length; e += 1) if (t.slides[e] === a) {
                r = !0, i = e;
                break
            }
            if (!a || !r) return t.clickedSlide = void 0, void (t.clickedIndex = void 0);
            t.clickedSlide = a, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(d(a).attr("data-swiper-slide-index"), 10) : t.clickedIndex = i, s.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide()
        }
    };
    var M = {
        getTranslate: function (e) {
            void 0 === e && (e = this.isHorizontal() ? "x" : "y");
            const {params: t, rtlTranslate: s, translate: a, $wrapperEl: i} = this;
            if (t.virtualTranslate) return s ? -a : a;
            if (t.cssMode) return a;
            let r = h(i[0], e);
            return s && (r = -r), r || 0
        }, setTranslate: function (e, t) {
            const s = this, {rtlTranslate: a, params: i, $wrapperEl: r, wrapperEl: n, progress: l} = s;
            let o, d = 0, c = 0;
            s.isHorizontal() ? d = a ? -e : e : c = e, i.roundLengths && (d = Math.floor(d), c = Math.floor(c)), i.cssMode ? n[s.isHorizontal() ? "scrollLeft" : "scrollTop"] = s.isHorizontal() ? -d : -c : i.virtualTranslate || r.transform(`translate3d(${d}px, ${c}px, 0px)`), s.previousTranslate = s.translate, s.translate = s.isHorizontal() ? d : c;
            const p = s.maxTranslate() - s.minTranslate();
            o = 0 === p ? 0 : (e - s.minTranslate()) / p, o !== l && s.updateProgress(e), s.emit("setTranslate", s.translate, t)
        }, minTranslate: function () {
            return -this.snapGrid[0]
        }, maxTranslate: function () {
            return -this.snapGrid[this.snapGrid.length - 1]
        }, translateTo: function (e, t, s, a, i) {
            void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), void 0 === a && (a = !0);
            const r = this, {params: n, wrapperEl: l} = r;
            if (r.animating && n.preventInteractionOnTransition) return !1;
            const o = r.minTranslate(), d = r.maxTranslate();
            let c;
            if (c = a && e > o ? o : a && e < d ? d : e, r.updateProgress(c), n.cssMode) {
                const e = r.isHorizontal();
                if (0 === t) l[e ? "scrollLeft" : "scrollTop"] = -c; else {
                    if (!r.support.smoothScroll) return w({
                        swiper: r,
                        targetPosition: -c,
                        side: e ? "left" : "top"
                    }), !0;
                    l.scrollTo({[e ? "left" : "top"]: -c, behavior: "smooth"})
                }
                return !0
            }
            return 0 === t ? (r.setTransition(0), r.setTranslate(c), s && (r.emit("beforeTransitionStart", t, i), r.emit("transitionEnd"))) : (r.setTransition(t), r.setTranslate(c), s && (r.emit("beforeTransitionStart", t, i), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function (e) {
                r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, s && r.emit("transitionEnd"))
            }), r.$wrapperEl[0].addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd))), !0
        }
    };

    function P(e) {
        let {swiper: t, runCallbacks: s, direction: a, step: i} = e;
        const {activeIndex: r, previousIndex: n} = t;
        let l = a;
        if (l || (l = r > n ? "next" : r < n ? "prev" : "reset"), t.emit(`transition${i}`), s && r !== n) {
            if ("reset" === l) return void t.emit(`slideResetTransition${i}`);
            t.emit(`slideChangeTransition${i}`), "next" === l ? t.emit(`slideNextTransition${i}`) : t.emit(`slidePrevTransition${i}`)
        }
    }

    var k = {
        slideTo: function (e, t, s, a, i) {
            if (void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), "number" != typeof e && "string" != typeof e) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof e}] given.`);
            if ("string" == typeof e) {
                const t = parseInt(e, 10);
                if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`);
                e = t
            }
            const r = this;
            let n = e;
            n < 0 && (n = 0);
            const {
                params: l,
                snapGrid: o,
                slidesGrid: d,
                previousIndex: c,
                activeIndex: p,
                rtlTranslate: u,
                wrapperEl: h,
                enabled: m
            } = r;
            if (r.animating && l.preventInteractionOnTransition || !m && !a && !i) return !1;
            const f = Math.min(r.params.slidesPerGroupSkip, n);
            let g = f + Math.floor((n - f) / r.params.slidesPerGroup);
            g >= o.length && (g = o.length - 1);
            const v = -o[g];
            if (l.normalizeSlideIndex) for (let e = 0; e < d.length; e += 1) {
                const t = -Math.floor(100 * v), s = Math.floor(100 * d[e]), a = Math.floor(100 * d[e + 1]);
                void 0 !== d[e + 1] ? t >= s && t < a - (a - s) / 2 ? n = e : t >= s && t < a && (n = e + 1) : t >= s && (n = e)
            }
            if (r.initialized && n !== p) {
                if (!r.allowSlideNext && v < r.translate && v < r.minTranslate()) return !1;
                if (!r.allowSlidePrev && v > r.translate && v > r.maxTranslate() && (p || 0) !== n) return !1
            }
            let b;
            if (n !== (c || 0) && s && r.emit("beforeSlideChangeStart"), r.updateProgress(v), b = n > p ? "next" : n < p ? "prev" : "reset", u && -v === r.translate || !u && v === r.translate) return r.updateActiveIndex(n), l.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), "slide" !== l.effect && r.setTranslate(v), "reset" !== b && (r.transitionStart(s, b), r.transitionEnd(s, b)), !1;
            if (l.cssMode) {
                const e = r.isHorizontal(), s = u ? v : -v;
                if (0 === t) {
                    const t = r.virtual && r.params.virtual.enabled;
                    t && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), h[e ? "scrollLeft" : "scrollTop"] = s, t && requestAnimationFrame((() => {
                        r.wrapperEl.style.scrollSnapType = "", r._swiperImmediateVirtual = !1
                    }))
                } else {
                    if (!r.support.smoothScroll) return w({swiper: r, targetPosition: s, side: e ? "left" : "top"}), !0;
                    h.scrollTo({[e ? "left" : "top"]: s, behavior: "smooth"})
                }
                return !0
            }
            return r.setTransition(t), r.setTranslate(v), r.updateActiveIndex(n), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, a), r.transitionStart(s, b), 0 === t ? r.transitionEnd(s, b) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function (e) {
                r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(s, b))
            }), r.$wrapperEl[0].addEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd)), !0
        }, slideToLoop: function (e, t, s, a) {
            if (void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), "string" == typeof e) {
                const t = parseInt(e, 10);
                if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`);
                e = t
            }
            const i = this;
            let r = e;
            return i.params.loop && (r += i.loopedSlides), i.slideTo(r, t, s, a)
        }, slideNext: function (e, t, s) {
            void 0 === e && (e = this.params.speed), void 0 === t && (t = !0);
            const a = this, {animating: i, enabled: r, params: n} = a;
            if (!r) return a;
            let l = n.slidesPerGroup;
            "auto" === n.slidesPerView && 1 === n.slidesPerGroup && n.slidesPerGroupAuto && (l = Math.max(a.slidesPerViewDynamic("current", !0), 1));
            const o = a.activeIndex < n.slidesPerGroupSkip ? 1 : l;
            if (n.loop) {
                if (i && n.loopPreventsSlide) return !1;
                a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft
            }
            return n.rewind && a.isEnd ? a.slideTo(0, e, t, s) : a.slideTo(a.activeIndex + o, e, t, s)
        }, slidePrev: function (e, t, s) {
            void 0 === e && (e = this.params.speed), void 0 === t && (t = !0);
            const a = this, {params: i, animating: r, snapGrid: n, slidesGrid: l, rtlTranslate: o, enabled: d} = a;
            if (!d) return a;
            if (i.loop) {
                if (r && i.loopPreventsSlide) return !1;
                a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft
            }

            function c(e) {
                return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e)
            }

            const p = c(o ? a.translate : -a.translate), u = n.map((e => c(e)));
            let h = n[u.indexOf(p) - 1];
            if (void 0 === h && i.cssMode) {
                let e;
                n.forEach(((t, s) => {
                    p >= t && (e = s)
                })), void 0 !== e && (h = n[e > 0 ? e - 1 : e])
            }
            let m = 0;
            if (void 0 !== h && (m = l.indexOf(h), m < 0 && (m = a.activeIndex - 1), "auto" === i.slidesPerView && 1 === i.slidesPerGroup && i.slidesPerGroupAuto && (m = m - a.slidesPerViewDynamic("previous", !0) + 1, m = Math.max(m, 0))), i.rewind && a.isBeginning) {
                const i = a.params.virtual && a.params.virtual.enabled && a.virtual ? a.virtual.slides.length - 1 : a.slides.length - 1;
                return a.slideTo(i, e, t, s)
            }
            return a.slideTo(m, e, t, s)
        }, slideReset: function (e, t, s) {
            return void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), this.slideTo(this.activeIndex, e, t, s)
        }, slideToClosest: function (e, t, s, a) {
            void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), void 0 === a && (a = .5);
            const i = this;
            let r = i.activeIndex;
            const n = Math.min(i.params.slidesPerGroupSkip, r), l = n + Math.floor((r - n) / i.params.slidesPerGroup),
                o = i.rtlTranslate ? i.translate : -i.translate;
            if (o >= i.snapGrid[l]) {
                const e = i.snapGrid[l];
                o - e > (i.snapGrid[l + 1] - e) * a && (r += i.params.slidesPerGroup)
            } else {
                const e = i.snapGrid[l - 1];
                o - e <= (i.snapGrid[l] - e) * a && (r -= i.params.slidesPerGroup)
            }
            return r = Math.max(r, 0), r = Math.min(r, i.slidesGrid.length - 1), i.slideTo(r, e, t, s)
        }, slideToClickedSlide: function () {
            const e = this, {params: t, $wrapperEl: s} = e,
                a = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView;
            let i, r = e.clickedIndex;
            if (t.loop) {
                if (e.animating) return;
                i = parseInt(d(e.clickedSlide).attr("data-swiper-slide-index"), 10), t.centeredSlides ? r < e.loopedSlides - a / 2 || r > e.slides.length - e.loopedSlides + a / 2 ? (e.loopFix(), r = s.children(`.${t.slideClass}[data-swiper-slide-index="${i}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), p((() => {
                    e.slideTo(r)
                }))) : e.slideTo(r) : r > e.slides.length - a ? (e.loopFix(), r = s.children(`.${t.slideClass}[data-swiper-slide-index="${i}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), p((() => {
                    e.slideTo(r)
                }))) : e.slideTo(r)
            } else e.slideTo(r)
        }
    };
    var z = {
        loopCreate: function () {
            const e = this, t = a(), {params: s, $wrapperEl: i} = e,
                r = i.children().length > 0 ? d(i.children()[0].parentNode) : i;
            r.children(`.${s.slideClass}.${s.slideDuplicateClass}`).remove();
            let n = r.children(`.${s.slideClass}`);
            if (s.loopFillGroupWithBlank) {
                const e = s.slidesPerGroup - n.length % s.slidesPerGroup;
                if (e !== s.slidesPerGroup) {
                    for (let a = 0; a < e; a += 1) {
                        const e = d(t.createElement("div")).addClass(`${s.slideClass} ${s.slideBlankClass}`);
                        r.append(e)
                    }
                    n = r.children(`.${s.slideClass}`)
                }
            }
            "auto" !== s.slidesPerView || s.loopedSlides || (s.loopedSlides = n.length), e.loopedSlides = Math.ceil(parseFloat(s.loopedSlides || s.slidesPerView, 10)), e.loopedSlides += s.loopAdditionalSlides, e.loopedSlides > n.length && e.params.loopedSlidesLimit && (e.loopedSlides = n.length);
            const l = [], o = [];
            n.each(((e, t) => {
                d(e).attr("data-swiper-slide-index", t)
            }));
            for (let t = 0; t < e.loopedSlides; t += 1) {
                const e = t - Math.floor(t / n.length) * n.length;
                o.push(n.eq(e)[0]), l.unshift(n.eq(n.length - e - 1)[0])
            }
            for (let e = 0; e < o.length; e += 1) r.append(d(o[e].cloneNode(!0)).addClass(s.slideDuplicateClass));
            for (let e = l.length - 1; e >= 0; e -= 1) r.prepend(d(l[e].cloneNode(!0)).addClass(s.slideDuplicateClass))
        }, loopFix: function () {
            const e = this;
            e.emit("beforeLoopFix");
            const {
                activeIndex: t,
                slides: s,
                loopedSlides: a,
                allowSlidePrev: i,
                allowSlideNext: r,
                snapGrid: n,
                rtlTranslate: l
            } = e;
            let o;
            e.allowSlidePrev = !0, e.allowSlideNext = !0;
            const d = -n[t] - e.getTranslate();
            if (t < a) {
                o = s.length - 3 * a + t, o += a;
                e.slideTo(o, 0, !1, !0) && 0 !== d && e.setTranslate((l ? -e.translate : e.translate) - d)
            } else if (t >= s.length - a) {
                o = -s.length + t + a, o += a;
                e.slideTo(o, 0, !1, !0) && 0 !== d && e.setTranslate((l ? -e.translate : e.translate) - d)
            }
            e.allowSlidePrev = i, e.allowSlideNext = r, e.emit("loopFix")
        }, loopDestroy: function () {
            const {$wrapperEl: e, params: t, slides: s} = this;
            e.children(`.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`).remove(), s.removeAttr("data-swiper-slide-index")
        }
    };

    function L(e) {
        const t = this, s = a(), i = r(), n = t.touchEventsData, {params: l, touches: o, enabled: c} = t;
        if (!c) return;
        if (t.animating && l.preventInteractionOnTransition) return;
        !t.animating && l.cssMode && l.loop && t.loopFix();
        let p = e;
        p.originalEvent && (p = p.originalEvent);
        let h = d(p.target);
        if ("wrapper" === l.touchEventsTarget && !h.closest(t.wrapperEl).length) return;
        if (n.isTouchEvent = "touchstart" === p.type, !n.isTouchEvent && "which" in p && 3 === p.which) return;
        if (!n.isTouchEvent && "button" in p && p.button > 0) return;
        if (n.isTouched && n.isMoved) return;
        const m = !!l.noSwipingClass && "" !== l.noSwipingClass, f = e.composedPath ? e.composedPath() : e.path;
        m && p.target && p.target.shadowRoot && f && (h = d(f[0]));
        const g = l.noSwipingSelector ? l.noSwipingSelector : `.${l.noSwipingClass}`,
            v = !(!p.target || !p.target.shadowRoot);
        if (l.noSwiping && (v ? function (e, t) {
            return void 0 === t && (t = this), function t(s) {
                if (!s || s === a() || s === r()) return null;
                s.assignedSlot && (s = s.assignedSlot);
                const i = s.closest(e);
                return i || s.getRootNode ? i || t(s.getRootNode().host) : null
            }(t)
        }(g, h[0]) : h.closest(g)[0])) return void (t.allowClick = !0);
        if (l.swipeHandler && !h.closest(l.swipeHandler)[0]) return;
        o.currentX = "touchstart" === p.type ? p.targetTouches[0].pageX : p.pageX, o.currentY = "touchstart" === p.type ? p.targetTouches[0].pageY : p.pageY;
        const w = o.currentX, b = o.currentY, x = l.edgeSwipeDetection || l.iOSEdgeSwipeDetection,
            y = l.edgeSwipeThreshold || l.iOSEdgeSwipeThreshold;
        if (x && (w <= y || w >= i.innerWidth - y)) {
            if ("prevent" !== x) return;
            e.preventDefault()
        }
        if (Object.assign(n, {
            isTouched: !0,
            isMoved: !1,
            allowTouchCallbacks: !0,
            isScrolling: void 0,
            startMoving: void 0
        }), o.startX = w, o.startY = b, n.touchStartTime = u(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, l.threshold > 0 && (n.allowThresholdMove = !1), "touchstart" !== p.type) {
            let e = !0;
            h.is(n.focusableElements) && (e = !1, "SELECT" === h[0].nodeName && (n.isTouched = !1)), s.activeElement && d(s.activeElement).is(n.focusableElements) && s.activeElement !== h[0] && s.activeElement.blur();
            const a = e && t.allowTouchMove && l.touchStartPreventDefault;
            !l.touchStartForcePreventDefault && !a || h[0].isContentEditable || p.preventDefault()
        }
        t.params.freeMode && t.params.freeMode.enabled && t.freeMode && t.animating && !l.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", p)
    }

    function O(e) {
        const t = a(), s = this, i = s.touchEventsData, {params: r, touches: n, rtlTranslate: l, enabled: o} = s;
        if (!o) return;
        let c = e;
        if (c.originalEvent && (c = c.originalEvent), !i.isTouched) return void (i.startMoving && i.isScrolling && s.emit("touchMoveOpposite", c));
        if (i.isTouchEvent && "touchmove" !== c.type) return;
        const p = "touchmove" === c.type && c.targetTouches && (c.targetTouches[0] || c.changedTouches[0]),
            h = "touchmove" === c.type ? p.pageX : c.pageX, m = "touchmove" === c.type ? p.pageY : c.pageY;
        if (c.preventedByNestedSwiper) return n.startX = h, void (n.startY = m);
        if (!s.allowTouchMove) return d(c.target).is(i.focusableElements) || (s.allowClick = !1), void (i.isTouched && (Object.assign(n, {
            startX: h,
            startY: m,
            currentX: h,
            currentY: m
        }), i.touchStartTime = u()));
        if (i.isTouchEvent && r.touchReleaseOnEdges && !r.loop) if (s.isVertical()) {
            if (m < n.startY && s.translate <= s.maxTranslate() || m > n.startY && s.translate >= s.minTranslate()) return i.isTouched = !1, void (i.isMoved = !1)
        } else if (h < n.startX && s.translate <= s.maxTranslate() || h > n.startX && s.translate >= s.minTranslate()) return;
        if (i.isTouchEvent && t.activeElement && c.target === t.activeElement && d(c.target).is(i.focusableElements)) return i.isMoved = !0, void (s.allowClick = !1);
        if (i.allowTouchCallbacks && s.emit("touchMove", c), c.targetTouches && c.targetTouches.length > 1) return;
        n.currentX = h, n.currentY = m;
        const f = n.currentX - n.startX, g = n.currentY - n.startY;
        if (s.params.threshold && Math.sqrt(f ** 2 + g ** 2) < s.params.threshold) return;
        if (void 0 === i.isScrolling) {
            let e;
            s.isHorizontal() && n.currentY === n.startY || s.isVertical() && n.currentX === n.startX ? i.isScrolling = !1 : f * f + g * g >= 25 && (e = 180 * Math.atan2(Math.abs(g), Math.abs(f)) / Math.PI, i.isScrolling = s.isHorizontal() ? e > r.touchAngle : 90 - e > r.touchAngle)
        }
        if (i.isScrolling && s.emit("touchMoveOpposite", c), void 0 === i.startMoving && (n.currentX === n.startX && n.currentY === n.startY || (i.startMoving = !0)), i.isScrolling) return void (i.isTouched = !1);
        if (!i.startMoving) return;
        s.allowClick = !1, !r.cssMode && c.cancelable && c.preventDefault(), r.touchMoveStopPropagation && !r.nested && c.stopPropagation(), i.isMoved || (r.loop && !r.cssMode && s.loopFix(), i.startTranslate = s.getTranslate(), s.setTransition(0), s.animating && s.$wrapperEl.trigger("webkitTransitionEnd transitionend"), i.allowMomentumBounce = !1, !r.grabCursor || !0 !== s.allowSlideNext && !0 !== s.allowSlidePrev || s.setGrabCursor(!0), s.emit("sliderFirstMove", c)), s.emit("sliderMove", c), i.isMoved = !0;
        let v = s.isHorizontal() ? f : g;
        n.diff = v, v *= r.touchRatio, l && (v = -v), s.swipeDirection = v > 0 ? "prev" : "next", i.currentTranslate = v + i.startTranslate;
        let w = !0, b = r.resistanceRatio;
        if (r.touchReleaseOnEdges && (b = 0), v > 0 && i.currentTranslate > s.minTranslate() ? (w = !1, r.resistance && (i.currentTranslate = s.minTranslate() - 1 + (-s.minTranslate() + i.startTranslate + v) ** b)) : v < 0 && i.currentTranslate < s.maxTranslate() && (w = !1, r.resistance && (i.currentTranslate = s.maxTranslate() + 1 - (s.maxTranslate() - i.startTranslate - v) ** b)), w && (c.preventedByNestedSwiper = !0), !s.allowSlideNext && "next" === s.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !s.allowSlidePrev && "prev" === s.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), s.allowSlidePrev || s.allowSlideNext || (i.currentTranslate = i.startTranslate), r.threshold > 0) {
            if (!(Math.abs(v) > r.threshold || i.allowThresholdMove)) return void (i.currentTranslate = i.startTranslate);
            if (!i.allowThresholdMove) return i.allowThresholdMove = !0, n.startX = n.currentX, n.startY = n.currentY, i.currentTranslate = i.startTranslate, void (n.diff = s.isHorizontal() ? n.currentX - n.startX : n.currentY - n.startY)
        }
        r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && s.freeMode || r.watchSlidesProgress) && (s.updateActiveIndex(), s.updateSlidesClasses()), s.params.freeMode && r.freeMode.enabled && s.freeMode && s.freeMode.onTouchMove(), s.updateProgress(i.currentTranslate), s.setTranslate(i.currentTranslate))
    }

    function I(e) {
        const t = this, s = t.touchEventsData, {params: a, touches: i, rtlTranslate: r, slidesGrid: n, enabled: l} = t;
        if (!l) return;
        let o = e;
        if (o.originalEvent && (o = o.originalEvent), s.allowTouchCallbacks && t.emit("touchEnd", o), s.allowTouchCallbacks = !1, !s.isTouched) return s.isMoved && a.grabCursor && t.setGrabCursor(!1), s.isMoved = !1, void (s.startMoving = !1);
        a.grabCursor && s.isMoved && s.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1);
        const d = u(), c = d - s.touchStartTime;
        if (t.allowClick) {
            const e = o.path || o.composedPath && o.composedPath();
            t.updateClickedSlide(e && e[0] || o.target), t.emit("tap click", o), c < 300 && d - s.lastClickTime < 300 && t.emit("doubleTap doubleClick", o)
        }
        if (s.lastClickTime = u(), p((() => {
            t.destroyed || (t.allowClick = !0)
        })), !s.isTouched || !s.isMoved || !t.swipeDirection || 0 === i.diff || s.currentTranslate === s.startTranslate) return s.isTouched = !1, s.isMoved = !1, void (s.startMoving = !1);
        let h;
        if (s.isTouched = !1, s.isMoved = !1, s.startMoving = !1, h = a.followFinger ? r ? t.translate : -t.translate : -s.currentTranslate, a.cssMode) return;
        if (t.params.freeMode && a.freeMode.enabled) return void t.freeMode.onTouchEnd({currentPos: h});
        let m = 0, f = t.slidesSizesGrid[0];
        for (let e = 0; e < n.length; e += e < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup) {
            const t = e < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
            void 0 !== n[e + t] ? h >= n[e] && h < n[e + t] && (m = e, f = n[e + t] - n[e]) : h >= n[e] && (m = e, f = n[n.length - 1] - n[n.length - 2])
        }
        let g = null, v = null;
        a.rewind && (t.isBeginning ? v = t.params.virtual && t.params.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (g = 0));
        const w = (h - n[m]) / f, b = m < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
        if (c > a.longSwipesMs) {
            if (!a.longSwipes) return void t.slideTo(t.activeIndex);
            "next" === t.swipeDirection && (w >= a.longSwipesRatio ? t.slideTo(a.rewind && t.isEnd ? g : m + b) : t.slideTo(m)), "prev" === t.swipeDirection && (w > 1 - a.longSwipesRatio ? t.slideTo(m + b) : null !== v && w < 0 && Math.abs(w) > a.longSwipesRatio ? t.slideTo(v) : t.slideTo(m))
        } else {
            if (!a.shortSwipes) return void t.slideTo(t.activeIndex);
            t.navigation && (o.target === t.navigation.nextEl || o.target === t.navigation.prevEl) ? o.target === t.navigation.nextEl ? t.slideTo(m + b) : t.slideTo(m) : ("next" === t.swipeDirection && t.slideTo(null !== g ? g : m + b), "prev" === t.swipeDirection && t.slideTo(null !== v ? v : m))
        }
    }

    function A() {
        const e = this, {params: t, el: s} = e;
        if (s && 0 === s.offsetWidth) return;
        t.breakpoints && e.setBreakpoint();
        const {allowSlideNext: a, allowSlidePrev: i, snapGrid: r} = e;
        e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), ("auto" === t.slidesPerView || t.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = i, e.allowSlideNext = a, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow()
    }

    function D(e) {
        const t = this;
        t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation())))
    }

    function G() {
        const e = this, {wrapperEl: t, rtlTranslate: s, enabled: a} = e;
        if (!a) return;
        let i;
        e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses();
        const r = e.maxTranslate() - e.minTranslate();
        i = 0 === r ? 0 : (e.translate - e.minTranslate()) / r, i !== e.progress && e.updateProgress(s ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1)
    }

    let N = !1;

    function B() {
    }

    const H = (e, t) => {
        const s = a(), {params: i, touchEvents: r, el: n, wrapperEl: l, device: o, support: d} = e, c = !!i.nested,
            p = "on" === t ? "addEventListener" : "removeEventListener", u = t;
        if (d.touch) {
            const t = !("touchstart" !== r.start || !d.passiveListener || !i.passiveListeners) && {
                passive: !0,
                capture: !1
            };
            n[p](r.start, e.onTouchStart, t), n[p](r.move, e.onTouchMove, d.passiveListener ? {
                passive: !1,
                capture: c
            } : c), n[p](r.end, e.onTouchEnd, t), r.cancel && n[p](r.cancel, e.onTouchEnd, t)
        } else n[p](r.start, e.onTouchStart, !1), s[p](r.move, e.onTouchMove, c), s[p](r.end, e.onTouchEnd, !1);
        (i.preventClicks || i.preventClicksPropagation) && n[p]("click", e.onClick, !0), i.cssMode && l[p]("scroll", e.onScroll), i.updateOnWindowResize ? e[u](o.ios || o.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", A, !0) : e[u]("observerUpdate", A, !0)
    };
    var X = {
        attachEvents: function () {
            const e = this, t = a(), {params: s, support: i} = e;
            e.onTouchStart = L.bind(e), e.onTouchMove = O.bind(e), e.onTouchEnd = I.bind(e), s.cssMode && (e.onScroll = G.bind(e)), e.onClick = D.bind(e), i.touch && !N && (t.addEventListener("touchstart", B), N = !0), H(e, "on")
        }, detachEvents: function () {
            H(this, "off")
        }
    };
    const Y = (e, t) => e.grid && t.grid && t.grid.rows > 1;
    var R = {
        addClasses: function () {
            const e = this, {classNames: t, params: s, rtl: a, $el: i, device: r, support: n} = e, l = function (e, t) {
                const s = [];
                return e.forEach((e => {
                    "object" == typeof e ? Object.keys(e).forEach((a => {
                        e[a] && s.push(t + a)
                    })) : "string" == typeof e && s.push(t + e)
                })), s
            }(["initialized", s.direction, {"pointer-events": !n.touch}, {"free-mode": e.params.freeMode && s.freeMode.enabled}, {autoheight: s.autoHeight}, {rtl: a}, {grid: s.grid && s.grid.rows > 1}, {"grid-column": s.grid && s.grid.rows > 1 && "column" === s.grid.fill}, {android: r.android}, {ios: r.ios}, {"css-mode": s.cssMode}, {centered: s.cssMode && s.centeredSlides}, {"watch-progress": s.watchSlidesProgress}], s.containerModifierClass);
            t.push(...l), i.addClass([...t].join(" ")), e.emitContainerClasses()
        }, removeClasses: function () {
            const {$el: e, classNames: t} = this;
            e.removeClass(t.join(" ")), this.emitContainerClasses()
        }
    };
    var W = {
        init: !0,
        direction: "horizontal",
        touchEventsTarget: "wrapper",
        initialSlide: 0,
        speed: 300,
        cssMode: !1,
        updateOnWindowResize: !0,
        resizeObserver: !0,
        nested: !1,
        createElements: !1,
        enabled: !0,
        focusableElements: "input, select, option, textarea, button, video, label",
        width: null,
        height: null,
        preventInteractionOnTransition: !1,
        userAgent: null,
        url: null,
        edgeSwipeDetection: !1,
        edgeSwipeThreshold: 20,
        autoHeight: !1,
        setWrapperSize: !1,
        virtualTranslate: !1,
        effect: "slide",
        breakpoints: void 0,
        breakpointsBase: "window",
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: !1,
        centeredSlides: !1,
        centeredSlidesBounds: !1,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: !0,
        centerInsufficientSlides: !1,
        watchOverflow: !0,
        roundLengths: !1,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: !0,
        shortSwipes: !0,
        longSwipes: !0,
        longSwipesRatio: .5,
        longSwipesMs: 300,
        followFinger: !0,
        allowTouchMove: !0,
        threshold: 0,
        touchMoveStopPropagation: !1,
        touchStartPreventDefault: !0,
        touchStartForcePreventDefault: !1,
        touchReleaseOnEdges: !1,
        uniqueNavElements: !0,
        resistance: !0,
        resistanceRatio: .85,
        watchSlidesProgress: !1,
        grabCursor: !1,
        preventClicks: !0,
        preventClicksPropagation: !0,
        slideToClickedSlide: !1,
        preloadImages: !0,
        updateOnImagesReady: !0,
        loop: !1,
        loopAdditionalSlides: 0,
        loopedSlides: null,
        loopedSlidesLimit: !0,
        loopFillGroupWithBlank: !1,
        loopPreventsSlide: !0,
        rewind: !1,
        allowSlidePrev: !0,
        allowSlideNext: !0,
        swipeHandler: null,
        noSwiping: !0,
        noSwipingClass: "swiper-no-swiping",
        noSwipingSelector: null,
        passiveListeners: !0,
        maxBackfaceHiddenSlides: 10,
        containerModifierClass: "swiper-",
        slideClass: "swiper-slide",
        slideBlankClass: "swiper-slide-invisible-blank",
        slideActiveClass: "swiper-slide-active",
        slideDuplicateActiveClass: "swiper-slide-duplicate-active",
        slideVisibleClass: "swiper-slide-visible",
        slideDuplicateClass: "swiper-slide-duplicate",
        slideNextClass: "swiper-slide-next",
        slideDuplicateNextClass: "swiper-slide-duplicate-next",
        slidePrevClass: "swiper-slide-prev",
        slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
        wrapperClass: "swiper-wrapper",
        runCallbacksOnInit: !0,
        _emitClasses: !1
    };

    function q(e, t) {
        return function (s) {
            void 0 === s && (s = {});
            const a = Object.keys(s)[0], i = s[a];
            "object" == typeof i && null !== i ? (["navigation", "pagination", "scrollbar"].indexOf(a) >= 0 && !0 === e[a] && (e[a] = {auto: !0}), a in e && "enabled" in i ? (!0 === e[a] && (e[a] = {enabled: !0}), "object" != typeof e[a] || "enabled" in e[a] || (e[a].enabled = !0), e[a] || (e[a] = {enabled: !1}), g(t, s)) : g(t, s)) : g(t, s)
        }
    }

    const j = {
        eventsEmitter: $, update: S, translate: M, transition: {
            setTransition: function (e, t) {
                const s = this;
                s.params.cssMode || s.$wrapperEl.transition(e), s.emit("setTransition", e, t)
            }, transitionStart: function (e, t) {
                void 0 === e && (e = !0);
                const s = this, {params: a} = s;
                a.cssMode || (a.autoHeight && s.updateAutoHeight(), P({
                    swiper: s,
                    runCallbacks: e,
                    direction: t,
                    step: "Start"
                }))
            }, transitionEnd: function (e, t) {
                void 0 === e && (e = !0);
                const s = this, {params: a} = s;
                s.animating = !1, a.cssMode || (s.setTransition(0), P({
                    swiper: s,
                    runCallbacks: e,
                    direction: t,
                    step: "End"
                }))
            }
        }, slide: k, loop: z, grabCursor: {
            setGrabCursor: function (e) {
                const t = this;
                if (t.support.touch || !t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return;
                const s = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl;
                s.style.cursor = "move", s.style.cursor = e ? "grabbing" : "grab"
            }, unsetGrabCursor: function () {
                const e = this;
                e.support.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "")
            }
        }, events: X, breakpoints: {
            setBreakpoint: function () {
                const e = this, {activeIndex: t, initialized: s, loopedSlides: a = 0, params: i, $el: r} = e,
                    n = i.breakpoints;
                if (!n || n && 0 === Object.keys(n).length) return;
                const l = e.getBreakpoint(n, e.params.breakpointsBase, e.el);
                if (!l || e.currentBreakpoint === l) return;
                const o = (l in n ? n[l] : void 0) || e.originalParams, d = Y(e, i), c = Y(e, o), p = i.enabled;
                d && !c ? (r.removeClass(`${i.containerModifierClass}grid ${i.containerModifierClass}grid-column`), e.emitContainerClasses()) : !d && c && (r.addClass(`${i.containerModifierClass}grid`), (o.grid.fill && "column" === o.grid.fill || !o.grid.fill && "column" === i.grid.fill) && r.addClass(`${i.containerModifierClass}grid-column`), e.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach((t => {
                    const s = i[t] && i[t].enabled, a = o[t] && o[t].enabled;
                    s && !a && e[t].disable(), !s && a && e[t].enable()
                }));
                const u = o.direction && o.direction !== i.direction,
                    h = i.loop && (o.slidesPerView !== i.slidesPerView || u);
                u && s && e.changeDirection(), g(e.params, o);
                const m = e.params.enabled;
                Object.assign(e, {
                    allowTouchMove: e.params.allowTouchMove,
                    allowSlideNext: e.params.allowSlideNext,
                    allowSlidePrev: e.params.allowSlidePrev
                }), p && !m ? e.disable() : !p && m && e.enable(), e.currentBreakpoint = l, e.emit("_beforeBreakpoint", o), h && s && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - a + e.loopedSlides, 0, !1)), e.emit("breakpoint", o)
            }, getBreakpoint: function (e, t, s) {
                if (void 0 === t && (t = "window"), !e || "container" === t && !s) return;
                let a = !1;
                const i = r(), n = "window" === t ? i.innerHeight : s.clientHeight, l = Object.keys(e).map((e => {
                    if ("string" == typeof e && 0 === e.indexOf("@")) {
                        const t = parseFloat(e.substr(1));
                        return {value: n * t, point: e}
                    }
                    return {value: e, point: e}
                }));
                l.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10)));
                for (let e = 0; e < l.length; e += 1) {
                    const {point: r, value: n} = l[e];
                    "window" === t ? i.matchMedia(`(min-width: ${n}px)`).matches && (a = r) : n <= s.clientWidth && (a = r)
                }
                return a || "max"
            }
        }, checkOverflow: {
            checkOverflow: function () {
                const e = this, {isLocked: t, params: s} = e, {slidesOffsetBefore: a} = s;
                if (a) {
                    const t = e.slides.length - 1, s = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * a;
                    e.isLocked = e.size > s
                } else e.isLocked = 1 === e.snapGrid.length;
                !0 === s.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === s.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock")
            }
        }, classes: R, images: {
            loadImage: function (e, t, s, a, i, n) {
                const l = r();
                let o;

                function c() {
                    n && n()
                }

                d(e).parent("picture")[0] || e.complete && i ? c() : t ? (o = new l.Image, o.onload = c, o.onerror = c, a && (o.sizes = a), s && (o.srcset = s), t && (o.src = t)) : c()
            }, preloadImages: function () {
                const e = this;

                function t() {
                    null != e && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit("imagesReady")))
                }

                e.imagesToLoad = e.$el.find("img");
                for (let s = 0; s < e.imagesToLoad.length; s += 1) {
                    const a = e.imagesToLoad[s];
                    e.loadImage(a, a.currentSrc || a.getAttribute("src"), a.srcset || a.getAttribute("srcset"), a.sizes || a.getAttribute("sizes"), !0, t)
                }
            }
        }
    }, _ = {};

    class V {
        constructor() {
            let e, t;
            for (var s = arguments.length, a = new Array(s), i = 0; i < s; i++) a[i] = arguments[i];
            if (1 === a.length && a[0].constructor && "Object" === Object.prototype.toString.call(a[0]).slice(8, -1) ? t = a[0] : [e, t] = a, t || (t = {}), t = g({}, t), e && !t.el && (t.el = e), t.el && d(t.el).length > 1) {
                const e = [];
                return d(t.el).each((s => {
                    const a = g({}, t, {el: s});
                    e.push(new V(a))
                })), e
            }
            const r = this;
            r.__swiper__ = !0, r.support = E(), r.device = C({userAgent: t.userAgent}), r.browser = T(), r.eventsListeners = {}, r.eventsAnyListeners = [], r.modules = [...r.__modules__], t.modules && Array.isArray(t.modules) && r.modules.push(...t.modules);
            const n = {};
            r.modules.forEach((e => {
                e({
                    swiper: r,
                    extendParams: q(t, n),
                    on: r.on.bind(r),
                    once: r.once.bind(r),
                    off: r.off.bind(r),
                    emit: r.emit.bind(r)
                })
            }));
            const l = g({}, W, n);
            return r.params = g({}, l, _, t), r.originalParams = g({}, r.params), r.passedParams = g({}, t), r.params && r.params.on && Object.keys(r.params.on).forEach((e => {
                r.on(e, r.params.on[e])
            })), r.params && r.params.onAny && r.onAny(r.params.onAny), r.$ = d, Object.assign(r, {
                enabled: r.params.enabled,
                el: e,
                classNames: [],
                slides: d(),
                slidesGrid: [],
                snapGrid: [],
                slidesSizesGrid: [],
                isHorizontal: () => "horizontal" === r.params.direction,
                isVertical: () => "vertical" === r.params.direction,
                activeIndex: 0,
                realIndex: 0,
                isBeginning: !0,
                isEnd: !1,
                translate: 0,
                previousTranslate: 0,
                progress: 0,
                velocity: 0,
                animating: !1,
                allowSlideNext: r.params.allowSlideNext,
                allowSlidePrev: r.params.allowSlidePrev,
                touchEvents: function () {
                    const e = ["touchstart", "touchmove", "touchend", "touchcancel"],
                        t = ["pointerdown", "pointermove", "pointerup"];
                    return r.touchEventsTouch = {
                        start: e[0],
                        move: e[1],
                        end: e[2],
                        cancel: e[3]
                    }, r.touchEventsDesktop = {
                        start: t[0],
                        move: t[1],
                        end: t[2]
                    }, r.support.touch || !r.params.simulateTouch ? r.touchEventsTouch : r.touchEventsDesktop
                }(),
                touchEventsData: {
                    isTouched: void 0,
                    isMoved: void 0,
                    allowTouchCallbacks: void 0,
                    touchStartTime: void 0,
                    isScrolling: void 0,
                    currentTranslate: void 0,
                    startTranslate: void 0,
                    allowThresholdMove: void 0,
                    focusableElements: r.params.focusableElements,
                    lastClickTime: u(),
                    clickTimeout: void 0,
                    velocities: [],
                    allowMomentumBounce: void 0,
                    isTouchEvent: void 0,
                    startMoving: void 0
                },
                allowClick: !0,
                allowTouchMove: r.params.allowTouchMove,
                touches: {startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0},
                imagesToLoad: [],
                imagesLoaded: 0
            }), r.emit("_swiper"), r.params.init && r.init(), r
        }

        enable() {
            const e = this;
            e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable"))
        }

        disable() {
            const e = this;
            e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable"))
        }

        setProgress(e, t) {
            const s = this;
            e = Math.min(Math.max(e, 0), 1);
            const a = s.minTranslate(), i = (s.maxTranslate() - a) * e + a;
            s.translateTo(i, void 0 === t ? 0 : t), s.updateActiveIndex(), s.updateSlidesClasses()
        }

        emitContainerClasses() {
            const e = this;
            if (!e.params._emitClasses || !e.el) return;
            const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass)));
            e.emit("_containerClasses", t.join(" "))
        }

        getSlideClasses(e) {
            const t = this;
            return t.destroyed ? "" : e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ")
        }

        emitSlidesClasses() {
            const e = this;
            if (!e.params._emitClasses || !e.el) return;
            const t = [];
            e.slides.each((s => {
                const a = e.getSlideClasses(s);
                t.push({slideEl: s, classNames: a}), e.emit("_slideClass", s, a)
            })), e.emit("_slideClasses", t)
        }

        slidesPerViewDynamic(e, t) {
            void 0 === e && (e = "current"), void 0 === t && (t = !1);
            const {params: s, slides: a, slidesGrid: i, slidesSizesGrid: r, size: n, activeIndex: l} = this;
            let o = 1;
            if (s.centeredSlides) {
                let e, t = a[l].swiperSlideSize;
                for (let s = l + 1; s < a.length; s += 1) a[s] && !e && (t += a[s].swiperSlideSize, o += 1, t > n && (e = !0));
                for (let s = l - 1; s >= 0; s -= 1) a[s] && !e && (t += a[s].swiperSlideSize, o += 1, t > n && (e = !0))
            } else if ("current" === e) for (let e = l + 1; e < a.length; e += 1) {
                (t ? i[e] + r[e] - i[l] < n : i[e] - i[l] < n) && (o += 1)
            } else for (let e = l - 1; e >= 0; e -= 1) {
                i[l] - i[e] < n && (o += 1)
            }
            return o
        }

        update() {
            const e = this;
            if (!e || e.destroyed) return;
            const {snapGrid: t, params: s} = e;

            function a() {
                const t = e.rtlTranslate ? -1 * e.translate : e.translate,
                    s = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
                e.setTranslate(s), e.updateActiveIndex(), e.updateSlidesClasses()
            }

            let i;
            s.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode && e.params.freeMode.enabled ? (a(), e.params.autoHeight && e.updateAutoHeight()) : (i = ("auto" === e.params.slidesPerView || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), i || a()), s.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update")
        }

        changeDirection(e, t) {
            void 0 === t && (t = !0);
            const s = this, a = s.params.direction;
            return e || (e = "horizontal" === a ? "vertical" : "horizontal"), e === a || "horizontal" !== e && "vertical" !== e || (s.$el.removeClass(`${s.params.containerModifierClass}${a}`).addClass(`${s.params.containerModifierClass}${e}`), s.emitContainerClasses(), s.params.direction = e, s.slides.each((t => {
                "vertical" === e ? t.style.width = "" : t.style.height = ""
            })), s.emit("changeDirection"), t && s.update()), s
        }

        changeLanguageDirection(e) {
            const t = this;
            t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e, t.rtlTranslate = "horizontal" === t.params.direction && t.rtl, t.rtl ? (t.$el.addClass(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.$el.removeClass(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update())
        }

        mount(e) {
            const t = this;
            if (t.mounted) return !0;
            const s = d(e || t.params.el);
            if (!(e = s[0])) return !1;
            e.swiper = t;
            const i = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`;
            let r = (() => {
                if (e && e.shadowRoot && e.shadowRoot.querySelector) {
                    const t = d(e.shadowRoot.querySelector(i()));
                    return t.children = e => s.children(e), t
                }
                return s.children ? s.children(i()) : d(s).children(i())
            })();
            if (0 === r.length && t.params.createElements) {
                const e = a().createElement("div");
                r = d(e), e.className = t.params.wrapperClass, s.append(e), s.children(`.${t.params.slideClass}`).each((e => {
                    r.append(e)
                }))
            }
            return Object.assign(t, {
                $el: s,
                el: e,
                $wrapperEl: r,
                wrapperEl: r[0],
                mounted: !0,
                rtl: "rtl" === e.dir.toLowerCase() || "rtl" === s.css("direction"),
                rtlTranslate: "horizontal" === t.params.direction && ("rtl" === e.dir.toLowerCase() || "rtl" === s.css("direction")),
                wrongRTL: "-webkit-box" === r.css("display")
            }), !0
        }

        init(e) {
            const t = this;
            if (t.initialized) return t;
            return !1 === t.mount(e) || (t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.params.loop && t.loopCreate(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.preloadImages && t.preloadImages(), t.params.loop ? t.slideTo(t.params.initialSlide + t.loopedSlides, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.attachEvents(), t.initialized = !0, t.emit("init"), t.emit("afterInit")), t
        }

        destroy(e, t) {
            void 0 === e && (e = !0), void 0 === t && (t = !0);
            const s = this, {params: a, $el: i, $wrapperEl: r, slides: n} = s;
            return void 0 === s.params || s.destroyed || (s.emit("beforeDestroy"), s.initialized = !1, s.detachEvents(), a.loop && s.loopDestroy(), t && (s.removeClasses(), i.removeAttr("style"), r.removeAttr("style"), n && n.length && n.removeClass([a.slideVisibleClass, a.slideActiveClass, a.slideNextClass, a.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), s.emit("destroy"), Object.keys(s.eventsListeners).forEach((e => {
                s.off(e)
            })), !1 !== e && (s.$el[0].swiper = null, function (e) {
                const t = e;
                Object.keys(t).forEach((e => {
                    try {
                        t[e] = null
                    } catch (e) {
                    }
                    try {
                        delete t[e]
                    } catch (e) {
                    }
                }))
            }(s)), s.destroyed = !0), null
        }

        static extendDefaults(e) {
            g(_, e)
        }

        static get extendedDefaults() {
            return _
        }

        static get defaults() {
            return W
        }

        static installModule(e) {
            V.prototype.__modules__ || (V.prototype.__modules__ = []);
            const t = V.prototype.__modules__;
            "function" == typeof e && t.indexOf(e) < 0 && t.push(e)
        }

        static use(e) {
            return Array.isArray(e) ? (e.forEach((e => V.installModule(e))), V) : (V.installModule(e), V)
        }
    }

    function F(e, t, s, i) {
        const r = a();
        return e.params.createElements && Object.keys(i).forEach((a => {
            if (!s[a] && !0 === s.auto) {
                let n = e.$el.children(`.${i[a]}`)[0];
                n || (n = r.createElement("div"), n.className = i[a], e.$el.append(n)), s[a] = n, t[a] = n
            }
        })), s
    }

    function U(e) {
        return void 0 === e && (e = ""), `.${e.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}`
    }

    function K(e) {
        const t = this, {$wrapperEl: s, params: a} = t;
        if (a.loop && t.loopDestroy(), "object" == typeof e && "length" in e) for (let t = 0; t < e.length; t += 1) e[t] && s.append(e[t]); else s.append(e);
        a.loop && t.loopCreate(), a.observer || t.update()
    }

    function Z(e) {
        const t = this, {params: s, $wrapperEl: a, activeIndex: i} = t;
        s.loop && t.loopDestroy();
        let r = i + 1;
        if ("object" == typeof e && "length" in e) {
            for (let t = 0; t < e.length; t += 1) e[t] && a.prepend(e[t]);
            r = i + e.length
        } else a.prepend(e);
        s.loop && t.loopCreate(), s.observer || t.update(), t.slideTo(r, 0, !1)
    }

    function Q(e, t) {
        const s = this, {$wrapperEl: a, params: i, activeIndex: r} = s;
        let n = r;
        i.loop && (n -= s.loopedSlides, s.loopDestroy(), s.slides = a.children(`.${i.slideClass}`));
        const l = s.slides.length;
        if (e <= 0) return void s.prependSlide(t);
        if (e >= l) return void s.appendSlide(t);
        let o = n > e ? n + 1 : n;
        const d = [];
        for (let t = l - 1; t >= e; t -= 1) {
            const e = s.slides.eq(t);
            e.remove(), d.unshift(e)
        }
        if ("object" == typeof t && "length" in t) {
            for (let e = 0; e < t.length; e += 1) t[e] && a.append(t[e]);
            o = n > e ? n + t.length : n
        } else a.append(t);
        for (let e = 0; e < d.length; e += 1) a.append(d[e]);
        i.loop && s.loopCreate(), i.observer || s.update(), i.loop ? s.slideTo(o + s.loopedSlides, 0, !1) : s.slideTo(o, 0, !1)
    }

    function J(e) {
        const t = this, {params: s, $wrapperEl: a, activeIndex: i} = t;
        let r = i;
        s.loop && (r -= t.loopedSlides, t.loopDestroy(), t.slides = a.children(`.${s.slideClass}`));
        let n, l = r;
        if ("object" == typeof e && "length" in e) {
            for (let s = 0; s < e.length; s += 1) n = e[s], t.slides[n] && t.slides.eq(n).remove(), n < l && (l -= 1);
            l = Math.max(l, 0)
        } else n = e, t.slides[n] && t.slides.eq(n).remove(), n < l && (l -= 1), l = Math.max(l, 0);
        s.loop && t.loopCreate(), s.observer || t.update(), s.loop ? t.slideTo(l + t.loopedSlides, 0, !1) : t.slideTo(l, 0, !1)
    }

    function ee() {
        const e = this, t = [];
        for (let s = 0; s < e.slides.length; s += 1) t.push(s);
        e.removeSlide(t)
    }

    function te(e) {
        const {
            effect: t,
            swiper: s,
            on: a,
            setTranslate: i,
            setTransition: r,
            overwriteParams: n,
            perspective: l,
            recreateShadows: o,
            getEffectParams: d
        } = e;
        let c;
        a("beforeInit", (() => {
            if (s.params.effect !== t) return;
            s.classNames.push(`${s.params.containerModifierClass}${t}`), l && l() && s.classNames.push(`${s.params.containerModifierClass}3d`);
            const e = n ? n() : {};
            Object.assign(s.params, e), Object.assign(s.originalParams, e)
        })), a("setTranslate", (() => {
            s.params.effect === t && i()
        })), a("setTransition", ((e, a) => {
            s.params.effect === t && r(a)
        })), a("transitionEnd", (() => {
            if (s.params.effect === t && o) {
                if (!d || !d().slideShadows) return;
                s.slides.each((e => {
                    s.$(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").remove()
                })), o()
            }
        })), a("virtualUpdate", (() => {
            s.params.effect === t && (s.slides.length || (c = !0), requestAnimationFrame((() => {
                c && s.slides && s.slides.length && (i(), c = !1)
            })))
        }))
    }

    function se(e, t) {
        return e.transformEl ? t.find(e.transformEl).css({
            "backface-visibility": "hidden",
            "-webkit-backface-visibility": "hidden"
        }) : t
    }

    function ae(e) {
        let {swiper: t, duration: s, transformEl: a, allSlides: i} = e;
        const {slides: r, activeIndex: n, $wrapperEl: l} = t;
        if (t.params.virtualTranslate && 0 !== s) {
            let e, s = !1;
            e = i ? a ? r.find(a) : r : a ? r.eq(n).find(a) : r.eq(n), e.transitionEnd((() => {
                if (s) return;
                if (!t || t.destroyed) return;
                s = !0, t.animating = !1;
                const e = ["webkitTransitionEnd", "transitionend"];
                for (let t = 0; t < e.length; t += 1) l.trigger(e[t])
            }))
        }
    }

    function ie(e, t, s) {
        const a = "swiper-slide-shadow" + (s ? `-${s}` : ""), i = e.transformEl ? t.find(e.transformEl) : t;
        let r = i.children(`.${a}`);
        return r.length || (r = d(`<div class="swiper-slide-shadow${s ? `-${s}` : ""}"></div>`), i.append(r)), r
    }

    Object.keys(j).forEach((e => {
        Object.keys(j[e]).forEach((t => {
            V.prototype[t] = j[e][t]
        }))
    })), V.use([function (e) {
        let {swiper: t, on: s, emit: a} = e;
        const i = r();
        let n = null, l = null;
        const o = () => {
            t && !t.destroyed && t.initialized && (a("beforeResize"), a("resize"))
        }, d = () => {
            t && !t.destroyed && t.initialized && a("orientationchange")
        };
        s("init", (() => {
            t.params.resizeObserver && void 0 !== i.ResizeObserver ? t && !t.destroyed && t.initialized && (n = new ResizeObserver((e => {
                l = i.requestAnimationFrame((() => {
                    const {width: s, height: a} = t;
                    let i = s, r = a;
                    e.forEach((e => {
                        let {contentBoxSize: s, contentRect: a, target: n} = e;
                        n && n !== t.el || (i = a ? a.width : (s[0] || s).inlineSize, r = a ? a.height : (s[0] || s).blockSize)
                    })), i === s && r === a || o()
                }))
            })), n.observe(t.el)) : (i.addEventListener("resize", o), i.addEventListener("orientationchange", d))
        })), s("destroy", (() => {
            l && i.cancelAnimationFrame(l), n && n.unobserve && t.el && (n.unobserve(t.el), n = null), i.removeEventListener("resize", o), i.removeEventListener("orientationchange", d)
        }))
    }, function (e) {
        let {swiper: t, extendParams: s, on: a, emit: i} = e;
        const n = [], l = r(), o = function (e, t) {
            void 0 === t && (t = {});
            const s = new (l.MutationObserver || l.WebkitMutationObserver)((e => {
                if (1 === e.length) return void i("observerUpdate", e[0]);
                const t = function () {
                    i("observerUpdate", e[0])
                };
                l.requestAnimationFrame ? l.requestAnimationFrame(t) : l.setTimeout(t, 0)
            }));
            s.observe(e, {
                attributes: void 0 === t.attributes || t.attributes,
                childList: void 0 === t.childList || t.childList,
                characterData: void 0 === t.characterData || t.characterData
            }), n.push(s)
        };
        s({observer: !1, observeParents: !1, observeSlideChildren: !1}), a("init", (() => {
            if (t.params.observer) {
                if (t.params.observeParents) {
                    const e = t.$el.parents();
                    for (let t = 0; t < e.length; t += 1) o(e[t])
                }
                o(t.$el[0], {childList: t.params.observeSlideChildren}), o(t.$wrapperEl[0], {attributes: !1})
            }
        })), a("destroy", (() => {
            n.forEach((e => {
                e.disconnect()
            })), n.splice(0, n.length)
        }))
    }]);
    const re = [function (e) {
        let t, {swiper: s, extendParams: a, on: i, emit: r} = e;

        function n(e, t) {
            const a = s.params.virtual;
            if (a.cache && s.virtual.cache[t]) return s.virtual.cache[t];
            const i = a.renderSlide ? d(a.renderSlide.call(s, e, t)) : d(`<div class="${s.params.slideClass}" data-swiper-slide-index="${t}">${e}</div>`);
            return i.attr("data-swiper-slide-index") || i.attr("data-swiper-slide-index", t), a.cache && (s.virtual.cache[t] = i), i
        }

        function l(e) {
            const {slidesPerView: t, slidesPerGroup: a, centeredSlides: i} = s.params, {
                addSlidesBefore: l,
                addSlidesAfter: o
            } = s.params.virtual, {from: d, to: c, slides: p, slidesGrid: u, offset: h} = s.virtual;
            s.params.cssMode || s.updateActiveIndex();
            const m = s.activeIndex || 0;
            let f, g, v;
            f = s.rtlTranslate ? "right" : s.isHorizontal() ? "left" : "top", i ? (g = Math.floor(t / 2) + a + o, v = Math.floor(t / 2) + a + l) : (g = t + (a - 1) + o, v = a + l);
            const w = Math.max((m || 0) - v, 0), b = Math.min((m || 0) + g, p.length - 1),
                x = (s.slidesGrid[w] || 0) - (s.slidesGrid[0] || 0);

            function y() {
                s.updateSlides(), s.updateProgress(), s.updateSlidesClasses(), s.lazy && s.params.lazy.enabled && s.lazy.load(), r("virtualUpdate")
            }

            if (Object.assign(s.virtual, {
                from: w,
                to: b,
                offset: x,
                slidesGrid: s.slidesGrid
            }), d === w && c === b && !e) return s.slidesGrid !== u && x !== h && s.slides.css(f, `${x}px`), s.updateProgress(), void r("virtualUpdate");
            if (s.params.virtual.renderExternal) return s.params.virtual.renderExternal.call(s, {
                offset: x,
                from: w,
                to: b,
                slides: function () {
                    const e = [];
                    for (let t = w; t <= b; t += 1) e.push(p[t]);
                    return e
                }()
            }), void (s.params.virtual.renderExternalUpdate ? y() : r("virtualUpdate"));
            const E = [], C = [];
            if (e) s.$wrapperEl.find(`.${s.params.slideClass}`).remove(); else for (let e = d; e <= c; e += 1) (e < w || e > b) && s.$wrapperEl.find(`.${s.params.slideClass}[data-swiper-slide-index="${e}"]`).remove();
            for (let t = 0; t < p.length; t += 1) t >= w && t <= b && (void 0 === c || e ? C.push(t) : (t > c && C.push(t), t < d && E.push(t)));
            C.forEach((e => {
                s.$wrapperEl.append(n(p[e], e))
            })), E.sort(((e, t) => t - e)).forEach((e => {
                s.$wrapperEl.prepend(n(p[e], e))
            })), s.$wrapperEl.children(".swiper-slide").css(f, `${x}px`), y()
        }

        a({
            virtual: {
                enabled: !1,
                slides: [],
                cache: !0,
                renderSlide: null,
                renderExternal: null,
                renderExternalUpdate: !0,
                addSlidesBefore: 0,
                addSlidesAfter: 0
            }
        }), s.virtual = {
            cache: {},
            from: void 0,
            to: void 0,
            slides: [],
            offset: 0,
            slidesGrid: []
        }, i("beforeInit", (() => {
            s.params.virtual.enabled && (s.virtual.slides = s.params.virtual.slides, s.classNames.push(`${s.params.containerModifierClass}virtual`), s.params.watchSlidesProgress = !0, s.originalParams.watchSlidesProgress = !0, s.params.initialSlide || l())
        })), i("setTranslate", (() => {
            s.params.virtual.enabled && (s.params.cssMode && !s._immediateVirtual ? (clearTimeout(t), t = setTimeout((() => {
                l()
            }), 100)) : l())
        })), i("init update resize", (() => {
            s.params.virtual.enabled && s.params.cssMode && v(s.wrapperEl, "--swiper-virtual-size", `${s.virtualSize}px`)
        })), Object.assign(s.virtual, {
            appendSlide: function (e) {
                if ("object" == typeof e && "length" in e) for (let t = 0; t < e.length; t += 1) e[t] && s.virtual.slides.push(e[t]); else s.virtual.slides.push(e);
                l(!0)
            }, prependSlide: function (e) {
                const t = s.activeIndex;
                let a = t + 1, i = 1;
                if (Array.isArray(e)) {
                    for (let t = 0; t < e.length; t += 1) e[t] && s.virtual.slides.unshift(e[t]);
                    a = t + e.length, i = e.length
                } else s.virtual.slides.unshift(e);
                if (s.params.virtual.cache) {
                    const e = s.virtual.cache, t = {};
                    Object.keys(e).forEach((s => {
                        const a = e[s], r = a.attr("data-swiper-slide-index");
                        r && a.attr("data-swiper-slide-index", parseInt(r, 10) + i), t[parseInt(s, 10) + i] = a
                    })), s.virtual.cache = t
                }
                l(!0), s.slideTo(a, 0)
            }, removeSlide: function (e) {
                if (null == e) return;
                let t = s.activeIndex;
                if (Array.isArray(e)) for (let a = e.length - 1; a >= 0; a -= 1) s.virtual.slides.splice(e[a], 1), s.params.virtual.cache && delete s.virtual.cache[e[a]], e[a] < t && (t -= 1), t = Math.max(t, 0); else s.virtual.slides.splice(e, 1), s.params.virtual.cache && delete s.virtual.cache[e], e < t && (t -= 1), t = Math.max(t, 0);
                l(!0), s.slideTo(t, 0)
            }, removeAllSlides: function () {
                s.virtual.slides = [], s.params.virtual.cache && (s.virtual.cache = {}), l(!0), s.slideTo(0, 0)
            }, update: l
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: i, emit: n} = e;
        const l = a(), o = r();

        function c(e) {
            if (!t.enabled) return;
            const {rtlTranslate: s} = t;
            let a = e;
            a.originalEvent && (a = a.originalEvent);
            const i = a.keyCode || a.charCode, r = t.params.keyboard.pageUpDown, d = r && 33 === i, c = r && 34 === i,
                p = 37 === i, u = 39 === i, h = 38 === i, m = 40 === i;
            if (!t.allowSlideNext && (t.isHorizontal() && u || t.isVertical() && m || c)) return !1;
            if (!t.allowSlidePrev && (t.isHorizontal() && p || t.isVertical() && h || d)) return !1;
            if (!(a.shiftKey || a.altKey || a.ctrlKey || a.metaKey || l.activeElement && l.activeElement.nodeName && ("input" === l.activeElement.nodeName.toLowerCase() || "textarea" === l.activeElement.nodeName.toLowerCase()))) {
                if (t.params.keyboard.onlyInViewport && (d || c || p || u || h || m)) {
                    let e = !1;
                    if (t.$el.parents(`.${t.params.slideClass}`).length > 0 && 0 === t.$el.parents(`.${t.params.slideActiveClass}`).length) return;
                    const a = t.$el, i = a[0].clientWidth, r = a[0].clientHeight, n = o.innerWidth, l = o.innerHeight,
                        d = t.$el.offset();
                    s && (d.left -= t.$el[0].scrollLeft);
                    const c = [[d.left, d.top], [d.left + i, d.top], [d.left, d.top + r], [d.left + i, d.top + r]];
                    for (let t = 0; t < c.length; t += 1) {
                        const s = c[t];
                        if (s[0] >= 0 && s[0] <= n && s[1] >= 0 && s[1] <= l) {
                            if (0 === s[0] && 0 === s[1]) continue;
                            e = !0
                        }
                    }
                    if (!e) return
                }
                t.isHorizontal() ? ((d || c || p || u) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), ((c || u) && !s || (d || p) && s) && t.slideNext(), ((d || p) && !s || (c || u) && s) && t.slidePrev()) : ((d || c || h || m) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), (c || m) && t.slideNext(), (d || h) && t.slidePrev()), n("keyPress", i)
            }
        }

        function p() {
            t.keyboard.enabled || (d(l).on("keydown", c), t.keyboard.enabled = !0)
        }

        function u() {
            t.keyboard.enabled && (d(l).off("keydown", c), t.keyboard.enabled = !1)
        }

        t.keyboard = {enabled: !1}, s({keyboard: {enabled: !1, onlyInViewport: !0, pageUpDown: !0}}), i("init", (() => {
            t.params.keyboard.enabled && p()
        })), i("destroy", (() => {
            t.keyboard.enabled && u()
        })), Object.assign(t.keyboard, {enable: p, disable: u})
    }, function (e) {
        let {swiper: t, extendParams: s, on: a, emit: i} = e;
        const n = r();
        let l;
        s({
            mousewheel: {
                enabled: !1,
                releaseOnEdges: !1,
                invert: !1,
                forceToAxis: !1,
                sensitivity: 1,
                eventsTarget: "container",
                thresholdDelta: null,
                thresholdTime: null
            }
        }), t.mousewheel = {enabled: !1};
        let o, c = u();
        const h = [];

        function m() {
            t.enabled && (t.mouseEntered = !0)
        }

        function f() {
            t.enabled && (t.mouseEntered = !1)
        }

        function g(e) {
            return !(t.params.mousewheel.thresholdDelta && e.delta < t.params.mousewheel.thresholdDelta) && (!(t.params.mousewheel.thresholdTime && u() - c < t.params.mousewheel.thresholdTime) && (e.delta >= 6 && u() - c < 60 || (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(), i("scroll", e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(), i("scroll", e.raw)), c = (new n.Date).getTime(), !1)))
        }

        function v(e) {
            let s = e, a = !0;
            if (!t.enabled) return;
            const r = t.params.mousewheel;
            t.params.cssMode && s.preventDefault();
            let n = t.$el;
            if ("container" !== t.params.mousewheel.eventsTarget && (n = d(t.params.mousewheel.eventsTarget)), !t.mouseEntered && !n[0].contains(s.target) && !r.releaseOnEdges) return !0;
            s.originalEvent && (s = s.originalEvent);
            let c = 0;
            const m = t.rtlTranslate ? -1 : 1, f = function (e) {
                let t = 0, s = 0, a = 0, i = 0;
                return "detail" in e && (s = e.detail), "wheelDelta" in e && (s = -e.wheelDelta / 120), "wheelDeltaY" in e && (s = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = s, s = 0), a = 10 * t, i = 10 * s, "deltaY" in e && (i = e.deltaY), "deltaX" in e && (a = e.deltaX), e.shiftKey && !a && (a = i, i = 0), (a || i) && e.deltaMode && (1 === e.deltaMode ? (a *= 40, i *= 40) : (a *= 800, i *= 800)), a && !t && (t = a < 1 ? -1 : 1), i && !s && (s = i < 1 ? -1 : 1), {
                    spinX: t,
                    spinY: s,
                    pixelX: a,
                    pixelY: i
                }
            }(s);
            if (r.forceToAxis) if (t.isHorizontal()) {
                if (!(Math.abs(f.pixelX) > Math.abs(f.pixelY))) return !0;
                c = -f.pixelX * m
            } else {
                if (!(Math.abs(f.pixelY) > Math.abs(f.pixelX))) return !0;
                c = -f.pixelY
            } else c = Math.abs(f.pixelX) > Math.abs(f.pixelY) ? -f.pixelX * m : -f.pixelY;
            if (0 === c) return !0;
            r.invert && (c = -c);
            let v = t.getTranslate() + c * r.sensitivity;
            if (v >= t.minTranslate() && (v = t.minTranslate()), v <= t.maxTranslate() && (v = t.maxTranslate()), a = !!t.params.loop || !(v === t.minTranslate() || v === t.maxTranslate()), a && t.params.nested && s.stopPropagation(), t.params.freeMode && t.params.freeMode.enabled) {
                const e = {time: u(), delta: Math.abs(c), direction: Math.sign(c)},
                    a = o && e.time < o.time + 500 && e.delta <= o.delta && e.direction === o.direction;
                if (!a) {
                    o = void 0, t.params.loop && t.loopFix();
                    let n = t.getTranslate() + c * r.sensitivity;
                    const d = t.isBeginning, u = t.isEnd;
                    if (n >= t.minTranslate() && (n = t.minTranslate()), n <= t.maxTranslate() && (n = t.maxTranslate()), t.setTransition(0), t.setTranslate(n), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses(), (!d && t.isBeginning || !u && t.isEnd) && t.updateSlidesClasses(), t.params.freeMode.sticky) {
                        clearTimeout(l), l = void 0, h.length >= 15 && h.shift();
                        const s = h.length ? h[h.length - 1] : void 0, a = h[0];
                        if (h.push(e), s && (e.delta > s.delta || e.direction !== s.direction)) h.splice(0); else if (h.length >= 15 && e.time - a.time < 500 && a.delta - e.delta >= 1 && e.delta <= 6) {
                            const s = c > 0 ? .8 : .2;
                            o = e, h.splice(0), l = p((() => {
                                t.slideToClosest(t.params.speed, !0, void 0, s)
                            }), 0)
                        }
                        l || (l = p((() => {
                            o = e, h.splice(0), t.slideToClosest(t.params.speed, !0, void 0, .5)
                        }), 500))
                    }
                    if (a || i("scroll", s), t.params.autoplay && t.params.autoplayDisableOnInteraction && t.autoplay.stop(), n === t.minTranslate() || n === t.maxTranslate()) return !0
                }
            } else {
                const s = {time: u(), delta: Math.abs(c), direction: Math.sign(c), raw: e};
                h.length >= 2 && h.shift();
                const a = h.length ? h[h.length - 1] : void 0;
                if (h.push(s), a ? (s.direction !== a.direction || s.delta > a.delta || s.time > a.time + 150) && g(s) : g(s), function (e) {
                    const s = t.params.mousewheel;
                    if (e.direction < 0) {
                        if (t.isEnd && !t.params.loop && s.releaseOnEdges) return !0
                    } else if (t.isBeginning && !t.params.loop && s.releaseOnEdges) return !0;
                    return !1
                }(s)) return !0
            }
            return s.preventDefault ? s.preventDefault() : s.returnValue = !1, !1
        }

        function w(e) {
            let s = t.$el;
            "container" !== t.params.mousewheel.eventsTarget && (s = d(t.params.mousewheel.eventsTarget)), s[e]("mouseenter", m), s[e]("mouseleave", f), s[e]("wheel", v)
        }

        function b() {
            return t.params.cssMode ? (t.wrapperEl.removeEventListener("wheel", v), !0) : !t.mousewheel.enabled && (w("on"), t.mousewheel.enabled = !0, !0)
        }

        function x() {
            return t.params.cssMode ? (t.wrapperEl.addEventListener(event, v), !0) : !!t.mousewheel.enabled && (w("off"), t.mousewheel.enabled = !1, !0)
        }

        a("init", (() => {
            !t.params.mousewheel.enabled && t.params.cssMode && x(), t.params.mousewheel.enabled && b()
        })), a("destroy", (() => {
            t.params.cssMode && b(), t.mousewheel.enabled && x()
        })), Object.assign(t.mousewheel, {enable: b, disable: x})
    }, function (e) {
        let {swiper: t, extendParams: s, on: a, emit: i} = e;

        function r(e) {
            let s;
            return e && (s = d(e), t.params.uniqueNavElements && "string" == typeof e && s.length > 1 && 1 === t.$el.find(e).length && (s = t.$el.find(e))), s
        }

        function n(e, s) {
            const a = t.params.navigation;
            e && e.length > 0 && (e[s ? "addClass" : "removeClass"](a.disabledClass), e[0] && "BUTTON" === e[0].tagName && (e[0].disabled = s), t.params.watchOverflow && t.enabled && e[t.isLocked ? "addClass" : "removeClass"](a.lockClass))
        }

        function l() {
            if (t.params.loop) return;
            const {$nextEl: e, $prevEl: s} = t.navigation;
            n(s, t.isBeginning && !t.params.rewind), n(e, t.isEnd && !t.params.rewind)
        }

        function o(e) {
            e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(), i("navigationPrev"))
        }

        function c(e) {
            e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(), i("navigationNext"))
        }

        function p() {
            const e = t.params.navigation;
            if (t.params.navigation = F(t, t.originalParams.navigation, t.params.navigation, {
                nextEl: "swiper-button-next",
                prevEl: "swiper-button-prev"
            }), !e.nextEl && !e.prevEl) return;
            const s = r(e.nextEl), a = r(e.prevEl);
            s && s.length > 0 && s.on("click", c), a && a.length > 0 && a.on("click", o), Object.assign(t.navigation, {
                $nextEl: s,
                nextEl: s && s[0],
                $prevEl: a,
                prevEl: a && a[0]
            }), t.enabled || (s && s.addClass(e.lockClass), a && a.addClass(e.lockClass))
        }

        function u() {
            const {$nextEl: e, $prevEl: s} = t.navigation;
            e && e.length && (e.off("click", c), e.removeClass(t.params.navigation.disabledClass)), s && s.length && (s.off("click", o), s.removeClass(t.params.navigation.disabledClass))
        }

        s({
            navigation: {
                nextEl: null,
                prevEl: null,
                hideOnClick: !1,
                disabledClass: "swiper-button-disabled",
                hiddenClass: "swiper-button-hidden",
                lockClass: "swiper-button-lock",
                navigationDisabledClass: "swiper-navigation-disabled"
            }
        }), t.navigation = {nextEl: null, $nextEl: null, prevEl: null, $prevEl: null}, a("init", (() => {
            !1 === t.params.navigation.enabled ? h() : (p(), l())
        })), a("toEdge fromEdge lock unlock", (() => {
            l()
        })), a("destroy", (() => {
            u()
        })), a("enable disable", (() => {
            const {$nextEl: e, $prevEl: s} = t.navigation;
            e && e[t.enabled ? "removeClass" : "addClass"](t.params.navigation.lockClass), s && s[t.enabled ? "removeClass" : "addClass"](t.params.navigation.lockClass)
        })), a("click", ((e, s) => {
            const {$nextEl: a, $prevEl: r} = t.navigation, n = s.target;
            if (t.params.navigation.hideOnClick && !d(n).is(r) && !d(n).is(a)) {
                if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === n || t.pagination.el.contains(n))) return;
                let e;
                a ? e = a.hasClass(t.params.navigation.hiddenClass) : r && (e = r.hasClass(t.params.navigation.hiddenClass)), i(!0 === e ? "navigationShow" : "navigationHide"), a && a.toggleClass(t.params.navigation.hiddenClass), r && r.toggleClass(t.params.navigation.hiddenClass)
            }
        }));
        const h = () => {
            t.$el.addClass(t.params.navigation.navigationDisabledClass), u()
        };
        Object.assign(t.navigation, {
            enable: () => {
                t.$el.removeClass(t.params.navigation.navigationDisabledClass), p(), l()
            }, disable: h, update: l, init: p, destroy: u
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: a, emit: i} = e;
        const r = "swiper-pagination";
        let n;
        s({
            pagination: {
                el: null,
                bulletElement: "span",
                clickable: !1,
                hideOnClick: !1,
                renderBullet: null,
                renderProgressbar: null,
                renderFraction: null,
                renderCustom: null,
                progressbarOpposite: !1,
                type: "bullets",
                dynamicBullets: !1,
                dynamicMainBullets: 1,
                formatFractionCurrent: e => e,
                formatFractionTotal: e => e,
                bulletClass: `${r}-bullet`,
                bulletActiveClass: `${r}-bullet-active`,
                modifierClass: `${r}-`,
                currentClass: `${r}-current`,
                totalClass: `${r}-total`,
                hiddenClass: `${r}-hidden`,
                progressbarFillClass: `${r}-progressbar-fill`,
                progressbarOppositeClass: `${r}-progressbar-opposite`,
                clickableClass: `${r}-clickable`,
                lockClass: `${r}-lock`,
                horizontalClass: `${r}-horizontal`,
                verticalClass: `${r}-vertical`,
                paginationDisabledClass: `${r}-disabled`
            }
        }), t.pagination = {el: null, $el: null, bullets: []};
        let l = 0;

        function o() {
            return !t.params.pagination.el || !t.pagination.el || !t.pagination.$el || 0 === t.pagination.$el.length
        }

        function c(e, s) {
            const {bulletActiveClass: a} = t.params.pagination;
            e[s]().addClass(`${a}-${s}`)[s]().addClass(`${a}-${s}-${s}`)
        }

        function p() {
            const e = t.rtl, s = t.params.pagination;
            if (o()) return;
            const a = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length,
                r = t.pagination.$el;
            let p;
            const u = t.params.loop ? Math.ceil((a - 2 * t.loopedSlides) / t.params.slidesPerGroup) : t.snapGrid.length;
            if (t.params.loop ? (p = Math.ceil((t.activeIndex - t.loopedSlides) / t.params.slidesPerGroup), p > a - 1 - 2 * t.loopedSlides && (p -= a - 2 * t.loopedSlides), p > u - 1 && (p -= u), p < 0 && "bullets" !== t.params.paginationType && (p = u + p)) : p = void 0 !== t.snapIndex ? t.snapIndex : t.activeIndex || 0, "bullets" === s.type && t.pagination.bullets && t.pagination.bullets.length > 0) {
                const a = t.pagination.bullets;
                let i, o, u;
                if (s.dynamicBullets && (n = a.eq(0)[t.isHorizontal() ? "outerWidth" : "outerHeight"](!0), r.css(t.isHorizontal() ? "width" : "height", n * (s.dynamicMainBullets + 4) + "px"), s.dynamicMainBullets > 1 && void 0 !== t.previousIndex && (l += p - (t.previousIndex - t.loopedSlides || 0), l > s.dynamicMainBullets - 1 ? l = s.dynamicMainBullets - 1 : l < 0 && (l = 0)), i = Math.max(p - l, 0), o = i + (Math.min(a.length, s.dynamicMainBullets) - 1), u = (o + i) / 2), a.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((e => `${s.bulletActiveClass}${e}`)).join(" ")), r.length > 1) a.each((e => {
                    const t = d(e), a = t.index();
                    a === p && t.addClass(s.bulletActiveClass), s.dynamicBullets && (a >= i && a <= o && t.addClass(`${s.bulletActiveClass}-main`), a === i && c(t, "prev"), a === o && c(t, "next"))
                })); else {
                    const e = a.eq(p), r = e.index();
                    if (e.addClass(s.bulletActiveClass), s.dynamicBullets) {
                        const e = a.eq(i), n = a.eq(o);
                        for (let e = i; e <= o; e += 1) a.eq(e).addClass(`${s.bulletActiveClass}-main`);
                        if (t.params.loop) if (r >= a.length) {
                            for (let e = s.dynamicMainBullets; e >= 0; e -= 1) a.eq(a.length - e).addClass(`${s.bulletActiveClass}-main`);
                            a.eq(a.length - s.dynamicMainBullets - 1).addClass(`${s.bulletActiveClass}-prev`)
                        } else c(e, "prev"), c(n, "next"); else c(e, "prev"), c(n, "next")
                    }
                }
                if (s.dynamicBullets) {
                    const i = Math.min(a.length, s.dynamicMainBullets + 4), r = (n * i - n) / 2 - u * n,
                        l = e ? "right" : "left";
                    a.css(t.isHorizontal() ? l : "top", `${r}px`)
                }
            }
            if ("fraction" === s.type && (r.find(U(s.currentClass)).text(s.formatFractionCurrent(p + 1)), r.find(U(s.totalClass)).text(s.formatFractionTotal(u))), "progressbar" === s.type) {
                let e;
                e = s.progressbarOpposite ? t.isHorizontal() ? "vertical" : "horizontal" : t.isHorizontal() ? "horizontal" : "vertical";
                const a = (p + 1) / u;
                let i = 1, n = 1;
                "horizontal" === e ? i = a : n = a, r.find(U(s.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${i}) scaleY(${n})`).transition(t.params.speed)
            }
            "custom" === s.type && s.renderCustom ? (r.html(s.renderCustom(t, p + 1, u)), i("paginationRender", r[0])) : i("paginationUpdate", r[0]), t.params.watchOverflow && t.enabled && r[t.isLocked ? "addClass" : "removeClass"](s.lockClass)
        }

        function u() {
            const e = t.params.pagination;
            if (o()) return;
            const s = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length,
                a = t.pagination.$el;
            let r = "";
            if ("bullets" === e.type) {
                let i = t.params.loop ? Math.ceil((s - 2 * t.loopedSlides) / t.params.slidesPerGroup) : t.snapGrid.length;
                t.params.freeMode && t.params.freeMode.enabled && !t.params.loop && i > s && (i = s);
                for (let s = 0; s < i; s += 1) e.renderBullet ? r += e.renderBullet.call(t, s, e.bulletClass) : r += `<${e.bulletElement} class="${e.bulletClass}"></${e.bulletElement}>`;
                a.html(r), t.pagination.bullets = a.find(U(e.bulletClass))
            }
            "fraction" === e.type && (r = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`, a.html(r)), "progressbar" === e.type && (r = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`, a.html(r)), "custom" !== e.type && i("paginationRender", t.pagination.$el[0])
        }

        function h() {
            t.params.pagination = F(t, t.originalParams.pagination, t.params.pagination, {el: "swiper-pagination"});
            const e = t.params.pagination;
            if (!e.el) return;
            let s = d(e.el);
            0 !== s.length && (t.params.uniqueNavElements && "string" == typeof e.el && s.length > 1 && (s = t.$el.find(e.el), s.length > 1 && (s = s.filter((e => d(e).parents(".swiper")[0] === t.el)))), "bullets" === e.type && e.clickable && s.addClass(e.clickableClass), s.addClass(e.modifierClass + e.type), s.addClass(t.isHorizontal() ? e.horizontalClass : e.verticalClass), "bullets" === e.type && e.dynamicBullets && (s.addClass(`${e.modifierClass}${e.type}-dynamic`), l = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), "progressbar" === e.type && e.progressbarOpposite && s.addClass(e.progressbarOppositeClass), e.clickable && s.on("click", U(e.bulletClass), (function (e) {
                e.preventDefault();
                let s = d(this).index() * t.params.slidesPerGroup;
                t.params.loop && (s += t.loopedSlides), t.slideTo(s)
            })), Object.assign(t.pagination, {$el: s, el: s[0]}), t.enabled || s.addClass(e.lockClass))
        }

        function m() {
            const e = t.params.pagination;
            if (o()) return;
            const s = t.pagination.$el;
            s.removeClass(e.hiddenClass), s.removeClass(e.modifierClass + e.type), s.removeClass(t.isHorizontal() ? e.horizontalClass : e.verticalClass), t.pagination.bullets && t.pagination.bullets.removeClass && t.pagination.bullets.removeClass(e.bulletActiveClass), e.clickable && s.off("click", U(e.bulletClass))
        }

        a("init", (() => {
            !1 === t.params.pagination.enabled ? f() : (h(), u(), p())
        })), a("activeIndexChange", (() => {
            (t.params.loop || void 0 === t.snapIndex) && p()
        })), a("snapIndexChange", (() => {
            t.params.loop || p()
        })), a("slidesLengthChange", (() => {
            t.params.loop && (u(), p())
        })), a("snapGridLengthChange", (() => {
            t.params.loop || (u(), p())
        })), a("destroy", (() => {
            m()
        })), a("enable disable", (() => {
            const {$el: e} = t.pagination;
            e && e[t.enabled ? "removeClass" : "addClass"](t.params.pagination.lockClass)
        })), a("lock unlock", (() => {
            p()
        })), a("click", ((e, s) => {
            const a = s.target, {$el: r} = t.pagination;
            if (t.params.pagination.el && t.params.pagination.hideOnClick && r && r.length > 0 && !d(a).hasClass(t.params.pagination.bulletClass)) {
                if (t.navigation && (t.navigation.nextEl && a === t.navigation.nextEl || t.navigation.prevEl && a === t.navigation.prevEl)) return;
                const e = r.hasClass(t.params.pagination.hiddenClass);
                i(!0 === e ? "paginationShow" : "paginationHide"), r.toggleClass(t.params.pagination.hiddenClass)
            }
        }));
        const f = () => {
            t.$el.addClass(t.params.pagination.paginationDisabledClass), t.pagination.$el && t.pagination.$el.addClass(t.params.pagination.paginationDisabledClass), m()
        };
        Object.assign(t.pagination, {
            enable: () => {
                t.$el.removeClass(t.params.pagination.paginationDisabledClass), t.pagination.$el && t.pagination.$el.removeClass(t.params.pagination.paginationDisabledClass), h(), u(), p()
            }, disable: f, render: u, update: p, init: h, destroy: m
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: i, emit: r} = e;
        const n = a();
        let l, o, c, u, h = !1, m = null, f = null;

        function g() {
            if (!t.params.scrollbar.el || !t.scrollbar.el) return;
            const {scrollbar: e, rtlTranslate: s, progress: a} = t, {$dragEl: i, $el: r} = e, n = t.params.scrollbar;
            let l = o, d = (c - o) * a;
            s ? (d = -d, d > 0 ? (l = o - d, d = 0) : -d + o > c && (l = c + d)) : d < 0 ? (l = o + d, d = 0) : d + o > c && (l = c - d), t.isHorizontal() ? (i.transform(`translate3d(${d}px, 0, 0)`), i[0].style.width = `${l}px`) : (i.transform(`translate3d(0px, ${d}px, 0)`), i[0].style.height = `${l}px`), n.hide && (clearTimeout(m), r[0].style.opacity = 1, m = setTimeout((() => {
                r[0].style.opacity = 0, r.transition(400)
            }), 1e3))
        }

        function v() {
            if (!t.params.scrollbar.el || !t.scrollbar.el) return;
            const {scrollbar: e} = t, {$dragEl: s, $el: a} = e;
            s[0].style.width = "", s[0].style.height = "", c = t.isHorizontal() ? a[0].offsetWidth : a[0].offsetHeight, u = t.size / (t.virtualSize + t.params.slidesOffsetBefore - (t.params.centeredSlides ? t.snapGrid[0] : 0)), o = "auto" === t.params.scrollbar.dragSize ? c * u : parseInt(t.params.scrollbar.dragSize, 10), t.isHorizontal() ? s[0].style.width = `${o}px` : s[0].style.height = `${o}px`, a[0].style.display = u >= 1 ? "none" : "", t.params.scrollbar.hide && (a[0].style.opacity = 0), t.params.watchOverflow && t.enabled && e.$el[t.isLocked ? "addClass" : "removeClass"](t.params.scrollbar.lockClass)
        }

        function w(e) {
            return t.isHorizontal() ? "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].clientX : e.clientX : "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].clientY : e.clientY
        }

        function b(e) {
            const {scrollbar: s, rtlTranslate: a} = t, {$el: i} = s;
            let r;
            r = (w(e) - i.offset()[t.isHorizontal() ? "left" : "top"] - (null !== l ? l : o / 2)) / (c - o), r = Math.max(Math.min(r, 1), 0), a && (r = 1 - r);
            const n = t.minTranslate() + (t.maxTranslate() - t.minTranslate()) * r;
            t.updateProgress(n), t.setTranslate(n), t.updateActiveIndex(), t.updateSlidesClasses()
        }

        function x(e) {
            const s = t.params.scrollbar, {scrollbar: a, $wrapperEl: i} = t, {$el: n, $dragEl: o} = a;
            h = !0, l = e.target === o[0] || e.target === o ? w(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? "left" : "top"] : null, e.preventDefault(), e.stopPropagation(), i.transition(100), o.transition(100), b(e), clearTimeout(f), n.transition(0), s.hide && n.css("opacity", 1), t.params.cssMode && t.$wrapperEl.css("scroll-snap-type", "none"), r("scrollbarDragStart", e)
        }

        function y(e) {
            const {scrollbar: s, $wrapperEl: a} = t, {$el: i, $dragEl: n} = s;
            h && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, b(e), a.transition(0), i.transition(0), n.transition(0), r("scrollbarDragMove", e))
        }

        function E(e) {
            const s = t.params.scrollbar, {scrollbar: a, $wrapperEl: i} = t, {$el: n} = a;
            h && (h = !1, t.params.cssMode && (t.$wrapperEl.css("scroll-snap-type", ""), i.transition("")), s.hide && (clearTimeout(f), f = p((() => {
                n.css("opacity", 0), n.transition(400)
            }), 1e3)), r("scrollbarDragEnd", e), s.snapOnRelease && t.slideToClosest())
        }

        function C(e) {
            const {scrollbar: s, touchEventsTouch: a, touchEventsDesktop: i, params: r, support: l} = t, o = s.$el;
            if (!o) return;
            const d = o[0], c = !(!l.passiveListener || !r.passiveListeners) && {passive: !1, capture: !1},
                p = !(!l.passiveListener || !r.passiveListeners) && {passive: !0, capture: !1};
            if (!d) return;
            const u = "on" === e ? "addEventListener" : "removeEventListener";
            l.touch ? (d[u](a.start, x, c), d[u](a.move, y, c), d[u](a.end, E, p)) : (d[u](i.start, x, c), n[u](i.move, y, c), n[u](i.end, E, p))
        }

        function T() {
            const {scrollbar: e, $el: s} = t;
            t.params.scrollbar = F(t, t.originalParams.scrollbar, t.params.scrollbar, {el: "swiper-scrollbar"});
            const a = t.params.scrollbar;
            if (!a.el) return;
            let i = d(a.el);
            t.params.uniqueNavElements && "string" == typeof a.el && i.length > 1 && 1 === s.find(a.el).length && (i = s.find(a.el)), i.addClass(t.isHorizontal() ? a.horizontalClass : a.verticalClass);
            let r = i.find(`.${t.params.scrollbar.dragClass}`);
            0 === r.length && (r = d(`<div class="${t.params.scrollbar.dragClass}"></div>`), i.append(r)), Object.assign(e, {
                $el: i,
                el: i[0],
                $dragEl: r,
                dragEl: r[0]
            }), a.draggable && t.params.scrollbar.el && t.scrollbar.el && C("on"), i && i[t.enabled ? "removeClass" : "addClass"](t.params.scrollbar.lockClass)
        }

        function $() {
            const e = t.params.scrollbar, s = t.scrollbar.$el;
            s && s.removeClass(t.isHorizontal() ? e.horizontalClass : e.verticalClass), t.params.scrollbar.el && t.scrollbar.el && C("off")
        }

        s({
            scrollbar: {
                el: null,
                dragSize: "auto",
                hide: !1,
                draggable: !1,
                snapOnRelease: !0,
                lockClass: "swiper-scrollbar-lock",
                dragClass: "swiper-scrollbar-drag",
                scrollbarDisabledClass: "swiper-scrollbar-disabled",
                horizontalClass: "swiper-scrollbar-horizontal",
                verticalClass: "swiper-scrollbar-vertical"
            }
        }), t.scrollbar = {el: null, dragEl: null, $el: null, $dragEl: null}, i("init", (() => {
            !1 === t.params.scrollbar.enabled ? S() : (T(), v(), g())
        })), i("update resize observerUpdate lock unlock", (() => {
            v()
        })), i("setTranslate", (() => {
            g()
        })), i("setTransition", ((e, s) => {
            !function (e) {
                t.params.scrollbar.el && t.scrollbar.el && t.scrollbar.$dragEl.transition(e)
            }(s)
        })), i("enable disable", (() => {
            const {$el: e} = t.scrollbar;
            e && e[t.enabled ? "removeClass" : "addClass"](t.params.scrollbar.lockClass)
        })), i("destroy", (() => {
            $()
        }));
        const S = () => {
            t.$el.addClass(t.params.scrollbar.scrollbarDisabledClass), t.scrollbar.$el && t.scrollbar.$el.addClass(t.params.scrollbar.scrollbarDisabledClass), $()
        };
        Object.assign(t.scrollbar, {
            enable: () => {
                t.$el.removeClass(t.params.scrollbar.scrollbarDisabledClass), t.scrollbar.$el && t.scrollbar.$el.removeClass(t.params.scrollbar.scrollbarDisabledClass), T(), v(), g()
            }, disable: S, updateSize: v, setTranslate: g, init: T, destroy: $
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({parallax: {enabled: !1}});
        const i = (e, s) => {
            const {rtl: a} = t, i = d(e), r = a ? -1 : 1, n = i.attr("data-swiper-parallax") || "0";
            let l = i.attr("data-swiper-parallax-x"), o = i.attr("data-swiper-parallax-y");
            const c = i.attr("data-swiper-parallax-scale"), p = i.attr("data-swiper-parallax-opacity");
            if (l || o ? (l = l || "0", o = o || "0") : t.isHorizontal() ? (l = n, o = "0") : (o = n, l = "0"), l = l.indexOf("%") >= 0 ? parseInt(l, 10) * s * r + "%" : l * s * r + "px", o = o.indexOf("%") >= 0 ? parseInt(o, 10) * s + "%" : o * s + "px", null != p) {
                const e = p - (p - 1) * (1 - Math.abs(s));
                i[0].style.opacity = e
            }
            if (null == c) i.transform(`translate3d(${l}, ${o}, 0px)`); else {
                const e = c - (c - 1) * (1 - Math.abs(s));
                i.transform(`translate3d(${l}, ${o}, 0px) scale(${e})`)
            }
        }, r = () => {
            const {$el: e, slides: s, progress: a, snapGrid: r} = t;
            e.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((e => {
                i(e, a)
            })), s.each(((e, s) => {
                let n = e.progress;
                t.params.slidesPerGroup > 1 && "auto" !== t.params.slidesPerView && (n += Math.ceil(s / 2) - a * (r.length - 1)), n = Math.min(Math.max(n, -1), 1), d(e).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((e => {
                    i(e, n)
                }))
            }))
        };
        a("beforeInit", (() => {
            t.params.parallax.enabled && (t.params.watchSlidesProgress = !0, t.originalParams.watchSlidesProgress = !0)
        })), a("init", (() => {
            t.params.parallax.enabled && r()
        })), a("setTranslate", (() => {
            t.params.parallax.enabled && r()
        })), a("setTransition", ((e, s) => {
            t.params.parallax.enabled && function (e) {
                void 0 === e && (e = t.params.speed);
                const {$el: s} = t;
                s.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((t => {
                    const s = d(t);
                    let a = parseInt(s.attr("data-swiper-parallax-duration"), 10) || e;
                    0 === e && (a = 0), s.transition(a)
                }))
            }(s)
        }))
    }, function (e) {
        let {swiper: t, extendParams: s, on: a, emit: i} = e;
        const n = r();
        s({
            zoom: {
                enabled: !1,
                maxRatio: 3,
                minRatio: 1,
                toggle: !0,
                containerClass: "swiper-zoom-container",
                zoomedSlideClass: "swiper-slide-zoomed"
            }
        }), t.zoom = {enabled: !1};
        let l, o, c, p = 1, u = !1;
        const m = {
            $slideEl: void 0,
            slideWidth: void 0,
            slideHeight: void 0,
            $imageEl: void 0,
            $imageWrapEl: void 0,
            maxRatio: 3
        }, f = {
            isTouched: void 0,
            isMoved: void 0,
            currentX: void 0,
            currentY: void 0,
            minX: void 0,
            minY: void 0,
            maxX: void 0,
            maxY: void 0,
            width: void 0,
            height: void 0,
            startX: void 0,
            startY: void 0,
            touchesStart: {},
            touchesCurrent: {}
        }, g = {x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0};
        let v = 1;

        function w(e) {
            if (e.targetTouches.length < 2) return 1;
            const t = e.targetTouches[0].pageX, s = e.targetTouches[0].pageY, a = e.targetTouches[1].pageX,
                i = e.targetTouches[1].pageY;
            return Math.sqrt((a - t) ** 2 + (i - s) ** 2)
        }

        function b(e) {
            const s = t.support, a = t.params.zoom;
            if (o = !1, c = !1, !s.gestures) {
                if ("touchstart" !== e.type || "touchstart" === e.type && e.targetTouches.length < 2) return;
                o = !0, m.scaleStart = w(e)
            }
            m.$slideEl && m.$slideEl.length || (m.$slideEl = d(e.target).closest(`.${t.params.slideClass}`), 0 === m.$slideEl.length && (m.$slideEl = t.slides.eq(t.activeIndex)), m.$imageEl = m.$slideEl.find(`.${a.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), m.$imageWrapEl = m.$imageEl.parent(`.${a.containerClass}`), m.maxRatio = m.$imageWrapEl.attr("data-swiper-zoom") || a.maxRatio, 0 !== m.$imageWrapEl.length) ? (m.$imageEl && m.$imageEl.transition(0), u = !0) : m.$imageEl = void 0
        }

        function x(e) {
            const s = t.support, a = t.params.zoom, i = t.zoom;
            if (!s.gestures) {
                if ("touchmove" !== e.type || "touchmove" === e.type && e.targetTouches.length < 2) return;
                c = !0, m.scaleMove = w(e)
            }
            m.$imageEl && 0 !== m.$imageEl.length ? (s.gestures ? i.scale = e.scale * p : i.scale = m.scaleMove / m.scaleStart * p, i.scale > m.maxRatio && (i.scale = m.maxRatio - 1 + (i.scale - m.maxRatio + 1) ** .5), i.scale < a.minRatio && (i.scale = a.minRatio + 1 - (a.minRatio - i.scale + 1) ** .5), m.$imageEl.transform(`translate3d(0,0,0) scale(${i.scale})`)) : "gesturechange" === e.type && b(e)
        }

        function y(e) {
            const s = t.device, a = t.support, i = t.params.zoom, r = t.zoom;
            if (!a.gestures) {
                if (!o || !c) return;
                if ("touchend" !== e.type || "touchend" === e.type && e.changedTouches.length < 2 && !s.android) return;
                o = !1, c = !1
            }
            m.$imageEl && 0 !== m.$imageEl.length && (r.scale = Math.max(Math.min(r.scale, m.maxRatio), i.minRatio), m.$imageEl.transition(t.params.speed).transform(`translate3d(0,0,0) scale(${r.scale})`), p = r.scale, u = !1, 1 === r.scale && (m.$slideEl = void 0))
        }

        function E(e) {
            const s = t.zoom;
            if (!m.$imageEl || 0 === m.$imageEl.length) return;
            if (t.allowClick = !1, !f.isTouched || !m.$slideEl) return;
            f.isMoved || (f.width = m.$imageEl[0].offsetWidth, f.height = m.$imageEl[0].offsetHeight, f.startX = h(m.$imageWrapEl[0], "x") || 0, f.startY = h(m.$imageWrapEl[0], "y") || 0, m.slideWidth = m.$slideEl[0].offsetWidth, m.slideHeight = m.$slideEl[0].offsetHeight, m.$imageWrapEl.transition(0));
            const a = f.width * s.scale, i = f.height * s.scale;
            if (!(a < m.slideWidth && i < m.slideHeight)) {
                if (f.minX = Math.min(m.slideWidth / 2 - a / 2, 0), f.maxX = -f.minX, f.minY = Math.min(m.slideHeight / 2 - i / 2, 0), f.maxY = -f.minY, f.touchesCurrent.x = "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX, f.touchesCurrent.y = "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY, !f.isMoved && !u) {
                    if (t.isHorizontal() && (Math.floor(f.minX) === Math.floor(f.startX) && f.touchesCurrent.x < f.touchesStart.x || Math.floor(f.maxX) === Math.floor(f.startX) && f.touchesCurrent.x > f.touchesStart.x)) return void (f.isTouched = !1);
                    if (!t.isHorizontal() && (Math.floor(f.minY) === Math.floor(f.startY) && f.touchesCurrent.y < f.touchesStart.y || Math.floor(f.maxY) === Math.floor(f.startY) && f.touchesCurrent.y > f.touchesStart.y)) return void (f.isTouched = !1)
                }
                e.cancelable && e.preventDefault(), e.stopPropagation(), f.isMoved = !0, f.currentX = f.touchesCurrent.x - f.touchesStart.x + f.startX, f.currentY = f.touchesCurrent.y - f.touchesStart.y + f.startY, f.currentX < f.minX && (f.currentX = f.minX + 1 - (f.minX - f.currentX + 1) ** .8), f.currentX > f.maxX && (f.currentX = f.maxX - 1 + (f.currentX - f.maxX + 1) ** .8), f.currentY < f.minY && (f.currentY = f.minY + 1 - (f.minY - f.currentY + 1) ** .8), f.currentY > f.maxY && (f.currentY = f.maxY - 1 + (f.currentY - f.maxY + 1) ** .8), g.prevPositionX || (g.prevPositionX = f.touchesCurrent.x), g.prevPositionY || (g.prevPositionY = f.touchesCurrent.y), g.prevTime || (g.prevTime = Date.now()), g.x = (f.touchesCurrent.x - g.prevPositionX) / (Date.now() - g.prevTime) / 2, g.y = (f.touchesCurrent.y - g.prevPositionY) / (Date.now() - g.prevTime) / 2, Math.abs(f.touchesCurrent.x - g.prevPositionX) < 2 && (g.x = 0), Math.abs(f.touchesCurrent.y - g.prevPositionY) < 2 && (g.y = 0), g.prevPositionX = f.touchesCurrent.x, g.prevPositionY = f.touchesCurrent.y, g.prevTime = Date.now(), m.$imageWrapEl.transform(`translate3d(${f.currentX}px, ${f.currentY}px,0)`)
            }
        }

        function C() {
            const e = t.zoom;
            m.$slideEl && t.previousIndex !== t.activeIndex && (m.$imageEl && m.$imageEl.transform("translate3d(0,0,0) scale(1)"), m.$imageWrapEl && m.$imageWrapEl.transform("translate3d(0,0,0)"), e.scale = 1, p = 1, m.$slideEl = void 0, m.$imageEl = void 0, m.$imageWrapEl = void 0)
        }

        function T(e) {
            const s = t.zoom, a = t.params.zoom;
            if (m.$slideEl || (e && e.target && (m.$slideEl = d(e.target).closest(`.${t.params.slideClass}`)), m.$slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? m.$slideEl = t.$wrapperEl.children(`.${t.params.slideActiveClass}`) : m.$slideEl = t.slides.eq(t.activeIndex)), m.$imageEl = m.$slideEl.find(`.${a.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), m.$imageWrapEl = m.$imageEl.parent(`.${a.containerClass}`)), !m.$imageEl || 0 === m.$imageEl.length || !m.$imageWrapEl || 0 === m.$imageWrapEl.length) return;
            let i, r, l, o, c, u, h, g, v, w, b, x, y, E, C, T, $, S;
            t.params.cssMode && (t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.touchAction = "none"), m.$slideEl.addClass(`${a.zoomedSlideClass}`), void 0 === f.touchesStart.x && e ? (i = "touchend" === e.type ? e.changedTouches[0].pageX : e.pageX, r = "touchend" === e.type ? e.changedTouches[0].pageY : e.pageY) : (i = f.touchesStart.x, r = f.touchesStart.y), s.scale = m.$imageWrapEl.attr("data-swiper-zoom") || a.maxRatio, p = m.$imageWrapEl.attr("data-swiper-zoom") || a.maxRatio, e ? ($ = m.$slideEl[0].offsetWidth, S = m.$slideEl[0].offsetHeight, l = m.$slideEl.offset().left + n.scrollX, o = m.$slideEl.offset().top + n.scrollY, c = l + $ / 2 - i, u = o + S / 2 - r, v = m.$imageEl[0].offsetWidth, w = m.$imageEl[0].offsetHeight, b = v * s.scale, x = w * s.scale, y = Math.min($ / 2 - b / 2, 0), E = Math.min(S / 2 - x / 2, 0), C = -y, T = -E, h = c * s.scale, g = u * s.scale, h < y && (h = y), h > C && (h = C), g < E && (g = E), g > T && (g = T)) : (h = 0, g = 0), m.$imageWrapEl.transition(300).transform(`translate3d(${h}px, ${g}px,0)`), m.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${s.scale})`)
        }

        function $() {
            const e = t.zoom, s = t.params.zoom;
            m.$slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? m.$slideEl = t.$wrapperEl.children(`.${t.params.slideActiveClass}`) : m.$slideEl = t.slides.eq(t.activeIndex), m.$imageEl = m.$slideEl.find(`.${s.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), m.$imageWrapEl = m.$imageEl.parent(`.${s.containerClass}`)), m.$imageEl && 0 !== m.$imageEl.length && m.$imageWrapEl && 0 !== m.$imageWrapEl.length && (t.params.cssMode && (t.wrapperEl.style.overflow = "", t.wrapperEl.style.touchAction = ""), e.scale = 1, p = 1, m.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"), m.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"), m.$slideEl.removeClass(`${s.zoomedSlideClass}`), m.$slideEl = void 0)
        }

        function S(e) {
            const s = t.zoom;
            s.scale && 1 !== s.scale ? $() : T(e)
        }

        function M() {
            const e = t.support;
            return {
                passiveListener: !("touchstart" !== t.touchEvents.start || !e.passiveListener || !t.params.passiveListeners) && {
                    passive: !0,
                    capture: !1
                }, activeListenerWithCapture: !e.passiveListener || {passive: !1, capture: !0}
            }
        }

        function P() {
            return `.${t.params.slideClass}`
        }

        function k(e) {
            const {passiveListener: s} = M(), a = P();
            t.$wrapperEl[e]("gesturestart", a, b, s), t.$wrapperEl[e]("gesturechange", a, x, s), t.$wrapperEl[e]("gestureend", a, y, s)
        }

        function z() {
            l || (l = !0, k("on"))
        }

        function L() {
            l && (l = !1, k("off"))
        }

        function O() {
            const e = t.zoom;
            if (e.enabled) return;
            e.enabled = !0;
            const s = t.support, {passiveListener: a, activeListenerWithCapture: i} = M(), r = P();
            s.gestures ? (t.$wrapperEl.on(t.touchEvents.start, z, a), t.$wrapperEl.on(t.touchEvents.end, L, a)) : "touchstart" === t.touchEvents.start && (t.$wrapperEl.on(t.touchEvents.start, r, b, a), t.$wrapperEl.on(t.touchEvents.move, r, x, i), t.$wrapperEl.on(t.touchEvents.end, r, y, a), t.touchEvents.cancel && t.$wrapperEl.on(t.touchEvents.cancel, r, y, a)), t.$wrapperEl.on(t.touchEvents.move, `.${t.params.zoom.containerClass}`, E, i)
        }

        function I() {
            const e = t.zoom;
            if (!e.enabled) return;
            const s = t.support;
            e.enabled = !1;
            const {passiveListener: a, activeListenerWithCapture: i} = M(), r = P();
            s.gestures ? (t.$wrapperEl.off(t.touchEvents.start, z, a), t.$wrapperEl.off(t.touchEvents.end, L, a)) : "touchstart" === t.touchEvents.start && (t.$wrapperEl.off(t.touchEvents.start, r, b, a), t.$wrapperEl.off(t.touchEvents.move, r, x, i), t.$wrapperEl.off(t.touchEvents.end, r, y, a), t.touchEvents.cancel && t.$wrapperEl.off(t.touchEvents.cancel, r, y, a)), t.$wrapperEl.off(t.touchEvents.move, `.${t.params.zoom.containerClass}`, E, i)
        }

        Object.defineProperty(t.zoom, "scale", {
            get: () => v, set(e) {
                if (v !== e) {
                    const t = m.$imageEl ? m.$imageEl[0] : void 0, s = m.$slideEl ? m.$slideEl[0] : void 0;
                    i("zoomChange", e, t, s)
                }
                v = e
            }
        }), a("init", (() => {
            t.params.zoom.enabled && O()
        })), a("destroy", (() => {
            I()
        })), a("touchStart", ((e, s) => {
            t.zoom.enabled && function (e) {
                const s = t.device;
                m.$imageEl && 0 !== m.$imageEl.length && (f.isTouched || (s.android && e.cancelable && e.preventDefault(), f.isTouched = !0, f.touchesStart.x = "touchstart" === e.type ? e.targetTouches[0].pageX : e.pageX, f.touchesStart.y = "touchstart" === e.type ? e.targetTouches[0].pageY : e.pageY))
            }(s)
        })), a("touchEnd", ((e, s) => {
            t.zoom.enabled && function () {
                const e = t.zoom;
                if (!m.$imageEl || 0 === m.$imageEl.length) return;
                if (!f.isTouched || !f.isMoved) return f.isTouched = !1, void (f.isMoved = !1);
                f.isTouched = !1, f.isMoved = !1;
                let s = 300, a = 300;
                const i = g.x * s, r = f.currentX + i, n = g.y * a, l = f.currentY + n;
                0 !== g.x && (s = Math.abs((r - f.currentX) / g.x)), 0 !== g.y && (a = Math.abs((l - f.currentY) / g.y));
                const o = Math.max(s, a);
                f.currentX = r, f.currentY = l;
                const d = f.width * e.scale, c = f.height * e.scale;
                f.minX = Math.min(m.slideWidth / 2 - d / 2, 0), f.maxX = -f.minX, f.minY = Math.min(m.slideHeight / 2 - c / 2, 0), f.maxY = -f.minY, f.currentX = Math.max(Math.min(f.currentX, f.maxX), f.minX), f.currentY = Math.max(Math.min(f.currentY, f.maxY), f.minY), m.$imageWrapEl.transition(o).transform(`translate3d(${f.currentX}px, ${f.currentY}px,0)`)
            }()
        })), a("doubleTap", ((e, s) => {
            !t.animating && t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && S(s)
        })), a("transitionEnd", (() => {
            t.zoom.enabled && t.params.zoom.enabled && C()
        })), a("slideChange", (() => {
            t.zoom.enabled && t.params.zoom.enabled && t.params.cssMode && C()
        })), Object.assign(t.zoom, {enable: O, disable: I, in: T, out: $, toggle: S})
    }, function (e) {
        let {swiper: t, extendParams: s, on: a, emit: i} = e;
        s({
            lazy: {
                checkInView: !1,
                enabled: !1,
                loadPrevNext: !1,
                loadPrevNextAmount: 1,
                loadOnTransitionStart: !1,
                scrollingElement: "",
                elementClass: "swiper-lazy",
                loadingClass: "swiper-lazy-loading",
                loadedClass: "swiper-lazy-loaded",
                preloaderClass: "swiper-lazy-preloader"
            }
        }), t.lazy = {};
        let n = !1, l = !1;

        function o(e, s) {
            void 0 === s && (s = !0);
            const a = t.params.lazy;
            if (void 0 === e) return;
            if (0 === t.slides.length) return;
            const r = t.virtual && t.params.virtual.enabled ? t.$wrapperEl.children(`.${t.params.slideClass}[data-swiper-slide-index="${e}"]`) : t.slides.eq(e),
                n = r.find(`.${a.elementClass}:not(.${a.loadedClass}):not(.${a.loadingClass})`);
            !r.hasClass(a.elementClass) || r.hasClass(a.loadedClass) || r.hasClass(a.loadingClass) || n.push(r[0]), 0 !== n.length && n.each((e => {
                const n = d(e);
                n.addClass(a.loadingClass);
                const l = n.attr("data-background"), c = n.attr("data-src"), p = n.attr("data-srcset"),
                    u = n.attr("data-sizes"), h = n.parent("picture");
                t.loadImage(n[0], c || l, p, u, !1, (() => {
                    if (null != t && t && (!t || t.params) && !t.destroyed) {
                        if (l ? (n.css("background-image", `url("${l}")`), n.removeAttr("data-background")) : (p && (n.attr("srcset", p), n.removeAttr("data-srcset")), u && (n.attr("sizes", u), n.removeAttr("data-sizes")), h.length && h.children("source").each((e => {
                            const t = d(e);
                            t.attr("data-srcset") && (t.attr("srcset", t.attr("data-srcset")), t.removeAttr("data-srcset"))
                        })), c && (n.attr("src", c), n.removeAttr("data-src"))), n.addClass(a.loadedClass).removeClass(a.loadingClass), r.find(`.${a.preloaderClass}`).remove(), t.params.loop && s) {
                            const e = r.attr("data-swiper-slide-index");
                            if (r.hasClass(t.params.slideDuplicateClass)) {
                                o(t.$wrapperEl.children(`[data-swiper-slide-index="${e}"]:not(.${t.params.slideDuplicateClass})`).index(), !1)
                            } else {
                                o(t.$wrapperEl.children(`.${t.params.slideDuplicateClass}[data-swiper-slide-index="${e}"]`).index(), !1)
                            }
                        }
                        i("lazyImageReady", r[0], n[0]), t.params.autoHeight && t.updateAutoHeight()
                    }
                })), i("lazyImageLoad", r[0], n[0])
            }))
        }

        function c() {
            const {$wrapperEl: e, params: s, slides: a, activeIndex: i} = t, r = t.virtual && s.virtual.enabled,
                n = s.lazy;
            let c = s.slidesPerView;

            function p(t) {
                if (r) {
                    if (e.children(`.${s.slideClass}[data-swiper-slide-index="${t}"]`).length) return !0
                } else if (a[t]) return !0;
                return !1
            }

            function u(e) {
                return r ? d(e).attr("data-swiper-slide-index") : d(e).index()
            }

            if ("auto" === c && (c = 0), l || (l = !0), t.params.watchSlidesProgress) e.children(`.${s.slideVisibleClass}`).each((e => {
                o(r ? d(e).attr("data-swiper-slide-index") : d(e).index())
            })); else if (c > 1) for (let e = i; e < i + c; e += 1) p(e) && o(e); else o(i);
            if (n.loadPrevNext) if (c > 1 || n.loadPrevNextAmount && n.loadPrevNextAmount > 1) {
                const e = n.loadPrevNextAmount, t = Math.ceil(c), s = Math.min(i + t + Math.max(e, t), a.length),
                    r = Math.max(i - Math.max(t, e), 0);
                for (let e = i + t; e < s; e += 1) p(e) && o(e);
                for (let e = r; e < i; e += 1) p(e) && o(e)
            } else {
                const t = e.children(`.${s.slideNextClass}`);
                t.length > 0 && o(u(t));
                const a = e.children(`.${s.slidePrevClass}`);
                a.length > 0 && o(u(a))
            }
        }

        function p() {
            const e = r();
            if (!t || t.destroyed) return;
            const s = t.params.lazy.scrollingElement ? d(t.params.lazy.scrollingElement) : d(e), a = s[0] === e,
                i = a ? e.innerWidth : s[0].offsetWidth, l = a ? e.innerHeight : s[0].offsetHeight,
                o = t.$el.offset(), {rtlTranslate: u} = t;
            let h = !1;
            u && (o.left -= t.$el[0].scrollLeft);
            const m = [[o.left, o.top], [o.left + t.width, o.top], [o.left, o.top + t.height], [o.left + t.width, o.top + t.height]];
            for (let e = 0; e < m.length; e += 1) {
                const t = m[e];
                if (t[0] >= 0 && t[0] <= i && t[1] >= 0 && t[1] <= l) {
                    if (0 === t[0] && 0 === t[1]) continue;
                    h = !0
                }
            }
            const f = !("touchstart" !== t.touchEvents.start || !t.support.passiveListener || !t.params.passiveListeners) && {
                passive: !0,
                capture: !1
            };
            h ? (c(), s.off("scroll", p, f)) : n || (n = !0, s.on("scroll", p, f))
        }

        a("beforeInit", (() => {
            t.params.lazy.enabled && t.params.preloadImages && (t.params.preloadImages = !1)
        })), a("init", (() => {
            t.params.lazy.enabled && (t.params.lazy.checkInView ? p() : c())
        })), a("scroll", (() => {
            t.params.freeMode && t.params.freeMode.enabled && !t.params.freeMode.sticky && c()
        })), a("scrollbarDragMove resize _freeModeNoMomentumRelease", (() => {
            t.params.lazy.enabled && (t.params.lazy.checkInView ? p() : c())
        })), a("transitionStart", (() => {
            t.params.lazy.enabled && (t.params.lazy.loadOnTransitionStart || !t.params.lazy.loadOnTransitionStart && !l) && (t.params.lazy.checkInView ? p() : c())
        })), a("transitionEnd", (() => {
            t.params.lazy.enabled && !t.params.lazy.loadOnTransitionStart && (t.params.lazy.checkInView ? p() : c())
        })), a("slideChange", (() => {
            const {lazy: e, cssMode: s, watchSlidesProgress: a, touchReleaseOnEdges: i, resistanceRatio: r} = t.params;
            e.enabled && (s || a && (i || 0 === r)) && c()
        })), a("destroy", (() => {
            t.$el && t.$el.find(`.${t.params.lazy.loadingClass}`).removeClass(t.params.lazy.loadingClass)
        })), Object.assign(t.lazy, {load: c, loadInSlide: o})
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;

        function i(e, t) {
            const s = function () {
                let e, t, s;
                return (a, i) => {
                    for (t = -1, e = a.length; e - t > 1;) s = e + t >> 1, a[s] <= i ? t = s : e = s;
                    return e
                }
            }();
            let a, i;
            return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) {
                return e ? (i = s(this.x, e), a = i - 1, (e - this.x[a]) * (this.y[i] - this.y[a]) / (this.x[i] - this.x[a]) + this.y[a]) : 0
            }, this
        }

        function r() {
            t.controller.control && t.controller.spline && (t.controller.spline = void 0, delete t.controller.spline)
        }

        s({
            controller: {
                control: void 0,
                inverse: !1,
                by: "slide"
            }
        }), t.controller = {control: void 0}, a("beforeInit", (() => {
            t.controller.control = t.params.controller.control
        })), a("update", (() => {
            r()
        })), a("resize", (() => {
            r()
        })), a("observerUpdate", (() => {
            r()
        })), a("setTranslate", ((e, s, a) => {
            t.controller.control && t.controller.setTranslate(s, a)
        })), a("setTransition", ((e, s, a) => {
            t.controller.control && t.controller.setTransition(s, a)
        })), Object.assign(t.controller, {
            setTranslate: function (e, s) {
                const a = t.controller.control;
                let r, n;
                const l = t.constructor;

                function o(e) {
                    const s = t.rtlTranslate ? -t.translate : t.translate;
                    "slide" === t.params.controller.by && (!function (e) {
                        t.controller.spline || (t.controller.spline = t.params.loop ? new i(t.slidesGrid, e.slidesGrid) : new i(t.snapGrid, e.snapGrid))
                    }(e), n = -t.controller.spline.interpolate(-s)), n && "container" !== t.params.controller.by || (r = (e.maxTranslate() - e.minTranslate()) / (t.maxTranslate() - t.minTranslate()), n = (s - t.minTranslate()) * r + e.minTranslate()), t.params.controller.inverse && (n = e.maxTranslate() - n), e.updateProgress(n), e.setTranslate(n, t), e.updateActiveIndex(), e.updateSlidesClasses()
                }

                if (Array.isArray(a)) for (let e = 0; e < a.length; e += 1) a[e] !== s && a[e] instanceof l && o(a[e]); else a instanceof l && s !== a && o(a)
            }, setTransition: function (e, s) {
                const a = t.constructor, i = t.controller.control;
                let r;

                function n(s) {
                    s.setTransition(e, t), 0 !== e && (s.transitionStart(), s.params.autoHeight && p((() => {
                        s.updateAutoHeight()
                    })), s.$wrapperEl.transitionEnd((() => {
                        i && (s.params.loop && "slide" === t.params.controller.by && s.loopFix(), s.transitionEnd())
                    })))
                }

                if (Array.isArray(i)) for (r = 0; r < i.length; r += 1) i[r] !== s && i[r] instanceof a && n(i[r]); else i instanceof a && s !== i && n(i)
            }
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({
            a11y: {
                enabled: !0,
                notificationClass: "swiper-notification",
                prevSlideMessage: "Previous slide",
                nextSlideMessage: "Next slide",
                firstSlideMessage: "This is the first slide",
                lastSlideMessage: "This is the last slide",
                paginationBulletMessage: "Go to slide {{index}}",
                slideLabelMessage: "{{index}} / {{slidesLength}}",
                containerMessage: null,
                containerRoleDescriptionMessage: null,
                itemRoleDescriptionMessage: null,
                slideRole: "group",
                id: null
            }
        }), t.a11y = {clicked: !1};
        let i = null;

        function r(e) {
            const t = i;
            0 !== t.length && (t.html(""), t.html(e))
        }

        function n(e) {
            e.attr("tabIndex", "0")
        }

        function l(e) {
            e.attr("tabIndex", "-1")
        }

        function o(e, t) {
            e.attr("role", t)
        }

        function c(e, t) {
            e.attr("aria-roledescription", t)
        }

        function p(e, t) {
            e.attr("aria-label", t)
        }

        function u(e) {
            e.attr("aria-disabled", !0)
        }

        function h(e) {
            e.attr("aria-disabled", !1)
        }

        function m(e) {
            if (13 !== e.keyCode && 32 !== e.keyCode) return;
            const s = t.params.a11y, a = d(e.target);
            t.navigation && t.navigation.$nextEl && a.is(t.navigation.$nextEl) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? r(s.lastSlideMessage) : r(s.nextSlideMessage)), t.navigation && t.navigation.$prevEl && a.is(t.navigation.$prevEl) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? r(s.firstSlideMessage) : r(s.prevSlideMessage)), t.pagination && a.is(U(t.params.pagination.bulletClass)) && a[0].click()
        }

        function f() {
            return t.pagination && t.pagination.bullets && t.pagination.bullets.length
        }

        function g() {
            return f() && t.params.pagination.clickable
        }

        const v = (e, t, s) => {
            n(e), "BUTTON" !== e[0].tagName && (o(e, "button"), e.on("keydown", m)), p(e, s), function (e, t) {
                e.attr("aria-controls", t)
            }(e, t)
        }, w = () => {
            t.a11y.clicked = !0
        }, b = () => {
            requestAnimationFrame((() => {
                requestAnimationFrame((() => {
                    t.destroyed || (t.a11y.clicked = !1)
                }))
            }))
        }, x = e => {
            if (t.a11y.clicked) return;
            const s = e.target.closest(`.${t.params.slideClass}`);
            if (!s || !t.slides.includes(s)) return;
            const a = t.slides.indexOf(s) === t.activeIndex,
                i = t.params.watchSlidesProgress && t.visibleSlides && t.visibleSlides.includes(s);
            a || i || e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents || (t.isHorizontal() ? t.el.scrollLeft = 0 : t.el.scrollTop = 0, t.slideTo(t.slides.indexOf(s), 0))
        }, y = () => {
            const e = t.params.a11y;
            e.itemRoleDescriptionMessage && c(d(t.slides), e.itemRoleDescriptionMessage), e.slideRole && o(d(t.slides), e.slideRole);
            const s = t.params.loop ? t.slides.filter((e => !e.classList.contains(t.params.slideDuplicateClass))).length : t.slides.length;
            e.slideLabelMessage && t.slides.each(((a, i) => {
                const r = d(a), n = t.params.loop ? parseInt(r.attr("data-swiper-slide-index"), 10) : i;
                p(r, e.slideLabelMessage.replace(/\{\{index\}\}/, n + 1).replace(/\{\{slidesLength\}\}/, s))
            }))
        }, E = () => {
            const e = t.params.a11y;
            t.$el.append(i);
            const s = t.$el;
            e.containerRoleDescriptionMessage && c(s, e.containerRoleDescriptionMessage), e.containerMessage && p(s, e.containerMessage);
            const a = t.$wrapperEl,
                r = e.id || a.attr("id") || `swiper-wrapper-${n = 16, void 0 === n && (n = 16), "x".repeat(n).replace(/x/g, (() => Math.round(16 * Math.random()).toString(16)))}`;
            var n;
            const l = t.params.autoplay && t.params.autoplay.enabled ? "off" : "polite";
            var o;
            let d, u;
            o = r, a.attr("id", o), function (e, t) {
                e.attr("aria-live", t)
            }(a, l), y(), t.navigation && t.navigation.$nextEl && (d = t.navigation.$nextEl), t.navigation && t.navigation.$prevEl && (u = t.navigation.$prevEl), d && d.length && v(d, r, e.nextSlideMessage), u && u.length && v(u, r, e.prevSlideMessage), g() && t.pagination.$el.on("keydown", U(t.params.pagination.bulletClass), m), t.$el.on("focus", x, !0), t.$el.on("pointerdown", w, !0), t.$el.on("pointerup", b, !0)
        };
        a("beforeInit", (() => {
            i = d(`<span class="${t.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`)
        })), a("afterInit", (() => {
            t.params.a11y.enabled && E()
        })), a("slidesLengthChange snapGridLengthChange slidesGridLengthChange", (() => {
            t.params.a11y.enabled && y()
        })), a("fromEdge toEdge afterInit lock unlock", (() => {
            t.params.a11y.enabled && function () {
                if (t.params.loop || t.params.rewind || !t.navigation) return;
                const {$nextEl: e, $prevEl: s} = t.navigation;
                s && s.length > 0 && (t.isBeginning ? (u(s), l(s)) : (h(s), n(s))), e && e.length > 0 && (t.isEnd ? (u(e), l(e)) : (h(e), n(e)))
            }()
        })), a("paginationUpdate", (() => {
            t.params.a11y.enabled && function () {
                const e = t.params.a11y;
                f() && t.pagination.bullets.each((s => {
                    const a = d(s);
                    t.params.pagination.clickable && (n(a), t.params.pagination.renderBullet || (o(a, "button"), p(a, e.paginationBulletMessage.replace(/\{\{index\}\}/, a.index() + 1)))), a.is(`.${t.params.pagination.bulletActiveClass}`) ? a.attr("aria-current", "true") : a.removeAttr("aria-current")
                }))
            }()
        })), a("destroy", (() => {
            t.params.a11y.enabled && function () {
                let e, s;
                i && i.length > 0 && i.remove(), t.navigation && t.navigation.$nextEl && (e = t.navigation.$nextEl), t.navigation && t.navigation.$prevEl && (s = t.navigation.$prevEl), e && e.off("keydown", m), s && s.off("keydown", m), g() && t.pagination.$el.off("keydown", U(t.params.pagination.bulletClass), m), t.$el.off("focus", x, !0), t.$el.off("pointerdown", w, !0), t.$el.off("pointerup", b, !0)
            }()
        }))
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({history: {enabled: !1, root: "", replaceState: !1, key: "slides", keepQuery: !1}});
        let i = !1, n = {};
        const l = e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""),
            o = e => {
                const t = r();
                let s;
                s = e ? new URL(e) : t.location;
                const a = s.pathname.slice(1).split("/").filter((e => "" !== e)), i = a.length;
                return {key: a[i - 2], value: a[i - 1]}
            }, d = (e, s) => {
                const a = r();
                if (!i || !t.params.history.enabled) return;
                let n;
                n = t.params.url ? new URL(t.params.url) : a.location;
                const o = t.slides.eq(s);
                let d = l(o.attr("data-history"));
                if (t.params.history.root.length > 0) {
                    let s = t.params.history.root;
                    "/" === s[s.length - 1] && (s = s.slice(0, s.length - 1)), d = `${s}/${e}/${d}`
                } else n.pathname.includes(e) || (d = `${e}/${d}`);
                t.params.history.keepQuery && (d += n.search);
                const c = a.history.state;
                c && c.value === d || (t.params.history.replaceState ? a.history.replaceState({value: d}, null, d) : a.history.pushState({value: d}, null, d))
            }, c = (e, s, a) => {
                if (s) for (let i = 0, r = t.slides.length; i < r; i += 1) {
                    const r = t.slides.eq(i);
                    if (l(r.attr("data-history")) === s && !r.hasClass(t.params.slideDuplicateClass)) {
                        const s = r.index();
                        t.slideTo(s, e, a)
                    }
                } else t.slideTo(0, e, a)
            }, p = () => {
                n = o(t.params.url), c(t.params.speed, n.value, !1)
            };
        a("init", (() => {
            t.params.history.enabled && (() => {
                const e = r();
                if (t.params.history) {
                    if (!e.history || !e.history.pushState) return t.params.history.enabled = !1, void (t.params.hashNavigation.enabled = !0);
                    i = !0, n = o(t.params.url), (n.key || n.value) && (c(0, n.value, t.params.runCallbacksOnInit), t.params.history.replaceState || e.addEventListener("popstate", p))
                }
            })()
        })), a("destroy", (() => {
            t.params.history.enabled && (() => {
                const e = r();
                t.params.history.replaceState || e.removeEventListener("popstate", p)
            })()
        })), a("transitionEnd _freeModeNoMomentumRelease", (() => {
            i && d(t.params.history.key, t.activeIndex)
        })), a("slideChange", (() => {
            i && t.params.cssMode && d(t.params.history.key, t.activeIndex)
        }))
    }, function (e) {
        let {swiper: t, extendParams: s, emit: i, on: n} = e, l = !1;
        const o = a(), c = r();
        s({hashNavigation: {enabled: !1, replaceState: !1, watchState: !1}});
        const p = () => {
            i("hashChange");
            const e = o.location.hash.replace("#", "");
            if (e !== t.slides.eq(t.activeIndex).attr("data-hash")) {
                const s = t.$wrapperEl.children(`.${t.params.slideClass}[data-hash="${e}"]`).index();
                if (void 0 === s) return;
                t.slideTo(s)
            }
        }, u = () => {
            if (l && t.params.hashNavigation.enabled) if (t.params.hashNavigation.replaceState && c.history && c.history.replaceState) c.history.replaceState(null, null, `#${t.slides.eq(t.activeIndex).attr("data-hash")}` || ""), i("hashSet"); else {
                const e = t.slides.eq(t.activeIndex), s = e.attr("data-hash") || e.attr("data-history");
                o.location.hash = s || "", i("hashSet")
            }
        };
        n("init", (() => {
            t.params.hashNavigation.enabled && (() => {
                if (!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled) return;
                l = !0;
                const e = o.location.hash.replace("#", "");
                if (e) {
                    const s = 0;
                    for (let a = 0, i = t.slides.length; a < i; a += 1) {
                        const i = t.slides.eq(a);
                        if ((i.attr("data-hash") || i.attr("data-history")) === e && !i.hasClass(t.params.slideDuplicateClass)) {
                            const e = i.index();
                            t.slideTo(e, s, t.params.runCallbacksOnInit, !0)
                        }
                    }
                }
                t.params.hashNavigation.watchState && d(c).on("hashchange", p)
            })()
        })), n("destroy", (() => {
            t.params.hashNavigation.enabled && t.params.hashNavigation.watchState && d(c).off("hashchange", p)
        })), n("transitionEnd _freeModeNoMomentumRelease", (() => {
            l && u()
        })), n("slideChange", (() => {
            l && t.params.cssMode && u()
        }))
    }, function (e) {
        let t, {swiper: s, extendParams: i, on: r, emit: n} = e;

        function l() {
            if (!s.size) return s.autoplay.running = !1, void (s.autoplay.paused = !1);
            const e = s.slides.eq(s.activeIndex);
            let a = s.params.autoplay.delay;
            e.attr("data-swiper-autoplay") && (a = e.attr("data-swiper-autoplay") || s.params.autoplay.delay), clearTimeout(t), t = p((() => {
                let e;
                s.params.autoplay.reverseDirection ? s.params.loop ? (s.loopFix(), e = s.slidePrev(s.params.speed, !0, !0), n("autoplay")) : s.isBeginning ? s.params.autoplay.stopOnLastSlide ? d() : (e = s.slideTo(s.slides.length - 1, s.params.speed, !0, !0), n("autoplay")) : (e = s.slidePrev(s.params.speed, !0, !0), n("autoplay")) : s.params.loop ? (s.loopFix(), e = s.slideNext(s.params.speed, !0, !0), n("autoplay")) : s.isEnd ? s.params.autoplay.stopOnLastSlide ? d() : (e = s.slideTo(0, s.params.speed, !0, !0), n("autoplay")) : (e = s.slideNext(s.params.speed, !0, !0), n("autoplay")), (s.params.cssMode && s.autoplay.running || !1 === e) && l()
            }), a)
        }

        function o() {
            return void 0 === t && (!s.autoplay.running && (s.autoplay.running = !0, n("autoplayStart"), l(), !0))
        }

        function d() {
            return !!s.autoplay.running && (void 0 !== t && (t && (clearTimeout(t), t = void 0), s.autoplay.running = !1, n("autoplayStop"), !0))
        }

        function c(e) {
            s.autoplay.running && (s.autoplay.paused || (t && clearTimeout(t), s.autoplay.paused = !0, 0 !== e && s.params.autoplay.waitForTransition ? ["transitionend", "webkitTransitionEnd"].forEach((e => {
                s.$wrapperEl[0].addEventListener(e, h)
            })) : (s.autoplay.paused = !1, l())))
        }

        function u() {
            const e = a();
            "hidden" === e.visibilityState && s.autoplay.running && c(), "visible" === e.visibilityState && s.autoplay.paused && (l(), s.autoplay.paused = !1)
        }

        function h(e) {
            s && !s.destroyed && s.$wrapperEl && e.target === s.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach((e => {
                s.$wrapperEl[0].removeEventListener(e, h)
            })), s.autoplay.paused = !1, s.autoplay.running ? l() : d())
        }

        function m() {
            s.params.autoplay.disableOnInteraction ? d() : (n("autoplayPause"), c()), ["transitionend", "webkitTransitionEnd"].forEach((e => {
                s.$wrapperEl[0].removeEventListener(e, h)
            }))
        }

        function f() {
            s.params.autoplay.disableOnInteraction || (s.autoplay.paused = !1, n("autoplayResume"), l())
        }

        s.autoplay = {running: !1, paused: !1}, i({
            autoplay: {
                enabled: !1,
                delay: 3e3,
                waitForTransition: !0,
                disableOnInteraction: !0,
                stopOnLastSlide: !1,
                reverseDirection: !1,
                pauseOnMouseEnter: !1
            }
        }), r("init", (() => {
            if (s.params.autoplay.enabled) {
                o();
                a().addEventListener("visibilitychange", u), s.params.autoplay.pauseOnMouseEnter && (s.$el.on("mouseenter", m), s.$el.on("mouseleave", f))
            }
        })), r("beforeTransitionStart", ((e, t, a) => {
            s.autoplay.running && (a || !s.params.autoplay.disableOnInteraction ? s.autoplay.pause(t) : d())
        })), r("sliderFirstMove", (() => {
            s.autoplay.running && (s.params.autoplay.disableOnInteraction ? d() : c())
        })), r("touchEnd", (() => {
            s.params.cssMode && s.autoplay.paused && !s.params.autoplay.disableOnInteraction && l()
        })), r("destroy", (() => {
            s.$el.off("mouseenter", m), s.$el.off("mouseleave", f), s.autoplay.running && d();
            a().removeEventListener("visibilitychange", u)
        })), Object.assign(s.autoplay, {pause: c, run: l, start: o, stop: d})
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({
            thumbs: {
                swiper: null,
                multipleActiveThumbs: !0,
                autoScrollOffset: 0,
                slideThumbActiveClass: "swiper-slide-thumb-active",
                thumbsContainerClass: "swiper-thumbs"
            }
        });
        let i = !1, r = !1;

        function n() {
            const e = t.thumbs.swiper;
            if (!e || e.destroyed) return;
            const s = e.clickedIndex, a = e.clickedSlide;
            if (a && d(a).hasClass(t.params.thumbs.slideThumbActiveClass)) return;
            if (null == s) return;
            let i;
            if (i = e.params.loop ? parseInt(d(e.clickedSlide).attr("data-swiper-slide-index"), 10) : s, t.params.loop) {
                let e = t.activeIndex;
                t.slides.eq(e).hasClass(t.params.slideDuplicateClass) && (t.loopFix(), t._clientLeft = t.$wrapperEl[0].clientLeft, e = t.activeIndex);
                const s = t.slides.eq(e).prevAll(`[data-swiper-slide-index="${i}"]`).eq(0).index(),
                    a = t.slides.eq(e).nextAll(`[data-swiper-slide-index="${i}"]`).eq(0).index();
                i = void 0 === s ? a : void 0 === a ? s : a - e < e - s ? a : s
            }
            t.slideTo(i)
        }

        function l() {
            const {thumbs: e} = t.params;
            if (i) return !1;
            i = !0;
            const s = t.constructor;
            if (e.swiper instanceof s) t.thumbs.swiper = e.swiper, Object.assign(t.thumbs.swiper.originalParams, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1
            }), Object.assign(t.thumbs.swiper.params, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1
            }); else if (m(e.swiper)) {
                const a = Object.assign({}, e.swiper);
                Object.assign(a, {watchSlidesProgress: !0, slideToClickedSlide: !1}), t.thumbs.swiper = new s(a), r = !0
            }
            return t.thumbs.swiper.$el.addClass(t.params.thumbs.thumbsContainerClass), t.thumbs.swiper.on("tap", n), !0
        }

        function o(e) {
            const s = t.thumbs.swiper;
            if (!s || s.destroyed) return;
            const a = "auto" === s.params.slidesPerView ? s.slidesPerViewDynamic() : s.params.slidesPerView;
            let i = 1;
            const r = t.params.thumbs.slideThumbActiveClass;
            if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (i = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (i = 1), i = Math.floor(i), s.slides.removeClass(r), s.params.loop || s.params.virtual && s.params.virtual.enabled) for (let e = 0; e < i; e += 1) s.$wrapperEl.children(`[data-swiper-slide-index="${t.realIndex + e}"]`).addClass(r); else for (let e = 0; e < i; e += 1) s.slides.eq(t.realIndex + e).addClass(r);
            const n = t.params.thumbs.autoScrollOffset, l = n && !s.params.loop;
            if (t.realIndex !== s.realIndex || l) {
                let i, r, o = s.activeIndex;
                if (s.params.loop) {
                    s.slides.eq(o).hasClass(s.params.slideDuplicateClass) && (s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft, o = s.activeIndex);
                    const e = s.slides.eq(o).prevAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index(),
                        a = s.slides.eq(o).nextAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index();
                    i = void 0 === e ? a : void 0 === a ? e : a - o == o - e ? s.params.slidesPerGroup > 1 ? a : o : a - o < o - e ? a : e, r = t.activeIndex > t.previousIndex ? "next" : "prev"
                } else i = t.realIndex, r = i > t.previousIndex ? "next" : "prev";
                l && (i += "next" === r ? n : -1 * n), s.visibleSlidesIndexes && s.visibleSlidesIndexes.indexOf(i) < 0 && (s.params.centeredSlides ? i = i > o ? i - Math.floor(a / 2) + 1 : i + Math.floor(a / 2) - 1 : i > o && s.params.slidesPerGroup, s.slideTo(i, e ? 0 : void 0))
            }
        }

        t.thumbs = {swiper: null}, a("beforeInit", (() => {
            const {thumbs: e} = t.params;
            e && e.swiper && (l(), o(!0))
        })), a("slideChange update resize observerUpdate", (() => {
            o()
        })), a("setTransition", ((e, s) => {
            const a = t.thumbs.swiper;
            a && !a.destroyed && a.setTransition(s)
        })), a("beforeDestroy", (() => {
            const e = t.thumbs.swiper;
            e && !e.destroyed && r && e.destroy()
        })), Object.assign(t.thumbs, {init: l, update: o})
    }, function (e) {
        let {swiper: t, extendParams: s, emit: a, once: i} = e;
        s({
            freeMode: {
                enabled: !1,
                momentum: !0,
                momentumRatio: 1,
                momentumBounce: !0,
                momentumBounceRatio: 1,
                momentumVelocityRatio: 1,
                sticky: !1,
                minimumVelocity: .02
            }
        }), Object.assign(t, {
            freeMode: {
                onTouchStart: function () {
                    const e = t.getTranslate();
                    t.setTranslate(e), t.setTransition(0), t.touchEventsData.velocities.length = 0, t.freeMode.onTouchEnd({currentPos: t.rtl ? t.translate : -t.translate})
                }, onTouchMove: function () {
                    const {touchEventsData: e, touches: s} = t;
                    0 === e.velocities.length && e.velocities.push({
                        position: s[t.isHorizontal() ? "startX" : "startY"],
                        time: e.touchStartTime
                    }), e.velocities.push({position: s[t.isHorizontal() ? "currentX" : "currentY"], time: u()})
                }, onTouchEnd: function (e) {
                    let {currentPos: s} = e;
                    const {params: r, $wrapperEl: n, rtlTranslate: l, snapGrid: o, touchEventsData: d} = t,
                        c = u() - d.touchStartTime;
                    if (s < -t.minTranslate()) t.slideTo(t.activeIndex); else if (s > -t.maxTranslate()) t.slides.length < o.length ? t.slideTo(o.length - 1) : t.slideTo(t.slides.length - 1); else {
                        if (r.freeMode.momentum) {
                            if (d.velocities.length > 1) {
                                const e = d.velocities.pop(), s = d.velocities.pop(), a = e.position - s.position,
                                    i = e.time - s.time;
                                t.velocity = a / i, t.velocity /= 2, Math.abs(t.velocity) < r.freeMode.minimumVelocity && (t.velocity = 0), (i > 150 || u() - e.time > 300) && (t.velocity = 0)
                            } else t.velocity = 0;
                            t.velocity *= r.freeMode.momentumVelocityRatio, d.velocities.length = 0;
                            let e = 1e3 * r.freeMode.momentumRatio;
                            const s = t.velocity * e;
                            let c = t.translate + s;
                            l && (c = -c);
                            let p, h = !1;
                            const m = 20 * Math.abs(t.velocity) * r.freeMode.momentumBounceRatio;
                            let f;
                            if (c < t.maxTranslate()) r.freeMode.momentumBounce ? (c + t.maxTranslate() < -m && (c = t.maxTranslate() - m), p = t.maxTranslate(), h = !0, d.allowMomentumBounce = !0) : c = t.maxTranslate(), r.loop && r.centeredSlides && (f = !0); else if (c > t.minTranslate()) r.freeMode.momentumBounce ? (c - t.minTranslate() > m && (c = t.minTranslate() + m), p = t.minTranslate(), h = !0, d.allowMomentumBounce = !0) : c = t.minTranslate(), r.loop && r.centeredSlides && (f = !0); else if (r.freeMode.sticky) {
                                let e;
                                for (let t = 0; t < o.length; t += 1) if (o[t] > -c) {
                                    e = t;
                                    break
                                }
                                c = Math.abs(o[e] - c) < Math.abs(o[e - 1] - c) || "next" === t.swipeDirection ? o[e] : o[e - 1], c = -c
                            }
                            if (f && i("transitionEnd", (() => {
                                t.loopFix()
                            })), 0 !== t.velocity) {
                                if (e = l ? Math.abs((-c - t.translate) / t.velocity) : Math.abs((c - t.translate) / t.velocity), r.freeMode.sticky) {
                                    const s = Math.abs((l ? -c : c) - t.translate),
                                        a = t.slidesSizesGrid[t.activeIndex];
                                    e = s < a ? r.speed : s < 2 * a ? 1.5 * r.speed : 2.5 * r.speed
                                }
                            } else if (r.freeMode.sticky) return void t.slideToClosest();
                            r.freeMode.momentumBounce && h ? (t.updateProgress(p), t.setTransition(e), t.setTranslate(c), t.transitionStart(!0, t.swipeDirection), t.animating = !0, n.transitionEnd((() => {
                                t && !t.destroyed && d.allowMomentumBounce && (a("momentumBounce"), t.setTransition(r.speed), setTimeout((() => {
                                    t.setTranslate(p), n.transitionEnd((() => {
                                        t && !t.destroyed && t.transitionEnd()
                                    }))
                                }), 0))
                            }))) : t.velocity ? (a("_freeModeNoMomentumRelease"), t.updateProgress(c), t.setTransition(e), t.setTranslate(c), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, n.transitionEnd((() => {
                                t && !t.destroyed && t.transitionEnd()
                            })))) : t.updateProgress(c), t.updateActiveIndex(), t.updateSlidesClasses()
                        } else {
                            if (r.freeMode.sticky) return void t.slideToClosest();
                            r.freeMode && a("_freeModeNoMomentumRelease")
                        }
                        (!r.freeMode.momentum || c >= r.longSwipesMs) && (t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses())
                    }
                }
            }
        })
    }, function (e) {
        let t, s, a, {swiper: i, extendParams: r} = e;
        r({grid: {rows: 1, fill: "column"}}), i.grid = {
            initSlides: e => {
                const {slidesPerView: r} = i.params, {rows: n, fill: l} = i.params.grid;
                s = t / n, a = Math.floor(e / n), t = Math.floor(e / n) === e / n ? e : Math.ceil(e / n) * n, "auto" !== r && "row" === l && (t = Math.max(t, r * n))
            }, updateSlide: (e, r, n, l) => {
                const {slidesPerGroup: o, spaceBetween: d} = i.params, {rows: c, fill: p} = i.params.grid;
                let u, h, m;
                if ("row" === p && o > 1) {
                    const s = Math.floor(e / (o * c)), a = e - c * o * s,
                        i = 0 === s ? o : Math.min(Math.ceil((n - s * c * o) / c), o);
                    m = Math.floor(a / i), h = a - m * i + s * o, u = h + m * t / c, r.css({
                        "-webkit-order": u,
                        order: u
                    })
                } else "column" === p ? (h = Math.floor(e / c), m = e - h * c, (h > a || h === a && m === c - 1) && (m += 1, m >= c && (m = 0, h += 1))) : (m = Math.floor(e / s), h = e - m * s);
                r.css(l("margin-top"), 0 !== m ? d && `${d}px` : "")
            }, updateWrapperSize: (e, s, a) => {
                const {spaceBetween: r, centeredSlides: n, roundLengths: l} = i.params, {rows: o} = i.params.grid;
                if (i.virtualSize = (e + r) * t, i.virtualSize = Math.ceil(i.virtualSize / o) - r, i.$wrapperEl.css({[a("width")]: `${i.virtualSize + r}px`}), n) {
                    s.splice(0, s.length);
                    const e = [];
                    for (let t = 0; t < s.length; t += 1) {
                        let a = s[t];
                        l && (a = Math.floor(a)), s[t] < i.virtualSize + s[0] && e.push(a)
                    }
                    s.push(...e)
                }
            }
        }
    }, function (e) {
        let {swiper: t} = e;
        Object.assign(t, {
            appendSlide: K.bind(t),
            prependSlide: Z.bind(t),
            addSlide: Q.bind(t),
            removeSlide: J.bind(t),
            removeAllSlides: ee.bind(t)
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({fadeEffect: {crossFade: !1, transformEl: null}}), te({
            effect: "fade",
            swiper: t,
            on: a,
            setTranslate: () => {
                const {slides: e} = t, s = t.params.fadeEffect;
                for (let a = 0; a < e.length; a += 1) {
                    const e = t.slides.eq(a);
                    let i = -e[0].swiperSlideOffset;
                    t.params.virtualTranslate || (i -= t.translate);
                    let r = 0;
                    t.isHorizontal() || (r = i, i = 0);
                    const n = t.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(e[0].progress), 0) : 1 + Math.min(Math.max(e[0].progress, -1), 0);
                    se(s, e).css({opacity: n}).transform(`translate3d(${i}px, ${r}px, 0px)`)
                }
            },
            setTransition: e => {
                const {transformEl: s} = t.params.fadeEffect;
                (s ? t.slides.find(s) : t.slides).transition(e), ae({
                    swiper: t,
                    duration: e,
                    transformEl: s,
                    allSlides: !0
                })
            },
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: !0,
                spaceBetween: 0,
                virtualTranslate: !t.params.cssMode
            })
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({cubeEffect: {slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: .94}});
        const i = (e, t, s) => {
            let a = s ? e.find(".swiper-slide-shadow-left") : e.find(".swiper-slide-shadow-top"),
                i = s ? e.find(".swiper-slide-shadow-right") : e.find(".swiper-slide-shadow-bottom");
            0 === a.length && (a = d(`<div class="swiper-slide-shadow-${s ? "left" : "top"}"></div>`), e.append(a)), 0 === i.length && (i = d(`<div class="swiper-slide-shadow-${s ? "right" : "bottom"}"></div>`), e.append(i)), a.length && (a[0].style.opacity = Math.max(-t, 0)), i.length && (i[0].style.opacity = Math.max(t, 0))
        };
        te({
            effect: "cube",
            swiper: t,
            on: a,
            setTranslate: () => {
                const {$el: e, $wrapperEl: s, slides: a, width: r, height: n, rtlTranslate: l, size: o, browser: c} = t,
                    p = t.params.cubeEffect, u = t.isHorizontal(), h = t.virtual && t.params.virtual.enabled;
                let m, f = 0;
                p.shadow && (u ? (m = s.find(".swiper-cube-shadow"), 0 === m.length && (m = d('<div class="swiper-cube-shadow"></div>'), s.append(m)), m.css({height: `${r}px`})) : (m = e.find(".swiper-cube-shadow"), 0 === m.length && (m = d('<div class="swiper-cube-shadow"></div>'), e.append(m))));
                for (let e = 0; e < a.length; e += 1) {
                    const t = a.eq(e);
                    let s = e;
                    h && (s = parseInt(t.attr("data-swiper-slide-index"), 10));
                    let r = 90 * s, n = Math.floor(r / 360);
                    l && (r = -r, n = Math.floor(-r / 360));
                    const d = Math.max(Math.min(t[0].progress, 1), -1);
                    let c = 0, m = 0, g = 0;
                    s % 4 == 0 ? (c = 4 * -n * o, g = 0) : (s - 1) % 4 == 0 ? (c = 0, g = 4 * -n * o) : (s - 2) % 4 == 0 ? (c = o + 4 * n * o, g = o) : (s - 3) % 4 == 0 && (c = -o, g = 3 * o + 4 * o * n), l && (c = -c), u || (m = c, c = 0);
                    const v = `rotateX(${u ? 0 : -r}deg) rotateY(${u ? r : 0}deg) translate3d(${c}px, ${m}px, ${g}px)`;
                    d <= 1 && d > -1 && (f = 90 * s + 90 * d, l && (f = 90 * -s - 90 * d)), t.transform(v), p.slideShadows && i(t, d, u)
                }
                if (s.css({
                    "-webkit-transform-origin": `50% 50% -${o / 2}px`,
                    "transform-origin": `50% 50% -${o / 2}px`
                }), p.shadow) if (u) m.transform(`translate3d(0px, ${r / 2 + p.shadowOffset}px, ${-r / 2}px) rotateX(90deg) rotateZ(0deg) scale(${p.shadowScale})`); else {
                    const e = Math.abs(f) - 90 * Math.floor(Math.abs(f) / 90),
                        t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2),
                        s = p.shadowScale, a = p.shadowScale / t, i = p.shadowOffset;
                    m.transform(`scale3d(${s}, 1, ${a}) translate3d(0px, ${n / 2 + i}px, ${-n / 2 / a}px) rotateX(-90deg)`)
                }
                const g = c.isSafari || c.isWebView ? -o / 2 : 0;
                s.transform(`translate3d(0px,0,${g}px) rotateX(${t.isHorizontal() ? 0 : f}deg) rotateY(${t.isHorizontal() ? -f : 0}deg)`), s[0].style.setProperty("--swiper-cube-translate-z", `${g}px`)
            },
            setTransition: e => {
                const {$el: s, slides: a} = t;
                a.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), t.params.cubeEffect.shadow && !t.isHorizontal() && s.find(".swiper-cube-shadow").transition(e)
            },
            recreateShadows: () => {
                const e = t.isHorizontal();
                t.slides.each((t => {
                    const s = Math.max(Math.min(t.progress, 1), -1);
                    i(d(t), s, e)
                }))
            },
            getEffectParams: () => t.params.cubeEffect,
            perspective: () => !0,
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: !0,
                resistanceRatio: 0,
                spaceBetween: 0,
                centeredSlides: !1,
                virtualTranslate: !0
            })
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({flipEffect: {slideShadows: !0, limitRotation: !0, transformEl: null}});
        const i = (e, s, a) => {
            let i = t.isHorizontal() ? e.find(".swiper-slide-shadow-left") : e.find(".swiper-slide-shadow-top"),
                r = t.isHorizontal() ? e.find(".swiper-slide-shadow-right") : e.find(".swiper-slide-shadow-bottom");
            0 === i.length && (i = ie(a, e, t.isHorizontal() ? "left" : "top")), 0 === r.length && (r = ie(a, e, t.isHorizontal() ? "right" : "bottom")), i.length && (i[0].style.opacity = Math.max(-s, 0)), r.length && (r[0].style.opacity = Math.max(s, 0))
        };
        te({
            effect: "flip",
            swiper: t,
            on: a,
            setTranslate: () => {
                const {slides: e, rtlTranslate: s} = t, a = t.params.flipEffect;
                for (let r = 0; r < e.length; r += 1) {
                    const n = e.eq(r);
                    let l = n[0].progress;
                    t.params.flipEffect.limitRotation && (l = Math.max(Math.min(n[0].progress, 1), -1));
                    const o = n[0].swiperSlideOffset;
                    let d = -180 * l, c = 0, p = t.params.cssMode ? -o - t.translate : -o, u = 0;
                    t.isHorizontal() ? s && (d = -d) : (u = p, p = 0, c = -d, d = 0), n[0].style.zIndex = -Math.abs(Math.round(l)) + e.length, a.slideShadows && i(n, l, a);
                    const h = `translate3d(${p}px, ${u}px, 0px) rotateX(${c}deg) rotateY(${d}deg)`;
                    se(a, n).transform(h)
                }
            },
            setTransition: e => {
                const {transformEl: s} = t.params.flipEffect;
                (s ? t.slides.find(s) : t.slides).transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), ae({
                    swiper: t,
                    duration: e,
                    transformEl: s
                })
            },
            recreateShadows: () => {
                const e = t.params.flipEffect;
                t.slides.each((s => {
                    const a = d(s);
                    let r = a[0].progress;
                    t.params.flipEffect.limitRotation && (r = Math.max(Math.min(s.progress, 1), -1)), i(a, r, e)
                }))
            },
            getEffectParams: () => t.params.flipEffect,
            perspective: () => !0,
            overwriteParams: () => ({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: !0,
                spaceBetween: 0,
                virtualTranslate: !t.params.cssMode
            })
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({
            coverflowEffect: {
                rotate: 50,
                stretch: 0,
                depth: 100,
                scale: 1,
                modifier: 1,
                slideShadows: !0,
                transformEl: null
            }
        }), te({
            effect: "coverflow", swiper: t, on: a, setTranslate: () => {
                const {width: e, height: s, slides: a, slidesSizesGrid: i} = t, r = t.params.coverflowEffect,
                    n = t.isHorizontal(), l = t.translate, o = n ? e / 2 - l : s / 2 - l, d = n ? r.rotate : -r.rotate,
                    c = r.depth;
                for (let e = 0, t = a.length; e < t; e += 1) {
                    const t = a.eq(e), s = i[e], l = (o - t[0].swiperSlideOffset - s / 2) / s,
                        p = "function" == typeof r.modifier ? r.modifier(l) : l * r.modifier;
                    let u = n ? d * p : 0, h = n ? 0 : d * p, m = -c * Math.abs(p), f = r.stretch;
                    "string" == typeof f && -1 !== f.indexOf("%") && (f = parseFloat(r.stretch) / 100 * s);
                    let g = n ? 0 : f * p, v = n ? f * p : 0, w = 1 - (1 - r.scale) * Math.abs(p);
                    Math.abs(v) < .001 && (v = 0), Math.abs(g) < .001 && (g = 0), Math.abs(m) < .001 && (m = 0), Math.abs(u) < .001 && (u = 0), Math.abs(h) < .001 && (h = 0), Math.abs(w) < .001 && (w = 0);
                    const b = `translate3d(${v}px,${g}px,${m}px)  rotateX(${h}deg) rotateY(${u}deg) scale(${w})`;
                    if (se(r, t).transform(b), t[0].style.zIndex = 1 - Math.abs(Math.round(p)), r.slideShadows) {
                        let e = n ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"),
                            s = n ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom");
                        0 === e.length && (e = ie(r, t, n ? "left" : "top")), 0 === s.length && (s = ie(r, t, n ? "right" : "bottom")), e.length && (e[0].style.opacity = p > 0 ? p : 0), s.length && (s[0].style.opacity = -p > 0 ? -p : 0)
                    }
                }
            }, setTransition: e => {
                const {transformEl: s} = t.params.coverflowEffect;
                (s ? t.slides.find(s) : t.slides).transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e)
            }, perspective: () => !0, overwriteParams: () => ({watchSlidesProgress: !0})
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({
            creativeEffect: {
                transformEl: null,
                limitProgress: 1,
                shadowPerProgress: !1,
                progressMultiplier: 1,
                perspective: !0,
                prev: {translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1},
                next: {translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1}
            }
        });
        const i = e => "string" == typeof e ? e : `${e}px`;
        te({
            effect: "creative",
            swiper: t,
            on: a,
            setTranslate: () => {
                const {slides: e, $wrapperEl: s, slidesSizesGrid: a} = t,
                    r = t.params.creativeEffect, {progressMultiplier: n} = r, l = t.params.centeredSlides;
                if (l) {
                    const e = a[0] / 2 - t.params.slidesOffsetBefore || 0;
                    s.transform(`translateX(calc(50% - ${e}px))`)
                }
                for (let s = 0; s < e.length; s += 1) {
                    const a = e.eq(s), o = a[0].progress,
                        d = Math.min(Math.max(a[0].progress, -r.limitProgress), r.limitProgress);
                    let c = d;
                    l || (c = Math.min(Math.max(a[0].originalProgress, -r.limitProgress), r.limitProgress));
                    const p = a[0].swiperSlideOffset, u = [t.params.cssMode ? -p - t.translate : -p, 0, 0],
                        h = [0, 0, 0];
                    let m = !1;
                    t.isHorizontal() || (u[1] = u[0], u[0] = 0);
                    let f = {translate: [0, 0, 0], rotate: [0, 0, 0], scale: 1, opacity: 1};
                    d < 0 ? (f = r.next, m = !0) : d > 0 && (f = r.prev, m = !0), u.forEach(((e, t) => {
                        u[t] = `calc(${e}px + (${i(f.translate[t])} * ${Math.abs(d * n)}))`
                    })), h.forEach(((e, t) => {
                        h[t] = f.rotate[t] * Math.abs(d * n)
                    })), a[0].style.zIndex = -Math.abs(Math.round(o)) + e.length;
                    const g = u.join(", "), v = `rotateX(${h[0]}deg) rotateY(${h[1]}deg) rotateZ(${h[2]}deg)`,
                        w = c < 0 ? `scale(${1 + (1 - f.scale) * c * n})` : `scale(${1 - (1 - f.scale) * c * n})`,
                        b = c < 0 ? 1 + (1 - f.opacity) * c * n : 1 - (1 - f.opacity) * c * n,
                        x = `translate3d(${g}) ${v} ${w}`;
                    if (m && f.shadow || !m) {
                        let e = a.children(".swiper-slide-shadow");
                        if (0 === e.length && f.shadow && (e = ie(r, a)), e.length) {
                            const t = r.shadowPerProgress ? d * (1 / r.limitProgress) : d;
                            e[0].style.opacity = Math.min(Math.max(Math.abs(t), 0), 1)
                        }
                    }
                    const y = se(r, a);
                    y.transform(x).css({opacity: b}), f.origin && y.css("transform-origin", f.origin)
                }
            },
            setTransition: e => {
                const {transformEl: s} = t.params.creativeEffect;
                (s ? t.slides.find(s) : t.slides).transition(e).find(".swiper-slide-shadow").transition(e), ae({
                    swiper: t,
                    duration: e,
                    transformEl: s,
                    allSlides: !0
                })
            },
            perspective: () => t.params.creativeEffect.perspective,
            overwriteParams: () => ({watchSlidesProgress: !0, virtualTranslate: !t.params.cssMode})
        })
    }, function (e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({cardsEffect: {slideShadows: !0, transformEl: null, rotate: !0, perSlideRotate: 2, perSlideOffset: 8}}), te({
            effect: "cards",
            swiper: t,
            on: a,
            setTranslate: () => {
                const {slides: e, activeIndex: s} = t, a = t.params.cardsEffect, {
                    startTranslate: i,
                    isTouched: r
                } = t.touchEventsData, n = t.translate;
                for (let l = 0; l < e.length; l += 1) {
                    const o = e.eq(l), d = o[0].progress, c = Math.min(Math.max(d, -4), 4);
                    let p = o[0].swiperSlideOffset;
                    t.params.centeredSlides && !t.params.cssMode && t.$wrapperEl.transform(`translateX(${t.minTranslate()}px)`), t.params.centeredSlides && t.params.cssMode && (p -= e[0].swiperSlideOffset);
                    let u = t.params.cssMode ? -p - t.translate : -p, h = 0;
                    const m = -100 * Math.abs(c);
                    let f = 1, g = -a.perSlideRotate * c, v = a.perSlideOffset - .75 * Math.abs(c);
                    const w = t.virtual && t.params.virtual.enabled ? t.virtual.from + l : l,
                        b = (w === s || w === s - 1) && c > 0 && c < 1 && (r || t.params.cssMode) && n < i,
                        x = (w === s || w === s + 1) && c < 0 && c > -1 && (r || t.params.cssMode) && n > i;
                    if (b || x) {
                        const e = (1 - Math.abs((Math.abs(c) - .5) / .5)) ** .5;
                        g += -28 * c * e, f += -.5 * e, v += 96 * e, h = -25 * e * Math.abs(c) + "%"
                    }
                    if (u = c < 0 ? `calc(${u}px + (${v * Math.abs(c)}%))` : c > 0 ? `calc(${u}px + (-${v * Math.abs(c)}%))` : `${u}px`, !t.isHorizontal()) {
                        const e = h;
                        h = u, u = e
                    }
                    const y = c < 0 ? "" + (1 + (1 - f) * c) : "" + (1 - (1 - f) * c),
                        E = `\n        translate3d(${u}, ${h}, ${m}px)\n        rotateZ(${a.rotate ? g : 0}deg)\n        scale(${y})\n      `;
                    if (a.slideShadows) {
                        let e = o.find(".swiper-slide-shadow");
                        0 === e.length && (e = ie(a, o)), e.length && (e[0].style.opacity = Math.min(Math.max((Math.abs(c) - .5) / .5, 0), 1))
                    }
                    o[0].style.zIndex = -Math.abs(Math.round(d)) + e.length;
                    se(a, o).transform(E)
                }
            },
            setTransition: e => {
                const {transformEl: s} = t.params.cardsEffect;
                (s ? t.slides.find(s) : t.slides).transition(e).find(".swiper-slide-shadow").transition(e), ae({
                    swiper: t,
                    duration: e,
                    transformEl: s
                })
            },
            perspective: () => !0,
            overwriteParams: () => ({watchSlidesProgress: !0, virtualTranslate: !t.params.cssMode})
        })
    }];
    return V.use(re), V
}));
//# sourceMappingURL=swiper-bundle.min.js.map
/*!
 * baguetteBox.js
 * @author  feimosi
 * @version 1.11.1
 * @url https://github.com/feimosi/baguetteBox.js
 */
!function(e,t){"use strict";"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.baguetteBox=t()}(this,function(){"use strict";var r,l,u,c,d,f='<svg width="44" height="60"><polyline points="30 10 10 30 30 50" stroke="rgba(255,255,255,0.5)" stroke-width="4"stroke-linecap="butt" fill="none" stroke-linejoin="round"/></svg>',g='<svg width="44" height="60"><polyline points="14 10 34 30 14 50" stroke="rgba(255,255,255,0.5)" stroke-width="4"stroke-linecap="butt" fill="none" stroke-linejoin="round"/></svg>',p='<svg width="30" height="30"><g stroke="rgb(160,160,160)" stroke-width="4"><line x1="5" y1="5" x2="25" y2="25"/><line x1="5" y1="25" x2="25" y2="5"/></g></svg>',b={},v={captions:!0,buttons:"auto",fullScreen:!1,noScrollbars:!1,bodyClass:"baguetteBox-open",titleTag:!1,async:!1,preload:2,animation:"slideIn",afterShow:null,afterHide:null,onChange:null,overlayBackgroundColor:"rgba(0,0,0,.8)"},m={},h=[],o=0,n=!1,i={},a=!1,y=/.+\.(gif|jpe?g|png|webp)/i,w={},k=[],s=null,x=function(e){-1!==e.target.id.indexOf("baguette-img")&&j()},E=function(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0,D()},C=function(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0,X()},B=function(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0,j()},T=function(e){i.count++,1<i.count&&(i.multitouch=!0),i.startX=e.changedTouches[0].pageX,i.startY=e.changedTouches[0].pageY},N=function(e){if(!a&&!i.multitouch){e.preventDefault?e.preventDefault():e.returnValue=!1;var t=e.touches[0]||e.changedTouches[0];40<t.pageX-i.startX?(a=!0,D()):t.pageX-i.startX<-40?(a=!0,X()):100<i.startY-t.pageY&&j()}},L=function(){i.count--,i.count<=0&&(i.multitouch=!1),a=!1},A=function(){L()},P=function(e){"block"===r.style.display&&r.contains&&!r.contains(e.target)&&(e.stopPropagation(),Y())};function S(e){if(w.hasOwnProperty(e)){var t=w[e].galleries;[].forEach.call(t,function(e){[].forEach.call(e,function(e){W(e.imageElement,"click",e.eventHandler)}),h===e&&(h=[])}),delete w[e]}}function F(e){switch(e.keyCode){case 37:D();break;case 39:X();break;case 27:j();break;case 36:!function t(e){e&&e.preventDefault();return M(0)}(e);break;case 35:!function n(e){e&&e.preventDefault();return M(h.length-1)}(e)}}function H(e,t){if(h!==e){for(h=e,function s(e){e=e||{};for(var t in v)b[t]=v[t],"undefined"!=typeof e[t]&&(b[t]=e[t]);l.style.transition=l.style.webkitTransition="fadeIn"===b.animation?"opacity .4s ease":"slideIn"===b.animation?"":"none","auto"===b.buttons&&("ontouchstart"in window||1===h.length)&&(b.buttons=!1);u.style.display=c.style.display=b.buttons?"":"none";try{r.style.backgroundColor=b.overlayBackgroundColor}catch(n){}}(t);l.firstChild;)l.removeChild(l.firstChild);for(var n,o=[],i=[],a=k.length=0;a<e.length;a++)(n=J("div")).className="full-image",n.id="baguette-img-"+a,k.push(n),o.push("baguetteBox-figure-"+a),i.push("baguetteBox-figcaption-"+a),l.appendChild(k[a]);r.setAttribute("aria-labelledby",o.join(" ")),r.setAttribute("aria-describedby",i.join(" "))}}function I(e){b.noScrollbars&&(document.documentElement.style.overflowY="hidden",document.body.style.overflowY="scroll"),"block"!==r.style.display&&(U(document,"keydown",F),i={count:0,startX:null,startY:null},q(o=e,function(){z(o),V(o)}),R(),r.style.display="block",b.fullScreen&&function t(){r.requestFullscreen?r.requestFullscreen():r.webkitRequestFullscreen?r.webkitRequestFullscreen():r.mozRequestFullScreen&&r.mozRequestFullScreen()}(),setTimeout(function(){r.className="visible",b.bodyClass&&document.body.classList&&document.body.classList.add(b.bodyClass),b.afterShow&&b.afterShow()},50),b.onChange&&b.onChange(o,k.length),s=document.activeElement,Y(),n=!0)}function Y(){b.buttons?u.focus():d.focus()}function j(){b.noScrollbars&&(document.documentElement.style.overflowY="auto",document.body.style.overflowY="auto"),"none"!==r.style.display&&(W(document,"keydown",F),r.className="",setTimeout(function(){r.style.display="none",document.fullscreen&&function e(){document.exitFullscreen?document.exitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitExitFullscreen&&document.webkitExitFullscreen()}(),b.bodyClass&&document.body.classList&&document.body.classList.remove(b.bodyClass),b.afterHide&&b.afterHide(),s&&s.focus(),n=!1},500))}function q(t,n){var e=k[t],o=h[t];if(void 0!==e&&void 0!==o)if(e.getElementsByTagName("img")[0])n&&n();else{var i=o.imageElement,a=i.getElementsByTagName("img")[0],s="function"==typeof b.captions?b.captions.call(h,i):i.getAttribute("data-caption")||i.title,r=function d(e){var t=e.href;if(e.dataset){var n=[];for(var o in e.dataset)"at-"!==o.substring(0,3)||isNaN(o.substring(3))||(n[o.replace("at-","")]=e.dataset[o]);for(var i=Object.keys(n).sort(function(e,t){return parseInt(e,10)<parseInt(t,10)?-1:1}),a=window.innerWidth*window.devicePixelRatio,s=0;s<i.length-1&&i[s]<a;)s++;t=n[i[s]]||t}return t}(i),l=J("figure");if(l.id="baguetteBox-figure-"+t,l.innerHTML='<div class="baguetteBox-spinner"><div class="baguetteBox-double-bounce1"></div><div class="baguetteBox-double-bounce2"></div></div>',b.captions&&s){var u=J("figcaption");u.id="baguetteBox-figcaption-"+t,u.innerHTML=s,l.appendChild(u)}e.appendChild(l);var c=J("img");c.onload=function(){var e=document.querySelector("#baguette-img-"+t+" .baguetteBox-spinner");l.removeChild(e),!b.async&&n&&n()},c.setAttribute("src",r),c.alt=a&&a.alt||"",b.titleTag&&s&&(c.title=s),l.appendChild(c),b.async&&n&&n()}}function X(){return M(o+1)}function D(){return M(o-1)}function M(e,t){return!n&&0<=e&&e<t.length?(H(t,b),I(e),!0):e<0?(b.animation&&O("left"),!1):e>=k.length?(b.animation&&O("right"),!1):(q(o=e,function(){z(o),V(o)}),R(),b.onChange&&b.onChange(o,k.length),!0)}function O(e){l.className="bounce-from-"+e,setTimeout(function(){l.className=""},400)}function R(){var e=100*-o+"%";"fadeIn"===b.animation?(l.style.opacity=0,setTimeout(function(){m.transforms?l.style.transform=l.style.webkitTransform="translate3d("+e+",0,0)":l.style.left=e,l.style.opacity=1},400)):m.transforms?l.style.transform=l.style.webkitTransform="translate3d("+e+",0,0)":l.style.left=e}function z(e){e-o>=b.preload||q(e+1,function(){z(e+1)})}function V(e){o-e>=b.preload||q(e-1,function(){V(e-1)})}function U(e,t,n,o){e.addEventListener?e.addEventListener(t,n,o):e.attachEvent("on"+t,function(e){(e=e||window.event).target=e.target||e.srcElement,n(e)})}function W(e,t,n,o){e.removeEventListener?e.removeEventListener(t,n,o):e.detachEvent("on"+t,n)}function G(e){return document.getElementById(e)}function J(e){return document.createElement(e)}return[].forEach||(Array.prototype.forEach=function(e,t){for(var n=0;n<this.length;n++)e.call(t,this[n],n,this)}),[].filter||(Array.prototype.filter=function(e,t,n,o,i){for(n=this,o=[],i=0;i<n.length;i++)e.call(t,n[i],i,n)&&o.push(n[i]);return o}),{run:function K(e,t){return m.transforms=function n(){var e=J("div");return"undefined"!=typeof e.style.perspective||"undefined"!=typeof e.style.webkitPerspective}(),m.svg=function o(){var e=J("div");return e.innerHTML="<svg/>","http://www.w3.org/2000/svg"===(e.firstChild&&e.firstChild.namespaceURI)}(),m.passiveEvents=function i(){var e=!1;try{var t=Object.defineProperty({},"passive",{get:function(){e=!0}});window.addEventListener("test",null,t)}catch(n){}return e}(),function a(){if(r=G("baguetteBox-overlay"))return l=G("baguetteBox-slider"),u=G("previous-button"),c=G("next-button"),void(d=G("close-button"));(r=J("div")).setAttribute("role","dialog"),r.id="baguetteBox-overlay",document.getElementsByTagName("body")[0].appendChild(r),(l=J("div")).id="baguetteBox-slider",r.appendChild(l),(u=J("button")).setAttribute("type","button"),u.id="previous-button",u.setAttribute("aria-label","Previous"),u.innerHTML=m.svg?f:"&lt;",r.appendChild(u),(c=J("button")).setAttribute("type","button"),c.id="next-button",c.setAttribute("aria-label","Next"),c.innerHTML=m.svg?g:"&gt;",r.appendChild(c),(d=J("button")).setAttribute("type","button"),d.id="close-button",d.setAttribute("aria-label","Close"),d.innerHTML=m.svg?p:"&times;",r.appendChild(d),u.className=c.className=d.className="baguetteBox-button",function n(){var e=m.passiveEvents?{passive:!1}:null,t=m.passiveEvents?{passive:!0}:null;U(r,"click",x),U(u,"click",E),U(c,"click",C),U(d,"click",B),U(l,"contextmenu",A),U(r,"touchstart",T,t),U(r,"touchmove",N,e),U(r,"touchend",L),U(document,"focus",P,!0)}()}(),S(e),function s(e,a){var t=document.querySelectorAll(e),n={galleries:[],nodeList:t};return w[e]=n,[].forEach.call(t,function(e){a&&a.filter&&(y=a.filter);var t=[];if(t="A"===e.tagName?[e]:e.getElementsByTagName("a"),0!==(t=[].filter.call(t,function(e){if(-1===e.className.indexOf(a&&a.ignoreClass))return y.test(e.href)})).length){var i=[];[].forEach.call(t,function(e,t){var n=function(e){e.preventDefault?e.preventDefault():e.returnValue=!1,H(i,a),I(t)},o={eventHandler:n,imageElement:e};U(e,"click",n),i.push(o)}),n.galleries.push(i)}}),n.galleries}(e,t)},show:M,showNext:X,showPrevious:D,hide:j,destroy:function e(){!function n(){var e=m.passiveEvents?{passive:!1}:null,t=m.passiveEvents?{passive:!0}:null;W(r,"click",x),W(u,"click",E),W(c,"click",C),W(d,"click",B),W(l,"contextmenu",A),W(r,"touchstart",T,t),W(r,"touchmove",N,e),W(r,"touchend",L),W(document,"focus",P,!0)}(),function t(){for(var e in w)w.hasOwnProperty(e)&&S(e)}(),W(document,"keydown",F),document.getElementsByTagName("body")[0].removeChild(document.getElementById("baguetteBox-overlay")),w={},h=[],o=0}}});

// CUSTOM SCRIPTS



$(document).ready(function () {
    function destroySwiper(sliderInstance) {
        if (sliderInstance instanceof Swiper && sliderInstance.initialized) {
            sliderInstance.destroy(true, true);
            console.log('destroy')
        }
    }

    // MOBILE MENU
    const nav = $('.header__nav');

    $('.btn-burger').click(function (e) {
        e.preventDefault();
        nav.toggleClass('open');
        $(this).toggleClass('open');
        jQuery('.backdrop').fadeToggle();
        $('body').toggleClass('modal_open');
    });

    $('.menu__link, .backdrop').click(function (e) {
        $('.btn-burger').removeClass('open');
        nav.removeClass('open');
        $('.sub-menu__toggle').removeClass('sub-menu__toggle_active')
        jQuery('.backdrop').fadeOut();
        $('body').removeClass('modal_open');
    });

    $('.sub-menu__toggle').click(function (e) {
        $(this).toggleClass('sub-menu__toggle_active')
    });

    //SLIDER NEWS
    var sliderNews = new Swiper(".slider-news", {
        breakpoints: {
            320: {
                slidesPerView: 1,
                spaceBetween: 24,
            },

            640: {
                slidesPerView: 2,
                spaceBetween: 24,
            }
        },
        navigation: {
            nextEl: ".swiper-button-next",
            prevEl: ".swiper-button-prev",
        },
        pagination: {
            el: ".swiper-pagination",
        },
    });

    var sliderGallery = new Swiper(".slider-gallery", {
        breakpoints: {
            320: {
                slidesPerView: 1,
                spaceBetween: 24,
            },

            640: {
                slidesPerView: 2,
                spaceBetween: 24,
            }
        },
        navigation: {
            nextEl: ".swiper-button-next",
            prevEl: ".swiper-button-prev",
        },
        pagination: {
            el: ".swiper-pagination",
        },
    });

    var sliderAboutHelps = new Swiper(".about-helps", {
        breakpoints: {
            320: {
                slidesPerView: 1,
                spaceBetween: 24,
            },
            640: {
                slidesPerView: 3,
                spaceBetween: 24,
            }
        },
        navigation: {
            nextEl: ".swiper-button-next",
            prevEl: ".swiper-button-prev",
        },
        pagination: {
            el: ".swiper-pagination",
        },
    });

    var sliderPartners = new Swiper(".slider-partners", {
        navigation: {
            nextEl: ".swiper-button-next",
            prevEl: ".swiper-button-prev",
        },
        pagination: {
            el: ".swiper-pagination",
        },
    });

    //SLIDERS
    let valuablesSlider;
    let advantagesSlider;

    function handleResponsive() {

        // DESTROY SLIDER INSTANCES

        if ($(window).outerWidth() <= 767) {
            if (!valuablesSlider) {
                valuablesSlider = new Swiper('.valuables', {
                    breakpoints: {
                        320: {
                            slidesPerView: 1,
                        },

                        540: {
                            slidesPerView: 2,
                        }
                    },
                    pagination: {
                        el: ".swiper-pagination",
                    },
                });
            }
        } else {
            console.log(valuablesSlider)
            destroySwiper(valuablesSlider);
            valuablesSlider = null;
        }

        if ($(window).outerWidth() <= 767) {
            if (!advantagesSlider) {
                valuablesSlider = new Swiper('.advantages', {
                    breakpoints: {
                        320: {
                            slidesPerView: 1,
                        },

                        540: {
                            slidesPerView: 2,
                        }
                    },
                    pagination: {
                        el: ".swiper-pagination",
                    },
                });
            }
        } else {
            destroySwiper(advantagesSlider);
            advantagesSlider = null;
        }
    }

    let resizeId;


    handleResponsive();

    window.addEventListener('resize', function () {
        clearTimeout(resizeId);
        resizeId = setTimeout(handleResponsive, 500);
    });


    //BAGUETTE BOX
    $('.awards-list a').click(function (e) {
        e.preventDefault();
    });

    baguetteBox.run('.awards-list', {
        buttons: 'auto', // arrows navigation
        noScrollbars: false,
        bodyClass: 'baguetteBox-open',
        titleTag: false,
        async: false,
        preload: 2,
        animation: 'fadeIn',
        overlayBackgroundColor: 'rgba (1,1,1, .25)'
    });
// VIDEO YOUTUBE
    // selector of all videos on the page
    const videos = document.querySelectorAll('.video');

// generate video url
    let generateUrl = function(id) {
        let query = '?rel=0&showinfo=0&autoplay=1';

        return 'https://www.youtube.com/embed/' + id + query;
    };

// creating iframe
    let createIframe = function(id) {
        let iframe = document.createElement('iframe');

        iframe.setAttribute('allowfullscreen', '');
        iframe.setAttribute('allow', 'autoplay; encrypted-media');
        iframe.setAttribute('src', generateUrl(id));

        return iframe;
    };

// main code
    videos.forEach((el) => {
        let videoHref = el.getAttribute('data-video');

        let deletedLength = 'https://youtu.be/'.length;

        let videoId = videoHref.substring(deletedLength, videoHref.length);

        let img = el.querySelector('img');
        let youtubeImgSrc = 'https://i.ytimg.com/vi/' + videoId + '/maxresdefault.jpg';
        img.setAttribute('src', youtubeImgSrc);

        el.addEventListener('click', (e) => {
            e.preventDefault();

            let iframe = createIframe(videoId);
            el.querySelector('.video__poster').remove();
            el.appendChild(iframe);
            el.querySelector('.btn_play').remove();
        });
    });


});




//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm1haW4uanMiLCIuLi9saWIvanF1ZXJ5Lm1pbi5qcyIsIi4uL2xpYi9zd2lwZXIvc3dpcGVyLWJ1bmRsZS5taW4uanMiLCIuLi9saWIvYmFndWV0dGVCb3gubWluLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQ0xBO0VBQ0E7RUFDQTtBREtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUVYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBRjcxT0E7QUdiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBSFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Im1haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4qIHRvIGluY2x1ZGUganMgZmlsZSB3cml0ZTogYC8vPSBpbmNsdWRlIC4vcGF0aC10by1maWxlYFxyXG4qICovXHJcblxyXG4vLz0gaW5jbHVkZSAuLi9saWIvanF1ZXJ5Lm1pbi5qcyA7XHJcbi8vPSBpbmNsdWRlIC4uL2xpYi9zd2lwZXIvc3dpcGVyLWJ1bmRsZS5taW4uanNcclxuLy89IGluY2x1ZGUgLi4vbGliL2JhZ3VldHRlQm94Lm1pbi5qc1xyXG5cclxuLy8gQ1VTVE9NIFNDUklQVFNcclxuXHJcblxyXG5cclxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gZGVzdHJveVN3aXBlcihzbGlkZXJJbnN0YW5jZSkge1xyXG4gICAgICAgIGlmIChzbGlkZXJJbnN0YW5jZSBpbnN0YW5jZW9mIFN3aXBlciAmJiBzbGlkZXJJbnN0YW5jZS5pbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICBzbGlkZXJJbnN0YW5jZS5kZXN0cm95KHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZGVzdHJveScpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE1PQklMRSBNRU5VXHJcbiAgICBjb25zdCBuYXYgPSAkKCcuaGVhZGVyX19uYXYnKTtcclxuXHJcbiAgICAkKCcuYnRuLWJ1cmdlcicpLmNsaWNrKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIG5hdi50b2dnbGVDbGFzcygnb3BlbicpO1xyXG4gICAgICAgICQodGhpcykudG9nZ2xlQ2xhc3MoJ29wZW4nKTtcclxuICAgICAgICBqUXVlcnkoJy5iYWNrZHJvcCcpLmZhZGVUb2dnbGUoKTtcclxuICAgICAgICAkKCdib2R5JykudG9nZ2xlQ2xhc3MoJ21vZGFsX29wZW4nKTtcclxuICAgIH0pO1xyXG5cclxuICAgICQoJy5tZW51X19saW5rLCAuYmFja2Ryb3AnKS5jbGljayhmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICQoJy5idG4tYnVyZ2VyJykucmVtb3ZlQ2xhc3MoJ29wZW4nKTtcclxuICAgICAgICBuYXYucmVtb3ZlQ2xhc3MoJ29wZW4nKTtcclxuICAgICAgICAkKCcuc3ViLW1lbnVfX3RvZ2dsZScpLnJlbW92ZUNsYXNzKCdzdWItbWVudV9fdG9nZ2xlX2FjdGl2ZScpXHJcbiAgICAgICAgalF1ZXJ5KCcuYmFja2Ryb3AnKS5mYWRlT3V0KCk7XHJcbiAgICAgICAgJCgnYm9keScpLnJlbW92ZUNsYXNzKCdtb2RhbF9vcGVuJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAkKCcuc3ViLW1lbnVfX3RvZ2dsZScpLmNsaWNrKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgJCh0aGlzKS50b2dnbGVDbGFzcygnc3ViLW1lbnVfX3RvZ2dsZV9hY3RpdmUnKVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy9TTElERVIgTkVXU1xyXG4gICAgdmFyIHNsaWRlck5ld3MgPSBuZXcgU3dpcGVyKFwiLnNsaWRlci1uZXdzXCIsIHtcclxuICAgICAgICBicmVha3BvaW50czoge1xyXG4gICAgICAgICAgICAzMjA6IHtcclxuICAgICAgICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDEsXHJcbiAgICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDI0LFxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgNjQwOiB7XHJcbiAgICAgICAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAyLFxyXG4gICAgICAgICAgICAgICAgc3BhY2VCZXR3ZWVuOiAyNCxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbmF2aWdhdGlvbjoge1xyXG4gICAgICAgICAgICBuZXh0RWw6IFwiLnN3aXBlci1idXR0b24tbmV4dFwiLFxyXG4gICAgICAgICAgICBwcmV2RWw6IFwiLnN3aXBlci1idXR0b24tcHJldlwiLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGFnaW5hdGlvbjoge1xyXG4gICAgICAgICAgICBlbDogXCIuc3dpcGVyLXBhZ2luYXRpb25cIixcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIHNsaWRlckdhbGxlcnkgPSBuZXcgU3dpcGVyKFwiLnNsaWRlci1nYWxsZXJ5XCIsIHtcclxuICAgICAgICBicmVha3BvaW50czoge1xyXG4gICAgICAgICAgICAzMjA6IHtcclxuICAgICAgICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDEsXHJcbiAgICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDI0LFxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgNjQwOiB7XHJcbiAgICAgICAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAyLFxyXG4gICAgICAgICAgICAgICAgc3BhY2VCZXR3ZWVuOiAyNCxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbmF2aWdhdGlvbjoge1xyXG4gICAgICAgICAgICBuZXh0RWw6IFwiLnN3aXBlci1idXR0b24tbmV4dFwiLFxyXG4gICAgICAgICAgICBwcmV2RWw6IFwiLnN3aXBlci1idXR0b24tcHJldlwiLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGFnaW5hdGlvbjoge1xyXG4gICAgICAgICAgICBlbDogXCIuc3dpcGVyLXBhZ2luYXRpb25cIixcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIHNsaWRlckFib3V0SGVscHMgPSBuZXcgU3dpcGVyKFwiLmFib3V0LWhlbHBzXCIsIHtcclxuICAgICAgICBicmVha3BvaW50czoge1xyXG4gICAgICAgICAgICAzMjA6IHtcclxuICAgICAgICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDEsXHJcbiAgICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDI0LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICA2NDA6IHtcclxuICAgICAgICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDMsXHJcbiAgICAgICAgICAgICAgICBzcGFjZUJldHdlZW46IDI0LFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuYXZpZ2F0aW9uOiB7XHJcbiAgICAgICAgICAgIG5leHRFbDogXCIuc3dpcGVyLWJ1dHRvbi1uZXh0XCIsXHJcbiAgICAgICAgICAgIHByZXZFbDogXCIuc3dpcGVyLWJ1dHRvbi1wcmV2XCIsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwYWdpbmF0aW9uOiB7XHJcbiAgICAgICAgICAgIGVsOiBcIi5zd2lwZXItcGFnaW5hdGlvblwiLFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgc2xpZGVyUGFydG5lcnMgPSBuZXcgU3dpcGVyKFwiLnNsaWRlci1wYXJ0bmVyc1wiLCB7XHJcbiAgICAgICAgbmF2aWdhdGlvbjoge1xyXG4gICAgICAgICAgICBuZXh0RWw6IFwiLnN3aXBlci1idXR0b24tbmV4dFwiLFxyXG4gICAgICAgICAgICBwcmV2RWw6IFwiLnN3aXBlci1idXR0b24tcHJldlwiLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGFnaW5hdGlvbjoge1xyXG4gICAgICAgICAgICBlbDogXCIuc3dpcGVyLXBhZ2luYXRpb25cIixcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy9TTElERVJTXHJcbiAgICBsZXQgdmFsdWFibGVzU2xpZGVyO1xyXG4gICAgbGV0IGFkdmFudGFnZXNTbGlkZXI7XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2l2ZSgpIHtcclxuXHJcbiAgICAgICAgLy8gREVTVFJPWSBTTElERVIgSU5TVEFOQ0VTXHJcblxyXG4gICAgICAgIGlmICgkKHdpbmRvdykub3V0ZXJXaWR0aCgpIDw9IDc2Nykge1xyXG4gICAgICAgICAgICBpZiAoIXZhbHVhYmxlc1NsaWRlcikge1xyXG4gICAgICAgICAgICAgICAgdmFsdWFibGVzU2xpZGVyID0gbmV3IFN3aXBlcignLnZhbHVhYmxlcycsIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVha3BvaW50czoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAzMjA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA1NDA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2luYXRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWw6IFwiLnN3aXBlci1wYWdpbmF0aW9uXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2codmFsdWFibGVzU2xpZGVyKVxyXG4gICAgICAgICAgICBkZXN0cm95U3dpcGVyKHZhbHVhYmxlc1NsaWRlcik7XHJcbiAgICAgICAgICAgIHZhbHVhYmxlc1NsaWRlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoJCh3aW5kb3cpLm91dGVyV2lkdGgoKSA8PSA3NjcpIHtcclxuICAgICAgICAgICAgaWYgKCFhZHZhbnRhZ2VzU2xpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1YWJsZXNTbGlkZXIgPSBuZXcgU3dpcGVyKCcuYWR2YW50YWdlcycsIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVha3BvaW50czoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAzMjA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA1NDA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2luYXRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWw6IFwiLnN3aXBlci1wYWdpbmF0aW9uXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGVzdHJveVN3aXBlcihhZHZhbnRhZ2VzU2xpZGVyKTtcclxuICAgICAgICAgICAgYWR2YW50YWdlc1NsaWRlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxldCByZXNpemVJZDtcclxuXHJcblxyXG4gICAgaGFuZGxlUmVzcG9uc2l2ZSgpO1xyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlc2l6ZUlkKTtcclxuICAgICAgICByZXNpemVJZCA9IHNldFRpbWVvdXQoaGFuZGxlUmVzcG9uc2l2ZSwgNTAwKTtcclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICAvL0JBR1VFVFRFIEJPWFxyXG4gICAgJCgnLmF3YXJkcy1saXN0IGEnKS5jbGljayhmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGJhZ3VldHRlQm94LnJ1bignLmF3YXJkcy1saXN0Jywge1xyXG4gICAgICAgIGJ1dHRvbnM6ICdhdXRvJywgLy8gYXJyb3dzIG5hdmlnYXRpb25cclxuICAgICAgICBub1Njcm9sbGJhcnM6IGZhbHNlLFxyXG4gICAgICAgIGJvZHlDbGFzczogJ2JhZ3VldHRlQm94LW9wZW4nLFxyXG4gICAgICAgIHRpdGxlVGFnOiBmYWxzZSxcclxuICAgICAgICBhc3luYzogZmFsc2UsXHJcbiAgICAgICAgcHJlbG9hZDogMixcclxuICAgICAgICBhbmltYXRpb246ICdmYWRlSW4nLFxyXG4gICAgICAgIG92ZXJsYXlCYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhICgxLDEsMSwgLjI1KSdcclxuICAgIH0pO1xyXG4vLyBWSURFTyBZT1VUVUJFXHJcbiAgICAvLyBzZWxlY3RvciBvZiBhbGwgdmlkZW9zIG9uIHRoZSBwYWdlXHJcbiAgICBjb25zdCB2aWRlb3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudmlkZW8nKTtcclxuXHJcbi8vIGdlbmVyYXRlIHZpZGVvIHVybFxyXG4gICAgbGV0IGdlbmVyYXRlVXJsID0gZnVuY3Rpb24oaWQpIHtcclxuICAgICAgICBsZXQgcXVlcnkgPSAnP3JlbD0wJnNob3dpbmZvPTAmYXV0b3BsYXk9MSc7XHJcblxyXG4gICAgICAgIHJldHVybiAnaHR0cHM6Ly93d3cueW91dHViZS5jb20vZW1iZWQvJyArIGlkICsgcXVlcnk7XHJcbiAgICB9O1xyXG5cclxuLy8gY3JlYXRpbmcgaWZyYW1lXHJcbiAgICBsZXQgY3JlYXRlSWZyYW1lID0gZnVuY3Rpb24oaWQpIHtcclxuICAgICAgICBsZXQgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XHJcblxyXG4gICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FsbG93ZnVsbHNjcmVlbicsICcnKTtcclxuICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdhbGxvdycsICdhdXRvcGxheTsgZW5jcnlwdGVkLW1lZGlhJyk7XHJcbiAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnc3JjJywgZ2VuZXJhdGVVcmwoaWQpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGlmcmFtZTtcclxuICAgIH07XHJcblxyXG4vLyBtYWluIGNvZGVcclxuICAgIHZpZGVvcy5mb3JFYWNoKChlbCkgPT4ge1xyXG4gICAgICAgIGxldCB2aWRlb0hyZWYgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmlkZW8nKTtcclxuXHJcbiAgICAgICAgbGV0IGRlbGV0ZWRMZW5ndGggPSAnaHR0cHM6Ly95b3V0dS5iZS8nLmxlbmd0aDtcclxuXHJcbiAgICAgICAgbGV0IHZpZGVvSWQgPSB2aWRlb0hyZWYuc3Vic3RyaW5nKGRlbGV0ZWRMZW5ndGgsIHZpZGVvSHJlZi5sZW5ndGgpO1xyXG5cclxuICAgICAgICBsZXQgaW1nID0gZWwucXVlcnlTZWxlY3RvcignaW1nJyk7XHJcbiAgICAgICAgbGV0IHlvdXR1YmVJbWdTcmMgPSAnaHR0cHM6Ly9pLnl0aW1nLmNvbS92aS8nICsgdmlkZW9JZCArICcvbWF4cmVzZGVmYXVsdC5qcGcnO1xyXG4gICAgICAgIGltZy5zZXRBdHRyaWJ1dGUoJ3NyYycsIHlvdXR1YmVJbWdTcmMpO1xyXG5cclxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBpZnJhbWUgPSBjcmVhdGVJZnJhbWUodmlkZW9JZCk7XHJcbiAgICAgICAgICAgIGVsLnF1ZXJ5U2VsZWN0b3IoJy52aWRlb19fcG9zdGVyJykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGlmcmFtZSk7XHJcbiAgICAgICAgICAgIGVsLnF1ZXJ5U2VsZWN0b3IoJy5idG5fcGxheScpLnJlbW92ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG5cclxufSk7XHJcblxyXG5cclxuXHJcbiIsIi8qISBqUXVlcnkgdjMuNi4xIHwgKGMpIE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgfCBqcXVlcnkub3JnL2xpY2Vuc2UgKi9cclxuIWZ1bmN0aW9uKGUsdCl7XCJ1c2Ugc3RyaWN0XCI7XCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZSYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWUuZG9jdW1lbnQ/dChlLCEwKTpmdW5jdGlvbihlKXtpZighZS5kb2N1bWVudCl0aHJvdyBuZXcgRXJyb3IoXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIpO3JldHVybiB0KGUpfTp0KGUpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzp0aGlzLGZ1bmN0aW9uKEMsZSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9W10scj1PYmplY3QuZ2V0UHJvdG90eXBlT2Yscz10LnNsaWNlLGc9dC5mbGF0P2Z1bmN0aW9uKGUpe3JldHVybiB0LmZsYXQuY2FsbChlKX06ZnVuY3Rpb24oZSl7cmV0dXJuIHQuY29uY2F0LmFwcGx5KFtdLGUpfSx1PXQucHVzaCxpPXQuaW5kZXhPZixuPXt9LG89bi50b1N0cmluZyx5PW4uaGFzT3duUHJvcGVydHksYT15LnRvU3RyaW5nLGw9YS5jYWxsKE9iamVjdCksdj17fSxtPWZ1bmN0aW9uKGUpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJlwibnVtYmVyXCIhPXR5cGVvZiBlLm5vZGVUeXBlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlLml0ZW19LHg9ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPWUmJmU9PT1lLndpbmRvd30sRT1DLmRvY3VtZW50LGM9e3R5cGU6ITAsc3JjOiEwLG5vbmNlOiEwLG5vTW9kdWxlOiEwfTtmdW5jdGlvbiBiKGUsdCxuKXt2YXIgcixpLG89KG49bnx8RSkuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtpZihvLnRleHQ9ZSx0KWZvcihyIGluIGMpKGk9dFtyXXx8dC5nZXRBdHRyaWJ1dGUmJnQuZ2V0QXR0cmlidXRlKHIpKSYmby5zZXRBdHRyaWJ1dGUocixpKTtuLmhlYWQuYXBwZW5kQ2hpbGQobykucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvKX1mdW5jdGlvbiB3KGUpe3JldHVybiBudWxsPT1lP2UrXCJcIjpcIm9iamVjdFwiPT10eXBlb2YgZXx8XCJmdW5jdGlvblwiPT10eXBlb2YgZT9uW28uY2FsbChlKV18fFwib2JqZWN0XCI6dHlwZW9mIGV9dmFyIGY9XCIzLjYuMVwiLFM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IFMuZm4uaW5pdChlLHQpfTtmdW5jdGlvbiBwKGUpe3ZhciB0PSEhZSYmXCJsZW5ndGhcImluIGUmJmUubGVuZ3RoLG49dyhlKTtyZXR1cm4hbShlKSYmIXgoZSkmJihcImFycmF5XCI9PT1ufHwwPT09dHx8XCJudW1iZXJcIj09dHlwZW9mIHQmJjA8dCYmdC0xIGluIGUpfVMuZm49Uy5wcm90b3R5cGU9e2pxdWVyeTpmLGNvbnN0cnVjdG9yOlMsbGVuZ3RoOjAsdG9BcnJheTpmdW5jdGlvbigpe3JldHVybiBzLmNhbGwodGhpcyl9LGdldDpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09ZT9zLmNhbGwodGhpcyk6ZTwwP3RoaXNbZSt0aGlzLmxlbmd0aF06dGhpc1tlXX0scHVzaFN0YWNrOmZ1bmN0aW9uKGUpe3ZhciB0PVMubWVyZ2UodGhpcy5jb25zdHJ1Y3RvcigpLGUpO3JldHVybiB0LnByZXZPYmplY3Q9dGhpcyx0fSxlYWNoOmZ1bmN0aW9uKGUpe3JldHVybiBTLmVhY2godGhpcyxlKX0sbWFwOmZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLnB1c2hTdGFjayhTLm1hcCh0aGlzLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIG4uY2FsbChlLHQsZSl9KSl9LHNsaWNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKHMuYXBwbHkodGhpcyxhcmd1bWVudHMpKX0sZmlyc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lcSgwKX0sbGFzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVxKC0xKX0sZXZlbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB1c2hTdGFjayhTLmdyZXAodGhpcyxmdW5jdGlvbihlLHQpe3JldHVybih0KzEpJTJ9KSl9LG9kZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB1c2hTdGFjayhTLmdyZXAodGhpcyxmdW5jdGlvbihlLHQpe3JldHVybiB0JTJ9KSl9LGVxOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMubGVuZ3RoLG49K2UrKGU8MD90OjApO3JldHVybiB0aGlzLnB1c2hTdGFjaygwPD1uJiZuPHQ/W3RoaXNbbl1dOltdKX0sZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJldk9iamVjdHx8dGhpcy5jb25zdHJ1Y3RvcigpfSxwdXNoOnUsc29ydDp0LnNvcnQsc3BsaWNlOnQuc3BsaWNlfSxTLmV4dGVuZD1TLmZuLmV4dGVuZD1mdW5jdGlvbigpe3ZhciBlLHQsbixyLGksbyxhPWFyZ3VtZW50c1swXXx8e30scz0xLHU9YXJndW1lbnRzLmxlbmd0aCxsPSExO2ZvcihcImJvb2xlYW5cIj09dHlwZW9mIGEmJihsPWEsYT1hcmd1bWVudHNbc118fHt9LHMrKyksXCJvYmplY3RcIj09dHlwZW9mIGF8fG0oYSl8fChhPXt9KSxzPT09dSYmKGE9dGhpcyxzLS0pO3M8dTtzKyspaWYobnVsbCE9KGU9YXJndW1lbnRzW3NdKSlmb3IodCBpbiBlKXI9ZVt0XSxcIl9fcHJvdG9fX1wiIT09dCYmYSE9PXImJihsJiZyJiYoUy5pc1BsYWluT2JqZWN0KHIpfHwoaT1BcnJheS5pc0FycmF5KHIpKSk/KG49YVt0XSxvPWkmJiFBcnJheS5pc0FycmF5KG4pP1tdOml8fFMuaXNQbGFpbk9iamVjdChuKT9uOnt9LGk9ITEsYVt0XT1TLmV4dGVuZChsLG8scikpOnZvaWQgMCE9PXImJihhW3RdPXIpKTtyZXR1cm4gYX0sUy5leHRlbmQoe2V4cGFuZG86XCJqUXVlcnlcIisoZitNYXRoLnJhbmRvbSgpKS5yZXBsYWNlKC9cXEQvZyxcIlwiKSxpc1JlYWR5OiEwLGVycm9yOmZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihlKX0sbm9vcDpmdW5jdGlvbigpe30saXNQbGFpbk9iamVjdDpmdW5jdGlvbihlKXt2YXIgdCxuO3JldHVybiEoIWV8fFwiW29iamVjdCBPYmplY3RdXCIhPT1vLmNhbGwoZSkpJiYoISh0PXIoZSkpfHxcImZ1bmN0aW9uXCI9PXR5cGVvZihuPXkuY2FsbCh0LFwiY29uc3RydWN0b3JcIikmJnQuY29uc3RydWN0b3IpJiZhLmNhbGwobik9PT1sKX0saXNFbXB0eU9iamVjdDpmdW5jdGlvbihlKXt2YXIgdDtmb3IodCBpbiBlKXJldHVybiExO3JldHVybiEwfSxnbG9iYWxFdmFsOmZ1bmN0aW9uKGUsdCxuKXtiKGUse25vbmNlOnQmJnQubm9uY2V9LG4pfSxlYWNoOmZ1bmN0aW9uKGUsdCl7dmFyIG4scj0wO2lmKHAoZSkpe2ZvcihuPWUubGVuZ3RoO3I8bjtyKyspaWYoITE9PT10LmNhbGwoZVtyXSxyLGVbcl0pKWJyZWFrfWVsc2UgZm9yKHIgaW4gZSlpZighMT09PXQuY2FsbChlW3JdLHIsZVtyXSkpYnJlYWs7cmV0dXJuIGV9LG1ha2VBcnJheTpmdW5jdGlvbihlLHQpe3ZhciBuPXR8fFtdO3JldHVybiBudWxsIT1lJiYocChPYmplY3QoZSkpP1MubWVyZ2UobixcInN0cmluZ1wiPT10eXBlb2YgZT9bZV06ZSk6dS5jYWxsKG4sZSkpLG59LGluQXJyYXk6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBudWxsPT10Py0xOmkuY2FsbCh0LGUsbil9LG1lcmdlOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPSt0Lmxlbmd0aCxyPTAsaT1lLmxlbmd0aDtyPG47cisrKWVbaSsrXT10W3JdO3JldHVybiBlLmxlbmd0aD1pLGV9LGdyZXA6ZnVuY3Rpb24oZSx0LG4pe2Zvcih2YXIgcj1bXSxpPTAsbz1lLmxlbmd0aCxhPSFuO2k8bztpKyspIXQoZVtpXSxpKSE9PWEmJnIucHVzaChlW2ldKTtyZXR1cm4gcn0sbWFwOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG89MCxhPVtdO2lmKHAoZSkpZm9yKHI9ZS5sZW5ndGg7bzxyO28rKyludWxsIT0oaT10KGVbb10sbyxuKSkmJmEucHVzaChpKTtlbHNlIGZvcihvIGluIGUpbnVsbCE9KGk9dChlW29dLG8sbikpJiZhLnB1c2goaSk7cmV0dXJuIGcoYSl9LGd1aWQ6MSxzdXBwb3J0OnZ9KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihTLmZuW1N5bWJvbC5pdGVyYXRvcl09dFtTeW1ib2wuaXRlcmF0b3JdKSxTLmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihlLHQpe25bXCJbb2JqZWN0IFwiK3QrXCJdXCJdPXQudG9Mb3dlckNhc2UoKX0pO3ZhciBkPWZ1bmN0aW9uKG4pe3ZhciBlLGQsYixvLGksaCxmLGcsdyx1LGwsVCxDLGEsRSx5LHMsYyx2LFM9XCJzaXp6bGVcIisxKm5ldyBEYXRlLHA9bi5kb2N1bWVudCxrPTAscj0wLG09dWUoKSx4PXVlKCksQT11ZSgpLE49dWUoKSxqPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU9PT10JiYobD0hMCksMH0sRD17fS5oYXNPd25Qcm9wZXJ0eSx0PVtdLHE9dC5wb3AsTD10LnB1c2gsSD10LnB1c2gsTz10LnNsaWNlLFA9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49MCxyPWUubGVuZ3RoO248cjtuKyspaWYoZVtuXT09PXQpcmV0dXJuIG47cmV0dXJuLTF9LFI9XCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLE09XCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLEk9XCIoPzpcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiK00rXCI/fFxcXFxcXFxcW15cXFxcclxcXFxuXFxcXGZdfFtcXFxcdy1dfFteXFwwLVxcXFx4N2ZdKStcIixXPVwiXFxcXFtcIitNK1wiKihcIitJK1wiKSg/OlwiK00rXCIqKFsqXiR8IX5dPz0pXCIrTStcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiK0krXCIpKXwpXCIrTStcIipcXFxcXVwiLEY9XCI6KFwiK0krXCIpKD86XFxcXCgoKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8KCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiK1crXCIpKil8LiopXFxcXCl8KVwiLCQ9bmV3IFJlZ0V4cChNK1wiK1wiLFwiZ1wiKSxCPW5ldyBSZWdFeHAoXCJeXCIrTStcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIrTStcIiskXCIsXCJnXCIpLF89bmV3IFJlZ0V4cChcIl5cIitNK1wiKixcIitNK1wiKlwiKSx6PW5ldyBSZWdFeHAoXCJeXCIrTStcIiooWz4rfl18XCIrTStcIilcIitNK1wiKlwiKSxVPW5ldyBSZWdFeHAoTStcInw+XCIpLFg9bmV3IFJlZ0V4cChGKSxWPW5ldyBSZWdFeHAoXCJeXCIrSStcIiRcIiksRz17SUQ6bmV3IFJlZ0V4cChcIl4jKFwiK0krXCIpXCIpLENMQVNTOm5ldyBSZWdFeHAoXCJeXFxcXC4oXCIrSStcIilcIiksVEFHOm5ldyBSZWdFeHAoXCJeKFwiK0krXCJ8WypdKVwiKSxBVFRSOm5ldyBSZWdFeHAoXCJeXCIrVyksUFNFVURPOm5ldyBSZWdFeHAoXCJeXCIrRiksQ0hJTEQ6bmV3IFJlZ0V4cChcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIrTStcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiK00rXCIqKD86KFsrLV18KVwiK00rXCIqKFxcXFxkKyl8KSlcIitNK1wiKlxcXFwpfClcIixcImlcIiksYm9vbDpuZXcgUmVnRXhwKFwiXig/OlwiK1IrXCIpJFwiLFwiaVwiKSxuZWVkc0NvbnRleHQ6bmV3IFJlZ0V4cChcIl5cIitNK1wiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIitNK1wiKigoPzotXFxcXGQpP1xcXFxkKilcIitNK1wiKlxcXFwpfCkoPz1bXi1dfCQpXCIsXCJpXCIpfSxZPS9IVE1MJC9pLFE9L14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxKPS9eaFxcZCQvaSxLPS9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sWj0vXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxlZT0vWyt+XS8sdGU9bmV3IFJlZ0V4cChcIlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIrTStcIj98XFxcXFxcXFwoW15cXFxcclxcXFxuXFxcXGZdKVwiLFwiZ1wiKSxuZT1mdW5jdGlvbihlLHQpe3ZhciBuPVwiMHhcIitlLnNsaWNlKDEpLTY1NTM2O3JldHVybiB0fHwobjwwP1N0cmluZy5mcm9tQ2hhckNvZGUobis2NTUzNik6U3RyaW5nLmZyb21DaGFyQ29kZShuPj4xMHw1NTI5NiwxMDIzJm58NTYzMjApKX0scmU9LyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csaWU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdD9cIlxcMFwiPT09ZT9cIlxcdWZmZmRcIjplLnNsaWNlKDAsLTEpK1wiXFxcXFwiK2UuY2hhckNvZGVBdChlLmxlbmd0aC0xKS50b1N0cmluZygxNikrXCIgXCI6XCJcXFxcXCIrZX0sb2U9ZnVuY3Rpb24oKXtUKCl9LGFlPWJlKGZ1bmN0aW9uKGUpe3JldHVybiEwPT09ZS5kaXNhYmxlZCYmXCJmaWVsZHNldFwiPT09ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpfSx7ZGlyOlwicGFyZW50Tm9kZVwiLG5leHQ6XCJsZWdlbmRcIn0pO3RyeXtILmFwcGx5KHQ9Ty5jYWxsKHAuY2hpbGROb2RlcykscC5jaGlsZE5vZGVzKSx0W3AuY2hpbGROb2Rlcy5sZW5ndGhdLm5vZGVUeXBlfWNhdGNoKGUpe0g9e2FwcGx5OnQubGVuZ3RoP2Z1bmN0aW9uKGUsdCl7TC5hcHBseShlLE8uY2FsbCh0KSl9OmZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5sZW5ndGgscj0wO3doaWxlKGVbbisrXT10W3IrK10pO2UubGVuZ3RoPW4tMX19fWZ1bmN0aW9uIHNlKHQsZSxuLHIpe3ZhciBpLG8sYSxzLHUsbCxjLGY9ZSYmZS5vd25lckRvY3VtZW50LHA9ZT9lLm5vZGVUeXBlOjk7aWYobj1ufHxbXSxcInN0cmluZ1wiIT10eXBlb2YgdHx8IXR8fDEhPT1wJiY5IT09cCYmMTEhPT1wKXJldHVybiBuO2lmKCFyJiYoVChlKSxlPWV8fEMsRSkpe2lmKDExIT09cCYmKHU9Wi5leGVjKHQpKSlpZihpPXVbMV0pe2lmKDk9PT1wKXtpZighKGE9ZS5nZXRFbGVtZW50QnlJZChpKSkpcmV0dXJuIG47aWYoYS5pZD09PWkpcmV0dXJuIG4ucHVzaChhKSxufWVsc2UgaWYoZiYmKGE9Zi5nZXRFbGVtZW50QnlJZChpKSkmJnYoZSxhKSYmYS5pZD09PWkpcmV0dXJuIG4ucHVzaChhKSxufWVsc2V7aWYodVsyXSlyZXR1cm4gSC5hcHBseShuLGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUodCkpLG47aWYoKGk9dVszXSkmJmQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSYmZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKXJldHVybiBILmFwcGx5KG4sZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGkpKSxufWlmKGQucXNhJiYhTlt0K1wiIFwiXSYmKCF5fHwheS50ZXN0KHQpKSYmKDEhPT1wfHxcIm9iamVjdFwiIT09ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSl7aWYoYz10LGY9ZSwxPT09cCYmKFUudGVzdCh0KXx8ei50ZXN0KHQpKSl7KGY9ZWUudGVzdCh0KSYmdmUoZS5wYXJlbnROb2RlKXx8ZSk9PT1lJiZkLnNjb3BlfHwoKHM9ZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSk/cz1zLnJlcGxhY2UocmUsaWUpOmUuc2V0QXR0cmlidXRlKFwiaWRcIixzPVMpKSxvPShsPWgodCkpLmxlbmd0aDt3aGlsZShvLS0pbFtvXT0ocz9cIiNcIitzOlwiOnNjb3BlXCIpK1wiIFwiK3hlKGxbb10pO2M9bC5qb2luKFwiLFwiKX10cnl7cmV0dXJuIEguYXBwbHkobixmLnF1ZXJ5U2VsZWN0b3JBbGwoYykpLG59Y2F0Y2goZSl7Tih0LCEwKX1maW5hbGx5e3M9PT1TJiZlLnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpfX19cmV0dXJuIGcodC5yZXBsYWNlKEIsXCIkMVwiKSxlLG4scil9ZnVuY3Rpb24gdWUoKXt2YXIgcj1bXTtyZXR1cm4gZnVuY3Rpb24gZSh0LG4pe3JldHVybiByLnB1c2godCtcIiBcIik+Yi5jYWNoZUxlbmd0aCYmZGVsZXRlIGVbci5zaGlmdCgpXSxlW3QrXCIgXCJdPW59fWZ1bmN0aW9uIGxlKGUpe3JldHVybiBlW1NdPSEwLGV9ZnVuY3Rpb24gY2UoZSl7dmFyIHQ9Qy5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7dHJ5e3JldHVybiEhZSh0KX1jYXRjaChlKXtyZXR1cm4hMX1maW5hbGx5e3QucGFyZW50Tm9kZSYmdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQpLHQ9bnVsbH19ZnVuY3Rpb24gZmUoZSx0KXt2YXIgbj1lLnNwbGl0KFwifFwiKSxyPW4ubGVuZ3RoO3doaWxlKHItLSliLmF0dHJIYW5kbGVbbltyXV09dH1mdW5jdGlvbiBwZShlLHQpe3ZhciBuPXQmJmUscj1uJiYxPT09ZS5ub2RlVHlwZSYmMT09PXQubm9kZVR5cGUmJmUuc291cmNlSW5kZXgtdC5zb3VyY2VJbmRleDtpZihyKXJldHVybiByO2lmKG4pd2hpbGUobj1uLm5leHRTaWJsaW5nKWlmKG49PT10KXJldHVybi0xO3JldHVybiBlPzE6LTF9ZnVuY3Rpb24gZGUodCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVyblwiaW5wdXRcIj09PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSYmZS50eXBlPT09dH19ZnVuY3Rpb24gaGUobil7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4oXCJpbnB1dFwiPT09dHx8XCJidXR0b25cIj09PXQpJiZlLnR5cGU9PT1ufX1mdW5jdGlvbiBnZSh0KXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuXCJmb3JtXCJpbiBlP2UucGFyZW50Tm9kZSYmITE9PT1lLmRpc2FibGVkP1wibGFiZWxcImluIGU/XCJsYWJlbFwiaW4gZS5wYXJlbnROb2RlP2UucGFyZW50Tm9kZS5kaXNhYmxlZD09PXQ6ZS5kaXNhYmxlZD09PXQ6ZS5pc0Rpc2FibGVkPT09dHx8ZS5pc0Rpc2FibGVkIT09IXQmJmFlKGUpPT09dDplLmRpc2FibGVkPT09dDpcImxhYmVsXCJpbiBlJiZlLmRpc2FibGVkPT09dH19ZnVuY3Rpb24geWUoYSl7cmV0dXJuIGxlKGZ1bmN0aW9uKG8pe3JldHVybiBvPStvLGxlKGZ1bmN0aW9uKGUsdCl7dmFyIG4scj1hKFtdLGUubGVuZ3RoLG8pLGk9ci5sZW5ndGg7d2hpbGUoaS0tKWVbbj1yW2ldXSYmKGVbbl09ISh0W25dPWVbbl0pKX0pfSl9ZnVuY3Rpb24gdmUoZSl7cmV0dXJuIGUmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBlLmdldEVsZW1lbnRzQnlUYWdOYW1lJiZlfWZvcihlIGluIGQ9c2Uuc3VwcG9ydD17fSxpPXNlLmlzWE1MPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUubmFtZXNwYWNlVVJJLG49ZSYmKGUub3duZXJEb2N1bWVudHx8ZSkuZG9jdW1lbnRFbGVtZW50O3JldHVybiFZLnRlc3QodHx8biYmbi5ub2RlTmFtZXx8XCJIVE1MXCIpfSxUPXNlLnNldERvY3VtZW50PWZ1bmN0aW9uKGUpe3ZhciB0LG4scj1lP2Uub3duZXJEb2N1bWVudHx8ZTpwO3JldHVybiByIT1DJiY5PT09ci5ub2RlVHlwZSYmci5kb2N1bWVudEVsZW1lbnQmJihhPShDPXIpLmRvY3VtZW50RWxlbWVudCxFPSFpKEMpLHAhPUMmJihuPUMuZGVmYXVsdFZpZXcpJiZuLnRvcCE9PW4mJihuLmFkZEV2ZW50TGlzdGVuZXI/bi5hZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsb2UsITEpOm4uYXR0YWNoRXZlbnQmJm4uYXR0YWNoRXZlbnQoXCJvbnVubG9hZFwiLG9lKSksZC5zY29wZT1jZShmdW5jdGlvbihlKXtyZXR1cm4gYS5hcHBlbmRDaGlsZChlKS5hcHBlbmRDaGlsZChDLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBlLnF1ZXJ5U2VsZWN0b3JBbGwmJiFlLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6c2NvcGUgZmllbGRzZXQgZGl2XCIpLmxlbmd0aH0pLGQuYXR0cmlidXRlcz1jZShmdW5jdGlvbihlKXtyZXR1cm4gZS5jbGFzc05hbWU9XCJpXCIsIWUuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpfSksZC5nZXRFbGVtZW50c0J5VGFnTmFtZT1jZShmdW5jdGlvbihlKXtyZXR1cm4gZS5hcHBlbmRDaGlsZChDLmNyZWF0ZUNvbW1lbnQoXCJcIikpLCFlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGh9KSxkLmdldEVsZW1lbnRzQnlDbGFzc05hbWU9Sy50ZXN0KEMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSksZC5nZXRCeUlkPWNlKGZ1bmN0aW9uKGUpe3JldHVybiBhLmFwcGVuZENoaWxkKGUpLmlkPVMsIUMuZ2V0RWxlbWVudHNCeU5hbWV8fCFDLmdldEVsZW1lbnRzQnlOYW1lKFMpLmxlbmd0aH0pLGQuZ2V0QnlJZD8oYi5maWx0ZXIuSUQ9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5yZXBsYWNlKHRlLG5lKTtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIGUuZ2V0QXR0cmlidXRlKFwiaWRcIik9PT10fX0sYi5maW5kLklEPWZ1bmN0aW9uKGUsdCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHQuZ2V0RWxlbWVudEJ5SWQmJkUpe3ZhciBuPXQuZ2V0RWxlbWVudEJ5SWQoZSk7cmV0dXJuIG4/W25dOltdfX0pOihiLmZpbHRlci5JRD1mdW5jdGlvbihlKXt2YXIgbj1lLnJlcGxhY2UodGUsbmUpO3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD1cInVuZGVmaW5lZFwiIT10eXBlb2YgZS5nZXRBdHRyaWJ1dGVOb2RlJiZlLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtyZXR1cm4gdCYmdC52YWx1ZT09PW59fSxiLmZpbmQuSUQ9ZnVuY3Rpb24oZSx0KXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgdC5nZXRFbGVtZW50QnlJZCYmRSl7dmFyIG4scixpLG89dC5nZXRFbGVtZW50QnlJZChlKTtpZihvKXtpZigobj1vLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKSkmJm4udmFsdWU9PT1lKXJldHVybltvXTtpPXQuZ2V0RWxlbWVudHNCeU5hbWUoZSkscj0wO3doaWxlKG89aVtyKytdKWlmKChuPW8uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpKSYmbi52YWx1ZT09PWUpcmV0dXJuW29dfXJldHVybltdfX0pLGIuZmluZC5UQUc9ZC5nZXRFbGVtZW50c0J5VGFnTmFtZT9mdW5jdGlvbihlLHQpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiB0LmdldEVsZW1lbnRzQnlUYWdOYW1lP3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSk6ZC5xc2E/dC5xdWVyeVNlbGVjdG9yQWxsKGUpOnZvaWQgMH06ZnVuY3Rpb24oZSx0KXt2YXIgbixyPVtdLGk9MCxvPXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZSk7aWYoXCIqXCI9PT1lKXt3aGlsZShuPW9baSsrXSkxPT09bi5ub2RlVHlwZSYmci5wdXNoKG4pO3JldHVybiByfXJldHVybiBvfSxiLmZpbmQuQ0xBU1M9ZC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lJiZmdW5jdGlvbihlLHQpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUmJkUpcmV0dXJuIHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShlKX0scz1bXSx5PVtdLChkLnFzYT1LLnRlc3QoQy5xdWVyeVNlbGVjdG9yQWxsKSkmJihjZShmdW5jdGlvbihlKXt2YXIgdDthLmFwcGVuZENoaWxkKGUpLmlubmVySFRNTD1cIjxhIGlkPSdcIitTK1wiJz48L2E+PHNlbGVjdCBpZD0nXCIrUytcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz48b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiLGUucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCYmeS5wdXNoKFwiWypeJF09XCIrTStcIiooPzonJ3xcXFwiXFxcIilcIiksZS5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGh8fHkucHVzaChcIlxcXFxbXCIrTStcIiooPzp2YWx1ZXxcIitSK1wiKVwiKSxlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbaWR+PVwiK1MrXCItXVwiKS5sZW5ndGh8fHkucHVzaChcIn49XCIpLCh0PUMuY3JlYXRlRWxlbWVudChcImlucHV0XCIpKS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsXCJcIiksZS5hcHBlbmRDaGlsZCh0KSxlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT0nJ11cIikubGVuZ3RofHx5LnB1c2goXCJcXFxcW1wiK00rXCIqbmFtZVwiK00rXCIqPVwiK00rXCIqKD86Jyd8XFxcIlxcXCIpXCIpLGUucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aHx8eS5wdXNoKFwiOmNoZWNrZWRcIiksZS5xdWVyeVNlbGVjdG9yQWxsKFwiYSNcIitTK1wiKypcIikubGVuZ3RofHx5LnB1c2goXCIuIy4rWyt+XVwiKSxlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJcXFxcXFxmXCIpLHkucHVzaChcIltcXFxcclxcXFxuXFxcXGZdXCIpfSksY2UoZnVuY3Rpb24oZSl7ZS5pbm5lckhUTUw9XCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjt2YXIgdD1DLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTt0LnNldEF0dHJpYnV0ZShcInR5cGVcIixcImhpZGRlblwiKSxlLmFwcGVuZENoaWxkKHQpLnNldEF0dHJpYnV0ZShcIm5hbWVcIixcIkRcIiksZS5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoJiZ5LnB1c2goXCJuYW1lXCIrTStcIipbKl4kfCF+XT89XCIpLDIhPT1lLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGgmJnkucHVzaChcIjplbmFibGVkXCIsXCI6ZGlzYWJsZWRcIiksYS5hcHBlbmRDaGlsZChlKS5kaXNhYmxlZD0hMCwyIT09ZS5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCYmeS5wdXNoKFwiOmVuYWJsZWRcIixcIjpkaXNhYmxlZFwiKSxlLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpLHkucHVzaChcIiwuKjpcIil9KSksKGQubWF0Y2hlc1NlbGVjdG9yPUsudGVzdChjPWEubWF0Y2hlc3x8YS53ZWJraXRNYXRjaGVzU2VsZWN0b3J8fGEubW96TWF0Y2hlc1NlbGVjdG9yfHxhLm9NYXRjaGVzU2VsZWN0b3J8fGEubXNNYXRjaGVzU2VsZWN0b3IpKSYmY2UoZnVuY3Rpb24oZSl7ZC5kaXNjb25uZWN0ZWRNYXRjaD1jLmNhbGwoZSxcIipcIiksYy5jYWxsKGUsXCJbcyE9JyddOnhcIikscy5wdXNoKFwiIT1cIixGKX0pLHk9eS5sZW5ndGgmJm5ldyBSZWdFeHAoeS5qb2luKFwifFwiKSkscz1zLmxlbmd0aCYmbmV3IFJlZ0V4cChzLmpvaW4oXCJ8XCIpKSx0PUsudGVzdChhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSx2PXR8fEsudGVzdChhLmNvbnRhaW5zKT9mdW5jdGlvbihlLHQpe3ZhciBuPTk9PT1lLm5vZGVUeXBlP2UuZG9jdW1lbnRFbGVtZW50OmUscj10JiZ0LnBhcmVudE5vZGU7cmV0dXJuIGU9PT1yfHwhKCFyfHwxIT09ci5ub2RlVHlwZXx8IShuLmNvbnRhaW5zP24uY29udGFpbnMocik6ZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiYmMTYmZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihyKSkpfTpmdW5jdGlvbihlLHQpe2lmKHQpd2hpbGUodD10LnBhcmVudE5vZGUpaWYodD09PWUpcmV0dXJuITA7cmV0dXJuITF9LGo9dD9mdW5jdGlvbihlLHQpe2lmKGU9PT10KXJldHVybiBsPSEwLDA7dmFyIG49IWUuY29tcGFyZURvY3VtZW50UG9zaXRpb24tIXQuY29tcGFyZURvY3VtZW50UG9zaXRpb247cmV0dXJuIG58fCgxJihuPShlLm93bmVyRG9jdW1lbnR8fGUpPT0odC5vd25lckRvY3VtZW50fHx0KT9lLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHQpOjEpfHwhZC5zb3J0RGV0YWNoZWQmJnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZSk9PT1uP2U9PUN8fGUub3duZXJEb2N1bWVudD09cCYmdihwLGUpPy0xOnQ9PUN8fHQub3duZXJEb2N1bWVudD09cCYmdihwLHQpPzE6dT9QKHUsZSktUCh1LHQpOjA6NCZuPy0xOjEpfTpmdW5jdGlvbihlLHQpe2lmKGU9PT10KXJldHVybiBsPSEwLDA7dmFyIG4scj0wLGk9ZS5wYXJlbnROb2RlLG89dC5wYXJlbnROb2RlLGE9W2VdLHM9W3RdO2lmKCFpfHwhbylyZXR1cm4gZT09Qz8tMTp0PT1DPzE6aT8tMTpvPzE6dT9QKHUsZSktUCh1LHQpOjA7aWYoaT09PW8pcmV0dXJuIHBlKGUsdCk7bj1lO3doaWxlKG49bi5wYXJlbnROb2RlKWEudW5zaGlmdChuKTtuPXQ7d2hpbGUobj1uLnBhcmVudE5vZGUpcy51bnNoaWZ0KG4pO3doaWxlKGFbcl09PT1zW3JdKXIrKztyZXR1cm4gcj9wZShhW3JdLHNbcl0pOmFbcl09PXA/LTE6c1tyXT09cD8xOjB9KSxDfSxzZS5tYXRjaGVzPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHNlKGUsbnVsbCxudWxsLHQpfSxzZS5tYXRjaGVzU2VsZWN0b3I9ZnVuY3Rpb24oZSx0KXtpZihUKGUpLGQubWF0Y2hlc1NlbGVjdG9yJiZFJiYhTlt0K1wiIFwiXSYmKCFzfHwhcy50ZXN0KHQpKSYmKCF5fHwheS50ZXN0KHQpKSl0cnl7dmFyIG49Yy5jYWxsKGUsdCk7aWYobnx8ZC5kaXNjb25uZWN0ZWRNYXRjaHx8ZS5kb2N1bWVudCYmMTEhPT1lLmRvY3VtZW50Lm5vZGVUeXBlKXJldHVybiBufWNhdGNoKGUpe04odCwhMCl9cmV0dXJuIDA8c2UodCxDLG51bGwsW2VdKS5sZW5ndGh9LHNlLmNvbnRhaW5zPWZ1bmN0aW9uKGUsdCl7cmV0dXJuKGUub3duZXJEb2N1bWVudHx8ZSkhPUMmJlQoZSksdihlLHQpfSxzZS5hdHRyPWZ1bmN0aW9uKGUsdCl7KGUub3duZXJEb2N1bWVudHx8ZSkhPUMmJlQoZSk7dmFyIG49Yi5hdHRySGFuZGxlW3QudG9Mb3dlckNhc2UoKV0scj1uJiZELmNhbGwoYi5hdHRySGFuZGxlLHQudG9Mb3dlckNhc2UoKSk/bihlLHQsIUUpOnZvaWQgMDtyZXR1cm4gdm9pZCAwIT09cj9yOmQuYXR0cmlidXRlc3x8IUU/ZS5nZXRBdHRyaWJ1dGUodCk6KHI9ZS5nZXRBdHRyaWJ1dGVOb2RlKHQpKSYmci5zcGVjaWZpZWQ/ci52YWx1ZTpudWxsfSxzZS5lc2NhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuKGUrXCJcIikucmVwbGFjZShyZSxpZSl9LHNlLmVycm9yPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiK2UpfSxzZS51bmlxdWVTb3J0PWZ1bmN0aW9uKGUpe3ZhciB0LG49W10scj0wLGk9MDtpZihsPSFkLmRldGVjdER1cGxpY2F0ZXMsdT0hZC5zb3J0U3RhYmxlJiZlLnNsaWNlKDApLGUuc29ydChqKSxsKXt3aGlsZSh0PWVbaSsrXSl0PT09ZVtpXSYmKHI9bi5wdXNoKGkpKTt3aGlsZShyLS0pZS5zcGxpY2UobltyXSwxKX1yZXR1cm4gdT1udWxsLGV9LG89c2UuZ2V0VGV4dD1mdW5jdGlvbihlKXt2YXIgdCxuPVwiXCIscj0wLGk9ZS5ub2RlVHlwZTtpZihpKXtpZigxPT09aXx8OT09PWl8fDExPT09aSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUudGV4dENvbnRlbnQpcmV0dXJuIGUudGV4dENvbnRlbnQ7Zm9yKGU9ZS5maXJzdENoaWxkO2U7ZT1lLm5leHRTaWJsaW5nKW4rPW8oZSl9ZWxzZSBpZigzPT09aXx8ND09PWkpcmV0dXJuIGUubm9kZVZhbHVlfWVsc2Ugd2hpbGUodD1lW3IrK10pbis9byh0KTtyZXR1cm4gbn0sKGI9c2Uuc2VsZWN0b3JzPXtjYWNoZUxlbmd0aDo1MCxjcmVhdGVQc2V1ZG86bGUsbWF0Y2g6RyxhdHRySGFuZGxlOnt9LGZpbmQ6e30scmVsYXRpdmU6e1wiPlwiOntkaXI6XCJwYXJlbnROb2RlXCIsZmlyc3Q6ITB9LFwiIFwiOntkaXI6XCJwYXJlbnROb2RlXCJ9LFwiK1wiOntkaXI6XCJwcmV2aW91c1NpYmxpbmdcIixmaXJzdDohMH0sXCJ+XCI6e2RpcjpcInByZXZpb3VzU2libGluZ1wifX0scHJlRmlsdGVyOntBVFRSOmZ1bmN0aW9uKGUpe3JldHVybiBlWzFdPWVbMV0ucmVwbGFjZSh0ZSxuZSksZVszXT0oZVszXXx8ZVs0XXx8ZVs1XXx8XCJcIikucmVwbGFjZSh0ZSxuZSksXCJ+PVwiPT09ZVsyXSYmKGVbM109XCIgXCIrZVszXStcIiBcIiksZS5zbGljZSgwLDQpfSxDSElMRDpmdW5jdGlvbihlKXtyZXR1cm4gZVsxXT1lWzFdLnRvTG93ZXJDYXNlKCksXCJudGhcIj09PWVbMV0uc2xpY2UoMCwzKT8oZVszXXx8c2UuZXJyb3IoZVswXSksZVs0XT0rKGVbNF0/ZVs1XSsoZVs2XXx8MSk6MiooXCJldmVuXCI9PT1lWzNdfHxcIm9kZFwiPT09ZVszXSkpLGVbNV09KyhlWzddK2VbOF18fFwib2RkXCI9PT1lWzNdKSk6ZVszXSYmc2UuZXJyb3IoZVswXSksZX0sUFNFVURPOmZ1bmN0aW9uKGUpe3ZhciB0LG49IWVbNl0mJmVbMl07cmV0dXJuIEcuQ0hJTEQudGVzdChlWzBdKT9udWxsOihlWzNdP2VbMl09ZVs0XXx8ZVs1XXx8XCJcIjpuJiZYLnRlc3QobikmJih0PWgobiwhMCkpJiYodD1uLmluZGV4T2YoXCIpXCIsbi5sZW5ndGgtdCktbi5sZW5ndGgpJiYoZVswXT1lWzBdLnNsaWNlKDAsdCksZVsyXT1uLnNsaWNlKDAsdCkpLGUuc2xpY2UoMCwzKSl9fSxmaWx0ZXI6e1RBRzpmdW5jdGlvbihlKXt2YXIgdD1lLnJlcGxhY2UodGUsbmUpLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCIqXCI9PT1lP2Z1bmN0aW9uKCl7cmV0dXJuITB9OmZ1bmN0aW9uKGUpe3JldHVybiBlLm5vZGVOYW1lJiZlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT10fX0sQ0xBU1M6ZnVuY3Rpb24oZSl7dmFyIHQ9bVtlK1wiIFwiXTtyZXR1cm4gdHx8KHQ9bmV3IFJlZ0V4cChcIihefFwiK00rXCIpXCIrZStcIihcIitNK1wifCQpXCIpKSYmbShlLGZ1bmN0aW9uKGUpe3JldHVybiB0LnRlc3QoXCJzdHJpbmdcIj09dHlwZW9mIGUuY2xhc3NOYW1lJiZlLmNsYXNzTmFtZXx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGUuZ2V0QXR0cmlidXRlJiZlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpfHxcIlwiKX0pfSxBVFRSOmZ1bmN0aW9uKG4scixpKXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9c2UuYXR0cihlLG4pO3JldHVybiBudWxsPT10P1wiIT1cIj09PXI6IXJ8fCh0Kz1cIlwiLFwiPVwiPT09cj90PT09aTpcIiE9XCI9PT1yP3QhPT1pOlwiXj1cIj09PXI/aSYmMD09PXQuaW5kZXhPZihpKTpcIio9XCI9PT1yP2kmJi0xPHQuaW5kZXhPZihpKTpcIiQ9XCI9PT1yP2kmJnQuc2xpY2UoLWkubGVuZ3RoKT09PWk6XCJ+PVwiPT09cj8tMTwoXCIgXCIrdC5yZXBsYWNlKCQsXCIgXCIpK1wiIFwiKS5pbmRleE9mKGkpOlwifD1cIj09PXImJih0PT09aXx8dC5zbGljZSgwLGkubGVuZ3RoKzEpPT09aStcIi1cIikpfX0sQ0hJTEQ6ZnVuY3Rpb24oaCxlLHQsZyx5KXt2YXIgdj1cIm50aFwiIT09aC5zbGljZSgwLDMpLG09XCJsYXN0XCIhPT1oLnNsaWNlKC00KSx4PVwib2YtdHlwZVwiPT09ZTtyZXR1cm4gMT09PWcmJjA9PT15P2Z1bmN0aW9uKGUpe3JldHVybiEhZS5wYXJlbnROb2RlfTpmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvLGEscyx1LGw9diE9PW0/XCJuZXh0U2libGluZ1wiOlwicHJldmlvdXNTaWJsaW5nXCIsYz1lLnBhcmVudE5vZGUsZj14JiZlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkscD0hbiYmIXgsZD0hMTtpZihjKXtpZih2KXt3aGlsZShsKXthPWU7d2hpbGUoYT1hW2xdKWlmKHg/YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09ZjoxPT09YS5ub2RlVHlwZSlyZXR1cm4hMTt1PWw9XCJvbmx5XCI9PT1oJiYhdSYmXCJuZXh0U2libGluZ1wifXJldHVybiEwfWlmKHU9W20/Yy5maXJzdENoaWxkOmMubGFzdENoaWxkXSxtJiZwKXtkPShzPShyPShpPShvPShhPWMpW1NdfHwoYVtTXT17fSkpW2EudW5pcXVlSURdfHwob1thLnVuaXF1ZUlEXT17fSkpW2hdfHxbXSlbMF09PT1rJiZyWzFdKSYmclsyXSxhPXMmJmMuY2hpbGROb2Rlc1tzXTt3aGlsZShhPSsrcyYmYSYmYVtsXXx8KGQ9cz0wKXx8dS5wb3AoKSlpZigxPT09YS5ub2RlVHlwZSYmKytkJiZhPT09ZSl7aVtoXT1bayxzLGRdO2JyZWFrfX1lbHNlIGlmKHAmJihkPXM9KHI9KGk9KG89KGE9ZSlbU118fChhW1NdPXt9KSlbYS51bmlxdWVJRF18fChvW2EudW5pcXVlSURdPXt9KSlbaF18fFtdKVswXT09PWsmJnJbMV0pLCExPT09ZCl3aGlsZShhPSsrcyYmYSYmYVtsXXx8KGQ9cz0wKXx8dS5wb3AoKSlpZigoeD9hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1mOjE9PT1hLm5vZGVUeXBlKSYmKytkJiYocCYmKChpPShvPWFbU118fChhW1NdPXt9KSlbYS51bmlxdWVJRF18fChvW2EudW5pcXVlSURdPXt9KSlbaF09W2ssZF0pLGE9PT1lKSlicmVhaztyZXR1cm4oZC09eSk9PT1nfHxkJWc9PTAmJjA8PWQvZ319fSxQU0VVRE86ZnVuY3Rpb24oZSxvKXt2YXIgdCxhPWIucHNldWRvc1tlXXx8Yi5zZXRGaWx0ZXJzW2UudG9Mb3dlckNhc2UoKV18fHNlLmVycm9yKFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIitlKTtyZXR1cm4gYVtTXT9hKG8pOjE8YS5sZW5ndGg/KHQ9W2UsZSxcIlwiLG9dLGIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eShlLnRvTG93ZXJDYXNlKCkpP2xlKGZ1bmN0aW9uKGUsdCl7dmFyIG4scj1hKGUsbyksaT1yLmxlbmd0aDt3aGlsZShpLS0pZVtuPVAoZSxyW2ldKV09ISh0W25dPXJbaV0pfSk6ZnVuY3Rpb24oZSl7cmV0dXJuIGEoZSwwLHQpfSk6YX19LHBzZXVkb3M6e25vdDpsZShmdW5jdGlvbihlKXt2YXIgcj1bXSxpPVtdLHM9ZihlLnJlcGxhY2UoQixcIiQxXCIpKTtyZXR1cm4gc1tTXT9sZShmdW5jdGlvbihlLHQsbixyKXt2YXIgaSxvPXMoZSxudWxsLHIsW10pLGE9ZS5sZW5ndGg7d2hpbGUoYS0tKShpPW9bYV0pJiYoZVthXT0hKHRbYV09aSkpfSk6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiByWzBdPWUscyhyLG51bGwsbixpKSxyWzBdPW51bGwsIWkucG9wKCl9fSksaGFzOmxlKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gMDxzZSh0LGUpLmxlbmd0aH19KSxjb250YWluczpsZShmdW5jdGlvbih0KXtyZXR1cm4gdD10LnJlcGxhY2UodGUsbmUpLGZ1bmN0aW9uKGUpe3JldHVybi0xPChlLnRleHRDb250ZW50fHxvKGUpKS5pbmRleE9mKHQpfX0pLGxhbmc6bGUoZnVuY3Rpb24obil7cmV0dXJuIFYudGVzdChufHxcIlwiKXx8c2UuZXJyb3IoXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIituKSxuPW4ucmVwbGFjZSh0ZSxuZSkudG9Mb3dlckNhc2UoKSxmdW5jdGlvbihlKXt2YXIgdDtkb3tpZih0PUU/ZS5sYW5nOmUuZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIil8fGUuZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSlyZXR1cm4odD10LnRvTG93ZXJDYXNlKCkpPT09bnx8MD09PXQuaW5kZXhPZihuK1wiLVwiKX13aGlsZSgoZT1lLnBhcmVudE5vZGUpJiYxPT09ZS5ub2RlVHlwZSk7cmV0dXJuITF9fSksdGFyZ2V0OmZ1bmN0aW9uKGUpe3ZhciB0PW4ubG9jYXRpb24mJm4ubG9jYXRpb24uaGFzaDtyZXR1cm4gdCYmdC5zbGljZSgxKT09PWUuaWR9LHJvb3Q6ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT1hfSxmb2N1czpmdW5jdGlvbihlKXtyZXR1cm4gZT09PUMuYWN0aXZlRWxlbWVudCYmKCFDLmhhc0ZvY3VzfHxDLmhhc0ZvY3VzKCkpJiYhIShlLnR5cGV8fGUuaHJlZnx8fmUudGFiSW5kZXgpfSxlbmFibGVkOmdlKCExKSxkaXNhYmxlZDpnZSghMCksY2hlY2tlZDpmdW5jdGlvbihlKXt2YXIgdD1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJpbnB1dFwiPT09dCYmISFlLmNoZWNrZWR8fFwib3B0aW9uXCI9PT10JiYhIWUuc2VsZWN0ZWR9LHNlbGVjdGVkOmZ1bmN0aW9uKGUpe3JldHVybiBlLnBhcmVudE5vZGUmJmUucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LCEwPT09ZS5zZWxlY3RlZH0sZW1wdHk6ZnVuY3Rpb24oZSl7Zm9yKGU9ZS5maXJzdENoaWxkO2U7ZT1lLm5leHRTaWJsaW5nKWlmKGUubm9kZVR5cGU8NilyZXR1cm4hMTtyZXR1cm4hMH0scGFyZW50OmZ1bmN0aW9uKGUpe3JldHVybiFiLnBzZXVkb3MuZW1wdHkoZSl9LGhlYWRlcjpmdW5jdGlvbihlKXtyZXR1cm4gSi50ZXN0KGUubm9kZU5hbWUpfSxpbnB1dDpmdW5jdGlvbihlKXtyZXR1cm4gUS50ZXN0KGUubm9kZU5hbWUpfSxidXR0b246ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVyblwiaW5wdXRcIj09PXQmJlwiYnV0dG9uXCI9PT1lLnR5cGV8fFwiYnV0dG9uXCI9PT10fSx0ZXh0OmZ1bmN0aW9uKGUpe3ZhciB0O3JldHVyblwiaW5wdXRcIj09PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSYmXCJ0ZXh0XCI9PT1lLnR5cGUmJihudWxsPT0odD1lLmdldEF0dHJpYnV0ZShcInR5cGVcIikpfHxcInRleHRcIj09PXQudG9Mb3dlckNhc2UoKSl9LGZpcnN0OnllKGZ1bmN0aW9uKCl7cmV0dXJuWzBdfSksbGFzdDp5ZShmdW5jdGlvbihlLHQpe3JldHVyblt0LTFdfSksZXE6eWUoZnVuY3Rpb24oZSx0LG4pe3JldHVybltuPDA/bit0Om5dfSksZXZlbjp5ZShmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0wO248dDtuKz0yKWUucHVzaChuKTtyZXR1cm4gZX0pLG9kZDp5ZShmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0xO248dDtuKz0yKWUucHVzaChuKTtyZXR1cm4gZX0pLGx0OnllKGZ1bmN0aW9uKGUsdCxuKXtmb3IodmFyIHI9bjwwP24rdDp0PG4/dDpuOzA8PS0tcjspZS5wdXNoKHIpO3JldHVybiBlfSksZ3Q6eWUoZnVuY3Rpb24oZSx0LG4pe2Zvcih2YXIgcj1uPDA/bit0Om47KytyPHQ7KWUucHVzaChyKTtyZXR1cm4gZX0pfX0pLnBzZXVkb3MubnRoPWIucHNldWRvcy5lcSx7cmFkaW86ITAsY2hlY2tib3g6ITAsZmlsZTohMCxwYXNzd29yZDohMCxpbWFnZTohMH0pYi5wc2V1ZG9zW2VdPWRlKGUpO2ZvcihlIGlue3N1Ym1pdDohMCxyZXNldDohMH0pYi5wc2V1ZG9zW2VdPWhlKGUpO2Z1bmN0aW9uIG1lKCl7fWZ1bmN0aW9uIHhlKGUpe2Zvcih2YXIgdD0wLG49ZS5sZW5ndGgscj1cIlwiO3Q8bjt0Kyspcis9ZVt0XS52YWx1ZTtyZXR1cm4gcn1mdW5jdGlvbiBiZShzLGUsdCl7dmFyIHU9ZS5kaXIsbD1lLm5leHQsYz1sfHx1LGY9dCYmXCJwYXJlbnROb2RlXCI9PT1jLHA9cisrO3JldHVybiBlLmZpcnN0P2Z1bmN0aW9uKGUsdCxuKXt3aGlsZShlPWVbdV0paWYoMT09PWUubm9kZVR5cGV8fGYpcmV0dXJuIHMoZSx0LG4pO3JldHVybiExfTpmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvLGE9W2sscF07aWYobil7d2hpbGUoZT1lW3VdKWlmKCgxPT09ZS5ub2RlVHlwZXx8ZikmJnMoZSx0LG4pKXJldHVybiEwfWVsc2Ugd2hpbGUoZT1lW3VdKWlmKDE9PT1lLm5vZGVUeXBlfHxmKWlmKGk9KG89ZVtTXXx8KGVbU109e30pKVtlLnVuaXF1ZUlEXXx8KG9bZS51bmlxdWVJRF09e30pLGwmJmw9PT1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpZT1lW3VdfHxlO2Vsc2V7aWYoKHI9aVtjXSkmJnJbMF09PT1rJiZyWzFdPT09cClyZXR1cm4gYVsyXT1yWzJdO2lmKChpW2NdPWEpWzJdPXMoZSx0LG4pKXJldHVybiEwfXJldHVybiExfX1mdW5jdGlvbiB3ZShpKXtyZXR1cm4gMTxpLmxlbmd0aD9mdW5jdGlvbihlLHQsbil7dmFyIHI9aS5sZW5ndGg7d2hpbGUoci0tKWlmKCFpW3JdKGUsdCxuKSlyZXR1cm4hMTtyZXR1cm4hMH06aVswXX1mdW5jdGlvbiBUZShlLHQsbixyLGkpe2Zvcih2YXIgbyxhPVtdLHM9MCx1PWUubGVuZ3RoLGw9bnVsbCE9dDtzPHU7cysrKShvPWVbc10pJiYobiYmIW4obyxyLGkpfHwoYS5wdXNoKG8pLGwmJnQucHVzaChzKSkpO3JldHVybiBhfWZ1bmN0aW9uIENlKGQsaCxnLHksdixlKXtyZXR1cm4geSYmIXlbU10mJih5PUNlKHkpKSx2JiYhdltTXSYmKHY9Q2UodixlKSksbGUoZnVuY3Rpb24oZSx0LG4scil7dmFyIGksbyxhLHM9W10sdT1bXSxsPXQubGVuZ3RoLGM9ZXx8ZnVuY3Rpb24oZSx0LG4pe2Zvcih2YXIgcj0wLGk9dC5sZW5ndGg7cjxpO3IrKylzZShlLHRbcl0sbik7cmV0dXJuIG59KGh8fFwiKlwiLG4ubm9kZVR5cGU/W25dOm4sW10pLGY9IWR8fCFlJiZoP2M6VGUoYyxzLGQsbixyKSxwPWc/dnx8KGU/ZDpsfHx5KT9bXTp0OmY7aWYoZyYmZyhmLHAsbixyKSx5KXtpPVRlKHAsdSkseShpLFtdLG4sciksbz1pLmxlbmd0aDt3aGlsZShvLS0pKGE9aVtvXSkmJihwW3Vbb11dPSEoZlt1W29dXT1hKSl9aWYoZSl7aWYodnx8ZCl7aWYodil7aT1bXSxvPXAubGVuZ3RoO3doaWxlKG8tLSkoYT1wW29dKSYmaS5wdXNoKGZbb109YSk7dihudWxsLHA9W10saSxyKX1vPXAubGVuZ3RoO3doaWxlKG8tLSkoYT1wW29dKSYmLTE8KGk9dj9QKGUsYSk6c1tvXSkmJihlW2ldPSEodFtpXT1hKSl9fWVsc2UgcD1UZShwPT09dD9wLnNwbGljZShsLHAubGVuZ3RoKTpwKSx2P3YobnVsbCx0LHAscik6SC5hcHBseSh0LHApfSl9ZnVuY3Rpb24gRWUoZSl7Zm9yKHZhciBpLHQsbixyPWUubGVuZ3RoLG89Yi5yZWxhdGl2ZVtlWzBdLnR5cGVdLGE9b3x8Yi5yZWxhdGl2ZVtcIiBcIl0scz1vPzE6MCx1PWJlKGZ1bmN0aW9uKGUpe3JldHVybiBlPT09aX0sYSwhMCksbD1iZShmdW5jdGlvbihlKXtyZXR1cm4tMTxQKGksZSl9LGEsITApLGM9W2Z1bmN0aW9uKGUsdCxuKXt2YXIgcj0hbyYmKG58fHQhPT13KXx8KChpPXQpLm5vZGVUeXBlP3UoZSx0LG4pOmwoZSx0LG4pKTtyZXR1cm4gaT1udWxsLHJ9XTtzPHI7cysrKWlmKHQ9Yi5yZWxhdGl2ZVtlW3NdLnR5cGVdKWM9W2JlKHdlKGMpLHQpXTtlbHNle2lmKCh0PWIuZmlsdGVyW2Vbc10udHlwZV0uYXBwbHkobnVsbCxlW3NdLm1hdGNoZXMpKVtTXSl7Zm9yKG49KytzO248cjtuKyspaWYoYi5yZWxhdGl2ZVtlW25dLnR5cGVdKWJyZWFrO3JldHVybiBDZSgxPHMmJndlKGMpLDE8cyYmeGUoZS5zbGljZSgwLHMtMSkuY29uY2F0KHt2YWx1ZTpcIiBcIj09PWVbcy0yXS50eXBlP1wiKlwiOlwiXCJ9KSkucmVwbGFjZShCLFwiJDFcIiksdCxzPG4mJkVlKGUuc2xpY2UocyxuKSksbjxyJiZFZShlPWUuc2xpY2UobikpLG48ciYmeGUoZSkpfWMucHVzaCh0KX1yZXR1cm4gd2UoYyl9cmV0dXJuIG1lLnByb3RvdHlwZT1iLmZpbHRlcnM9Yi5wc2V1ZG9zLGIuc2V0RmlsdGVycz1uZXcgbWUsaD1zZS50b2tlbml6ZT1mdW5jdGlvbihlLHQpe3ZhciBuLHIsaSxvLGEscyx1LGw9eFtlK1wiIFwiXTtpZihsKXJldHVybiB0PzA6bC5zbGljZSgwKTthPWUscz1bXSx1PWIucHJlRmlsdGVyO3doaWxlKGEpe2ZvcihvIGluIG4mJiEocj1fLmV4ZWMoYSkpfHwociYmKGE9YS5zbGljZShyWzBdLmxlbmd0aCl8fGEpLHMucHVzaChpPVtdKSksbj0hMSwocj16LmV4ZWMoYSkpJiYobj1yLnNoaWZ0KCksaS5wdXNoKHt2YWx1ZTpuLHR5cGU6clswXS5yZXBsYWNlKEIsXCIgXCIpfSksYT1hLnNsaWNlKG4ubGVuZ3RoKSksYi5maWx0ZXIpIShyPUdbb10uZXhlYyhhKSl8fHVbb10mJiEocj11W29dKHIpKXx8KG49ci5zaGlmdCgpLGkucHVzaCh7dmFsdWU6bix0eXBlOm8sbWF0Y2hlczpyfSksYT1hLnNsaWNlKG4ubGVuZ3RoKSk7aWYoIW4pYnJlYWt9cmV0dXJuIHQ/YS5sZW5ndGg6YT9zZS5lcnJvcihlKTp4KGUscykuc2xpY2UoMCl9LGY9c2UuY29tcGlsZT1mdW5jdGlvbihlLHQpe3ZhciBuLHksdixtLHgscixpPVtdLG89W10sYT1BW2UrXCIgXCJdO2lmKCFhKXt0fHwodD1oKGUpKSxuPXQubGVuZ3RoO3doaWxlKG4tLSkoYT1FZSh0W25dKSlbU10/aS5wdXNoKGEpOm8ucHVzaChhKTsoYT1BKGUsKHk9byxtPTA8KHY9aSkubGVuZ3RoLHg9MDx5Lmxlbmd0aCxyPWZ1bmN0aW9uKGUsdCxuLHIsaSl7dmFyIG8sYSxzLHU9MCxsPVwiMFwiLGM9ZSYmW10sZj1bXSxwPXcsZD1lfHx4JiZiLmZpbmQuVEFHKFwiKlwiLGkpLGg9ays9bnVsbD09cD8xOk1hdGgucmFuZG9tKCl8fC4xLGc9ZC5sZW5ndGg7Zm9yKGkmJih3PXQ9PUN8fHR8fGkpO2whPT1nJiZudWxsIT0obz1kW2xdKTtsKyspe2lmKHgmJm8pe2E9MCx0fHxvLm93bmVyRG9jdW1lbnQ9PUN8fChUKG8pLG49IUUpO3doaWxlKHM9eVthKytdKWlmKHMobyx0fHxDLG4pKXtyLnB1c2gobyk7YnJlYWt9aSYmKGs9aCl9bSYmKChvPSFzJiZvKSYmdS0tLGUmJmMucHVzaChvKSl9aWYodSs9bCxtJiZsIT09dSl7YT0wO3doaWxlKHM9dlthKytdKXMoYyxmLHQsbik7aWYoZSl7aWYoMDx1KXdoaWxlKGwtLSljW2xdfHxmW2xdfHwoZltsXT1xLmNhbGwocikpO2Y9VGUoZil9SC5hcHBseShyLGYpLGkmJiFlJiYwPGYubGVuZ3RoJiYxPHUrdi5sZW5ndGgmJnNlLnVuaXF1ZVNvcnQocil9cmV0dXJuIGkmJihrPWgsdz1wKSxjfSxtP2xlKHIpOnIpKSkuc2VsZWN0b3I9ZX1yZXR1cm4gYX0sZz1zZS5zZWxlY3Q9ZnVuY3Rpb24oZSx0LG4scil7dmFyIGksbyxhLHMsdSxsPVwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJmUsYz0hciYmaChlPWwuc2VsZWN0b3J8fGUpO2lmKG49bnx8W10sMT09PWMubGVuZ3RoKXtpZigyPChvPWNbMF09Y1swXS5zbGljZSgwKSkubGVuZ3RoJiZcIklEXCI9PT0oYT1vWzBdKS50eXBlJiY5PT09dC5ub2RlVHlwZSYmRSYmYi5yZWxhdGl2ZVtvWzFdLnR5cGVdKXtpZighKHQ9KGIuZmluZC5JRChhLm1hdGNoZXNbMF0ucmVwbGFjZSh0ZSxuZSksdCl8fFtdKVswXSkpcmV0dXJuIG47bCYmKHQ9dC5wYXJlbnROb2RlKSxlPWUuc2xpY2Uoby5zaGlmdCgpLnZhbHVlLmxlbmd0aCl9aT1HLm5lZWRzQ29udGV4dC50ZXN0KGUpPzA6by5sZW5ndGg7d2hpbGUoaS0tKXtpZihhPW9baV0sYi5yZWxhdGl2ZVtzPWEudHlwZV0pYnJlYWs7aWYoKHU9Yi5maW5kW3NdKSYmKHI9dShhLm1hdGNoZXNbMF0ucmVwbGFjZSh0ZSxuZSksZWUudGVzdChvWzBdLnR5cGUpJiZ2ZSh0LnBhcmVudE5vZGUpfHx0KSkpe2lmKG8uc3BsaWNlKGksMSksIShlPXIubGVuZ3RoJiZ4ZShvKSkpcmV0dXJuIEguYXBwbHkobixyKSxuO2JyZWFrfX19cmV0dXJuKGx8fGYoZSxjKSkocix0LCFFLG4sIXR8fGVlLnRlc3QoZSkmJnZlKHQucGFyZW50Tm9kZSl8fHQpLG59LGQuc29ydFN0YWJsZT1TLnNwbGl0KFwiXCIpLnNvcnQoaikuam9pbihcIlwiKT09PVMsZC5kZXRlY3REdXBsaWNhdGVzPSEhbCxUKCksZC5zb3J0RGV0YWNoZWQ9Y2UoZnVuY3Rpb24oZSl7cmV0dXJuIDEmZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihDLmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKSl9KSxjZShmdW5jdGlvbihlKXtyZXR1cm4gZS5pbm5lckhUTUw9XCI8YSBocmVmPScjJz48L2E+XCIsXCIjXCI9PT1lLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKX0pfHxmZShcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIixmdW5jdGlvbihlLHQsbil7aWYoIW4pcmV0dXJuIGUuZ2V0QXR0cmlidXRlKHQsXCJ0eXBlXCI9PT10LnRvTG93ZXJDYXNlKCk/MToyKX0pLGQuYXR0cmlidXRlcyYmY2UoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaW5uZXJIVE1MPVwiPGlucHV0Lz5cIixlLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwidmFsdWVcIixcIlwiKSxcIlwiPT09ZS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpfSl8fGZlKFwidmFsdWVcIixmdW5jdGlvbihlLHQsbil7aWYoIW4mJlwiaW5wdXRcIj09PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSlyZXR1cm4gZS5kZWZhdWx0VmFsdWV9KSxjZShmdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09ZS5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKX0pfHxmZShSLGZ1bmN0aW9uKGUsdCxuKXt2YXIgcjtpZighbilyZXR1cm4hMD09PWVbdF0/dC50b0xvd2VyQ2FzZSgpOihyPWUuZ2V0QXR0cmlidXRlTm9kZSh0KSkmJnIuc3BlY2lmaWVkP3IudmFsdWU6bnVsbH0pLHNlfShDKTtTLmZpbmQ9ZCxTLmV4cHI9ZC5zZWxlY3RvcnMsUy5leHByW1wiOlwiXT1TLmV4cHIucHNldWRvcyxTLnVuaXF1ZVNvcnQ9Uy51bmlxdWU9ZC51bmlxdWVTb3J0LFMudGV4dD1kLmdldFRleHQsUy5pc1hNTERvYz1kLmlzWE1MLFMuY29udGFpbnM9ZC5jb250YWlucyxTLmVzY2FwZVNlbGVjdG9yPWQuZXNjYXBlO3ZhciBoPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1bXSxpPXZvaWQgMCE9PW47d2hpbGUoKGU9ZVt0XSkmJjkhPT1lLm5vZGVUeXBlKWlmKDE9PT1lLm5vZGVUeXBlKXtpZihpJiZTKGUpLmlzKG4pKWJyZWFrO3IucHVzaChlKX1yZXR1cm4gcn0sVD1mdW5jdGlvbihlLHQpe2Zvcih2YXIgbj1bXTtlO2U9ZS5uZXh0U2libGluZykxPT09ZS5ub2RlVHlwZSYmZSE9PXQmJm4ucHVzaChlKTtyZXR1cm4gbn0saz1TLmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O2Z1bmN0aW9uIEEoZSx0KXtyZXR1cm4gZS5ub2RlTmFtZSYmZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09dC50b0xvd2VyQ2FzZSgpfXZhciBOPS9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pO2Z1bmN0aW9uIGooZSxuLHIpe3JldHVybiBtKG4pP1MuZ3JlcChlLGZ1bmN0aW9uKGUsdCl7cmV0dXJuISFuLmNhbGwoZSx0LGUpIT09cn0pOm4ubm9kZVR5cGU/Uy5ncmVwKGUsZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT1uIT09cn0pOlwic3RyaW5nXCIhPXR5cGVvZiBuP1MuZ3JlcChlLGZ1bmN0aW9uKGUpe3JldHVybi0xPGkuY2FsbChuLGUpIT09cn0pOlMuZmlsdGVyKG4sZSxyKX1TLmZpbHRlcj1mdW5jdGlvbihlLHQsbil7dmFyIHI9dFswXTtyZXR1cm4gbiYmKGU9XCI6bm90KFwiK2UrXCIpXCIpLDE9PT10Lmxlbmd0aCYmMT09PXIubm9kZVR5cGU/Uy5maW5kLm1hdGNoZXNTZWxlY3RvcihyLGUpP1tyXTpbXTpTLmZpbmQubWF0Y2hlcyhlLFMuZ3JlcCh0LGZ1bmN0aW9uKGUpe3JldHVybiAxPT09ZS5ub2RlVHlwZX0pKX0sUy5mbi5leHRlbmQoe2ZpbmQ6ZnVuY3Rpb24oZSl7dmFyIHQsbixyPXRoaXMubGVuZ3RoLGk9dGhpcztpZihcInN0cmluZ1wiIT10eXBlb2YgZSlyZXR1cm4gdGhpcy5wdXNoU3RhY2soUyhlKS5maWx0ZXIoZnVuY3Rpb24oKXtmb3IodD0wO3Q8cjt0KyspaWYoUy5jb250YWlucyhpW3RdLHRoaXMpKXJldHVybiEwfSkpO2ZvcihuPXRoaXMucHVzaFN0YWNrKFtdKSx0PTA7dDxyO3QrKylTLmZpbmQoZSxpW3RdLG4pO3JldHVybiAxPHI/Uy51bmlxdWVTb3J0KG4pOm59LGZpbHRlcjpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soaih0aGlzLGV8fFtdLCExKSl9LG5vdDpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soaih0aGlzLGV8fFtdLCEwKSl9LGlzOmZ1bmN0aW9uKGUpe3JldHVybiEhaih0aGlzLFwic3RyaW5nXCI9PXR5cGVvZiBlJiZrLnRlc3QoZSk/UyhlKTplfHxbXSwhMSkubGVuZ3RofX0pO3ZhciBELHE9L14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC87KFMuZm4uaW5pdD1mdW5jdGlvbihlLHQsbil7dmFyIHIsaTtpZighZSlyZXR1cm4gdGhpcztpZihuPW58fEQsXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKCEocj1cIjxcIj09PWVbMF0mJlwiPlwiPT09ZVtlLmxlbmd0aC0xXSYmMzw9ZS5sZW5ndGg/W251bGwsZSxudWxsXTpxLmV4ZWMoZSkpfHwhclsxXSYmdClyZXR1cm4hdHx8dC5qcXVlcnk/KHR8fG4pLmZpbmQoZSk6dGhpcy5jb25zdHJ1Y3Rvcih0KS5maW5kKGUpO2lmKHJbMV0pe2lmKHQ9dCBpbnN0YW5jZW9mIFM/dFswXTp0LFMubWVyZ2UodGhpcyxTLnBhcnNlSFRNTChyWzFdLHQmJnQubm9kZVR5cGU/dC5vd25lckRvY3VtZW50fHx0OkUsITApKSxOLnRlc3QoclsxXSkmJlMuaXNQbGFpbk9iamVjdCh0KSlmb3IociBpbiB0KW0odGhpc1tyXSk/dGhpc1tyXSh0W3JdKTp0aGlzLmF0dHIocix0W3JdKTtyZXR1cm4gdGhpc31yZXR1cm4oaT1FLmdldEVsZW1lbnRCeUlkKHJbMl0pKSYmKHRoaXNbMF09aSx0aGlzLmxlbmd0aD0xKSx0aGlzfXJldHVybiBlLm5vZGVUeXBlPyh0aGlzWzBdPWUsdGhpcy5sZW5ndGg9MSx0aGlzKTptKGUpP3ZvaWQgMCE9PW4ucmVhZHk/bi5yZWFkeShlKTplKFMpOlMubWFrZUFycmF5KGUsdGhpcyl9KS5wcm90b3R5cGU9Uy5mbixEPVMoRSk7dmFyIEw9L14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sSD17Y2hpbGRyZW46ITAsY29udGVudHM6ITAsbmV4dDohMCxwcmV2OiEwfTtmdW5jdGlvbiBPKGUsdCl7d2hpbGUoKGU9ZVt0XSkmJjEhPT1lLm5vZGVUeXBlKTtyZXR1cm4gZX1TLmZuLmV4dGVuZCh7aGFzOmZ1bmN0aW9uKGUpe3ZhciB0PVMoZSx0aGlzKSxuPXQubGVuZ3RoO3JldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpe2Zvcih2YXIgZT0wO2U8bjtlKyspaWYoUy5jb250YWlucyh0aGlzLHRbZV0pKXJldHVybiEwfSl9LGNsb3Nlc3Q6ZnVuY3Rpb24oZSx0KXt2YXIgbixyPTAsaT10aGlzLmxlbmd0aCxvPVtdLGE9XCJzdHJpbmdcIiE9dHlwZW9mIGUmJlMoZSk7aWYoIWsudGVzdChlKSlmb3IoO3I8aTtyKyspZm9yKG49dGhpc1tyXTtuJiZuIT09dDtuPW4ucGFyZW50Tm9kZSlpZihuLm5vZGVUeXBlPDExJiYoYT8tMTxhLmluZGV4KG4pOjE9PT1uLm5vZGVUeXBlJiZTLmZpbmQubWF0Y2hlc1NlbGVjdG9yKG4sZSkpKXtvLnB1c2gobik7YnJlYWt9cmV0dXJuIHRoaXMucHVzaFN0YWNrKDE8by5sZW5ndGg/Uy51bmlxdWVTb3J0KG8pOm8pfSxpbmRleDpmdW5jdGlvbihlKXtyZXR1cm4gZT9cInN0cmluZ1wiPT10eXBlb2YgZT9pLmNhbGwoUyhlKSx0aGlzWzBdKTppLmNhbGwodGhpcyxlLmpxdWVyeT9lWzBdOmUpOnRoaXNbMF0mJnRoaXNbMF0ucGFyZW50Tm9kZT90aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aDotMX0sYWRkOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKFMudW5pcXVlU29ydChTLm1lcmdlKHRoaXMuZ2V0KCksUyhlLHQpKSkpfSxhZGRCYWNrOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmFkZChudWxsPT1lP3RoaXMucHJldk9iamVjdDp0aGlzLnByZXZPYmplY3QuZmlsdGVyKGUpKX19KSxTLmVhY2goe3BhcmVudDpmdW5jdGlvbihlKXt2YXIgdD1lLnBhcmVudE5vZGU7cmV0dXJuIHQmJjExIT09dC5ub2RlVHlwZT90Om51bGx9LHBhcmVudHM6ZnVuY3Rpb24oZSl7cmV0dXJuIGgoZSxcInBhcmVudE5vZGVcIil9LHBhcmVudHNVbnRpbDpmdW5jdGlvbihlLHQsbil7cmV0dXJuIGgoZSxcInBhcmVudE5vZGVcIixuKX0sbmV4dDpmdW5jdGlvbihlKXtyZXR1cm4gTyhlLFwibmV4dFNpYmxpbmdcIil9LHByZXY6ZnVuY3Rpb24oZSl7cmV0dXJuIE8oZSxcInByZXZpb3VzU2libGluZ1wiKX0sbmV4dEFsbDpmdW5jdGlvbihlKXtyZXR1cm4gaChlLFwibmV4dFNpYmxpbmdcIil9LHByZXZBbGw6ZnVuY3Rpb24oZSl7cmV0dXJuIGgoZSxcInByZXZpb3VzU2libGluZ1wiKX0sbmV4dFVudGlsOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gaChlLFwibmV4dFNpYmxpbmdcIixuKX0scHJldlVudGlsOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gaChlLFwicHJldmlvdXNTaWJsaW5nXCIsbil9LHNpYmxpbmdzOmZ1bmN0aW9uKGUpe3JldHVybiBUKChlLnBhcmVudE5vZGV8fHt9KS5maXJzdENoaWxkLGUpfSxjaGlsZHJlbjpmdW5jdGlvbihlKXtyZXR1cm4gVChlLmZpcnN0Q2hpbGQpfSxjb250ZW50czpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9ZS5jb250ZW50RG9jdW1lbnQmJnIoZS5jb250ZW50RG9jdW1lbnQpP2UuY29udGVudERvY3VtZW50OihBKGUsXCJ0ZW1wbGF0ZVwiKSYmKGU9ZS5jb250ZW50fHxlKSxTLm1lcmdlKFtdLGUuY2hpbGROb2RlcykpfX0sZnVuY3Rpb24ocixpKXtTLmZuW3JdPWZ1bmN0aW9uKGUsdCl7dmFyIG49Uy5tYXAodGhpcyxpLGUpO3JldHVyblwiVW50aWxcIiE9PXIuc2xpY2UoLTUpJiYodD1lKSx0JiZcInN0cmluZ1wiPT10eXBlb2YgdCYmKG49Uy5maWx0ZXIodCxuKSksMTx0aGlzLmxlbmd0aCYmKEhbcl18fFMudW5pcXVlU29ydChuKSxMLnRlc3QocikmJm4ucmV2ZXJzZSgpKSx0aGlzLnB1c2hTdGFjayhuKX19KTt2YXIgUD0vW15cXHgyMFxcdFxcclxcblxcZl0rL2c7ZnVuY3Rpb24gUihlKXtyZXR1cm4gZX1mdW5jdGlvbiBNKGUpe3Rocm93IGV9ZnVuY3Rpb24gSShlLHQsbixyKXt2YXIgaTt0cnl7ZSYmbShpPWUucHJvbWlzZSk/aS5jYWxsKGUpLmRvbmUodCkuZmFpbChuKTplJiZtKGk9ZS50aGVuKT9pLmNhbGwoZSx0LG4pOnQuYXBwbHkodm9pZCAwLFtlXS5zbGljZShyKSl9Y2F0Y2goZSl7bi5hcHBseSh2b2lkIDAsW2VdKX19Uy5DYWxsYmFja3M9ZnVuY3Rpb24ocil7dmFyIGUsbjtyPVwic3RyaW5nXCI9PXR5cGVvZiByPyhlPXIsbj17fSxTLmVhY2goZS5tYXRjaChQKXx8W10sZnVuY3Rpb24oZSx0KXtuW3RdPSEwfSksbik6Uy5leHRlbmQoe30scik7dmFyIGksdCxvLGEscz1bXSx1PVtdLGw9LTEsYz1mdW5jdGlvbigpe2ZvcihhPWF8fHIub25jZSxvPWk9ITA7dS5sZW5ndGg7bD0tMSl7dD11LnNoaWZ0KCk7d2hpbGUoKytsPHMubGVuZ3RoKSExPT09c1tsXS5hcHBseSh0WzBdLHRbMV0pJiZyLnN0b3BPbkZhbHNlJiYobD1zLmxlbmd0aCx0PSExKX1yLm1lbW9yeXx8KHQ9ITEpLGk9ITEsYSYmKHM9dD9bXTpcIlwiKX0sZj17YWRkOmZ1bmN0aW9uKCl7cmV0dXJuIHMmJih0JiYhaSYmKGw9cy5sZW5ndGgtMSx1LnB1c2godCkpLGZ1bmN0aW9uIG4oZSl7Uy5lYWNoKGUsZnVuY3Rpb24oZSx0KXttKHQpP3IudW5pcXVlJiZmLmhhcyh0KXx8cy5wdXNoKHQpOnQmJnQubGVuZ3RoJiZcInN0cmluZ1wiIT09dyh0KSYmbih0KX0pfShhcmd1bWVudHMpLHQmJiFpJiZjKCkpLHRoaXN9LHJlbW92ZTpmdW5jdGlvbigpe3JldHVybiBTLmVhY2goYXJndW1lbnRzLGZ1bmN0aW9uKGUsdCl7dmFyIG47d2hpbGUoLTE8KG49Uy5pbkFycmF5KHQscyxuKSkpcy5zcGxpY2UobiwxKSxuPD1sJiZsLS19KSx0aGlzfSxoYXM6ZnVuY3Rpb24oZSl7cmV0dXJuIGU/LTE8Uy5pbkFycmF5KGUscyk6MDxzLmxlbmd0aH0sZW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gcyYmKHM9W10pLHRoaXN9LGRpc2FibGU6ZnVuY3Rpb24oKXtyZXR1cm4gYT11PVtdLHM9dD1cIlwiLHRoaXN9LGRpc2FibGVkOmZ1bmN0aW9uKCl7cmV0dXJuIXN9LGxvY2s6ZnVuY3Rpb24oKXtyZXR1cm4gYT11PVtdLHR8fGl8fChzPXQ9XCJcIiksdGhpc30sbG9ja2VkOmZ1bmN0aW9uKCl7cmV0dXJuISFhfSxmaXJlV2l0aDpmdW5jdGlvbihlLHQpe3JldHVybiBhfHwodD1bZSwodD10fHxbXSkuc2xpY2U/dC5zbGljZSgpOnRdLHUucHVzaCh0KSxpfHxjKCkpLHRoaXN9LGZpcmU6ZnVuY3Rpb24oKXtyZXR1cm4gZi5maXJlV2l0aCh0aGlzLGFyZ3VtZW50cyksdGhpc30sZmlyZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hIW99fTtyZXR1cm4gZn0sUy5leHRlbmQoe0RlZmVycmVkOmZ1bmN0aW9uKGUpe3ZhciBvPVtbXCJub3RpZnlcIixcInByb2dyZXNzXCIsUy5DYWxsYmFja3MoXCJtZW1vcnlcIiksUy5DYWxsYmFja3MoXCJtZW1vcnlcIiksMl0sW1wicmVzb2x2ZVwiLFwiZG9uZVwiLFMuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksUy5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwwLFwicmVzb2x2ZWRcIl0sW1wicmVqZWN0XCIsXCJmYWlsXCIsUy5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxTLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLDEsXCJyZWplY3RlZFwiXV0saT1cInBlbmRpbmdcIixhPXtzdGF0ZTpmdW5jdGlvbigpe3JldHVybiBpfSxhbHdheXM6ZnVuY3Rpb24oKXtyZXR1cm4gcy5kb25lKGFyZ3VtZW50cykuZmFpbChhcmd1bWVudHMpLHRoaXN9LFwiY2F0Y2hcIjpmdW5jdGlvbihlKXtyZXR1cm4gYS50aGVuKG51bGwsZSl9LHBpcGU6ZnVuY3Rpb24oKXt2YXIgaT1hcmd1bWVudHM7cmV0dXJuIFMuRGVmZXJyZWQoZnVuY3Rpb24ocil7Uy5lYWNoKG8sZnVuY3Rpb24oZSx0KXt2YXIgbj1tKGlbdFs0XV0pJiZpW3RbNF1dO3NbdFsxXV0oZnVuY3Rpb24oKXt2YXIgZT1uJiZuLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtlJiZtKGUucHJvbWlzZSk/ZS5wcm9taXNlKCkucHJvZ3Jlc3Moci5ub3RpZnkpLmRvbmUoci5yZXNvbHZlKS5mYWlsKHIucmVqZWN0KTpyW3RbMF0rXCJXaXRoXCJdKHRoaXMsbj9bZV06YXJndW1lbnRzKX0pfSksaT1udWxsfSkucHJvbWlzZSgpfSx0aGVuOmZ1bmN0aW9uKHQsbixyKXt2YXIgdT0wO2Z1bmN0aW9uIGwoaSxvLGEscyl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG49dGhpcyxyPWFyZ3VtZW50cyxlPWZ1bmN0aW9uKCl7dmFyIGUsdDtpZighKGk8dSkpe2lmKChlPWEuYXBwbHkobixyKSk9PT1vLnByb21pc2UoKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIpO3Q9ZSYmKFwib2JqZWN0XCI9PXR5cGVvZiBlfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlKSYmZS50aGVuLG0odCk/cz90LmNhbGwoZSxsKHUsbyxSLHMpLGwodSxvLE0scykpOih1KyssdC5jYWxsKGUsbCh1LG8sUixzKSxsKHUsbyxNLHMpLGwodSxvLFIsby5ub3RpZnlXaXRoKSkpOihhIT09UiYmKG49dm9pZCAwLHI9W2VdKSwoc3x8by5yZXNvbHZlV2l0aCkobixyKSl9fSx0PXM/ZTpmdW5jdGlvbigpe3RyeXtlKCl9Y2F0Y2goZSl7Uy5EZWZlcnJlZC5leGNlcHRpb25Ib29rJiZTLkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soZSx0LnN0YWNrVHJhY2UpLHU8PWkrMSYmKGEhPT1NJiYobj12b2lkIDAscj1bZV0pLG8ucmVqZWN0V2l0aChuLHIpKX19O2k/dCgpOihTLkRlZmVycmVkLmdldFN0YWNrSG9vayYmKHQuc3RhY2tUcmFjZT1TLkRlZmVycmVkLmdldFN0YWNrSG9vaygpKSxDLnNldFRpbWVvdXQodCkpfX1yZXR1cm4gUy5EZWZlcnJlZChmdW5jdGlvbihlKXtvWzBdWzNdLmFkZChsKDAsZSxtKHIpP3I6UixlLm5vdGlmeVdpdGgpKSxvWzFdWzNdLmFkZChsKDAsZSxtKHQpP3Q6UikpLG9bMl1bM10uYWRkKGwoMCxlLG0obik/bjpNKSl9KS5wcm9taXNlKCl9LHByb21pc2U6ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPWU/Uy5leHRlbmQoZSxhKTphfX0scz17fTtyZXR1cm4gUy5lYWNoKG8sZnVuY3Rpb24oZSx0KXt2YXIgbj10WzJdLHI9dFs1XTthW3RbMV1dPW4uYWRkLHImJm4uYWRkKGZ1bmN0aW9uKCl7aT1yfSxvWzMtZV1bMl0uZGlzYWJsZSxvWzMtZV1bM10uZGlzYWJsZSxvWzBdWzJdLmxvY2ssb1swXVszXS5sb2NrKSxuLmFkZCh0WzNdLmZpcmUpLHNbdFswXV09ZnVuY3Rpb24oKXtyZXR1cm4gc1t0WzBdK1wiV2l0aFwiXSh0aGlzPT09cz92b2lkIDA6dGhpcyxhcmd1bWVudHMpLHRoaXN9LHNbdFswXStcIldpdGhcIl09bi5maXJlV2l0aH0pLGEucHJvbWlzZShzKSxlJiZlLmNhbGwocyxzKSxzfSx3aGVuOmZ1bmN0aW9uKGUpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGgsdD1uLHI9QXJyYXkodCksaT1zLmNhbGwoYXJndW1lbnRzKSxvPVMuRGVmZXJyZWQoKSxhPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtyW3RdPXRoaXMsaVt0XT0xPGFyZ3VtZW50cy5sZW5ndGg/cy5jYWxsKGFyZ3VtZW50cyk6ZSwtLW58fG8ucmVzb2x2ZVdpdGgocixpKX19O2lmKG48PTEmJihJKGUsby5kb25lKGEodCkpLnJlc29sdmUsby5yZWplY3QsIW4pLFwicGVuZGluZ1wiPT09by5zdGF0ZSgpfHxtKGlbdF0mJmlbdF0udGhlbikpKXJldHVybiBvLnRoZW4oKTt3aGlsZSh0LS0pSShpW3RdLGEodCksby5yZWplY3QpO3JldHVybiBvLnByb21pc2UoKX19KTt2YXIgVz0vXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztTLkRlZmVycmVkLmV4Y2VwdGlvbkhvb2s9ZnVuY3Rpb24oZSx0KXtDLmNvbnNvbGUmJkMuY29uc29sZS53YXJuJiZlJiZXLnRlc3QoZS5uYW1lKSYmQy5jb25zb2xlLndhcm4oXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIitlLm1lc3NhZ2UsZS5zdGFjayx0KX0sUy5yZWFkeUV4Y2VwdGlvbj1mdW5jdGlvbihlKXtDLnNldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyBlfSl9O3ZhciBGPVMuRGVmZXJyZWQoKTtmdW5jdGlvbiAkKCl7RS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCQpLEMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwkKSxTLnJlYWR5KCl9Uy5mbi5yZWFkeT1mdW5jdGlvbihlKXtyZXR1cm4gRi50aGVuKGUpW1wiY2F0Y2hcIl0oZnVuY3Rpb24oZSl7Uy5yZWFkeUV4Y2VwdGlvbihlKX0pLHRoaXN9LFMuZXh0ZW5kKHtpc1JlYWR5OiExLHJlYWR5V2FpdDoxLHJlYWR5OmZ1bmN0aW9uKGUpeyghMD09PWU/LS1TLnJlYWR5V2FpdDpTLmlzUmVhZHkpfHwoUy5pc1JlYWR5PSEwKSE9PWUmJjA8LS1TLnJlYWR5V2FpdHx8Ri5yZXNvbHZlV2l0aChFLFtTXSl9fSksUy5yZWFkeS50aGVuPUYudGhlbixcImNvbXBsZXRlXCI9PT1FLnJlYWR5U3RhdGV8fFwibG9hZGluZ1wiIT09RS5yZWFkeVN0YXRlJiYhRS5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGw/Qy5zZXRUaW1lb3V0KFMucmVhZHkpOihFLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsJCksQy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCQpKTt2YXIgQj1mdW5jdGlvbihlLHQsbixyLGksbyxhKXt2YXIgcz0wLHU9ZS5sZW5ndGgsbD1udWxsPT1uO2lmKFwib2JqZWN0XCI9PT13KG4pKWZvcihzIGluIGk9ITAsbilCKGUsdCxzLG5bc10sITAsbyxhKTtlbHNlIGlmKHZvaWQgMCE9PXImJihpPSEwLG0ocil8fChhPSEwKSxsJiYoYT8odC5jYWxsKGUsciksdD1udWxsKToobD10LHQ9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBsLmNhbGwoUyhlKSxuKX0pKSx0KSlmb3IoO3M8dTtzKyspdChlW3NdLG4sYT9yOnIuY2FsbChlW3NdLHMsdChlW3NdLG4pKSk7cmV0dXJuIGk/ZTpsP3QuY2FsbChlKTp1P3QoZVswXSxuKTpvfSxfPS9eLW1zLS8sej0vLShbYS16XSkvZztmdW5jdGlvbiBVKGUsdCl7cmV0dXJuIHQudG9VcHBlckNhc2UoKX1mdW5jdGlvbiBYKGUpe3JldHVybiBlLnJlcGxhY2UoXyxcIm1zLVwiKS5yZXBsYWNlKHosVSl9dmFyIFY9ZnVuY3Rpb24oZSl7cmV0dXJuIDE9PT1lLm5vZGVUeXBlfHw5PT09ZS5ub2RlVHlwZXx8IStlLm5vZGVUeXBlfTtmdW5jdGlvbiBHKCl7dGhpcy5leHBhbmRvPVMuZXhwYW5kbytHLnVpZCsrfUcudWlkPTEsRy5wcm90b3R5cGU9e2NhY2hlOmZ1bmN0aW9uKGUpe3ZhciB0PWVbdGhpcy5leHBhbmRvXTtyZXR1cm4gdHx8KHQ9e30sVihlKSYmKGUubm9kZVR5cGU/ZVt0aGlzLmV4cGFuZG9dPXQ6T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdGhpcy5leHBhbmRvLHt2YWx1ZTp0LGNvbmZpZ3VyYWJsZTohMH0pKSksdH0sc2V0OmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpPXRoaXMuY2FjaGUoZSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpaVtYKHQpXT1uO2Vsc2UgZm9yKHIgaW4gdClpW1gocildPXRbcl07cmV0dXJuIGl9LGdldDpmdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT10P3RoaXMuY2FjaGUoZSk6ZVt0aGlzLmV4cGFuZG9dJiZlW3RoaXMuZXhwYW5kb11bWCh0KV19LGFjY2VzczpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHZvaWQgMD09PXR8fHQmJlwic3RyaW5nXCI9PXR5cGVvZiB0JiZ2b2lkIDA9PT1uP3RoaXMuZ2V0KGUsdCk6KHRoaXMuc2V0KGUsdCxuKSx2b2lkIDAhPT1uP246dCl9LHJlbW92ZTpmdW5jdGlvbihlLHQpe3ZhciBuLHI9ZVt0aGlzLmV4cGFuZG9dO2lmKHZvaWQgMCE9PXIpe2lmKHZvaWQgMCE9PXQpe249KHQ9QXJyYXkuaXNBcnJheSh0KT90Lm1hcChYKToodD1YKHQpKWluIHI/W3RdOnQubWF0Y2goUCl8fFtdKS5sZW5ndGg7d2hpbGUobi0tKWRlbGV0ZSByW3Rbbl1dfSh2b2lkIDA9PT10fHxTLmlzRW1wdHlPYmplY3QocikpJiYoZS5ub2RlVHlwZT9lW3RoaXMuZXhwYW5kb109dm9pZCAwOmRlbGV0ZSBlW3RoaXMuZXhwYW5kb10pfX0saGFzRGF0YTpmdW5jdGlvbihlKXt2YXIgdD1lW3RoaXMuZXhwYW5kb107cmV0dXJuIHZvaWQgMCE9PXQmJiFTLmlzRW1wdHlPYmplY3QodCl9fTt2YXIgWT1uZXcgRyxRPW5ldyBHLEo9L14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLEs9L1tBLVpdL2c7ZnVuY3Rpb24gWihlLHQsbil7dmFyIHIsaTtpZih2b2lkIDA9PT1uJiYxPT09ZS5ub2RlVHlwZSlpZihyPVwiZGF0YS1cIit0LnJlcGxhY2UoSyxcIi0kJlwiKS50b0xvd2VyQ2FzZSgpLFwic3RyaW5nXCI9PXR5cGVvZihuPWUuZ2V0QXR0cmlidXRlKHIpKSl7dHJ5e249XCJ0cnVlXCI9PT0oaT1uKXx8XCJmYWxzZVwiIT09aSYmKFwibnVsbFwiPT09aT9udWxsOmk9PT0raStcIlwiPytpOkoudGVzdChpKT9KU09OLnBhcnNlKGkpOmkpfWNhdGNoKGUpe31RLnNldChlLHQsbil9ZWxzZSBuPXZvaWQgMDtyZXR1cm4gbn1TLmV4dGVuZCh7aGFzRGF0YTpmdW5jdGlvbihlKXtyZXR1cm4gUS5oYXNEYXRhKGUpfHxZLmhhc0RhdGEoZSl9LGRhdGE6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBRLmFjY2VzcyhlLHQsbil9LHJlbW92ZURhdGE6ZnVuY3Rpb24oZSx0KXtRLnJlbW92ZShlLHQpfSxfZGF0YTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIFkuYWNjZXNzKGUsdCxuKX0sX3JlbW92ZURhdGE6ZnVuY3Rpb24oZSx0KXtZLnJlbW92ZShlLHQpfX0pLFMuZm4uZXh0ZW5kKHtkYXRhOmZ1bmN0aW9uKG4sZSl7dmFyIHQscixpLG89dGhpc1swXSxhPW8mJm8uYXR0cmlidXRlcztpZih2b2lkIDA9PT1uKXtpZih0aGlzLmxlbmd0aCYmKGk9US5nZXQobyksMT09PW8ubm9kZVR5cGUmJiFZLmdldChvLFwiaGFzRGF0YUF0dHJzXCIpKSl7dD1hLmxlbmd0aDt3aGlsZSh0LS0pYVt0XSYmMD09PShyPWFbdF0ubmFtZSkuaW5kZXhPZihcImRhdGEtXCIpJiYocj1YKHIuc2xpY2UoNSkpLFoobyxyLGlbcl0pKTtZLnNldChvLFwiaGFzRGF0YUF0dHJzXCIsITApfXJldHVybiBpfXJldHVyblwib2JqZWN0XCI9PXR5cGVvZiBuP3RoaXMuZWFjaChmdW5jdGlvbigpe1Euc2V0KHRoaXMsbil9KTpCKHRoaXMsZnVuY3Rpb24oZSl7dmFyIHQ7aWYobyYmdm9pZCAwPT09ZSlyZXR1cm4gdm9pZCAwIT09KHQ9US5nZXQobyxuKSk/dDp2b2lkIDAhPT0odD1aKG8sbikpP3Q6dm9pZCAwO3RoaXMuZWFjaChmdW5jdGlvbigpe1Euc2V0KHRoaXMsbixlKX0pfSxudWxsLGUsMTxhcmd1bWVudHMubGVuZ3RoLG51bGwsITApfSxyZW1vdmVEYXRhOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtRLnJlbW92ZSh0aGlzLGUpfSl9fSksUy5leHRlbmQoe3F1ZXVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcjtpZihlKXJldHVybiB0PSh0fHxcImZ4XCIpK1wicXVldWVcIixyPVkuZ2V0KGUsdCksbiYmKCFyfHxBcnJheS5pc0FycmF5KG4pP3I9WS5hY2Nlc3MoZSx0LFMubWFrZUFycmF5KG4pKTpyLnB1c2gobikpLHJ8fFtdfSxkZXF1ZXVlOmZ1bmN0aW9uKGUsdCl7dD10fHxcImZ4XCI7dmFyIG49Uy5xdWV1ZShlLHQpLHI9bi5sZW5ndGgsaT1uLnNoaWZ0KCksbz1TLl9xdWV1ZUhvb2tzKGUsdCk7XCJpbnByb2dyZXNzXCI9PT1pJiYoaT1uLnNoaWZ0KCksci0tKSxpJiYoXCJmeFwiPT09dCYmbi51bnNoaWZ0KFwiaW5wcm9ncmVzc1wiKSxkZWxldGUgby5zdG9wLGkuY2FsbChlLGZ1bmN0aW9uKCl7Uy5kZXF1ZXVlKGUsdCl9LG8pKSwhciYmbyYmby5lbXB0eS5maXJlKCl9LF9xdWV1ZUhvb2tzOmZ1bmN0aW9uKGUsdCl7dmFyIG49dCtcInF1ZXVlSG9va3NcIjtyZXR1cm4gWS5nZXQoZSxuKXx8WS5hY2Nlc3MoZSxuLHtlbXB0eTpTLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLmFkZChmdW5jdGlvbigpe1kucmVtb3ZlKGUsW3QrXCJxdWV1ZVwiLG5dKX0pfSl9fSksUy5mbi5leHRlbmQoe3F1ZXVlOmZ1bmN0aW9uKHQsbil7dmFyIGU9MjtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgdCYmKG49dCx0PVwiZnhcIixlLS0pLGFyZ3VtZW50cy5sZW5ndGg8ZT9TLnF1ZXVlKHRoaXNbMF0sdCk6dm9pZCAwPT09bj90aGlzOnRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBlPVMucXVldWUodGhpcyx0LG4pO1MuX3F1ZXVlSG9va3ModGhpcyx0KSxcImZ4XCI9PT10JiZcImlucHJvZ3Jlc3NcIiE9PWVbMF0mJlMuZGVxdWV1ZSh0aGlzLHQpfSl9LGRlcXVldWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1MuZGVxdWV1ZSh0aGlzLGUpfSl9LGNsZWFyUXVldWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucXVldWUoZXx8XCJmeFwiLFtdKX0scHJvbWlzZTpmdW5jdGlvbihlLHQpe3ZhciBuLHI9MSxpPVMuRGVmZXJyZWQoKSxvPXRoaXMsYT10aGlzLmxlbmd0aCxzPWZ1bmN0aW9uKCl7LS1yfHxpLnJlc29sdmVXaXRoKG8sW29dKX07XCJzdHJpbmdcIiE9dHlwZW9mIGUmJih0PWUsZT12b2lkIDApLGU9ZXx8XCJmeFwiO3doaWxlKGEtLSkobj1ZLmdldChvW2FdLGUrXCJxdWV1ZUhvb2tzXCIpKSYmbi5lbXB0eSYmKHIrKyxuLmVtcHR5LmFkZChzKSk7cmV0dXJuIHMoKSxpLnByb21pc2UodCl9fSk7dmFyIGVlPS9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvLnNvdXJjZSx0ZT1uZXcgUmVnRXhwKFwiXig/OihbKy1dKT18KShcIitlZStcIikoW2EteiVdKikkXCIsXCJpXCIpLG5lPVtcIlRvcFwiLFwiUmlnaHRcIixcIkJvdHRvbVwiLFwiTGVmdFwiXSxyZT1FLmRvY3VtZW50RWxlbWVudCxpZT1mdW5jdGlvbihlKXtyZXR1cm4gUy5jb250YWlucyhlLm93bmVyRG9jdW1lbnQsZSl9LG9lPXtjb21wb3NlZDohMH07cmUuZ2V0Um9vdE5vZGUmJihpZT1mdW5jdGlvbihlKXtyZXR1cm4gUy5jb250YWlucyhlLm93bmVyRG9jdW1lbnQsZSl8fGUuZ2V0Um9vdE5vZGUob2UpPT09ZS5vd25lckRvY3VtZW50fSk7dmFyIGFlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJub25lXCI9PT0oZT10fHxlKS5zdHlsZS5kaXNwbGF5fHxcIlwiPT09ZS5zdHlsZS5kaXNwbGF5JiZpZShlKSYmXCJub25lXCI9PT1TLmNzcyhlLFwiZGlzcGxheVwiKX07ZnVuY3Rpb24gc2UoZSx0LG4scil7dmFyIGksbyxhPTIwLHM9cj9mdW5jdGlvbigpe3JldHVybiByLmN1cigpfTpmdW5jdGlvbigpe3JldHVybiBTLmNzcyhlLHQsXCJcIil9LHU9cygpLGw9biYmblszXXx8KFMuY3NzTnVtYmVyW3RdP1wiXCI6XCJweFwiKSxjPWUubm9kZVR5cGUmJihTLmNzc051bWJlclt0XXx8XCJweFwiIT09bCYmK3UpJiZ0ZS5leGVjKFMuY3NzKGUsdCkpO2lmKGMmJmNbM10hPT1sKXt1Lz0yLGw9bHx8Y1szXSxjPSt1fHwxO3doaWxlKGEtLSlTLnN0eWxlKGUsdCxjK2wpLCgxLW8pKigxLShvPXMoKS91fHwuNSkpPD0wJiYoYT0wKSxjLz1vO2MqPTIsUy5zdHlsZShlLHQsYytsKSxuPW58fFtdfXJldHVybiBuJiYoYz0rY3x8K3V8fDAsaT1uWzFdP2MrKG5bMV0rMSkqblsyXTorblsyXSxyJiYoci51bml0PWwsci5zdGFydD1jLHIuZW5kPWkpKSxpfXZhciB1ZT17fTtmdW5jdGlvbiBsZShlLHQpe2Zvcih2YXIgbixyLGksbyxhLHMsdSxsPVtdLGM9MCxmPWUubGVuZ3RoO2M8ZjtjKyspKHI9ZVtjXSkuc3R5bGUmJihuPXIuc3R5bGUuZGlzcGxheSx0PyhcIm5vbmVcIj09PW4mJihsW2NdPVkuZ2V0KHIsXCJkaXNwbGF5XCIpfHxudWxsLGxbY118fChyLnN0eWxlLmRpc3BsYXk9XCJcIikpLFwiXCI9PT1yLnN0eWxlLmRpc3BsYXkmJmFlKHIpJiYobFtjXT0odT1hPW89dm9pZCAwLGE9KGk9cikub3duZXJEb2N1bWVudCxzPWkubm9kZU5hbWUsKHU9dWVbc10pfHwobz1hLmJvZHkuYXBwZW5kQ2hpbGQoYS5jcmVhdGVFbGVtZW50KHMpKSx1PVMuY3NzKG8sXCJkaXNwbGF5XCIpLG8ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvKSxcIm5vbmVcIj09PXUmJih1PVwiYmxvY2tcIiksdWVbc109dSkpKSk6XCJub25lXCIhPT1uJiYobFtjXT1cIm5vbmVcIixZLnNldChyLFwiZGlzcGxheVwiLG4pKSk7Zm9yKGM9MDtjPGY7YysrKW51bGwhPWxbY10mJihlW2NdLnN0eWxlLmRpc3BsYXk9bFtjXSk7cmV0dXJuIGV9Uy5mbi5leHRlbmQoe3Nob3c6ZnVuY3Rpb24oKXtyZXR1cm4gbGUodGhpcywhMCl9LGhpZGU6ZnVuY3Rpb24oKXtyZXR1cm4gbGUodGhpcyl9LHRvZ2dsZTpmdW5jdGlvbihlKXtyZXR1cm5cImJvb2xlYW5cIj09dHlwZW9mIGU/ZT90aGlzLnNob3coKTp0aGlzLmhpZGUoKTp0aGlzLmVhY2goZnVuY3Rpb24oKXthZSh0aGlzKT9TKHRoaXMpLnNob3coKTpTKHRoaXMpLmhpZGUoKX0pfX0pO3ZhciBjZSxmZSxwZT0vXig/OmNoZWNrYm94fHJhZGlvKSQvaSxkZT0vPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopL2ksaGU9L14kfF5tb2R1bGUkfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaTtjZT1FLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKS5hcHBlbmRDaGlsZChFLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLChmZT1FLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSkuc2V0QXR0cmlidXRlKFwidHlwZVwiLFwicmFkaW9cIiksZmUuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLFwiY2hlY2tlZFwiKSxmZS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsXCJ0XCIpLGNlLmFwcGVuZENoaWxkKGZlKSx2LmNoZWNrQ2xvbmU9Y2UuY2xvbmVOb2RlKCEwKS5jbG9uZU5vZGUoITApLmxhc3RDaGlsZC5jaGVja2VkLGNlLmlubmVySFRNTD1cIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIix2Lm5vQ2xvbmVDaGVja2VkPSEhY2UuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlLGNlLmlubmVySFRNTD1cIjxvcHRpb24+PC9vcHRpb24+XCIsdi5vcHRpb249ISFjZS5sYXN0Q2hpbGQ7dmFyIGdlPXt0aGVhZDpbMSxcIjx0YWJsZT5cIixcIjwvdGFibGU+XCJdLGNvbDpbMixcIjx0YWJsZT48Y29sZ3JvdXA+XCIsXCI8L2NvbGdyb3VwPjwvdGFibGU+XCJdLHRyOlsyLFwiPHRhYmxlPjx0Ym9keT5cIixcIjwvdGJvZHk+PC90YWJsZT5cIl0sdGQ6WzMsXCI8dGFibGU+PHRib2R5Pjx0cj5cIixcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiXSxfZGVmYXVsdDpbMCxcIlwiLFwiXCJdfTtmdW5jdGlvbiB5ZShlLHQpe3ZhciBuO3JldHVybiBuPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBlLmdldEVsZW1lbnRzQnlUYWdOYW1lP2UuZ2V0RWxlbWVudHNCeVRhZ05hbWUodHx8XCIqXCIpOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBlLnF1ZXJ5U2VsZWN0b3JBbGw/ZS5xdWVyeVNlbGVjdG9yQWxsKHR8fFwiKlwiKTpbXSx2b2lkIDA9PT10fHx0JiZBKGUsdCk/Uy5tZXJnZShbZV0sbik6bn1mdW5jdGlvbiB2ZShlLHQpe2Zvcih2YXIgbj0wLHI9ZS5sZW5ndGg7bjxyO24rKylZLnNldChlW25dLFwiZ2xvYmFsRXZhbFwiLCF0fHxZLmdldCh0W25dLFwiZ2xvYmFsRXZhbFwiKSl9Z2UudGJvZHk9Z2UudGZvb3Q9Z2UuY29sZ3JvdXA9Z2UuY2FwdGlvbj1nZS50aGVhZCxnZS50aD1nZS50ZCx2Lm9wdGlvbnx8KGdlLm9wdGdyb3VwPWdlLm9wdGlvbj1bMSxcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIixcIjwvc2VsZWN0PlwiXSk7dmFyIG1lPS88fCYjP1xcdys7LztmdW5jdGlvbiB4ZShlLHQsbixyLGkpe2Zvcih2YXIgbyxhLHMsdSxsLGMsZj10LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxwPVtdLGQ9MCxoPWUubGVuZ3RoO2Q8aDtkKyspaWYoKG89ZVtkXSl8fDA9PT1vKWlmKFwib2JqZWN0XCI9PT13KG8pKVMubWVyZ2UocCxvLm5vZGVUeXBlP1tvXTpvKTtlbHNlIGlmKG1lLnRlc3Qobykpe2E9YXx8Zi5hcHBlbmRDaGlsZCh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLHM9KGRlLmV4ZWMobyl8fFtcIlwiLFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpLHU9Z2Vbc118fGdlLl9kZWZhdWx0LGEuaW5uZXJIVE1MPXVbMV0rUy5odG1sUHJlZmlsdGVyKG8pK3VbMl0sYz11WzBdO3doaWxlKGMtLSlhPWEubGFzdENoaWxkO1MubWVyZ2UocCxhLmNoaWxkTm9kZXMpLChhPWYuZmlyc3RDaGlsZCkudGV4dENvbnRlbnQ9XCJcIn1lbHNlIHAucHVzaCh0LmNyZWF0ZVRleHROb2RlKG8pKTtmLnRleHRDb250ZW50PVwiXCIsZD0wO3doaWxlKG89cFtkKytdKWlmKHImJi0xPFMuaW5BcnJheShvLHIpKWkmJmkucHVzaChvKTtlbHNlIGlmKGw9aWUobyksYT15ZShmLmFwcGVuZENoaWxkKG8pLFwic2NyaXB0XCIpLGwmJnZlKGEpLG4pe2M9MDt3aGlsZShvPWFbYysrXSloZS50ZXN0KG8udHlwZXx8XCJcIikmJm4ucHVzaChvKX1yZXR1cm4gZn12YXIgYmU9L14oW14uXSopKD86XFwuKC4rKXwpLztmdW5jdGlvbiB3ZSgpe3JldHVybiEwfWZ1bmN0aW9uIFRlKCl7cmV0dXJuITF9ZnVuY3Rpb24gQ2UoZSx0KXtyZXR1cm4gZT09PWZ1bmN0aW9uKCl7dHJ5e3JldHVybiBFLmFjdGl2ZUVsZW1lbnR9Y2F0Y2goZSl7fX0oKT09KFwiZm9jdXNcIj09PXQpfWZ1bmN0aW9uIEVlKGUsdCxuLHIsaSxvKXt2YXIgYSxzO2lmKFwib2JqZWN0XCI9PXR5cGVvZiB0KXtmb3IocyBpblwic3RyaW5nXCIhPXR5cGVvZiBuJiYocj1yfHxuLG49dm9pZCAwKSx0KUVlKGUscyxuLHIsdFtzXSxvKTtyZXR1cm4gZX1pZihudWxsPT1yJiZudWxsPT1pPyhpPW4scj1uPXZvaWQgMCk6bnVsbD09aSYmKFwic3RyaW5nXCI9PXR5cGVvZiBuPyhpPXIscj12b2lkIDApOihpPXIscj1uLG49dm9pZCAwKSksITE9PT1pKWk9VGU7ZWxzZSBpZighaSlyZXR1cm4gZTtyZXR1cm4gMT09PW8mJihhPWksKGk9ZnVuY3Rpb24oZSl7cmV0dXJuIFMoKS5vZmYoZSksYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KS5ndWlkPWEuZ3VpZHx8KGEuZ3VpZD1TLmd1aWQrKykpLGUuZWFjaChmdW5jdGlvbigpe1MuZXZlbnQuYWRkKHRoaXMsdCxpLHIsbil9KX1mdW5jdGlvbiBTZShlLGksbyl7bz8oWS5zZXQoZSxpLCExKSxTLmV2ZW50LmFkZChlLGkse25hbWVzcGFjZTohMSxoYW5kbGVyOmZ1bmN0aW9uKGUpe3ZhciB0LG4scj1ZLmdldCh0aGlzLGkpO2lmKDEmZS5pc1RyaWdnZXImJnRoaXNbaV0pe2lmKHIubGVuZ3RoKShTLmV2ZW50LnNwZWNpYWxbaV18fHt9KS5kZWxlZ2F0ZVR5cGUmJmUuc3RvcFByb3BhZ2F0aW9uKCk7ZWxzZSBpZihyPXMuY2FsbChhcmd1bWVudHMpLFkuc2V0KHRoaXMsaSxyKSx0PW8odGhpcyxpKSx0aGlzW2ldKCksciE9PShuPVkuZ2V0KHRoaXMsaSkpfHx0P1kuc2V0KHRoaXMsaSwhMSk6bj17fSxyIT09bilyZXR1cm4gZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSxlLnByZXZlbnREZWZhdWx0KCksbiYmbi52YWx1ZX1lbHNlIHIubGVuZ3RoJiYoWS5zZXQodGhpcyxpLHt2YWx1ZTpTLmV2ZW50LnRyaWdnZXIoUy5leHRlbmQoclswXSxTLkV2ZW50LnByb3RvdHlwZSksci5zbGljZSgxKSx0aGlzKX0pLGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkpfX0pKTp2b2lkIDA9PT1ZLmdldChlLGkpJiZTLmV2ZW50LmFkZChlLGksd2UpfVMuZXZlbnQ9e2dsb2JhbDp7fSxhZGQ6ZnVuY3Rpb24odCxlLG4scixpKXt2YXIgbyxhLHMsdSxsLGMsZixwLGQsaCxnLHk9WS5nZXQodCk7aWYoVih0KSl7bi5oYW5kbGVyJiYobj0obz1uKS5oYW5kbGVyLGk9by5zZWxlY3RvciksaSYmUy5maW5kLm1hdGNoZXNTZWxlY3RvcihyZSxpKSxuLmd1aWR8fChuLmd1aWQ9Uy5ndWlkKyspLCh1PXkuZXZlbnRzKXx8KHU9eS5ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSksKGE9eS5oYW5kbGUpfHwoYT15LmhhbmRsZT1mdW5jdGlvbihlKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgUyYmUy5ldmVudC50cmlnZ2VyZWQhPT1lLnR5cGU/Uy5ldmVudC5kaXNwYXRjaC5hcHBseSh0LGFyZ3VtZW50cyk6dm9pZCAwfSksbD0oZT0oZXx8XCJcIikubWF0Y2goUCl8fFtcIlwiXSkubGVuZ3RoO3doaWxlKGwtLSlkPWc9KHM9YmUuZXhlYyhlW2xdKXx8W10pWzFdLGg9KHNbMl18fFwiXCIpLnNwbGl0KFwiLlwiKS5zb3J0KCksZCYmKGY9Uy5ldmVudC5zcGVjaWFsW2RdfHx7fSxkPShpP2YuZGVsZWdhdGVUeXBlOmYuYmluZFR5cGUpfHxkLGY9Uy5ldmVudC5zcGVjaWFsW2RdfHx7fSxjPVMuZXh0ZW5kKHt0eXBlOmQsb3JpZ1R5cGU6ZyxkYXRhOnIsaGFuZGxlcjpuLGd1aWQ6bi5ndWlkLHNlbGVjdG9yOmksbmVlZHNDb250ZXh0OmkmJlMuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdChpKSxuYW1lc3BhY2U6aC5qb2luKFwiLlwiKX0sbyksKHA9dVtkXSl8fCgocD11W2RdPVtdKS5kZWxlZ2F0ZUNvdW50PTAsZi5zZXR1cCYmITEhPT1mLnNldHVwLmNhbGwodCxyLGgsYSl8fHQuYWRkRXZlbnRMaXN0ZW5lciYmdC5hZGRFdmVudExpc3RlbmVyKGQsYSkpLGYuYWRkJiYoZi5hZGQuY2FsbCh0LGMpLGMuaGFuZGxlci5ndWlkfHwoYy5oYW5kbGVyLmd1aWQ9bi5ndWlkKSksaT9wLnNwbGljZShwLmRlbGVnYXRlQ291bnQrKywwLGMpOnAucHVzaChjKSxTLmV2ZW50Lmdsb2JhbFtkXT0hMCl9fSxyZW1vdmU6ZnVuY3Rpb24oZSx0LG4scixpKXt2YXIgbyxhLHMsdSxsLGMsZixwLGQsaCxnLHk9WS5oYXNEYXRhKGUpJiZZLmdldChlKTtpZih5JiYodT15LmV2ZW50cykpe2w9KHQ9KHR8fFwiXCIpLm1hdGNoKFApfHxbXCJcIl0pLmxlbmd0aDt3aGlsZShsLS0paWYoZD1nPShzPWJlLmV4ZWModFtsXSl8fFtdKVsxXSxoPShzWzJdfHxcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLGQpe2Y9Uy5ldmVudC5zcGVjaWFsW2RdfHx7fSxwPXVbZD0ocj9mLmRlbGVnYXRlVHlwZTpmLmJpbmRUeXBlKXx8ZF18fFtdLHM9c1syXSYmbmV3IFJlZ0V4cChcIihefFxcXFwuKVwiK2guam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpK1wiKFxcXFwufCQpXCIpLGE9bz1wLmxlbmd0aDt3aGlsZShvLS0pYz1wW29dLCFpJiZnIT09Yy5vcmlnVHlwZXx8biYmbi5ndWlkIT09Yy5ndWlkfHxzJiYhcy50ZXN0KGMubmFtZXNwYWNlKXx8ciYmciE9PWMuc2VsZWN0b3ImJihcIioqXCIhPT1yfHwhYy5zZWxlY3Rvcil8fChwLnNwbGljZShvLDEpLGMuc2VsZWN0b3ImJnAuZGVsZWdhdGVDb3VudC0tLGYucmVtb3ZlJiZmLnJlbW92ZS5jYWxsKGUsYykpO2EmJiFwLmxlbmd0aCYmKGYudGVhcmRvd24mJiExIT09Zi50ZWFyZG93bi5jYWxsKGUsaCx5LmhhbmRsZSl8fFMucmVtb3ZlRXZlbnQoZSxkLHkuaGFuZGxlKSxkZWxldGUgdVtkXSl9ZWxzZSBmb3IoZCBpbiB1KVMuZXZlbnQucmVtb3ZlKGUsZCt0W2xdLG4sciwhMCk7Uy5pc0VtcHR5T2JqZWN0KHUpJiZZLnJlbW92ZShlLFwiaGFuZGxlIGV2ZW50c1wiKX19LGRpc3BhdGNoOmZ1bmN0aW9uKGUpe3ZhciB0LG4scixpLG8sYSxzPW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKSx1PVMuZXZlbnQuZml4KGUpLGw9KFkuZ2V0KHRoaXMsXCJldmVudHNcIil8fE9iamVjdC5jcmVhdGUobnVsbCkpW3UudHlwZV18fFtdLGM9Uy5ldmVudC5zcGVjaWFsW3UudHlwZV18fHt9O2ZvcihzWzBdPXUsdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspc1t0XT1hcmd1bWVudHNbdF07aWYodS5kZWxlZ2F0ZVRhcmdldD10aGlzLCFjLnByZURpc3BhdGNofHwhMSE9PWMucHJlRGlzcGF0Y2guY2FsbCh0aGlzLHUpKXthPVMuZXZlbnQuaGFuZGxlcnMuY2FsbCh0aGlzLHUsbCksdD0wO3doaWxlKChpPWFbdCsrXSkmJiF1LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpe3UuY3VycmVudFRhcmdldD1pLmVsZW0sbj0wO3doaWxlKChvPWkuaGFuZGxlcnNbbisrXSkmJiF1LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpdS5ybmFtZXNwYWNlJiYhMSE9PW8ubmFtZXNwYWNlJiYhdS5ybmFtZXNwYWNlLnRlc3Qoby5uYW1lc3BhY2UpfHwodS5oYW5kbGVPYmo9byx1LmRhdGE9by5kYXRhLHZvaWQgMCE9PShyPSgoUy5ldmVudC5zcGVjaWFsW28ub3JpZ1R5cGVdfHx7fSkuaGFuZGxlfHxvLmhhbmRsZXIpLmFwcGx5KGkuZWxlbSxzKSkmJiExPT09KHUucmVzdWx0PXIpJiYodS5wcmV2ZW50RGVmYXVsdCgpLHUuc3RvcFByb3BhZ2F0aW9uKCkpKX1yZXR1cm4gYy5wb3N0RGlzcGF0Y2gmJmMucG9zdERpc3BhdGNoLmNhbGwodGhpcyx1KSx1LnJlc3VsdH19LGhhbmRsZXJzOmZ1bmN0aW9uKGUsdCl7dmFyIG4scixpLG8sYSxzPVtdLHU9dC5kZWxlZ2F0ZUNvdW50LGw9ZS50YXJnZXQ7aWYodSYmbC5ub2RlVHlwZSYmIShcImNsaWNrXCI9PT1lLnR5cGUmJjE8PWUuYnV0dG9uKSlmb3IoO2whPT10aGlzO2w9bC5wYXJlbnROb2RlfHx0aGlzKWlmKDE9PT1sLm5vZGVUeXBlJiYoXCJjbGlja1wiIT09ZS50eXBlfHwhMCE9PWwuZGlzYWJsZWQpKXtmb3Iobz1bXSxhPXt9LG49MDtuPHU7bisrKXZvaWQgMD09PWFbaT0ocj10W25dKS5zZWxlY3RvcitcIiBcIl0mJihhW2ldPXIubmVlZHNDb250ZXh0Py0xPFMoaSx0aGlzKS5pbmRleChsKTpTLmZpbmQoaSx0aGlzLG51bGwsW2xdKS5sZW5ndGgpLGFbaV0mJm8ucHVzaChyKTtvLmxlbmd0aCYmcy5wdXNoKHtlbGVtOmwsaGFuZGxlcnM6b30pfXJldHVybiBsPXRoaXMsdTx0Lmxlbmd0aCYmcy5wdXNoKHtlbGVtOmwsaGFuZGxlcnM6dC5zbGljZSh1KX0pLHN9LGFkZFByb3A6ZnVuY3Rpb24odCxlKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoUy5FdmVudC5wcm90b3R5cGUsdCx7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0Om0oZSk/ZnVuY3Rpb24oKXtpZih0aGlzLm9yaWdpbmFsRXZlbnQpcmV0dXJuIGUodGhpcy5vcmlnaW5hbEV2ZW50KX06ZnVuY3Rpb24oKXtpZih0aGlzLm9yaWdpbmFsRXZlbnQpcmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFt0XX0sc2V0OmZ1bmN0aW9uKGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLHQse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmV9KX19KX0sZml4OmZ1bmN0aW9uKGUpe3JldHVybiBlW1MuZXhwYW5kb10/ZTpuZXcgUy5FdmVudChlKX0sc3BlY2lhbDp7bG9hZDp7bm9CdWJibGU6ITB9LGNsaWNrOntzZXR1cDpmdW5jdGlvbihlKXt2YXIgdD10aGlzfHxlO3JldHVybiBwZS50ZXN0KHQudHlwZSkmJnQuY2xpY2smJkEodCxcImlucHV0XCIpJiZTZSh0LFwiY2xpY2tcIix3ZSksITF9LHRyaWdnZXI6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpc3x8ZTtyZXR1cm4gcGUudGVzdCh0LnR5cGUpJiZ0LmNsaWNrJiZBKHQsXCJpbnB1dFwiKSYmU2UodCxcImNsaWNrXCIpLCEwfSxfZGVmYXVsdDpmdW5jdGlvbihlKXt2YXIgdD1lLnRhcmdldDtyZXR1cm4gcGUudGVzdCh0LnR5cGUpJiZ0LmNsaWNrJiZBKHQsXCJpbnB1dFwiKSYmWS5nZXQodCxcImNsaWNrXCIpfHxBKHQsXCJhXCIpfX0sYmVmb3JldW5sb2FkOntwb3N0RGlzcGF0Y2g6ZnVuY3Rpb24oZSl7dm9pZCAwIT09ZS5yZXN1bHQmJmUub3JpZ2luYWxFdmVudCYmKGUub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZT1lLnJlc3VsdCl9fX19LFMucmVtb3ZlRXZlbnQ9ZnVuY3Rpb24oZSx0LG4pe2UucmVtb3ZlRXZlbnRMaXN0ZW5lciYmZS5yZW1vdmVFdmVudExpc3RlbmVyKHQsbil9LFMuRXZlbnQ9ZnVuY3Rpb24oZSx0KXtpZighKHRoaXMgaW5zdGFuY2VvZiBTLkV2ZW50KSlyZXR1cm4gbmV3IFMuRXZlbnQoZSx0KTtlJiZlLnR5cGU/KHRoaXMub3JpZ2luYWxFdmVudD1lLHRoaXMudHlwZT1lLnR5cGUsdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9ZS5kZWZhdWx0UHJldmVudGVkfHx2b2lkIDA9PT1lLmRlZmF1bHRQcmV2ZW50ZWQmJiExPT09ZS5yZXR1cm5WYWx1ZT93ZTpUZSx0aGlzLnRhcmdldD1lLnRhcmdldCYmMz09PWUudGFyZ2V0Lm5vZGVUeXBlP2UudGFyZ2V0LnBhcmVudE5vZGU6ZS50YXJnZXQsdGhpcy5jdXJyZW50VGFyZ2V0PWUuY3VycmVudFRhcmdldCx0aGlzLnJlbGF0ZWRUYXJnZXQ9ZS5yZWxhdGVkVGFyZ2V0KTp0aGlzLnR5cGU9ZSx0JiZTLmV4dGVuZCh0aGlzLHQpLHRoaXMudGltZVN0YW1wPWUmJmUudGltZVN0YW1wfHxEYXRlLm5vdygpLHRoaXNbUy5leHBhbmRvXT0hMH0sUy5FdmVudC5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlMuRXZlbnQsaXNEZWZhdWx0UHJldmVudGVkOlRlLGlzUHJvcGFnYXRpb25TdG9wcGVkOlRlLGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOlRlLGlzU2ltdWxhdGVkOiExLHByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5vcmlnaW5hbEV2ZW50O3RoaXMuaXNEZWZhdWx0UHJldmVudGVkPXdlLGUmJiF0aGlzLmlzU2ltdWxhdGVkJiZlLnByZXZlbnREZWZhdWx0KCl9LHN0b3BQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3ZhciBlPXRoaXMub3JpZ2luYWxFdmVudDt0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPXdlLGUmJiF0aGlzLmlzU2ltdWxhdGVkJiZlLnN0b3BQcm9wYWdhdGlvbigpfSxzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm9yaWdpbmFsRXZlbnQ7dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZD13ZSxlJiYhdGhpcy5pc1NpbXVsYXRlZCYmZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSx0aGlzLnN0b3BQcm9wYWdhdGlvbigpfX0sUy5lYWNoKHthbHRLZXk6ITAsYnViYmxlczohMCxjYW5jZWxhYmxlOiEwLGNoYW5nZWRUb3VjaGVzOiEwLGN0cmxLZXk6ITAsZGV0YWlsOiEwLGV2ZW50UGhhc2U6ITAsbWV0YUtleTohMCxwYWdlWDohMCxwYWdlWTohMCxzaGlmdEtleTohMCx2aWV3OiEwLFwiY2hhclwiOiEwLGNvZGU6ITAsY2hhckNvZGU6ITAsa2V5OiEwLGtleUNvZGU6ITAsYnV0dG9uOiEwLGJ1dHRvbnM6ITAsY2xpZW50WDohMCxjbGllbnRZOiEwLG9mZnNldFg6ITAsb2Zmc2V0WTohMCxwb2ludGVySWQ6ITAscG9pbnRlclR5cGU6ITAsc2NyZWVuWDohMCxzY3JlZW5ZOiEwLHRhcmdldFRvdWNoZXM6ITAsdG9FbGVtZW50OiEwLHRvdWNoZXM6ITAsd2hpY2g6ITB9LFMuZXZlbnQuYWRkUHJvcCksUy5lYWNoKHtmb2N1czpcImZvY3VzaW5cIixibHVyOlwiZm9jdXNvdXRcIn0sZnVuY3Rpb24odCxlKXtTLmV2ZW50LnNwZWNpYWxbdF09e3NldHVwOmZ1bmN0aW9uKCl7cmV0dXJuIFNlKHRoaXMsdCxDZSksITF9LHRyaWdnZXI6ZnVuY3Rpb24oKXtyZXR1cm4gU2UodGhpcyx0KSwhMH0sX2RlZmF1bHQ6ZnVuY3Rpb24oZSl7cmV0dXJuIFkuZ2V0KGUudGFyZ2V0LHQpfSxkZWxlZ2F0ZVR5cGU6ZX19KSxTLmVhY2goe21vdXNlZW50ZXI6XCJtb3VzZW92ZXJcIixtb3VzZWxlYXZlOlwibW91c2VvdXRcIixwb2ludGVyZW50ZXI6XCJwb2ludGVyb3ZlclwiLHBvaW50ZXJsZWF2ZTpcInBvaW50ZXJvdXRcIn0sZnVuY3Rpb24oZSxpKXtTLmV2ZW50LnNwZWNpYWxbZV09e2RlbGVnYXRlVHlwZTppLGJpbmRUeXBlOmksaGFuZGxlOmZ1bmN0aW9uKGUpe3ZhciB0LG49ZS5yZWxhdGVkVGFyZ2V0LHI9ZS5oYW5kbGVPYmo7cmV0dXJuIG4mJihuPT09dGhpc3x8Uy5jb250YWlucyh0aGlzLG4pKXx8KGUudHlwZT1yLm9yaWdUeXBlLHQ9ci5oYW5kbGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxlLnR5cGU9aSksdH19fSksUy5mbi5leHRlbmQoe29uOmZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiBFZSh0aGlzLGUsdCxuLHIpfSxvbmU6ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIEVlKHRoaXMsZSx0LG4sciwxKX0sb2ZmOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpO2lmKGUmJmUucHJldmVudERlZmF1bHQmJmUuaGFuZGxlT2JqKXJldHVybiByPWUuaGFuZGxlT2JqLFMoZS5kZWxlZ2F0ZVRhcmdldCkub2ZmKHIubmFtZXNwYWNlP3Iub3JpZ1R5cGUrXCIuXCIrci5uYW1lc3BhY2U6ci5vcmlnVHlwZSxyLnNlbGVjdG9yLHIuaGFuZGxlciksdGhpcztpZihcIm9iamVjdFwiPT10eXBlb2YgZSl7Zm9yKGkgaW4gZSl0aGlzLm9mZihpLHQsZVtpXSk7cmV0dXJuIHRoaXN9cmV0dXJuITEhPT10JiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0fHwobj10LHQ9dm9pZCAwKSwhMT09PW4mJihuPVRlKSx0aGlzLmVhY2goZnVuY3Rpb24oKXtTLmV2ZW50LnJlbW92ZSh0aGlzLGUsbix0KX0pfX0pO3ZhciBrZT0vPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxBZT0vY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLE5lPS9eXFxzKjwhXFxbQ0RBVEFcXFt8XFxdXFxdPlxccyokL2c7ZnVuY3Rpb24gamUoZSx0KXtyZXR1cm4gQShlLFwidGFibGVcIikmJkEoMTEhPT10Lm5vZGVUeXBlP3Q6dC5maXJzdENoaWxkLFwidHJcIikmJlMoZSkuY2hpbGRyZW4oXCJ0Ym9keVwiKVswXXx8ZX1mdW5jdGlvbiBEZShlKXtyZXR1cm4gZS50eXBlPShudWxsIT09ZS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKStcIi9cIitlLnR5cGUsZX1mdW5jdGlvbiBxZShlKXtyZXR1cm5cInRydWUvXCI9PT0oZS50eXBlfHxcIlwiKS5zbGljZSgwLDUpP2UudHlwZT1lLnR5cGUuc2xpY2UoNSk6ZS5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpLGV9ZnVuY3Rpb24gTGUoZSx0KXt2YXIgbixyLGksbyxhLHM7aWYoMT09PXQubm9kZVR5cGUpe2lmKFkuaGFzRGF0YShlKSYmKHM9WS5nZXQoZSkuZXZlbnRzKSlmb3IoaSBpbiBZLnJlbW92ZSh0LFwiaGFuZGxlIGV2ZW50c1wiKSxzKWZvcihuPTAscj1zW2ldLmxlbmd0aDtuPHI7bisrKVMuZXZlbnQuYWRkKHQsaSxzW2ldW25dKTtRLmhhc0RhdGEoZSkmJihvPVEuYWNjZXNzKGUpLGE9Uy5leHRlbmQoe30sbyksUS5zZXQodCxhKSl9fWZ1bmN0aW9uIEhlKG4scixpLG8pe3I9ZyhyKTt2YXIgZSx0LGEscyx1LGwsYz0wLGY9bi5sZW5ndGgscD1mLTEsZD1yWzBdLGg9bShkKTtpZihofHwxPGYmJlwic3RyaW5nXCI9PXR5cGVvZiBkJiYhdi5jaGVja0Nsb25lJiZBZS50ZXN0KGQpKXJldHVybiBuLmVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9bi5lcShlKTtoJiYoclswXT1kLmNhbGwodGhpcyxlLHQuaHRtbCgpKSksSGUodCxyLGksbyl9KTtpZihmJiYodD0oZT14ZShyLG5bMF0ub3duZXJEb2N1bWVudCwhMSxuLG8pKS5maXJzdENoaWxkLDE9PT1lLmNoaWxkTm9kZXMubGVuZ3RoJiYoZT10KSx0fHxvKSl7Zm9yKHM9KGE9Uy5tYXAoeWUoZSxcInNjcmlwdFwiKSxEZSkpLmxlbmd0aDtjPGY7YysrKXU9ZSxjIT09cCYmKHU9Uy5jbG9uZSh1LCEwLCEwKSxzJiZTLm1lcmdlKGEseWUodSxcInNjcmlwdFwiKSkpLGkuY2FsbChuW2NdLHUsYyk7aWYocylmb3IobD1hW2EubGVuZ3RoLTFdLm93bmVyRG9jdW1lbnQsUy5tYXAoYSxxZSksYz0wO2M8cztjKyspdT1hW2NdLGhlLnRlc3QodS50eXBlfHxcIlwiKSYmIVkuYWNjZXNzKHUsXCJnbG9iYWxFdmFsXCIpJiZTLmNvbnRhaW5zKGwsdSkmJih1LnNyYyYmXCJtb2R1bGVcIiE9PSh1LnR5cGV8fFwiXCIpLnRvTG93ZXJDYXNlKCk/Uy5fZXZhbFVybCYmIXUubm9Nb2R1bGUmJlMuX2V2YWxVcmwodS5zcmMse25vbmNlOnUubm9uY2V8fHUuZ2V0QXR0cmlidXRlKFwibm9uY2VcIil9LGwpOmIodS50ZXh0Q29udGVudC5yZXBsYWNlKE5lLFwiXCIpLHUsbCkpfXJldHVybiBufWZ1bmN0aW9uIE9lKGUsdCxuKXtmb3IodmFyIHIsaT10P1MuZmlsdGVyKHQsZSk6ZSxvPTA7bnVsbCE9KHI9aVtvXSk7bysrKW58fDEhPT1yLm5vZGVUeXBlfHxTLmNsZWFuRGF0YSh5ZShyKSksci5wYXJlbnROb2RlJiYobiYmaWUocikmJnZlKHllKHIsXCJzY3JpcHRcIikpLHIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyKSk7cmV0dXJuIGV9Uy5leHRlbmQoe2h0bWxQcmVmaWx0ZXI6ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LGNsb25lOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG8sYSxzLHUsbCxjPWUuY2xvbmVOb2RlKCEwKSxmPWllKGUpO2lmKCEodi5ub0Nsb25lQ2hlY2tlZHx8MSE9PWUubm9kZVR5cGUmJjExIT09ZS5ub2RlVHlwZXx8Uy5pc1hNTERvYyhlKSkpZm9yKGE9eWUoYykscj0wLGk9KG89eWUoZSkpLmxlbmd0aDtyPGk7cisrKXM9b1tyXSx1PWFbcl0sdm9pZCAwLFwiaW5wdXRcIj09PShsPXUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkmJnBlLnRlc3Qocy50eXBlKT91LmNoZWNrZWQ9cy5jaGVja2VkOlwiaW5wdXRcIiE9PWwmJlwidGV4dGFyZWFcIiE9PWx8fCh1LmRlZmF1bHRWYWx1ZT1zLmRlZmF1bHRWYWx1ZSk7aWYodClpZihuKWZvcihvPW98fHllKGUpLGE9YXx8eWUoYykscj0wLGk9by5sZW5ndGg7cjxpO3IrKylMZShvW3JdLGFbcl0pO2Vsc2UgTGUoZSxjKTtyZXR1cm4gMDwoYT15ZShjLFwic2NyaXB0XCIpKS5sZW5ndGgmJnZlKGEsIWYmJnllKGUsXCJzY3JpcHRcIikpLGN9LGNsZWFuRGF0YTpmdW5jdGlvbihlKXtmb3IodmFyIHQsbixyLGk9Uy5ldmVudC5zcGVjaWFsLG89MDt2b2lkIDAhPT0obj1lW29dKTtvKyspaWYoVihuKSl7aWYodD1uW1kuZXhwYW5kb10pe2lmKHQuZXZlbnRzKWZvcihyIGluIHQuZXZlbnRzKWlbcl0/Uy5ldmVudC5yZW1vdmUobixyKTpTLnJlbW92ZUV2ZW50KG4scix0LmhhbmRsZSk7bltZLmV4cGFuZG9dPXZvaWQgMH1uW1EuZXhwYW5kb10mJihuW1EuZXhwYW5kb109dm9pZCAwKX19fSksUy5mbi5leHRlbmQoe2RldGFjaDpmdW5jdGlvbihlKXtyZXR1cm4gT2UodGhpcyxlLCEwKX0scmVtb3ZlOmZ1bmN0aW9uKGUpe3JldHVybiBPZSh0aGlzLGUpfSx0ZXh0OmZ1bmN0aW9uKGUpe3JldHVybiBCKHRoaXMsZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWU/Uy50ZXh0KHRoaXMpOnRoaXMuZW1wdHkoKS5lYWNoKGZ1bmN0aW9uKCl7MSE9PXRoaXMubm9kZVR5cGUmJjExIT09dGhpcy5ub2RlVHlwZSYmOSE9PXRoaXMubm9kZVR5cGV8fCh0aGlzLnRleHRDb250ZW50PWUpfSl9LG51bGwsZSxhcmd1bWVudHMubGVuZ3RoKX0sYXBwZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIEhlKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKGUpezEhPT10aGlzLm5vZGVUeXBlJiYxMSE9PXRoaXMubm9kZVR5cGUmJjkhPT10aGlzLm5vZGVUeXBlfHxqZSh0aGlzLGUpLmFwcGVuZENoaWxkKGUpfSl9LHByZXBlbmQ6ZnVuY3Rpb24oKXtyZXR1cm4gSGUodGhpcyxhcmd1bWVudHMsZnVuY3Rpb24oZSl7aWYoMT09PXRoaXMubm9kZVR5cGV8fDExPT09dGhpcy5ub2RlVHlwZXx8OT09PXRoaXMubm9kZVR5cGUpe3ZhciB0PWplKHRoaXMsZSk7dC5pbnNlcnRCZWZvcmUoZSx0LmZpcnN0Q2hpbGQpfX0pfSxiZWZvcmU6ZnVuY3Rpb24oKXtyZXR1cm4gSGUodGhpcyxhcmd1bWVudHMsZnVuY3Rpb24oZSl7dGhpcy5wYXJlbnROb2RlJiZ0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsdGhpcyl9KX0sYWZ0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gSGUodGhpcyxhcmd1bWVudHMsZnVuY3Rpb24oZSl7dGhpcy5wYXJlbnROb2RlJiZ0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsdGhpcy5uZXh0U2libGluZyl9KX0sZW1wdHk6ZnVuY3Rpb24oKXtmb3IodmFyIGUsdD0wO251bGwhPShlPXRoaXNbdF0pO3QrKykxPT09ZS5ub2RlVHlwZSYmKFMuY2xlYW5EYXRhKHllKGUsITEpKSxlLnRleHRDb250ZW50PVwiXCIpO3JldHVybiB0aGlzfSxjbG9uZTpmdW5jdGlvbihlLHQpe3JldHVybiBlPW51bGwhPWUmJmUsdD1udWxsPT10P2U6dCx0aGlzLm1hcChmdW5jdGlvbigpe3JldHVybiBTLmNsb25lKHRoaXMsZSx0KX0pfSxodG1sOmZ1bmN0aW9uKGUpe3JldHVybiBCKHRoaXMsZnVuY3Rpb24oZSl7dmFyIHQ9dGhpc1swXXx8e30sbj0wLHI9dGhpcy5sZW5ndGg7aWYodm9pZCAwPT09ZSYmMT09PXQubm9kZVR5cGUpcmV0dXJuIHQuaW5uZXJIVE1MO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlJiYha2UudGVzdChlKSYmIWdlWyhkZS5leGVjKGUpfHxbXCJcIixcIlwiXSlbMV0udG9Mb3dlckNhc2UoKV0pe2U9Uy5odG1sUHJlZmlsdGVyKGUpO3RyeXtmb3IoO248cjtuKyspMT09PSh0PXRoaXNbbl18fHt9KS5ub2RlVHlwZSYmKFMuY2xlYW5EYXRhKHllKHQsITEpKSx0LmlubmVySFRNTD1lKTt0PTB9Y2F0Y2goZSl7fX10JiZ0aGlzLmVtcHR5KCkuYXBwZW5kKGUpfSxudWxsLGUsYXJndW1lbnRzLmxlbmd0aCl9LHJlcGxhY2VXaXRoOmZ1bmN0aW9uKCl7dmFyIG49W107cmV0dXJuIEhlKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMucGFyZW50Tm9kZTtTLmluQXJyYXkodGhpcyxuKTwwJiYoUy5jbGVhbkRhdGEoeWUodGhpcykpLHQmJnQucmVwbGFjZUNoaWxkKGUsdGhpcykpfSxuKX19KSxTLmVhY2goe2FwcGVuZFRvOlwiYXBwZW5kXCIscHJlcGVuZFRvOlwicHJlcGVuZFwiLGluc2VydEJlZm9yZTpcImJlZm9yZVwiLGluc2VydEFmdGVyOlwiYWZ0ZXJcIixyZXBsYWNlQWxsOlwicmVwbGFjZVdpdGhcIn0sZnVuY3Rpb24oZSxhKXtTLmZuW2VdPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxuPVtdLHI9UyhlKSxpPXIubGVuZ3RoLTEsbz0wO288PWk7bysrKXQ9bz09PWk/dGhpczp0aGlzLmNsb25lKCEwKSxTKHJbb10pW2FdKHQpLHUuYXBwbHkobix0LmdldCgpKTtyZXR1cm4gdGhpcy5wdXNoU3RhY2sobil9fSk7dmFyIFBlPW5ldyBSZWdFeHAoXCJeKFwiK2VlK1wiKSg/IXB4KVthLXolXSskXCIsXCJpXCIpLFJlPS9eLS0vLE1lPWZ1bmN0aW9uKGUpe3ZhciB0PWUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztyZXR1cm4gdCYmdC5vcGVuZXJ8fCh0PUMpLHQuZ2V0Q29tcHV0ZWRTdHlsZShlKX0sSWU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbz17fTtmb3IoaSBpbiB0KW9baV09ZS5zdHlsZVtpXSxlLnN0eWxlW2ldPXRbaV07Zm9yKGkgaW4gcj1uLmNhbGwoZSksdCllLnN0eWxlW2ldPW9baV07cmV0dXJuIHJ9LFdlPW5ldyBSZWdFeHAobmUuam9pbihcInxcIiksXCJpXCIpLEZlPVwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIiwkZT1uZXcgUmVnRXhwKFwiXlwiK0ZlK1wiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIitGZStcIiskXCIsXCJnXCIpO2Z1bmN0aW9uIEJlKGUsdCxuKXt2YXIgcixpLG8sYSxzPVJlLnRlc3QodCksdT1lLnN0eWxlO3JldHVybihuPW58fE1lKGUpKSYmKGE9bi5nZXRQcm9wZXJ0eVZhbHVlKHQpfHxuW3RdLHMmJihhPWEucmVwbGFjZSgkZSxcIiQxXCIpKSxcIlwiIT09YXx8aWUoZSl8fChhPVMuc3R5bGUoZSx0KSksIXYucGl4ZWxCb3hTdHlsZXMoKSYmUGUudGVzdChhKSYmV2UudGVzdCh0KSYmKHI9dS53aWR0aCxpPXUubWluV2lkdGgsbz11Lm1heFdpZHRoLHUubWluV2lkdGg9dS5tYXhXaWR0aD11LndpZHRoPWEsYT1uLndpZHRoLHUud2lkdGg9cix1Lm1pbldpZHRoPWksdS5tYXhXaWR0aD1vKSksdm9pZCAwIT09YT9hK1wiXCI6YX1mdW5jdGlvbiBfZShlLHQpe3JldHVybntnZXQ6ZnVuY3Rpb24oKXtpZighZSgpKXJldHVybih0aGlzLmdldD10KS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7ZGVsZXRlIHRoaXMuZ2V0fX19IWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe2lmKGwpe3Uuc3R5bGUuY3NzVGV4dD1cInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDttYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIixsLnN0eWxlLmNzc1RleHQ9XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7bWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDt3aWR0aDo2MCU7dG9wOjElXCIscmUuYXBwZW5kQ2hpbGQodSkuYXBwZW5kQ2hpbGQobCk7dmFyIGU9Qy5nZXRDb21wdXRlZFN0eWxlKGwpO249XCIxJVwiIT09ZS50b3Ascz0xMj09PXQoZS5tYXJnaW5MZWZ0KSxsLnN0eWxlLnJpZ2h0PVwiNjAlXCIsbz0zNj09PXQoZS5yaWdodCkscj0zNj09PXQoZS53aWR0aCksbC5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCIsaT0xMj09PXQobC5vZmZzZXRXaWR0aC8zKSxyZS5yZW1vdmVDaGlsZCh1KSxsPW51bGx9fWZ1bmN0aW9uIHQoZSl7cmV0dXJuIE1hdGgucm91bmQocGFyc2VGbG9hdChlKSl9dmFyIG4scixpLG8sYSxzLHU9RS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGw9RS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2wuc3R5bGUmJihsLnN0eWxlLmJhY2tncm91bmRDbGlwPVwiY29udGVudC1ib3hcIixsLmNsb25lTm9kZSghMCkuc3R5bGUuYmFja2dyb3VuZENsaXA9XCJcIix2LmNsZWFyQ2xvbmVTdHlsZT1cImNvbnRlbnQtYm94XCI9PT1sLnN0eWxlLmJhY2tncm91bmRDbGlwLFMuZXh0ZW5kKHYse2JveFNpemluZ1JlbGlhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIGUoKSxyfSxwaXhlbEJveFN0eWxlczpmdW5jdGlvbigpe3JldHVybiBlKCksb30scGl4ZWxQb3NpdGlvbjpmdW5jdGlvbigpe3JldHVybiBlKCksbn0scmVsaWFibGVNYXJnaW5MZWZ0OmZ1bmN0aW9uKCl7cmV0dXJuIGUoKSxzfSxzY3JvbGxib3hTaXplOmZ1bmN0aW9uKCl7cmV0dXJuIGUoKSxpfSxyZWxpYWJsZVRyRGltZW5zaW9uczpmdW5jdGlvbigpe3ZhciBlLHQsbixyO3JldHVybiBudWxsPT1hJiYoZT1FLmNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiKSx0PUUuY3JlYXRlRWxlbWVudChcInRyXCIpLG49RS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGUuc3R5bGUuY3NzVGV4dD1cInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7Ym9yZGVyLWNvbGxhcHNlOnNlcGFyYXRlXCIsdC5zdHlsZS5jc3NUZXh0PVwiYm9yZGVyOjFweCBzb2xpZFwiLHQuc3R5bGUuaGVpZ2h0PVwiMXB4XCIsbi5zdHlsZS5oZWlnaHQ9XCI5cHhcIixuLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLHJlLmFwcGVuZENoaWxkKGUpLmFwcGVuZENoaWxkKHQpLmFwcGVuZENoaWxkKG4pLHI9Qy5nZXRDb21wdXRlZFN0eWxlKHQpLGE9cGFyc2VJbnQoci5oZWlnaHQsMTApK3BhcnNlSW50KHIuYm9yZGVyVG9wV2lkdGgsMTApK3BhcnNlSW50KHIuYm9yZGVyQm90dG9tV2lkdGgsMTApPT09dC5vZmZzZXRIZWlnaHQscmUucmVtb3ZlQ2hpbGQoZSkpLGF9fSkpfSgpO3ZhciB6ZT1bXCJXZWJraXRcIixcIk1velwiLFwibXNcIl0sVWU9RS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlLFhlPXt9O2Z1bmN0aW9uIFZlKGUpe3ZhciB0PVMuY3NzUHJvcHNbZV18fFhlW2VdO3JldHVybiB0fHwoZSBpbiBVZT9lOlhlW2VdPWZ1bmN0aW9uKGUpe3ZhciB0PWVbMF0udG9VcHBlckNhc2UoKStlLnNsaWNlKDEpLG49emUubGVuZ3RoO3doaWxlKG4tLSlpZigoZT16ZVtuXSt0KWluIFVlKXJldHVybiBlfShlKXx8ZSl9dmFyIEdlPS9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxZZT17cG9zaXRpb246XCJhYnNvbHV0ZVwiLHZpc2liaWxpdHk6XCJoaWRkZW5cIixkaXNwbGF5OlwiYmxvY2tcIn0sUWU9e2xldHRlclNwYWNpbmc6XCIwXCIsZm9udFdlaWdodDpcIjQwMFwifTtmdW5jdGlvbiBKZShlLHQsbil7dmFyIHI9dGUuZXhlYyh0KTtyZXR1cm4gcj9NYXRoLm1heCgwLHJbMl0tKG58fDApKSsoclszXXx8XCJweFwiKTp0fWZ1bmN0aW9uIEtlKGUsdCxuLHIsaSxvKXt2YXIgYT1cIndpZHRoXCI9PT10PzE6MCxzPTAsdT0wO2lmKG49PT0ocj9cImJvcmRlclwiOlwiY29udGVudFwiKSlyZXR1cm4gMDtmb3IoO2E8NDthKz0yKVwibWFyZ2luXCI9PT1uJiYodSs9Uy5jc3MoZSxuK25lW2FdLCEwLGkpKSxyPyhcImNvbnRlbnRcIj09PW4mJih1LT1TLmNzcyhlLFwicGFkZGluZ1wiK25lW2FdLCEwLGkpKSxcIm1hcmdpblwiIT09biYmKHUtPVMuY3NzKGUsXCJib3JkZXJcIituZVthXStcIldpZHRoXCIsITAsaSkpKToodSs9Uy5jc3MoZSxcInBhZGRpbmdcIituZVthXSwhMCxpKSxcInBhZGRpbmdcIiE9PW4/dSs9Uy5jc3MoZSxcImJvcmRlclwiK25lW2FdK1wiV2lkdGhcIiwhMCxpKTpzKz1TLmNzcyhlLFwiYm9yZGVyXCIrbmVbYV0rXCJXaWR0aFwiLCEwLGkpKTtyZXR1cm4hciYmMDw9byYmKHUrPU1hdGgubWF4KDAsTWF0aC5jZWlsKGVbXCJvZmZzZXRcIit0WzBdLnRvVXBwZXJDYXNlKCkrdC5zbGljZSgxKV0tby11LXMtLjUpKXx8MCksdX1mdW5jdGlvbiBaZShlLHQsbil7dmFyIHI9TWUoZSksaT0oIXYuYm94U2l6aW5nUmVsaWFibGUoKXx8bikmJlwiYm9yZGVyLWJveFwiPT09Uy5jc3MoZSxcImJveFNpemluZ1wiLCExLHIpLG89aSxhPUJlKGUsdCxyKSxzPVwib2Zmc2V0XCIrdFswXS50b1VwcGVyQ2FzZSgpK3Quc2xpY2UoMSk7aWYoUGUudGVzdChhKSl7aWYoIW4pcmV0dXJuIGE7YT1cImF1dG9cIn1yZXR1cm4oIXYuYm94U2l6aW5nUmVsaWFibGUoKSYmaXx8IXYucmVsaWFibGVUckRpbWVuc2lvbnMoKSYmQShlLFwidHJcIil8fFwiYXV0b1wiPT09YXx8IXBhcnNlRmxvYXQoYSkmJlwiaW5saW5lXCI9PT1TLmNzcyhlLFwiZGlzcGxheVwiLCExLHIpKSYmZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCYmKGk9XCJib3JkZXItYm94XCI9PT1TLmNzcyhlLFwiYm94U2l6aW5nXCIsITEsciksKG89cyBpbiBlKSYmKGE9ZVtzXSkpLChhPXBhcnNlRmxvYXQoYSl8fDApK0tlKGUsdCxufHwoaT9cImJvcmRlclwiOlwiY29udGVudFwiKSxvLHIsYSkrXCJweFwifWZ1bmN0aW9uIGV0KGUsdCxuLHIsaSl7cmV0dXJuIG5ldyBldC5wcm90b3R5cGUuaW5pdChlLHQsbixyLGkpfVMuZXh0ZW5kKHtjc3NIb29rczp7b3BhY2l0eTp7Z2V0OmZ1bmN0aW9uKGUsdCl7aWYodCl7dmFyIG49QmUoZSxcIm9wYWNpdHlcIik7cmV0dXJuXCJcIj09PW4/XCIxXCI6bn19fX0sY3NzTnVtYmVyOnthbmltYXRpb25JdGVyYXRpb25Db3VudDohMCxjb2x1bW5Db3VudDohMCxmaWxsT3BhY2l0eTohMCxmbGV4R3JvdzohMCxmbGV4U2hyaW5rOiEwLGZvbnRXZWlnaHQ6ITAsZ3JpZEFyZWE6ITAsZ3JpZENvbHVtbjohMCxncmlkQ29sdW1uRW5kOiEwLGdyaWRDb2x1bW5TdGFydDohMCxncmlkUm93OiEwLGdyaWRSb3dFbmQ6ITAsZ3JpZFJvd1N0YXJ0OiEwLGxpbmVIZWlnaHQ6ITAsb3BhY2l0eTohMCxvcmRlcjohMCxvcnBoYW5zOiEwLHdpZG93czohMCx6SW5kZXg6ITAsem9vbTohMH0sY3NzUHJvcHM6e30sc3R5bGU6ZnVuY3Rpb24oZSx0LG4scil7aWYoZSYmMyE9PWUubm9kZVR5cGUmJjghPT1lLm5vZGVUeXBlJiZlLnN0eWxlKXt2YXIgaSxvLGEscz1YKHQpLHU9UmUudGVzdCh0KSxsPWUuc3R5bGU7aWYodXx8KHQ9VmUocykpLGE9Uy5jc3NIb29rc1t0XXx8Uy5jc3NIb29rc1tzXSx2b2lkIDA9PT1uKXJldHVybiBhJiZcImdldFwiaW4gYSYmdm9pZCAwIT09KGk9YS5nZXQoZSwhMSxyKSk/aTpsW3RdO1wic3RyaW5nXCI9PT0obz10eXBlb2YgbikmJihpPXRlLmV4ZWMobikpJiZpWzFdJiYobj1zZShlLHQsaSksbz1cIm51bWJlclwiKSxudWxsIT1uJiZuPT1uJiYoXCJudW1iZXJcIiE9PW98fHV8fChuKz1pJiZpWzNdfHwoUy5jc3NOdW1iZXJbc10/XCJcIjpcInB4XCIpKSx2LmNsZWFyQ2xvbmVTdHlsZXx8XCJcIiE9PW58fDAhPT10LmluZGV4T2YoXCJiYWNrZ3JvdW5kXCIpfHwobFt0XT1cImluaGVyaXRcIiksYSYmXCJzZXRcImluIGEmJnZvaWQgMD09PShuPWEuc2V0KGUsbixyKSl8fCh1P2wuc2V0UHJvcGVydHkodCxuKTpsW3RdPW4pKX19LGNzczpmdW5jdGlvbihlLHQsbixyKXt2YXIgaSxvLGEscz1YKHQpO3JldHVybiBSZS50ZXN0KHQpfHwodD1WZShzKSksKGE9Uy5jc3NIb29rc1t0XXx8Uy5jc3NIb29rc1tzXSkmJlwiZ2V0XCJpbiBhJiYoaT1hLmdldChlLCEwLG4pKSx2b2lkIDA9PT1pJiYoaT1CZShlLHQscikpLFwibm9ybWFsXCI9PT1pJiZ0IGluIFFlJiYoaT1RZVt0XSksXCJcIj09PW58fG4/KG89cGFyc2VGbG9hdChpKSwhMD09PW58fGlzRmluaXRlKG8pP298fDA6aSk6aX19KSxTLmVhY2goW1wiaGVpZ2h0XCIsXCJ3aWR0aFwiXSxmdW5jdGlvbihlLHUpe1MuY3NzSG9va3NbdV09e2dldDpmdW5jdGlvbihlLHQsbil7aWYodClyZXR1cm4hR2UudGVzdChTLmNzcyhlLFwiZGlzcGxheVwiKSl8fGUuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgmJmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg/WmUoZSx1LG4pOkllKGUsWWUsZnVuY3Rpb24oKXtyZXR1cm4gWmUoZSx1LG4pfSl9LHNldDpmdW5jdGlvbihlLHQsbil7dmFyIHIsaT1NZShlKSxvPSF2LnNjcm9sbGJveFNpemUoKSYmXCJhYnNvbHV0ZVwiPT09aS5wb3NpdGlvbixhPShvfHxuKSYmXCJib3JkZXItYm94XCI9PT1TLmNzcyhlLFwiYm94U2l6aW5nXCIsITEsaSkscz1uP0tlKGUsdSxuLGEsaSk6MDtyZXR1cm4gYSYmbyYmKHMtPU1hdGguY2VpbChlW1wib2Zmc2V0XCIrdVswXS50b1VwcGVyQ2FzZSgpK3Uuc2xpY2UoMSldLXBhcnNlRmxvYXQoaVt1XSktS2UoZSx1LFwiYm9yZGVyXCIsITEsaSktLjUpKSxzJiYocj10ZS5leGVjKHQpKSYmXCJweFwiIT09KHJbM118fFwicHhcIikmJihlLnN0eWxlW3VdPXQsdD1TLmNzcyhlLHUpKSxKZSgwLHQscyl9fX0pLFMuY3NzSG9va3MubWFyZ2luTGVmdD1fZSh2LnJlbGlhYmxlTWFyZ2luTGVmdCxmdW5jdGlvbihlLHQpe2lmKHQpcmV0dXJuKHBhcnNlRmxvYXQoQmUoZSxcIm1hcmdpbkxlZnRcIikpfHxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQtSWUoZSx7bWFyZ2luTGVmdDowfSxmdW5jdGlvbigpe3JldHVybiBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnR9KSkrXCJweFwifSksUy5lYWNoKHttYXJnaW46XCJcIixwYWRkaW5nOlwiXCIsYm9yZGVyOlwiV2lkdGhcIn0sZnVuY3Rpb24oaSxvKXtTLmNzc0hvb2tzW2krb109e2V4cGFuZDpmdW5jdGlvbihlKXtmb3IodmFyIHQ9MCxuPXt9LHI9XCJzdHJpbmdcIj09dHlwZW9mIGU/ZS5zcGxpdChcIiBcIik6W2VdO3Q8NDt0KyspbltpK25lW3RdK29dPXJbdF18fHJbdC0yXXx8clswXTtyZXR1cm4gbn19LFwibWFyZ2luXCIhPT1pJiYoUy5jc3NIb29rc1tpK29dLnNldD1KZSl9KSxTLmZuLmV4dGVuZCh7Y3NzOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIEIodGhpcyxmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvPXt9LGE9MDtpZihBcnJheS5pc0FycmF5KHQpKXtmb3Iocj1NZShlKSxpPXQubGVuZ3RoO2E8aTthKyspb1t0W2FdXT1TLmNzcyhlLHRbYV0sITEscik7cmV0dXJuIG99cmV0dXJuIHZvaWQgMCE9PW4/Uy5zdHlsZShlLHQsbik6Uy5jc3MoZSx0KX0sZSx0LDE8YXJndW1lbnRzLmxlbmd0aCl9fSksKChTLlR3ZWVuPWV0KS5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOmV0LGluaXQ6ZnVuY3Rpb24oZSx0LG4scixpLG8pe3RoaXMuZWxlbT1lLHRoaXMucHJvcD1uLHRoaXMuZWFzaW5nPWl8fFMuZWFzaW5nLl9kZWZhdWx0LHRoaXMub3B0aW9ucz10LHRoaXMuc3RhcnQ9dGhpcy5ub3c9dGhpcy5jdXIoKSx0aGlzLmVuZD1yLHRoaXMudW5pdD1vfHwoUy5jc3NOdW1iZXJbbl0/XCJcIjpcInB4XCIpfSxjdXI6ZnVuY3Rpb24oKXt2YXIgZT1ldC5wcm9wSG9va3NbdGhpcy5wcm9wXTtyZXR1cm4gZSYmZS5nZXQ/ZS5nZXQodGhpcyk6ZXQucHJvcEhvb2tzLl9kZWZhdWx0LmdldCh0aGlzKX0scnVuOmZ1bmN0aW9uKGUpe3ZhciB0LG49ZXQucHJvcEhvb2tzW3RoaXMucHJvcF07cmV0dXJuIHRoaXMub3B0aW9ucy5kdXJhdGlvbj90aGlzLnBvcz10PVMuZWFzaW5nW3RoaXMuZWFzaW5nXShlLHRoaXMub3B0aW9ucy5kdXJhdGlvbiplLDAsMSx0aGlzLm9wdGlvbnMuZHVyYXRpb24pOnRoaXMucG9zPXQ9ZSx0aGlzLm5vdz0odGhpcy5lbmQtdGhpcy5zdGFydCkqdCt0aGlzLnN0YXJ0LHRoaXMub3B0aW9ucy5zdGVwJiZ0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKHRoaXMuZWxlbSx0aGlzLm5vdyx0aGlzKSxuJiZuLnNldD9uLnNldCh0aGlzKTpldC5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KHRoaXMpLHRoaXN9fSkuaW5pdC5wcm90b3R5cGU9ZXQucHJvdG90eXBlLChldC5wcm9wSG9va3M9e19kZWZhdWx0OntnZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ7cmV0dXJuIDEhPT1lLmVsZW0ubm9kZVR5cGV8fG51bGwhPWUuZWxlbVtlLnByb3BdJiZudWxsPT1lLmVsZW0uc3R5bGVbZS5wcm9wXT9lLmVsZW1bZS5wcm9wXToodD1TLmNzcyhlLmVsZW0sZS5wcm9wLFwiXCIpKSYmXCJhdXRvXCIhPT10P3Q6MH0sc2V0OmZ1bmN0aW9uKGUpe1MuZnguc3RlcFtlLnByb3BdP1MuZnguc3RlcFtlLnByb3BdKGUpOjEhPT1lLmVsZW0ubm9kZVR5cGV8fCFTLmNzc0hvb2tzW2UucHJvcF0mJm51bGw9PWUuZWxlbS5zdHlsZVtWZShlLnByb3ApXT9lLmVsZW1bZS5wcm9wXT1lLm5vdzpTLnN0eWxlKGUuZWxlbSxlLnByb3AsZS5ub3crZS51bml0KX19fSkuc2Nyb2xsVG9wPWV0LnByb3BIb29rcy5zY3JvbGxMZWZ0PXtzZXQ6ZnVuY3Rpb24oZSl7ZS5lbGVtLm5vZGVUeXBlJiZlLmVsZW0ucGFyZW50Tm9kZSYmKGUuZWxlbVtlLnByb3BdPWUubm93KX19LFMuZWFzaW5nPXtsaW5lYXI6ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LHN3aW5nOmZ1bmN0aW9uKGUpe3JldHVybi41LU1hdGguY29zKGUqTWF0aC5QSSkvMn0sX2RlZmF1bHQ6XCJzd2luZ1wifSxTLmZ4PWV0LnByb3RvdHlwZS5pbml0LFMuZnguc3RlcD17fTt2YXIgdHQsbnQscnQsaXQsb3Q9L14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLGF0PS9xdWV1ZUhvb2tzJC87ZnVuY3Rpb24gc3QoKXtudCYmKCExPT09RS5oaWRkZW4mJkMucmVxdWVzdEFuaW1hdGlvbkZyYW1lP0MucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0KTpDLnNldFRpbWVvdXQoc3QsUy5meC5pbnRlcnZhbCksUy5meC50aWNrKCkpfWZ1bmN0aW9uIHV0KCl7cmV0dXJuIEMuc2V0VGltZW91dChmdW5jdGlvbigpe3R0PXZvaWQgMH0pLHR0PURhdGUubm93KCl9ZnVuY3Rpb24gbHQoZSx0KXt2YXIgbixyPTAsaT17aGVpZ2h0OmV9O2Zvcih0PXQ/MTowO3I8NDtyKz0yLXQpaVtcIm1hcmdpblwiKyhuPW5lW3JdKV09aVtcInBhZGRpbmdcIituXT1lO3JldHVybiB0JiYoaS5vcGFjaXR5PWkud2lkdGg9ZSksaX1mdW5jdGlvbiBjdChlLHQsbil7Zm9yKHZhciByLGk9KGZ0LnR3ZWVuZXJzW3RdfHxbXSkuY29uY2F0KGZ0LnR3ZWVuZXJzW1wiKlwiXSksbz0wLGE9aS5sZW5ndGg7bzxhO28rKylpZihyPWlbb10uY2FsbChuLHQsZSkpcmV0dXJuIHJ9ZnVuY3Rpb24gZnQobyxlLHQpe3ZhciBuLGEscj0wLGk9ZnQucHJlZmlsdGVycy5sZW5ndGgscz1TLkRlZmVycmVkKCkuYWx3YXlzKGZ1bmN0aW9uKCl7ZGVsZXRlIHUuZWxlbX0pLHU9ZnVuY3Rpb24oKXtpZihhKXJldHVybiExO2Zvcih2YXIgZT10dHx8dXQoKSx0PU1hdGgubWF4KDAsbC5zdGFydFRpbWUrbC5kdXJhdGlvbi1lKSxuPTEtKHQvbC5kdXJhdGlvbnx8MCkscj0wLGk9bC50d2VlbnMubGVuZ3RoO3I8aTtyKyspbC50d2VlbnNbcl0ucnVuKG4pO3JldHVybiBzLm5vdGlmeVdpdGgobyxbbCxuLHRdKSxuPDEmJmk/dDooaXx8cy5ub3RpZnlXaXRoKG8sW2wsMSwwXSkscy5yZXNvbHZlV2l0aChvLFtsXSksITEpfSxsPXMucHJvbWlzZSh7ZWxlbTpvLHByb3BzOlMuZXh0ZW5kKHt9LGUpLG9wdHM6Uy5leHRlbmQoITAse3NwZWNpYWxFYXNpbmc6e30sZWFzaW5nOlMuZWFzaW5nLl9kZWZhdWx0fSx0KSxvcmlnaW5hbFByb3BlcnRpZXM6ZSxvcmlnaW5hbE9wdGlvbnM6dCxzdGFydFRpbWU6dHR8fHV0KCksZHVyYXRpb246dC5kdXJhdGlvbix0d2VlbnM6W10sY3JlYXRlVHdlZW46ZnVuY3Rpb24oZSx0KXt2YXIgbj1TLlR3ZWVuKG8sbC5vcHRzLGUsdCxsLm9wdHMuc3BlY2lhbEVhc2luZ1tlXXx8bC5vcHRzLmVhc2luZyk7cmV0dXJuIGwudHdlZW5zLnB1c2gobiksbn0sc3RvcDpmdW5jdGlvbihlKXt2YXIgdD0wLG49ZT9sLnR3ZWVucy5sZW5ndGg6MDtpZihhKXJldHVybiB0aGlzO2ZvcihhPSEwO3Q8bjt0KyspbC50d2VlbnNbdF0ucnVuKDEpO3JldHVybiBlPyhzLm5vdGlmeVdpdGgobyxbbCwxLDBdKSxzLnJlc29sdmVXaXRoKG8sW2wsZV0pKTpzLnJlamVjdFdpdGgobyxbbCxlXSksdGhpc319KSxjPWwucHJvcHM7Zm9yKCFmdW5jdGlvbihlLHQpe3ZhciBuLHIsaSxvLGE7Zm9yKG4gaW4gZSlpZihpPXRbcj1YKG4pXSxvPWVbbl0sQXJyYXkuaXNBcnJheShvKSYmKGk9b1sxXSxvPWVbbl09b1swXSksbiE9PXImJihlW3JdPW8sZGVsZXRlIGVbbl0pLChhPVMuY3NzSG9va3Nbcl0pJiZcImV4cGFuZFwiaW4gYSlmb3IobiBpbiBvPWEuZXhwYW5kKG8pLGRlbGV0ZSBlW3JdLG8pbiBpbiBlfHwoZVtuXT1vW25dLHRbbl09aSk7ZWxzZSB0W3JdPWl9KGMsbC5vcHRzLnNwZWNpYWxFYXNpbmcpO3I8aTtyKyspaWYobj1mdC5wcmVmaWx0ZXJzW3JdLmNhbGwobCxvLGMsbC5vcHRzKSlyZXR1cm4gbShuLnN0b3ApJiYoUy5fcXVldWVIb29rcyhsLmVsZW0sbC5vcHRzLnF1ZXVlKS5zdG9wPW4uc3RvcC5iaW5kKG4pKSxuO3JldHVybiBTLm1hcChjLGN0LGwpLG0obC5vcHRzLnN0YXJ0KSYmbC5vcHRzLnN0YXJ0LmNhbGwobyxsKSxsLnByb2dyZXNzKGwub3B0cy5wcm9ncmVzcykuZG9uZShsLm9wdHMuZG9uZSxsLm9wdHMuY29tcGxldGUpLmZhaWwobC5vcHRzLmZhaWwpLmFsd2F5cyhsLm9wdHMuYWx3YXlzKSxTLmZ4LnRpbWVyKFMuZXh0ZW5kKHUse2VsZW06byxhbmltOmwscXVldWU6bC5vcHRzLnF1ZXVlfSkpLGx9Uy5BbmltYXRpb249Uy5leHRlbmQoZnQse3R3ZWVuZXJzOntcIipcIjpbZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLmNyZWF0ZVR3ZWVuKGUsdCk7cmV0dXJuIHNlKG4uZWxlbSxlLHRlLmV4ZWModCksbiksbn1dfSx0d2VlbmVyOmZ1bmN0aW9uKGUsdCl7bShlKT8odD1lLGU9W1wiKlwiXSk6ZT1lLm1hdGNoKFApO2Zvcih2YXIgbixyPTAsaT1lLmxlbmd0aDtyPGk7cisrKW49ZVtyXSxmdC50d2VlbmVyc1tuXT1mdC50d2VlbmVyc1tuXXx8W10sZnQudHdlZW5lcnNbbl0udW5zaGlmdCh0KX0scHJlZmlsdGVyczpbZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbyxhLHMsdSxsLGMsZj1cIndpZHRoXCJpbiB0fHxcImhlaWdodFwiaW4gdCxwPXRoaXMsZD17fSxoPWUuc3R5bGUsZz1lLm5vZGVUeXBlJiZhZShlKSx5PVkuZ2V0KGUsXCJmeHNob3dcIik7Zm9yKHIgaW4gbi5xdWV1ZXx8KG51bGw9PShhPVMuX3F1ZXVlSG9va3MoZSxcImZ4XCIpKS51bnF1ZXVlZCYmKGEudW5xdWV1ZWQ9MCxzPWEuZW1wdHkuZmlyZSxhLmVtcHR5LmZpcmU9ZnVuY3Rpb24oKXthLnVucXVldWVkfHxzKCl9KSxhLnVucXVldWVkKysscC5hbHdheXMoZnVuY3Rpb24oKXtwLmFsd2F5cyhmdW5jdGlvbigpe2EudW5xdWV1ZWQtLSxTLnF1ZXVlKGUsXCJmeFwiKS5sZW5ndGh8fGEuZW1wdHkuZmlyZSgpfSl9KSksdClpZihpPXRbcl0sb3QudGVzdChpKSl7aWYoZGVsZXRlIHRbcl0sbz1vfHxcInRvZ2dsZVwiPT09aSxpPT09KGc/XCJoaWRlXCI6XCJzaG93XCIpKXtpZihcInNob3dcIiE9PWl8fCF5fHx2b2lkIDA9PT15W3JdKWNvbnRpbnVlO2c9ITB9ZFtyXT15JiZ5W3JdfHxTLnN0eWxlKGUscil9aWYoKHU9IVMuaXNFbXB0eU9iamVjdCh0KSl8fCFTLmlzRW1wdHlPYmplY3QoZCkpZm9yKHIgaW4gZiYmMT09PWUubm9kZVR5cGUmJihuLm92ZXJmbG93PVtoLm92ZXJmbG93LGgub3ZlcmZsb3dYLGgub3ZlcmZsb3dZXSxudWxsPT0obD15JiZ5LmRpc3BsYXkpJiYobD1ZLmdldChlLFwiZGlzcGxheVwiKSksXCJub25lXCI9PT0oYz1TLmNzcyhlLFwiZGlzcGxheVwiKSkmJihsP2M9bDoobGUoW2VdLCEwKSxsPWUuc3R5bGUuZGlzcGxheXx8bCxjPVMuY3NzKGUsXCJkaXNwbGF5XCIpLGxlKFtlXSkpKSwoXCJpbmxpbmVcIj09PWN8fFwiaW5saW5lLWJsb2NrXCI9PT1jJiZudWxsIT1sKSYmXCJub25lXCI9PT1TLmNzcyhlLFwiZmxvYXRcIikmJih1fHwocC5kb25lKGZ1bmN0aW9uKCl7aC5kaXNwbGF5PWx9KSxudWxsPT1sJiYoYz1oLmRpc3BsYXksbD1cIm5vbmVcIj09PWM/XCJcIjpjKSksaC5kaXNwbGF5PVwiaW5saW5lLWJsb2NrXCIpKSxuLm92ZXJmbG93JiYoaC5vdmVyZmxvdz1cImhpZGRlblwiLHAuYWx3YXlzKGZ1bmN0aW9uKCl7aC5vdmVyZmxvdz1uLm92ZXJmbG93WzBdLGgub3ZlcmZsb3dYPW4ub3ZlcmZsb3dbMV0saC5vdmVyZmxvd1k9bi5vdmVyZmxvd1syXX0pKSx1PSExLGQpdXx8KHk/XCJoaWRkZW5cImluIHkmJihnPXkuaGlkZGVuKTp5PVkuYWNjZXNzKGUsXCJmeHNob3dcIix7ZGlzcGxheTpsfSksbyYmKHkuaGlkZGVuPSFnKSxnJiZsZShbZV0sITApLHAuZG9uZShmdW5jdGlvbigpe2ZvcihyIGluIGd8fGxlKFtlXSksWS5yZW1vdmUoZSxcImZ4c2hvd1wiKSxkKVMuc3R5bGUoZSxyLGRbcl0pfSkpLHU9Y3QoZz95W3JdOjAscixwKSxyIGluIHl8fCh5W3JdPXUuc3RhcnQsZyYmKHUuZW5kPXUuc3RhcnQsdS5zdGFydD0wKSl9XSxwcmVmaWx0ZXI6ZnVuY3Rpb24oZSx0KXt0P2Z0LnByZWZpbHRlcnMudW5zaGlmdChlKTpmdC5wcmVmaWx0ZXJzLnB1c2goZSl9fSksUy5zcGVlZD1mdW5jdGlvbihlLHQsbil7dmFyIHI9ZSYmXCJvYmplY3RcIj09dHlwZW9mIGU/Uy5leHRlbmQoe30sZSk6e2NvbXBsZXRlOm58fCFuJiZ0fHxtKGUpJiZlLGR1cmF0aW9uOmUsZWFzaW5nOm4mJnR8fHQmJiFtKHQpJiZ0fTtyZXR1cm4gUy5meC5vZmY/ci5kdXJhdGlvbj0wOlwibnVtYmVyXCIhPXR5cGVvZiByLmR1cmF0aW9uJiYoci5kdXJhdGlvbiBpbiBTLmZ4LnNwZWVkcz9yLmR1cmF0aW9uPVMuZnguc3BlZWRzW3IuZHVyYXRpb25dOnIuZHVyYXRpb249Uy5meC5zcGVlZHMuX2RlZmF1bHQpLG51bGwhPXIucXVldWUmJiEwIT09ci5xdWV1ZXx8KHIucXVldWU9XCJmeFwiKSxyLm9sZD1yLmNvbXBsZXRlLHIuY29tcGxldGU9ZnVuY3Rpb24oKXttKHIub2xkKSYmci5vbGQuY2FsbCh0aGlzKSxyLnF1ZXVlJiZTLmRlcXVldWUodGhpcyxyLnF1ZXVlKX0scn0sUy5mbi5leHRlbmQoe2ZhZGVUbzpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gdGhpcy5maWx0ZXIoYWUpLmNzcyhcIm9wYWNpdHlcIiwwKS5zaG93KCkuZW5kKCkuYW5pbWF0ZSh7b3BhY2l0eTp0fSxlLG4scil9LGFuaW1hdGU6ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9Uy5pc0VtcHR5T2JqZWN0KHQpLG89Uy5zcGVlZChlLG4sciksYT1mdW5jdGlvbigpe3ZhciBlPWZ0KHRoaXMsUy5leHRlbmQoe30sdCksbyk7KGl8fFkuZ2V0KHRoaXMsXCJmaW5pc2hcIikpJiZlLnN0b3AoITApfTtyZXR1cm4gYS5maW5pc2g9YSxpfHwhMT09PW8ucXVldWU/dGhpcy5lYWNoKGEpOnRoaXMucXVldWUoby5xdWV1ZSxhKX0sc3RvcDpmdW5jdGlvbihpLGUsbyl7dmFyIGE9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zdG9wO2RlbGV0ZSBlLnN0b3AsdChvKX07cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIGkmJihvPWUsZT1pLGk9dm9pZCAwKSxlJiZ0aGlzLnF1ZXVlKGl8fFwiZnhcIixbXSksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGU9ITAsdD1udWxsIT1pJiZpK1wicXVldWVIb29rc1wiLG49Uy50aW1lcnMscj1ZLmdldCh0aGlzKTtpZih0KXJbdF0mJnJbdF0uc3RvcCYmYShyW3RdKTtlbHNlIGZvcih0IGluIHIpclt0XSYmclt0XS5zdG9wJiZhdC50ZXN0KHQpJiZhKHJbdF0pO2Zvcih0PW4ubGVuZ3RoO3QtLTspblt0XS5lbGVtIT09dGhpc3x8bnVsbCE9aSYmblt0XS5xdWV1ZSE9PWl8fChuW3RdLmFuaW0uc3RvcChvKSxlPSExLG4uc3BsaWNlKHQsMSkpOyFlJiZvfHxTLmRlcXVldWUodGhpcyxpKX0pfSxmaW5pc2g6ZnVuY3Rpb24oYSl7cmV0dXJuITEhPT1hJiYoYT1hfHxcImZ4XCIpLHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBlLHQ9WS5nZXQodGhpcyksbj10W2ErXCJxdWV1ZVwiXSxyPXRbYStcInF1ZXVlSG9va3NcIl0saT1TLnRpbWVycyxvPW4/bi5sZW5ndGg6MDtmb3IodC5maW5pc2g9ITAsUy5xdWV1ZSh0aGlzLGEsW10pLHImJnIuc3RvcCYmci5zdG9wLmNhbGwodGhpcywhMCksZT1pLmxlbmd0aDtlLS07KWlbZV0uZWxlbT09PXRoaXMmJmlbZV0ucXVldWU9PT1hJiYoaVtlXS5hbmltLnN0b3AoITApLGkuc3BsaWNlKGUsMSkpO2ZvcihlPTA7ZTxvO2UrKyluW2VdJiZuW2VdLmZpbmlzaCYmbltlXS5maW5pc2guY2FsbCh0aGlzKTtkZWxldGUgdC5maW5pc2h9KX19KSxTLmVhY2goW1widG9nZ2xlXCIsXCJzaG93XCIsXCJoaWRlXCJdLGZ1bmN0aW9uKGUscil7dmFyIGk9Uy5mbltyXTtTLmZuW3JdPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gbnVsbD09ZXx8XCJib29sZWFuXCI9PXR5cGVvZiBlP2kuYXBwbHkodGhpcyxhcmd1bWVudHMpOnRoaXMuYW5pbWF0ZShsdChyLCEwKSxlLHQsbil9fSksUy5lYWNoKHtzbGlkZURvd246bHQoXCJzaG93XCIpLHNsaWRlVXA6bHQoXCJoaWRlXCIpLHNsaWRlVG9nZ2xlOmx0KFwidG9nZ2xlXCIpLGZhZGVJbjp7b3BhY2l0eTpcInNob3dcIn0sZmFkZU91dDp7b3BhY2l0eTpcImhpZGVcIn0sZmFkZVRvZ2dsZTp7b3BhY2l0eTpcInRvZ2dsZVwifX0sZnVuY3Rpb24oZSxyKXtTLmZuW2VdPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdGhpcy5hbmltYXRlKHIsZSx0LG4pfX0pLFMudGltZXJzPVtdLFMuZngudGljaz1mdW5jdGlvbigpe3ZhciBlLHQ9MCxuPVMudGltZXJzO2Zvcih0dD1EYXRlLm5vdygpO3Q8bi5sZW5ndGg7dCsrKShlPW5bdF0pKCl8fG5bdF0hPT1lfHxuLnNwbGljZSh0LS0sMSk7bi5sZW5ndGh8fFMuZnguc3RvcCgpLHR0PXZvaWQgMH0sUy5meC50aW1lcj1mdW5jdGlvbihlKXtTLnRpbWVycy5wdXNoKGUpLFMuZnguc3RhcnQoKX0sUy5meC5pbnRlcnZhbD0xMyxTLmZ4LnN0YXJ0PWZ1bmN0aW9uKCl7bnR8fChudD0hMCxzdCgpKX0sUy5meC5zdG9wPWZ1bmN0aW9uKCl7bnQ9bnVsbH0sUy5meC5zcGVlZHM9e3Nsb3c6NjAwLGZhc3Q6MjAwLF9kZWZhdWx0OjQwMH0sUy5mbi5kZWxheT1mdW5jdGlvbihyLGUpe3JldHVybiByPVMuZngmJlMuZnguc3BlZWRzW3JdfHxyLGU9ZXx8XCJmeFwiLHRoaXMucXVldWUoZSxmdW5jdGlvbihlLHQpe3ZhciBuPUMuc2V0VGltZW91dChlLHIpO3Quc3RvcD1mdW5jdGlvbigpe0MuY2xlYXJUaW1lb3V0KG4pfX0pfSxydD1FLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxpdD1FLmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIikuYXBwZW5kQ2hpbGQoRS5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpKSxydC50eXBlPVwiY2hlY2tib3hcIix2LmNoZWNrT249XCJcIiE9PXJ0LnZhbHVlLHYub3B0U2VsZWN0ZWQ9aXQuc2VsZWN0ZWQsKHJ0PUUuY3JlYXRlRWxlbWVudChcImlucHV0XCIpKS52YWx1ZT1cInRcIixydC50eXBlPVwicmFkaW9cIix2LnJhZGlvVmFsdWU9XCJ0XCI9PT1ydC52YWx1ZTt2YXIgcHQsZHQ9Uy5leHByLmF0dHJIYW5kbGU7Uy5mbi5leHRlbmQoe2F0dHI6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gQih0aGlzLFMuYXR0cixlLHQsMTxhcmd1bWVudHMubGVuZ3RoKX0scmVtb3ZlQXR0cjpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7Uy5yZW1vdmVBdHRyKHRoaXMsZSl9KX19KSxTLmV4dGVuZCh7YXR0cjpmdW5jdGlvbihlLHQsbil7dmFyIHIsaSxvPWUubm9kZVR5cGU7aWYoMyE9PW8mJjghPT1vJiYyIT09bylyZXR1cm5cInVuZGVmaW5lZFwiPT10eXBlb2YgZS5nZXRBdHRyaWJ1dGU/Uy5wcm9wKGUsdCxuKTooMT09PW8mJlMuaXNYTUxEb2MoZSl8fChpPVMuYXR0ckhvb2tzW3QudG9Mb3dlckNhc2UoKV18fChTLmV4cHIubWF0Y2guYm9vbC50ZXN0KHQpP3B0OnZvaWQgMCkpLHZvaWQgMCE9PW4/bnVsbD09PW4/dm9pZCBTLnJlbW92ZUF0dHIoZSx0KTppJiZcInNldFwiaW4gaSYmdm9pZCAwIT09KHI9aS5zZXQoZSxuLHQpKT9yOihlLnNldEF0dHJpYnV0ZSh0LG4rXCJcIiksbik6aSYmXCJnZXRcImluIGkmJm51bGwhPT0ocj1pLmdldChlLHQpKT9yOm51bGw9PShyPVMuZmluZC5hdHRyKGUsdCkpP3ZvaWQgMDpyKX0sYXR0ckhvb2tzOnt0eXBlOntzZXQ6ZnVuY3Rpb24oZSx0KXtpZighdi5yYWRpb1ZhbHVlJiZcInJhZGlvXCI9PT10JiZBKGUsXCJpbnB1dFwiKSl7dmFyIG49ZS52YWx1ZTtyZXR1cm4gZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsdCksbiYmKGUudmFsdWU9biksdH19fX0scmVtb3ZlQXR0cjpmdW5jdGlvbihlLHQpe3ZhciBuLHI9MCxpPXQmJnQubWF0Y2goUCk7aWYoaSYmMT09PWUubm9kZVR5cGUpd2hpbGUobj1pW3IrK10pZS5yZW1vdmVBdHRyaWJ1dGUobil9fSkscHQ9e3NldDpmdW5jdGlvbihlLHQsbil7cmV0dXJuITE9PT10P1MucmVtb3ZlQXR0cihlLG4pOmUuc2V0QXR0cmlidXRlKG4sbiksbn19LFMuZWFjaChTLmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goL1xcdysvZyksZnVuY3Rpb24oZSx0KXt2YXIgYT1kdFt0XXx8Uy5maW5kLmF0dHI7ZHRbdF09ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbz10LnRvTG93ZXJDYXNlKCk7cmV0dXJuIG58fChpPWR0W29dLGR0W29dPXIscj1udWxsIT1hKGUsdCxuKT9vOm51bGwsZHRbb109aSkscn19KTt2YXIgaHQ9L14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxndD0vXig/OmF8YXJlYSkkL2k7ZnVuY3Rpb24geXQoZSl7cmV0dXJuKGUubWF0Y2goUCl8fFtdKS5qb2luKFwiIFwiKX1mdW5jdGlvbiB2dChlKXtyZXR1cm4gZS5nZXRBdHRyaWJ1dGUmJmUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIil8fFwiXCJ9ZnVuY3Rpb24gbXQoZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/ZTpcInN0cmluZ1wiPT10eXBlb2YgZSYmZS5tYXRjaChQKXx8W119Uy5mbi5leHRlbmQoe3Byb3A6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gQih0aGlzLFMucHJvcCxlLHQsMTxhcmd1bWVudHMubGVuZ3RoKX0scmVtb3ZlUHJvcDpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7ZGVsZXRlIHRoaXNbUy5wcm9wRml4W2VdfHxlXX0pfX0pLFMuZXh0ZW5kKHtwcm9wOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG89ZS5ub2RlVHlwZTtpZigzIT09byYmOCE9PW8mJjIhPT1vKXJldHVybiAxPT09byYmUy5pc1hNTERvYyhlKXx8KHQ9Uy5wcm9wRml4W3RdfHx0LGk9Uy5wcm9wSG9va3NbdF0pLHZvaWQgMCE9PW4/aSYmXCJzZXRcImluIGkmJnZvaWQgMCE9PShyPWkuc2V0KGUsbix0KSk/cjplW3RdPW46aSYmXCJnZXRcImluIGkmJm51bGwhPT0ocj1pLmdldChlLHQpKT9yOmVbdF19LHByb3BIb29rczp7dGFiSW5kZXg6e2dldDpmdW5jdGlvbihlKXt2YXIgdD1TLmZpbmQuYXR0cihlLFwidGFiaW5kZXhcIik7cmV0dXJuIHQ/cGFyc2VJbnQodCwxMCk6aHQudGVzdChlLm5vZGVOYW1lKXx8Z3QudGVzdChlLm5vZGVOYW1lKSYmZS5ocmVmPzA6LTF9fX0scHJvcEZpeDp7XCJmb3JcIjpcImh0bWxGb3JcIixcImNsYXNzXCI6XCJjbGFzc05hbWVcIn19KSx2Lm9wdFNlbGVjdGVkfHwoUy5wcm9wSG9va3Muc2VsZWN0ZWQ9e2dldDpmdW5jdGlvbihlKXt2YXIgdD1lLnBhcmVudE5vZGU7cmV0dXJuIHQmJnQucGFyZW50Tm9kZSYmdC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgsbnVsbH0sc2V0OmZ1bmN0aW9uKGUpe3ZhciB0PWUucGFyZW50Tm9kZTt0JiYodC5zZWxlY3RlZEluZGV4LHQucGFyZW50Tm9kZSYmdC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgpfX0pLFMuZWFjaChbXCJ0YWJJbmRleFwiLFwicmVhZE9ubHlcIixcIm1heExlbmd0aFwiLFwiY2VsbFNwYWNpbmdcIixcImNlbGxQYWRkaW5nXCIsXCJyb3dTcGFuXCIsXCJjb2xTcGFuXCIsXCJ1c2VNYXBcIixcImZyYW1lQm9yZGVyXCIsXCJjb250ZW50RWRpdGFibGVcIl0sZnVuY3Rpb24oKXtTLnByb3BGaXhbdGhpcy50b0xvd2VyQ2FzZSgpXT10aGlzfSksUy5mbi5leHRlbmQoe2FkZENsYXNzOmZ1bmN0aW9uKHQpe3ZhciBlLG4scixpLG8sYTtyZXR1cm4gbSh0KT90aGlzLmVhY2goZnVuY3Rpb24oZSl7Uyh0aGlzKS5hZGRDbGFzcyh0LmNhbGwodGhpcyxlLHZ0KHRoaXMpKSl9KTooZT1tdCh0KSkubGVuZ3RoP3RoaXMuZWFjaChmdW5jdGlvbigpe2lmKHI9dnQodGhpcyksbj0xPT09dGhpcy5ub2RlVHlwZSYmXCIgXCIreXQocikrXCIgXCIpe2ZvcihvPTA7bzxlLmxlbmd0aDtvKyspaT1lW29dLG4uaW5kZXhPZihcIiBcIitpK1wiIFwiKTwwJiYobis9aStcIiBcIik7YT15dChuKSxyIT09YSYmdGhpcy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLGEpfX0pOnRoaXN9LHJlbW92ZUNsYXNzOmZ1bmN0aW9uKHQpe3ZhciBlLG4scixpLG8sYTtyZXR1cm4gbSh0KT90aGlzLmVhY2goZnVuY3Rpb24oZSl7Uyh0aGlzKS5yZW1vdmVDbGFzcyh0LmNhbGwodGhpcyxlLHZ0KHRoaXMpKSl9KTphcmd1bWVudHMubGVuZ3RoPyhlPW10KHQpKS5sZW5ndGg/dGhpcy5lYWNoKGZ1bmN0aW9uKCl7aWYocj12dCh0aGlzKSxuPTE9PT10aGlzLm5vZGVUeXBlJiZcIiBcIit5dChyKStcIiBcIil7Zm9yKG89MDtvPGUubGVuZ3RoO28rKyl7aT1lW29dO3doaWxlKC0xPG4uaW5kZXhPZihcIiBcIitpK1wiIFwiKSluPW4ucmVwbGFjZShcIiBcIitpK1wiIFwiLFwiIFwiKX1hPXl0KG4pLHIhPT1hJiZ0aGlzLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsYSl9fSk6dGhpczp0aGlzLmF0dHIoXCJjbGFzc1wiLFwiXCIpfSx0b2dnbGVDbGFzczpmdW5jdGlvbih0LG4pe3ZhciBlLHIsaSxvLGE9dHlwZW9mIHQscz1cInN0cmluZ1wiPT09YXx8QXJyYXkuaXNBcnJheSh0KTtyZXR1cm4gbSh0KT90aGlzLmVhY2goZnVuY3Rpb24oZSl7Uyh0aGlzKS50b2dnbGVDbGFzcyh0LmNhbGwodGhpcyxlLHZ0KHRoaXMpLG4pLG4pfSk6XCJib29sZWFuXCI9PXR5cGVvZiBuJiZzP24/dGhpcy5hZGRDbGFzcyh0KTp0aGlzLnJlbW92ZUNsYXNzKHQpOihlPW10KHQpLHRoaXMuZWFjaChmdW5jdGlvbigpe2lmKHMpZm9yKG89Uyh0aGlzKSxpPTA7aTxlLmxlbmd0aDtpKyspcj1lW2ldLG8uaGFzQ2xhc3Mocik/by5yZW1vdmVDbGFzcyhyKTpvLmFkZENsYXNzKHIpO2Vsc2Ugdm9pZCAwIT09dCYmXCJib29sZWFuXCIhPT1hfHwoKHI9dnQodGhpcykpJiZZLnNldCh0aGlzLFwiX19jbGFzc05hbWVfX1wiLHIpLHRoaXMuc2V0QXR0cmlidXRlJiZ0aGlzLnNldEF0dHJpYnV0ZShcImNsYXNzXCIscnx8ITE9PT10P1wiXCI6WS5nZXQodGhpcyxcIl9fY2xhc3NOYW1lX19cIil8fFwiXCIpKX0pKX0saGFzQ2xhc3M6ZnVuY3Rpb24oZSl7dmFyIHQsbixyPTA7dD1cIiBcIitlK1wiIFwiO3doaWxlKG49dGhpc1tyKytdKWlmKDE9PT1uLm5vZGVUeXBlJiYtMTwoXCIgXCIreXQodnQobikpK1wiIFwiKS5pbmRleE9mKHQpKXJldHVybiEwO3JldHVybiExfX0pO3ZhciB4dD0vXFxyL2c7Uy5mbi5leHRlbmQoe3ZhbDpmdW5jdGlvbihuKXt2YXIgcixlLGksdD10aGlzWzBdO3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhpPW0obiksdGhpcy5lYWNoKGZ1bmN0aW9uKGUpe3ZhciB0OzE9PT10aGlzLm5vZGVUeXBlJiYobnVsbD09KHQ9aT9uLmNhbGwodGhpcyxlLFModGhpcykudmFsKCkpOm4pP3Q9XCJcIjpcIm51bWJlclwiPT10eXBlb2YgdD90Kz1cIlwiOkFycmF5LmlzQXJyYXkodCkmJih0PVMubWFwKHQsZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWU/XCJcIjplK1wiXCJ9KSksKHI9Uy52YWxIb29rc1t0aGlzLnR5cGVdfHxTLnZhbEhvb2tzW3RoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0pJiZcInNldFwiaW4gciYmdm9pZCAwIT09ci5zZXQodGhpcyx0LFwidmFsdWVcIil8fCh0aGlzLnZhbHVlPXQpKX0pKTp0PyhyPVMudmFsSG9va3NbdC50eXBlXXx8Uy52YWxIb29rc1t0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldKSYmXCJnZXRcImluIHImJnZvaWQgMCE9PShlPXIuZ2V0KHQsXCJ2YWx1ZVwiKSk/ZTpcInN0cmluZ1wiPT10eXBlb2YoZT10LnZhbHVlKT9lLnJlcGxhY2UoeHQsXCJcIik6bnVsbD09ZT9cIlwiOmU6dm9pZCAwfX0pLFMuZXh0ZW5kKHt2YWxIb29rczp7b3B0aW9uOntnZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9Uy5maW5kLmF0dHIoZSxcInZhbHVlXCIpO3JldHVybiBudWxsIT10P3Q6eXQoUy50ZXh0KGUpKX19LHNlbGVjdDp7Z2V0OmZ1bmN0aW9uKGUpe3ZhciB0LG4scixpPWUub3B0aW9ucyxvPWUuc2VsZWN0ZWRJbmRleCxhPVwic2VsZWN0LW9uZVwiPT09ZS50eXBlLHM9YT9udWxsOltdLHU9YT9vKzE6aS5sZW5ndGg7Zm9yKHI9bzwwP3U6YT9vOjA7cjx1O3IrKylpZigoKG49aVtyXSkuc2VsZWN0ZWR8fHI9PT1vKSYmIW4uZGlzYWJsZWQmJighbi5wYXJlbnROb2RlLmRpc2FibGVkfHwhQShuLnBhcmVudE5vZGUsXCJvcHRncm91cFwiKSkpe2lmKHQ9UyhuKS52YWwoKSxhKXJldHVybiB0O3MucHVzaCh0KX1yZXR1cm4gc30sc2V0OmZ1bmN0aW9uKGUsdCl7dmFyIG4scixpPWUub3B0aW9ucyxvPVMubWFrZUFycmF5KHQpLGE9aS5sZW5ndGg7d2hpbGUoYS0tKSgocj1pW2FdKS5zZWxlY3RlZD0tMTxTLmluQXJyYXkoUy52YWxIb29rcy5vcHRpb24uZ2V0KHIpLG8pKSYmKG49ITApO3JldHVybiBufHwoZS5zZWxlY3RlZEluZGV4PS0xKSxvfX19fSksUy5lYWNoKFtcInJhZGlvXCIsXCJjaGVja2JveFwiXSxmdW5jdGlvbigpe1MudmFsSG9va3NbdGhpc109e3NldDpmdW5jdGlvbihlLHQpe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIGUuY2hlY2tlZD0tMTxTLmluQXJyYXkoUyhlKS52YWwoKSx0KX19LHYuY2hlY2tPbnx8KFMudmFsSG9va3NbdGhpc10uZ2V0PWZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT09ZS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKT9cIm9uXCI6ZS52YWx1ZX0pfSksdi5mb2N1c2luPVwib25mb2N1c2luXCJpbiBDO3ZhciBidD0vXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sd3Q9ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKX07Uy5leHRlbmQoUy5ldmVudCx7dHJpZ2dlcjpmdW5jdGlvbihlLHQsbixyKXt2YXIgaSxvLGEscyx1LGwsYyxmLHA9W258fEVdLGQ9eS5jYWxsKGUsXCJ0eXBlXCIpP2UudHlwZTplLGg9eS5jYWxsKGUsXCJuYW1lc3BhY2VcIik/ZS5uYW1lc3BhY2Uuc3BsaXQoXCIuXCIpOltdO2lmKG89Zj1hPW49bnx8RSwzIT09bi5ub2RlVHlwZSYmOCE9PW4ubm9kZVR5cGUmJiFidC50ZXN0KGQrUy5ldmVudC50cmlnZ2VyZWQpJiYoLTE8ZC5pbmRleE9mKFwiLlwiKSYmKGQ9KGg9ZC5zcGxpdChcIi5cIikpLnNoaWZ0KCksaC5zb3J0KCkpLHU9ZC5pbmRleE9mKFwiOlwiKTwwJiZcIm9uXCIrZCwoZT1lW1MuZXhwYW5kb10/ZTpuZXcgUy5FdmVudChkLFwib2JqZWN0XCI9PXR5cGVvZiBlJiZlKSkuaXNUcmlnZ2VyPXI/MjozLGUubmFtZXNwYWNlPWguam9pbihcIi5cIiksZS5ybmFtZXNwYWNlPWUubmFtZXNwYWNlP25ldyBSZWdFeHAoXCIoXnxcXFxcLilcIitoLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKStcIihcXFxcLnwkKVwiKTpudWxsLGUucmVzdWx0PXZvaWQgMCxlLnRhcmdldHx8KGUudGFyZ2V0PW4pLHQ9bnVsbD09dD9bZV06Uy5tYWtlQXJyYXkodCxbZV0pLGM9Uy5ldmVudC5zcGVjaWFsW2RdfHx7fSxyfHwhYy50cmlnZ2VyfHwhMSE9PWMudHJpZ2dlci5hcHBseShuLHQpKSl7aWYoIXImJiFjLm5vQnViYmxlJiYheChuKSl7Zm9yKHM9Yy5kZWxlZ2F0ZVR5cGV8fGQsYnQudGVzdChzK2QpfHwobz1vLnBhcmVudE5vZGUpO287bz1vLnBhcmVudE5vZGUpcC5wdXNoKG8pLGE9bzthPT09KG4ub3duZXJEb2N1bWVudHx8RSkmJnAucHVzaChhLmRlZmF1bHRWaWV3fHxhLnBhcmVudFdpbmRvd3x8Qyl9aT0wO3doaWxlKChvPXBbaSsrXSkmJiFlLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpZj1vLGUudHlwZT0xPGk/czpjLmJpbmRUeXBlfHxkLChsPShZLmdldChvLFwiZXZlbnRzXCIpfHxPYmplY3QuY3JlYXRlKG51bGwpKVtlLnR5cGVdJiZZLmdldChvLFwiaGFuZGxlXCIpKSYmbC5hcHBseShvLHQpLChsPXUmJm9bdV0pJiZsLmFwcGx5JiZWKG8pJiYoZS5yZXN1bHQ9bC5hcHBseShvLHQpLCExPT09ZS5yZXN1bHQmJmUucHJldmVudERlZmF1bHQoKSk7cmV0dXJuIGUudHlwZT1kLHJ8fGUuaXNEZWZhdWx0UHJldmVudGVkKCl8fGMuX2RlZmF1bHQmJiExIT09Yy5fZGVmYXVsdC5hcHBseShwLnBvcCgpLHQpfHwhVihuKXx8dSYmbShuW2RdKSYmIXgobikmJigoYT1uW3VdKSYmKG5bdV09bnVsbCksUy5ldmVudC50cmlnZ2VyZWQ9ZCxlLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkmJmYuYWRkRXZlbnRMaXN0ZW5lcihkLHd0KSxuW2RdKCksZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpJiZmLnJlbW92ZUV2ZW50TGlzdGVuZXIoZCx3dCksUy5ldmVudC50cmlnZ2VyZWQ9dm9pZCAwLGEmJihuW3VdPWEpKSxlLnJlc3VsdH19LHNpbXVsYXRlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1TLmV4dGVuZChuZXcgUy5FdmVudCxuLHt0eXBlOmUsaXNTaW11bGF0ZWQ6ITB9KTtTLmV2ZW50LnRyaWdnZXIocixudWxsLHQpfX0pLFMuZm4uZXh0ZW5kKHt0cmlnZ2VyOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1MuZXZlbnQudHJpZ2dlcihlLHQsdGhpcyl9KX0sdHJpZ2dlckhhbmRsZXI6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzWzBdO2lmKG4pcmV0dXJuIFMuZXZlbnQudHJpZ2dlcihlLHQsbiwhMCl9fSksdi5mb2N1c2lufHxTLmVhY2goe2ZvY3VzOlwiZm9jdXNpblwiLGJsdXI6XCJmb2N1c291dFwifSxmdW5jdGlvbihuLHIpe3ZhciBpPWZ1bmN0aW9uKGUpe1MuZXZlbnQuc2ltdWxhdGUocixlLnRhcmdldCxTLmV2ZW50LmZpeChlKSl9O1MuZXZlbnQuc3BlY2lhbFtyXT17c2V0dXA6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm93bmVyRG9jdW1lbnR8fHRoaXMuZG9jdW1lbnR8fHRoaXMsdD1ZLmFjY2VzcyhlLHIpO3R8fGUuYWRkRXZlbnRMaXN0ZW5lcihuLGksITApLFkuYWNjZXNzKGUsciwodHx8MCkrMSl9LHRlYXJkb3duOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5vd25lckRvY3VtZW50fHx0aGlzLmRvY3VtZW50fHx0aGlzLHQ9WS5hY2Nlc3MoZSxyKS0xO3Q/WS5hY2Nlc3MoZSxyLHQpOihlLnJlbW92ZUV2ZW50TGlzdGVuZXIobixpLCEwKSxZLnJlbW92ZShlLHIpKX19fSk7dmFyIFR0PUMubG9jYXRpb24sQ3Q9e2d1aWQ6RGF0ZS5ub3coKX0sRXQ9L1xcPy87Uy5wYXJzZVhNTD1mdW5jdGlvbihlKXt2YXIgdCxuO2lmKCFlfHxcInN0cmluZ1wiIT10eXBlb2YgZSlyZXR1cm4gbnVsbDt0cnl7dD0obmV3IEMuRE9NUGFyc2VyKS5wYXJzZUZyb21TdHJpbmcoZSxcInRleHQveG1sXCIpfWNhdGNoKGUpe31yZXR1cm4gbj10JiZ0LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFyc2VyZXJyb3JcIilbMF0sdCYmIW58fFMuZXJyb3IoXCJJbnZhbGlkIFhNTDogXCIrKG4/Uy5tYXAobi5jaGlsZE5vZGVzLGZ1bmN0aW9uKGUpe3JldHVybiBlLnRleHRDb250ZW50fSkuam9pbihcIlxcblwiKTplKSksdH07dmFyIFN0PS9cXFtcXF0kLyxrdD0vXFxyP1xcbi9nLEF0PS9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxOdD0vXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7ZnVuY3Rpb24ganQobixlLHIsaSl7dmFyIHQ7aWYoQXJyYXkuaXNBcnJheShlKSlTLmVhY2goZSxmdW5jdGlvbihlLHQpe3J8fFN0LnRlc3Qobik/aShuLHQpOmp0KG4rXCJbXCIrKFwib2JqZWN0XCI9PXR5cGVvZiB0JiZudWxsIT10P2U6XCJcIikrXCJdXCIsdCxyLGkpfSk7ZWxzZSBpZihyfHxcIm9iamVjdFwiIT09dyhlKSlpKG4sZSk7ZWxzZSBmb3IodCBpbiBlKWp0KG4rXCJbXCIrdCtcIl1cIixlW3RdLHIsaSl9Uy5wYXJhbT1mdW5jdGlvbihlLHQpe3ZhciBuLHI9W10saT1mdW5jdGlvbihlLHQpe3ZhciBuPW0odCk/dCgpOnQ7cltyLmxlbmd0aF09ZW5jb2RlVVJJQ29tcG9uZW50KGUpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudChudWxsPT1uP1wiXCI6bil9O2lmKG51bGw9PWUpcmV0dXJuXCJcIjtpZihBcnJheS5pc0FycmF5KGUpfHxlLmpxdWVyeSYmIVMuaXNQbGFpbk9iamVjdChlKSlTLmVhY2goZSxmdW5jdGlvbigpe2kodGhpcy5uYW1lLHRoaXMudmFsdWUpfSk7ZWxzZSBmb3IobiBpbiBlKWp0KG4sZVtuXSx0LGkpO3JldHVybiByLmpvaW4oXCImXCIpfSxTLmZuLmV4dGVuZCh7c2VyaWFsaXplOmZ1bmN0aW9uKCl7cmV0dXJuIFMucGFyYW0odGhpcy5zZXJpYWxpemVBcnJheSgpKX0sc2VyaWFsaXplQXJyYXk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXt2YXIgZT1TLnByb3AodGhpcyxcImVsZW1lbnRzXCIpO3JldHVybiBlP1MubWFrZUFycmF5KGUpOnRoaXN9KS5maWx0ZXIoZnVuY3Rpb24oKXt2YXIgZT10aGlzLnR5cGU7cmV0dXJuIHRoaXMubmFtZSYmIVModGhpcykuaXMoXCI6ZGlzYWJsZWRcIikmJk50LnRlc3QodGhpcy5ub2RlTmFtZSkmJiFBdC50ZXN0KGUpJiYodGhpcy5jaGVja2VkfHwhcGUudGVzdChlKSl9KS5tYXAoZnVuY3Rpb24oZSx0KXt2YXIgbj1TKHRoaXMpLnZhbCgpO3JldHVybiBudWxsPT1uP251bGw6QXJyYXkuaXNBcnJheShuKT9TLm1hcChuLGZ1bmN0aW9uKGUpe3JldHVybntuYW1lOnQubmFtZSx2YWx1ZTplLnJlcGxhY2Uoa3QsXCJcXHJcXG5cIil9fSk6e25hbWU6dC5uYW1lLHZhbHVlOm4ucmVwbGFjZShrdCxcIlxcclxcblwiKX19KS5nZXQoKX19KTt2YXIgRHQ9LyUyMC9nLHF0PS8jLiokLyxMdD0vKFs/Jl0pXz1bXiZdKi8sSHQ9L14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9nbSxPdD0vXig/OkdFVHxIRUFEKSQvLFB0PS9eXFwvXFwvLyxSdD17fSxNdD17fSxJdD1cIiovXCIuY29uY2F0KFwiKlwiKSxXdD1FLmNyZWF0ZUVsZW1lbnQoXCJhXCIpO2Z1bmN0aW9uIEZ0KG8pe3JldHVybiBmdW5jdGlvbihlLHQpe1wic3RyaW5nXCIhPXR5cGVvZiBlJiYodD1lLGU9XCIqXCIpO3ZhciBuLHI9MCxpPWUudG9Mb3dlckNhc2UoKS5tYXRjaChQKXx8W107aWYobSh0KSl3aGlsZShuPWlbcisrXSlcIitcIj09PW5bMF0/KG49bi5zbGljZSgxKXx8XCIqXCIsKG9bbl09b1tuXXx8W10pLnVuc2hpZnQodCkpOihvW25dPW9bbl18fFtdKS5wdXNoKHQpfX1mdW5jdGlvbiAkdCh0LGksbyxhKXt2YXIgcz17fSx1PXQ9PT1NdDtmdW5jdGlvbiBsKGUpe3ZhciByO3JldHVybiBzW2VdPSEwLFMuZWFjaCh0W2VdfHxbXSxmdW5jdGlvbihlLHQpe3ZhciBuPXQoaSxvLGEpO3JldHVyblwic3RyaW5nXCIhPXR5cGVvZiBufHx1fHxzW25dP3U/IShyPW4pOnZvaWQgMDooaS5kYXRhVHlwZXMudW5zaGlmdChuKSxsKG4pLCExKX0pLHJ9cmV0dXJuIGwoaS5kYXRhVHlwZXNbMF0pfHwhc1tcIipcIl0mJmwoXCIqXCIpfWZ1bmN0aW9uIEJ0KGUsdCl7dmFyIG4scixpPVMuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zfHx7fTtmb3IobiBpbiB0KXZvaWQgMCE9PXRbbl0mJigoaVtuXT9lOnJ8fChyPXt9KSlbbl09dFtuXSk7cmV0dXJuIHImJlMuZXh0ZW5kKCEwLGUsciksZX1XdC5ocmVmPVR0LmhyZWYsUy5leHRlbmQoe2FjdGl2ZTowLGxhc3RNb2RpZmllZDp7fSxldGFnOnt9LGFqYXhTZXR0aW5nczp7dXJsOlR0LmhyZWYsdHlwZTpcIkdFVFwiLGlzTG9jYWw6L14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8udGVzdChUdC5wcm90b2NvbCksZ2xvYmFsOiEwLHByb2Nlc3NEYXRhOiEwLGFzeW5jOiEwLGNvbnRlbnRUeXBlOlwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsYWNjZXB0czp7XCIqXCI6SXQsdGV4dDpcInRleHQvcGxhaW5cIixodG1sOlwidGV4dC9odG1sXCIseG1sOlwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLGpzb246XCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIn0sY29udGVudHM6e3htbDovXFxieG1sXFxiLyxodG1sOi9cXGJodG1sLyxqc29uOi9cXGJqc29uXFxiL30scmVzcG9uc2VGaWVsZHM6e3htbDpcInJlc3BvbnNlWE1MXCIsdGV4dDpcInJlc3BvbnNlVGV4dFwiLGpzb246XCJyZXNwb25zZUpTT05cIn0sY29udmVydGVyczp7XCIqIHRleHRcIjpTdHJpbmcsXCJ0ZXh0IGh0bWxcIjohMCxcInRleHQganNvblwiOkpTT04ucGFyc2UsXCJ0ZXh0IHhtbFwiOlMucGFyc2VYTUx9LGZsYXRPcHRpb25zOnt1cmw6ITAsY29udGV4dDohMH19LGFqYXhTZXR1cDpmdW5jdGlvbihlLHQpe3JldHVybiB0P0J0KEJ0KGUsUy5hamF4U2V0dGluZ3MpLHQpOkJ0KFMuYWpheFNldHRpbmdzLGUpfSxhamF4UHJlZmlsdGVyOkZ0KFJ0KSxhamF4VHJhbnNwb3J0OkZ0KE10KSxhamF4OmZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGUmJih0PWUsZT12b2lkIDApLHQ9dHx8e307dmFyIGMsZixwLG4sZCxyLGgsZyxpLG8seT1TLmFqYXhTZXR1cCh7fSx0KSx2PXkuY29udGV4dHx8eSxtPXkuY29udGV4dCYmKHYubm9kZVR5cGV8fHYuanF1ZXJ5KT9TKHYpOlMuZXZlbnQseD1TLkRlZmVycmVkKCksYj1TLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLHc9eS5zdGF0dXNDb2RlfHx7fSxhPXt9LHM9e30sdT1cImNhbmNlbGVkXCIsVD17cmVhZHlTdGF0ZTowLGdldFJlc3BvbnNlSGVhZGVyOmZ1bmN0aW9uKGUpe3ZhciB0O2lmKGgpe2lmKCFuKXtuPXt9O3doaWxlKHQ9SHQuZXhlYyhwKSluW3RbMV0udG9Mb3dlckNhc2UoKStcIiBcIl09KG5bdFsxXS50b0xvd2VyQ2FzZSgpK1wiIFwiXXx8W10pLmNvbmNhdCh0WzJdKX10PW5bZS50b0xvd2VyQ2FzZSgpK1wiIFwiXX1yZXR1cm4gbnVsbD09dD9udWxsOnQuam9pbihcIiwgXCIpfSxnZXRBbGxSZXNwb25zZUhlYWRlcnM6ZnVuY3Rpb24oKXtyZXR1cm4gaD9wOm51bGx9LHNldFJlcXVlc3RIZWFkZXI6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbnVsbD09aCYmKGU9c1tlLnRvTG93ZXJDYXNlKCldPXNbZS50b0xvd2VyQ2FzZSgpXXx8ZSxhW2VdPXQpLHRoaXN9LG92ZXJyaWRlTWltZVR5cGU6ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PWgmJih5Lm1pbWVUeXBlPWUpLHRoaXN9LHN0YXR1c0NvZGU6ZnVuY3Rpb24oZSl7dmFyIHQ7aWYoZSlpZihoKVQuYWx3YXlzKGVbVC5zdGF0dXNdKTtlbHNlIGZvcih0IGluIGUpd1t0XT1bd1t0XSxlW3RdXTtyZXR1cm4gdGhpc30sYWJvcnQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ZXx8dTtyZXR1cm4gYyYmYy5hYm9ydCh0KSxsKDAsdCksdGhpc319O2lmKHgucHJvbWlzZShUKSx5LnVybD0oKGV8fHkudXJsfHxUdC5ocmVmKStcIlwiKS5yZXBsYWNlKFB0LFR0LnByb3RvY29sK1wiLy9cIikseS50eXBlPXQubWV0aG9kfHx0LnR5cGV8fHkubWV0aG9kfHx5LnR5cGUseS5kYXRhVHlwZXM9KHkuZGF0YVR5cGV8fFwiKlwiKS50b0xvd2VyQ2FzZSgpLm1hdGNoKFApfHxbXCJcIl0sbnVsbD09eS5jcm9zc0RvbWFpbil7cj1FLmNyZWF0ZUVsZW1lbnQoXCJhXCIpO3RyeXtyLmhyZWY9eS51cmwsci5ocmVmPXIuaHJlZix5LmNyb3NzRG9tYWluPVd0LnByb3RvY29sK1wiLy9cIitXdC5ob3N0IT1yLnByb3RvY29sK1wiLy9cIityLmhvc3R9Y2F0Y2goZSl7eS5jcm9zc0RvbWFpbj0hMH19aWYoeS5kYXRhJiZ5LnByb2Nlc3NEYXRhJiZcInN0cmluZ1wiIT10eXBlb2YgeS5kYXRhJiYoeS5kYXRhPVMucGFyYW0oeS5kYXRhLHkudHJhZGl0aW9uYWwpKSwkdChSdCx5LHQsVCksaClyZXR1cm4gVDtmb3IoaSBpbihnPVMuZXZlbnQmJnkuZ2xvYmFsKSYmMD09Uy5hY3RpdmUrKyYmUy5ldmVudC50cmlnZ2VyKFwiYWpheFN0YXJ0XCIpLHkudHlwZT15LnR5cGUudG9VcHBlckNhc2UoKSx5Lmhhc0NvbnRlbnQ9IU90LnRlc3QoeS50eXBlKSxmPXkudXJsLnJlcGxhY2UocXQsXCJcIikseS5oYXNDb250ZW50P3kuZGF0YSYmeS5wcm9jZXNzRGF0YSYmMD09PSh5LmNvbnRlbnRUeXBlfHxcIlwiKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpJiYoeS5kYXRhPXkuZGF0YS5yZXBsYWNlKER0LFwiK1wiKSk6KG89eS51cmwuc2xpY2UoZi5sZW5ndGgpLHkuZGF0YSYmKHkucHJvY2Vzc0RhdGF8fFwic3RyaW5nXCI9PXR5cGVvZiB5LmRhdGEpJiYoZis9KEV0LnRlc3QoZik/XCImXCI6XCI/XCIpK3kuZGF0YSxkZWxldGUgeS5kYXRhKSwhMT09PXkuY2FjaGUmJihmPWYucmVwbGFjZShMdCxcIiQxXCIpLG89KEV0LnRlc3QoZik/XCImXCI6XCI/XCIpK1wiXz1cIitDdC5ndWlkKysrbykseS51cmw9ZitvKSx5LmlmTW9kaWZpZWQmJihTLmxhc3RNb2RpZmllZFtmXSYmVC5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTW9kaWZpZWQtU2luY2VcIixTLmxhc3RNb2RpZmllZFtmXSksUy5ldGFnW2ZdJiZULnNldFJlcXVlc3RIZWFkZXIoXCJJZi1Ob25lLU1hdGNoXCIsUy5ldGFnW2ZdKSksKHkuZGF0YSYmeS5oYXNDb250ZW50JiYhMSE9PXkuY29udGVudFR5cGV8fHQuY29udGVudFR5cGUpJiZULnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIix5LmNvbnRlbnRUeXBlKSxULnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIix5LmRhdGFUeXBlc1swXSYmeS5hY2NlcHRzW3kuZGF0YVR5cGVzWzBdXT95LmFjY2VwdHNbeS5kYXRhVHlwZXNbMF1dKyhcIipcIiE9PXkuZGF0YVR5cGVzWzBdP1wiLCBcIitJdCtcIjsgcT0wLjAxXCI6XCJcIik6eS5hY2NlcHRzW1wiKlwiXSkseS5oZWFkZXJzKVQuc2V0UmVxdWVzdEhlYWRlcihpLHkuaGVhZGVyc1tpXSk7aWYoeS5iZWZvcmVTZW5kJiYoITE9PT15LmJlZm9yZVNlbmQuY2FsbCh2LFQseSl8fGgpKXJldHVybiBULmFib3J0KCk7aWYodT1cImFib3J0XCIsYi5hZGQoeS5jb21wbGV0ZSksVC5kb25lKHkuc3VjY2VzcyksVC5mYWlsKHkuZXJyb3IpLGM9JHQoTXQseSx0LFQpKXtpZihULnJlYWR5U3RhdGU9MSxnJiZtLnRyaWdnZXIoXCJhamF4U2VuZFwiLFtULHldKSxoKXJldHVybiBUO3kuYXN5bmMmJjA8eS50aW1lb3V0JiYoZD1DLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtULmFib3J0KFwidGltZW91dFwiKX0seS50aW1lb3V0KSk7dHJ5e2g9ITEsYy5zZW5kKGEsbCl9Y2F0Y2goZSl7aWYoaCl0aHJvdyBlO2woLTEsZSl9fWVsc2UgbCgtMSxcIk5vIFRyYW5zcG9ydFwiKTtmdW5jdGlvbiBsKGUsdCxuLHIpe3ZhciBpLG8sYSxzLHUsbD10O2h8fChoPSEwLGQmJkMuY2xlYXJUaW1lb3V0KGQpLGM9dm9pZCAwLHA9cnx8XCJcIixULnJlYWR5U3RhdGU9MDxlPzQ6MCxpPTIwMDw9ZSYmZTwzMDB8fDMwND09PWUsbiYmKHM9ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbyxhLHM9ZS5jb250ZW50cyx1PWUuZGF0YVR5cGVzO3doaWxlKFwiKlwiPT09dVswXSl1LnNoaWZ0KCksdm9pZCAwPT09ciYmKHI9ZS5taW1lVHlwZXx8dC5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKSk7aWYocilmb3IoaSBpbiBzKWlmKHNbaV0mJnNbaV0udGVzdChyKSl7dS51bnNoaWZ0KGkpO2JyZWFrfWlmKHVbMF1pbiBuKW89dVswXTtlbHNle2ZvcihpIGluIG4pe2lmKCF1WzBdfHxlLmNvbnZlcnRlcnNbaStcIiBcIit1WzBdXSl7bz1pO2JyZWFrfWF8fChhPWkpfW89b3x8YX1pZihvKXJldHVybiBvIT09dVswXSYmdS51bnNoaWZ0KG8pLG5bb119KHksVCxuKSksIWkmJi0xPFMuaW5BcnJheShcInNjcmlwdFwiLHkuZGF0YVR5cGVzKSYmUy5pbkFycmF5KFwianNvblwiLHkuZGF0YVR5cGVzKTwwJiYoeS5jb252ZXJ0ZXJzW1widGV4dCBzY3JpcHRcIl09ZnVuY3Rpb24oKXt9KSxzPWZ1bmN0aW9uKGUsdCxuLHIpe3ZhciBpLG8sYSxzLHUsbD17fSxjPWUuZGF0YVR5cGVzLnNsaWNlKCk7aWYoY1sxXSlmb3IoYSBpbiBlLmNvbnZlcnRlcnMpbFthLnRvTG93ZXJDYXNlKCldPWUuY29udmVydGVyc1thXTtvPWMuc2hpZnQoKTt3aGlsZShvKWlmKGUucmVzcG9uc2VGaWVsZHNbb10mJihuW2UucmVzcG9uc2VGaWVsZHNbb11dPXQpLCF1JiZyJiZlLmRhdGFGaWx0ZXImJih0PWUuZGF0YUZpbHRlcih0LGUuZGF0YVR5cGUpKSx1PW8sbz1jLnNoaWZ0KCkpaWYoXCIqXCI9PT1vKW89dTtlbHNlIGlmKFwiKlwiIT09dSYmdSE9PW8pe2lmKCEoYT1sW3UrXCIgXCIrb118fGxbXCIqIFwiK29dKSlmb3IoaSBpbiBsKWlmKChzPWkuc3BsaXQoXCIgXCIpKVsxXT09PW8mJihhPWxbdStcIiBcIitzWzBdXXx8bFtcIiogXCIrc1swXV0pKXshMD09PWE/YT1sW2ldOiEwIT09bFtpXSYmKG89c1swXSxjLnVuc2hpZnQoc1sxXSkpO2JyZWFrfWlmKCEwIT09YSlpZihhJiZlW1widGhyb3dzXCJdKXQ9YSh0KTtlbHNlIHRyeXt0PWEodCl9Y2F0Y2goZSl7cmV0dXJue3N0YXRlOlwicGFyc2VyZXJyb3JcIixlcnJvcjphP2U6XCJObyBjb252ZXJzaW9uIGZyb20gXCIrdStcIiB0byBcIitvfX19cmV0dXJue3N0YXRlOlwic3VjY2Vzc1wiLGRhdGE6dH19KHkscyxULGkpLGk/KHkuaWZNb2RpZmllZCYmKCh1PVQuZ2V0UmVzcG9uc2VIZWFkZXIoXCJMYXN0LU1vZGlmaWVkXCIpKSYmKFMubGFzdE1vZGlmaWVkW2ZdPXUpLCh1PVQuZ2V0UmVzcG9uc2VIZWFkZXIoXCJldGFnXCIpKSYmKFMuZXRhZ1tmXT11KSksMjA0PT09ZXx8XCJIRUFEXCI9PT15LnR5cGU/bD1cIm5vY29udGVudFwiOjMwND09PWU/bD1cIm5vdG1vZGlmaWVkXCI6KGw9cy5zdGF0ZSxvPXMuZGF0YSxpPSEoYT1zLmVycm9yKSkpOihhPWwsIWUmJmx8fChsPVwiZXJyb3JcIixlPDAmJihlPTApKSksVC5zdGF0dXM9ZSxULnN0YXR1c1RleHQ9KHR8fGwpK1wiXCIsaT94LnJlc29sdmVXaXRoKHYsW28sbCxUXSk6eC5yZWplY3RXaXRoKHYsW1QsbCxhXSksVC5zdGF0dXNDb2RlKHcpLHc9dm9pZCAwLGcmJm0udHJpZ2dlcihpP1wiYWpheFN1Y2Nlc3NcIjpcImFqYXhFcnJvclwiLFtULHksaT9vOmFdKSxiLmZpcmVXaXRoKHYsW1QsbF0pLGcmJihtLnRyaWdnZXIoXCJhamF4Q29tcGxldGVcIixbVCx5XSksLS1TLmFjdGl2ZXx8Uy5ldmVudC50cmlnZ2VyKFwiYWpheFN0b3BcIikpKX1yZXR1cm4gVH0sZ2V0SlNPTjpmdW5jdGlvbihlLHQsbil7cmV0dXJuIFMuZ2V0KGUsdCxuLFwianNvblwiKX0sZ2V0U2NyaXB0OmZ1bmN0aW9uKGUsdCl7cmV0dXJuIFMuZ2V0KGUsdm9pZCAwLHQsXCJzY3JpcHRcIil9fSksUy5lYWNoKFtcImdldFwiLFwicG9zdFwiXSxmdW5jdGlvbihlLGkpe1NbaV09ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIG0odCkmJihyPXJ8fG4sbj10LHQ9dm9pZCAwKSxTLmFqYXgoUy5leHRlbmQoe3VybDplLHR5cGU6aSxkYXRhVHlwZTpyLGRhdGE6dCxzdWNjZXNzOm59LFMuaXNQbGFpbk9iamVjdChlKSYmZSkpfX0pLFMuYWpheFByZWZpbHRlcihmdW5jdGlvbihlKXt2YXIgdDtmb3IodCBpbiBlLmhlYWRlcnMpXCJjb250ZW50LXR5cGVcIj09PXQudG9Mb3dlckNhc2UoKSYmKGUuY29udGVudFR5cGU9ZS5oZWFkZXJzW3RdfHxcIlwiKX0pLFMuX2V2YWxVcmw9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBTLmFqYXgoe3VybDplLHR5cGU6XCJHRVRcIixkYXRhVHlwZTpcInNjcmlwdFwiLGNhY2hlOiEwLGFzeW5jOiExLGdsb2JhbDohMSxjb252ZXJ0ZXJzOntcInRleHQgc2NyaXB0XCI6ZnVuY3Rpb24oKXt9fSxkYXRhRmlsdGVyOmZ1bmN0aW9uKGUpe1MuZ2xvYmFsRXZhbChlLHQsbil9fSl9LFMuZm4uZXh0ZW5kKHt3cmFwQWxsOmZ1bmN0aW9uKGUpe3ZhciB0O3JldHVybiB0aGlzWzBdJiYobShlKSYmKGU9ZS5jYWxsKHRoaXNbMF0pKSx0PVMoZSx0aGlzWzBdLm93bmVyRG9jdW1lbnQpLmVxKDApLmNsb25lKCEwKSx0aGlzWzBdLnBhcmVudE5vZGUmJnQuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pLHQubWFwKGZ1bmN0aW9uKCl7dmFyIGU9dGhpczt3aGlsZShlLmZpcnN0RWxlbWVudENoaWxkKWU9ZS5maXJzdEVsZW1lbnRDaGlsZDtyZXR1cm4gZX0pLmFwcGVuZCh0aGlzKSksdGhpc30sd3JhcElubmVyOmZ1bmN0aW9uKG4pe3JldHVybiBtKG4pP3RoaXMuZWFjaChmdW5jdGlvbihlKXtTKHRoaXMpLndyYXBJbm5lcihuLmNhbGwodGhpcyxlKSl9KTp0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZT1TKHRoaXMpLHQ9ZS5jb250ZW50cygpO3QubGVuZ3RoP3Qud3JhcEFsbChuKTplLmFwcGVuZChuKX0pfSx3cmFwOmZ1bmN0aW9uKHQpe3ZhciBuPW0odCk7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihlKXtTKHRoaXMpLndyYXBBbGwobj90LmNhbGwodGhpcyxlKTp0KX0pfSx1bndyYXA6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucGFyZW50KGUpLm5vdChcImJvZHlcIikuZWFjaChmdW5jdGlvbigpe1ModGhpcykucmVwbGFjZVdpdGgodGhpcy5jaGlsZE5vZGVzKX0pLHRoaXN9fSksUy5leHByLnBzZXVkb3MuaGlkZGVuPWZ1bmN0aW9uKGUpe3JldHVybiFTLmV4cHIucHNldWRvcy52aXNpYmxlKGUpfSxTLmV4cHIucHNldWRvcy52aXNpYmxlPWZ1bmN0aW9uKGUpe3JldHVybiEhKGUub2Zmc2V0V2lkdGh8fGUub2Zmc2V0SGVpZ2h0fHxlLmdldENsaWVudFJlY3RzKCkubGVuZ3RoKX0sUy5hamF4U2V0dGluZ3MueGhyPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiBuZXcgQy5YTUxIdHRwUmVxdWVzdH1jYXRjaChlKXt9fTt2YXIgX3Q9ezA6MjAwLDEyMjM6MjA0fSx6dD1TLmFqYXhTZXR0aW5ncy54aHIoKTt2LmNvcnM9ISF6dCYmXCJ3aXRoQ3JlZGVudGlhbHNcImluIHp0LHYuYWpheD16dD0hIXp0LFMuYWpheFRyYW5zcG9ydChmdW5jdGlvbihpKXt2YXIgbyxhO2lmKHYuY29yc3x8enQmJiFpLmNyb3NzRG9tYWluKXJldHVybntzZW5kOmZ1bmN0aW9uKGUsdCl7dmFyIG4scj1pLnhocigpO2lmKHIub3BlbihpLnR5cGUsaS51cmwsaS5hc3luYyxpLnVzZXJuYW1lLGkucGFzc3dvcmQpLGkueGhyRmllbGRzKWZvcihuIGluIGkueGhyRmllbGRzKXJbbl09aS54aHJGaWVsZHNbbl07Zm9yKG4gaW4gaS5taW1lVHlwZSYmci5vdmVycmlkZU1pbWVUeXBlJiZyLm92ZXJyaWRlTWltZVR5cGUoaS5taW1lVHlwZSksaS5jcm9zc0RvbWFpbnx8ZVtcIlgtUmVxdWVzdGVkLVdpdGhcIl18fChlW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXT1cIlhNTEh0dHBSZXF1ZXN0XCIpLGUpci5zZXRSZXF1ZXN0SGVhZGVyKG4sZVtuXSk7bz1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oKXtvJiYobz1hPXIub25sb2FkPXIub25lcnJvcj1yLm9uYWJvcnQ9ci5vbnRpbWVvdXQ9ci5vbnJlYWR5c3RhdGVjaGFuZ2U9bnVsbCxcImFib3J0XCI9PT1lP3IuYWJvcnQoKTpcImVycm9yXCI9PT1lP1wibnVtYmVyXCIhPXR5cGVvZiByLnN0YXR1cz90KDAsXCJlcnJvclwiKTp0KHIuc3RhdHVzLHIuc3RhdHVzVGV4dCk6dChfdFtyLnN0YXR1c118fHIuc3RhdHVzLHIuc3RhdHVzVGV4dCxcInRleHRcIiE9PShyLnJlc3BvbnNlVHlwZXx8XCJ0ZXh0XCIpfHxcInN0cmluZ1wiIT10eXBlb2Ygci5yZXNwb25zZVRleHQ/e2JpbmFyeTpyLnJlc3BvbnNlfTp7dGV4dDpyLnJlc3BvbnNlVGV4dH0sci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpfX0sci5vbmxvYWQ9bygpLGE9ci5vbmVycm9yPXIub250aW1lb3V0PW8oXCJlcnJvclwiKSx2b2lkIDAhPT1yLm9uYWJvcnQ/ci5vbmFib3J0PWE6ci5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXs0PT09ci5yZWFkeVN0YXRlJiZDLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtvJiZhKCl9KX0sbz1vKFwiYWJvcnRcIik7dHJ5e3Iuc2VuZChpLmhhc0NvbnRlbnQmJmkuZGF0YXx8bnVsbCl9Y2F0Y2goZSl7aWYobyl0aHJvdyBlfX0sYWJvcnQ6ZnVuY3Rpb24oKXtvJiZvKCl9fX0pLFMuYWpheFByZWZpbHRlcihmdW5jdGlvbihlKXtlLmNyb3NzRG9tYWluJiYoZS5jb250ZW50cy5zY3JpcHQ9ITEpfSksUy5hamF4U2V0dXAoe2FjY2VwdHM6e3NjcmlwdDpcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJ9LGNvbnRlbnRzOntzY3JpcHQ6L1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvfSxjb252ZXJ0ZXJzOntcInRleHQgc2NyaXB0XCI6ZnVuY3Rpb24oZSl7cmV0dXJuIFMuZ2xvYmFsRXZhbChlKSxlfX19KSxTLmFqYXhQcmVmaWx0ZXIoXCJzY3JpcHRcIixmdW5jdGlvbihlKXt2b2lkIDA9PT1lLmNhY2hlJiYoZS5jYWNoZT0hMSksZS5jcm9zc0RvbWFpbiYmKGUudHlwZT1cIkdFVFwiKX0pLFMuYWpheFRyYW5zcG9ydChcInNjcmlwdFwiLGZ1bmN0aW9uKG4pe3ZhciByLGk7aWYobi5jcm9zc0RvbWFpbnx8bi5zY3JpcHRBdHRycylyZXR1cm57c2VuZDpmdW5jdGlvbihlLHQpe3I9UyhcIjxzY3JpcHQ+XCIpLmF0dHIobi5zY3JpcHRBdHRyc3x8e30pLnByb3Aoe2NoYXJzZXQ6bi5zY3JpcHRDaGFyc2V0LHNyYzpuLnVybH0pLm9uKFwibG9hZCBlcnJvclwiLGk9ZnVuY3Rpb24oZSl7ci5yZW1vdmUoKSxpPW51bGwsZSYmdChcImVycm9yXCI9PT1lLnR5cGU/NDA0OjIwMCxlLnR5cGUpfSksRS5oZWFkLmFwcGVuZENoaWxkKHJbMF0pfSxhYm9ydDpmdW5jdGlvbigpe2kmJmkoKX19fSk7dmFyIFV0LFh0PVtdLFZ0PS8oPSlcXD8oPz0mfCQpfFxcP1xcPy87Uy5hamF4U2V0dXAoe2pzb25wOlwiY2FsbGJhY2tcIixqc29ucENhbGxiYWNrOmZ1bmN0aW9uKCl7dmFyIGU9WHQucG9wKCl8fFMuZXhwYW5kbytcIl9cIitDdC5ndWlkKys7cmV0dXJuIHRoaXNbZV09ITAsZX19KSxTLmFqYXhQcmVmaWx0ZXIoXCJqc29uIGpzb25wXCIsZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbyxhPSExIT09ZS5qc29ucCYmKFZ0LnRlc3QoZS51cmwpP1widXJsXCI6XCJzdHJpbmdcIj09dHlwZW9mIGUuZGF0YSYmMD09PShlLmNvbnRlbnRUeXBlfHxcIlwiKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpJiZWdC50ZXN0KGUuZGF0YSkmJlwiZGF0YVwiKTtpZihhfHxcImpzb25wXCI9PT1lLmRhdGFUeXBlc1swXSlyZXR1cm4gcj1lLmpzb25wQ2FsbGJhY2s9bShlLmpzb25wQ2FsbGJhY2spP2UuanNvbnBDYWxsYmFjaygpOmUuanNvbnBDYWxsYmFjayxhP2VbYV09ZVthXS5yZXBsYWNlKFZ0LFwiJDFcIityKTohMSE9PWUuanNvbnAmJihlLnVybCs9KEV0LnRlc3QoZS51cmwpP1wiJlwiOlwiP1wiKStlLmpzb25wK1wiPVwiK3IpLGUuY29udmVydGVyc1tcInNjcmlwdCBqc29uXCJdPWZ1bmN0aW9uKCl7cmV0dXJuIG98fFMuZXJyb3IocitcIiB3YXMgbm90IGNhbGxlZFwiKSxvWzBdfSxlLmRhdGFUeXBlc1swXT1cImpzb25cIixpPUNbcl0sQ1tyXT1mdW5jdGlvbigpe289YXJndW1lbnRzfSxuLmFsd2F5cyhmdW5jdGlvbigpe3ZvaWQgMD09PWk/UyhDKS5yZW1vdmVQcm9wKHIpOkNbcl09aSxlW3JdJiYoZS5qc29ucENhbGxiYWNrPXQuanNvbnBDYWxsYmFjayxYdC5wdXNoKHIpKSxvJiZtKGkpJiZpKG9bMF0pLG89aT12b2lkIDB9KSxcInNjcmlwdFwifSksdi5jcmVhdGVIVE1MRG9jdW1lbnQ9KChVdD1FLmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcIlwiKS5ib2R5KS5pbm5lckhUTUw9XCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiLDI9PT1VdC5jaGlsZE5vZGVzLmxlbmd0aCksUy5wYXJzZUhUTUw9ZnVuY3Rpb24oZSx0LG4pe3JldHVyblwic3RyaW5nXCIhPXR5cGVvZiBlP1tdOihcImJvb2xlYW5cIj09dHlwZW9mIHQmJihuPXQsdD0hMSksdHx8KHYuY3JlYXRlSFRNTERvY3VtZW50Pygocj0odD1FLmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcIlwiKSkuY3JlYXRlRWxlbWVudChcImJhc2VcIikpLmhyZWY9RS5sb2NhdGlvbi5ocmVmLHQuaGVhZC5hcHBlbmRDaGlsZChyKSk6dD1FKSxvPSFuJiZbXSwoaT1OLmV4ZWMoZSkpP1t0LmNyZWF0ZUVsZW1lbnQoaVsxXSldOihpPXhlKFtlXSx0LG8pLG8mJm8ubGVuZ3RoJiZTKG8pLnJlbW92ZSgpLFMubWVyZ2UoW10saS5jaGlsZE5vZGVzKSkpO3ZhciByLGksb30sUy5mbi5sb2FkPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcixpLG8sYT10aGlzLHM9ZS5pbmRleE9mKFwiIFwiKTtyZXR1cm4tMTxzJiYocj15dChlLnNsaWNlKHMpKSxlPWUuc2xpY2UoMCxzKSksbSh0KT8obj10LHQ9dm9pZCAwKTp0JiZcIm9iamVjdFwiPT10eXBlb2YgdCYmKGk9XCJQT1NUXCIpLDA8YS5sZW5ndGgmJlMuYWpheCh7dXJsOmUsdHlwZTppfHxcIkdFVFwiLGRhdGFUeXBlOlwiaHRtbFwiLGRhdGE6dH0pLmRvbmUoZnVuY3Rpb24oZSl7bz1hcmd1bWVudHMsYS5odG1sKHI/UyhcIjxkaXY+XCIpLmFwcGVuZChTLnBhcnNlSFRNTChlKSkuZmluZChyKTplKX0pLmFsd2F5cyhuJiZmdW5jdGlvbihlLHQpe2EuZWFjaChmdW5jdGlvbigpe24uYXBwbHkodGhpcyxvfHxbZS5yZXNwb25zZVRleHQsdCxlXSl9KX0pLHRoaXN9LFMuZXhwci5wc2V1ZG9zLmFuaW1hdGVkPWZ1bmN0aW9uKHQpe3JldHVybiBTLmdyZXAoUy50aW1lcnMsZnVuY3Rpb24oZSl7cmV0dXJuIHQ9PT1lLmVsZW19KS5sZW5ndGh9LFMub2Zmc2V0PXtzZXRPZmZzZXQ6ZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbyxhLHMsdSxsPVMuY3NzKGUsXCJwb3NpdGlvblwiKSxjPVMoZSksZj17fTtcInN0YXRpY1wiPT09bCYmKGUuc3R5bGUucG9zaXRpb249XCJyZWxhdGl2ZVwiKSxzPWMub2Zmc2V0KCksbz1TLmNzcyhlLFwidG9wXCIpLHU9Uy5jc3MoZSxcImxlZnRcIiksKFwiYWJzb2x1dGVcIj09PWx8fFwiZml4ZWRcIj09PWwpJiYtMTwobyt1KS5pbmRleE9mKFwiYXV0b1wiKT8oYT0ocj1jLnBvc2l0aW9uKCkpLnRvcCxpPXIubGVmdCk6KGE9cGFyc2VGbG9hdChvKXx8MCxpPXBhcnNlRmxvYXQodSl8fDApLG0odCkmJih0PXQuY2FsbChlLG4sUy5leHRlbmQoe30scykpKSxudWxsIT10LnRvcCYmKGYudG9wPXQudG9wLXMudG9wK2EpLG51bGwhPXQubGVmdCYmKGYubGVmdD10LmxlZnQtcy5sZWZ0K2kpLFwidXNpbmdcImluIHQ/dC51c2luZy5jYWxsKGUsZik6Yy5jc3MoZil9fSxTLmZuLmV4dGVuZCh7b2Zmc2V0OmZ1bmN0aW9uKHQpe2lmKGFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHZvaWQgMD09PXQ/dGhpczp0aGlzLmVhY2goZnVuY3Rpb24oZSl7Uy5vZmZzZXQuc2V0T2Zmc2V0KHRoaXMsdCxlKX0pO3ZhciBlLG4scj10aGlzWzBdO3JldHVybiByP3IuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGg/KGU9ci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxuPXIub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldyx7dG9wOmUudG9wK24ucGFnZVlPZmZzZXQsbGVmdDplLmxlZnQrbi5wYWdlWE9mZnNldH0pOnt0b3A6MCxsZWZ0OjB9OnZvaWQgMH0scG9zaXRpb246ZnVuY3Rpb24oKXtpZih0aGlzWzBdKXt2YXIgZSx0LG4scj10aGlzWzBdLGk9e3RvcDowLGxlZnQ6MH07aWYoXCJmaXhlZFwiPT09Uy5jc3MocixcInBvc2l0aW9uXCIpKXQ9ci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtlbHNle3Q9dGhpcy5vZmZzZXQoKSxuPXIub3duZXJEb2N1bWVudCxlPXIub2Zmc2V0UGFyZW50fHxuLmRvY3VtZW50RWxlbWVudDt3aGlsZShlJiYoZT09PW4uYm9keXx8ZT09PW4uZG9jdW1lbnRFbGVtZW50KSYmXCJzdGF0aWNcIj09PVMuY3NzKGUsXCJwb3NpdGlvblwiKSllPWUucGFyZW50Tm9kZTtlJiZlIT09ciYmMT09PWUubm9kZVR5cGUmJigoaT1TKGUpLm9mZnNldCgpKS50b3ArPVMuY3NzKGUsXCJib3JkZXJUb3BXaWR0aFwiLCEwKSxpLmxlZnQrPVMuY3NzKGUsXCJib3JkZXJMZWZ0V2lkdGhcIiwhMCkpfXJldHVybnt0b3A6dC50b3AtaS50b3AtUy5jc3MocixcIm1hcmdpblRvcFwiLCEwKSxsZWZ0OnQubGVmdC1pLmxlZnQtUy5jc3MocixcIm1hcmdpbkxlZnRcIiwhMCl9fX0sb2Zmc2V0UGFyZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5vZmZzZXRQYXJlbnQ7d2hpbGUoZSYmXCJzdGF0aWNcIj09PVMuY3NzKGUsXCJwb3NpdGlvblwiKSllPWUub2Zmc2V0UGFyZW50O3JldHVybiBlfHxyZX0pfX0pLFMuZWFjaCh7c2Nyb2xsTGVmdDpcInBhZ2VYT2Zmc2V0XCIsc2Nyb2xsVG9wOlwicGFnZVlPZmZzZXRcIn0sZnVuY3Rpb24odCxpKXt2YXIgbz1cInBhZ2VZT2Zmc2V0XCI9PT1pO1MuZm5bdF09ZnVuY3Rpb24oZSl7cmV0dXJuIEIodGhpcyxmdW5jdGlvbihlLHQsbil7dmFyIHI7aWYoeChlKT9yPWU6OT09PWUubm9kZVR5cGUmJihyPWUuZGVmYXVsdFZpZXcpLHZvaWQgMD09PW4pcmV0dXJuIHI/cltpXTplW3RdO3I/ci5zY3JvbGxUbyhvP3IucGFnZVhPZmZzZXQ6bixvP246ci5wYWdlWU9mZnNldCk6ZVt0XT1ufSx0LGUsYXJndW1lbnRzLmxlbmd0aCl9fSksUy5lYWNoKFtcInRvcFwiLFwibGVmdFwiXSxmdW5jdGlvbihlLG4pe1MuY3NzSG9va3Nbbl09X2Uodi5waXhlbFBvc2l0aW9uLGZ1bmN0aW9uKGUsdCl7aWYodClyZXR1cm4gdD1CZShlLG4pLFBlLnRlc3QodCk/UyhlKS5wb3NpdGlvbigpW25dK1wicHhcIjp0fSl9KSxTLmVhY2goe0hlaWdodDpcImhlaWdodFwiLFdpZHRoOlwid2lkdGhcIn0sZnVuY3Rpb24oYSxzKXtTLmVhY2goe3BhZGRpbmc6XCJpbm5lclwiK2EsY29udGVudDpzLFwiXCI6XCJvdXRlclwiK2F9LGZ1bmN0aW9uKHIsbyl7Uy5mbltvXT1mdW5jdGlvbihlLHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGgmJihyfHxcImJvb2xlYW5cIiE9dHlwZW9mIGUpLGk9cnx8KCEwPT09ZXx8ITA9PT10P1wibWFyZ2luXCI6XCJib3JkZXJcIik7cmV0dXJuIEIodGhpcyxmdW5jdGlvbihlLHQsbil7dmFyIHI7cmV0dXJuIHgoZSk/MD09PW8uaW5kZXhPZihcIm91dGVyXCIpP2VbXCJpbm5lclwiK2FdOmUuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W1wiY2xpZW50XCIrYV06OT09PWUubm9kZVR5cGU/KHI9ZS5kb2N1bWVudEVsZW1lbnQsTWF0aC5tYXgoZS5ib2R5W1wic2Nyb2xsXCIrYV0scltcInNjcm9sbFwiK2FdLGUuYm9keVtcIm9mZnNldFwiK2FdLHJbXCJvZmZzZXRcIithXSxyW1wiY2xpZW50XCIrYV0pKTp2b2lkIDA9PT1uP1MuY3NzKGUsdCxpKTpTLnN0eWxlKGUsdCxuLGkpfSxzLG4/ZTp2b2lkIDAsbil9fSl9KSxTLmVhY2goW1wiYWpheFN0YXJ0XCIsXCJhamF4U3RvcFwiLFwiYWpheENvbXBsZXRlXCIsXCJhamF4RXJyb3JcIixcImFqYXhTdWNjZXNzXCIsXCJhamF4U2VuZFwiXSxmdW5jdGlvbihlLHQpe1MuZm5bdF09ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMub24odCxlKX19KSxTLmZuLmV4dGVuZCh7YmluZDpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHRoaXMub24oZSxudWxsLHQsbil9LHVuYmluZDpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLm9mZihlLG51bGwsdCl9LGRlbGVnYXRlOmZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiB0aGlzLm9uKHQsZSxuLHIpfSx1bmRlbGVnYXRlOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gMT09PWFyZ3VtZW50cy5sZW5ndGg/dGhpcy5vZmYoZSxcIioqXCIpOnRoaXMub2ZmKHQsZXx8XCIqKlwiLG4pfSxob3ZlcjpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLm1vdXNlZW50ZXIoZSkubW91c2VsZWF2ZSh0fHxlKX19KSxTLmVhY2goXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIuc3BsaXQoXCIgXCIpLGZ1bmN0aW9uKGUsbil7Uy5mbltuXT1mdW5jdGlvbihlLHQpe3JldHVybiAwPGFyZ3VtZW50cy5sZW5ndGg/dGhpcy5vbihuLG51bGwsZSx0KTp0aGlzLnRyaWdnZXIobil9fSk7dmFyIEd0PS9eW1xcc1xcdUZFRkZcXHhBMF0rfChbXlxcc1xcdUZFRkZcXHhBMF0pW1xcc1xcdUZFRkZcXHhBMF0rJC9nO1MucHJveHk9ZnVuY3Rpb24oZSx0KXt2YXIgbixyLGk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQmJihuPWVbdF0sdD1lLGU9biksbShlKSlyZXR1cm4gcj1zLmNhbGwoYXJndW1lbnRzLDIpLChpPWZ1bmN0aW9uKCl7cmV0dXJuIGUuYXBwbHkodHx8dGhpcyxyLmNvbmNhdChzLmNhbGwoYXJndW1lbnRzKSkpfSkuZ3VpZD1lLmd1aWQ9ZS5ndWlkfHxTLmd1aWQrKyxpfSxTLmhvbGRSZWFkeT1mdW5jdGlvbihlKXtlP1MucmVhZHlXYWl0Kys6Uy5yZWFkeSghMCl9LFMuaXNBcnJheT1BcnJheS5pc0FycmF5LFMucGFyc2VKU09OPUpTT04ucGFyc2UsUy5ub2RlTmFtZT1BLFMuaXNGdW5jdGlvbj1tLFMuaXNXaW5kb3c9eCxTLmNhbWVsQ2FzZT1YLFMudHlwZT13LFMubm93PURhdGUubm93LFMuaXNOdW1lcmljPWZ1bmN0aW9uKGUpe3ZhciB0PVMudHlwZShlKTtyZXR1cm4oXCJudW1iZXJcIj09PXR8fFwic3RyaW5nXCI9PT10KSYmIWlzTmFOKGUtcGFyc2VGbG9hdChlKSl9LFMudHJpbT1mdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09ZT9cIlwiOihlK1wiXCIpLnJlcGxhY2UoR3QsXCIkMVwiKX0sXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kJiZkZWZpbmUoXCJqcXVlcnlcIixbXSxmdW5jdGlvbigpe3JldHVybiBTfSk7dmFyIFl0PUMualF1ZXJ5LFF0PUMuJDtyZXR1cm4gUy5ub0NvbmZsaWN0PWZ1bmN0aW9uKGUpe3JldHVybiBDLiQ9PT1TJiYoQy4kPVF0KSxlJiZDLmpRdWVyeT09PVMmJihDLmpRdWVyeT1ZdCksU30sXCJ1bmRlZmluZWRcIj09dHlwZW9mIGUmJihDLmpRdWVyeT1DLiQ9UyksU30pOyIsIi8qKlxyXG4gKiBTd2lwZXIgOC40LjdcclxuICogTW9zdCBtb2Rlcm4gbW9iaWxlIHRvdWNoIHNsaWRlciBhbmQgZnJhbWV3b3JrIHdpdGggaGFyZHdhcmUgYWNjZWxlcmF0ZWQgdHJhbnNpdGlvbnNcclxuICogaHR0cHM6Ly9zd2lwZXJqcy5jb21cclxuICpcclxuICogQ29weXJpZ2h0IDIwMTQtMjAyMyBWbGFkaW1pciBLaGFybGFtcGlkaVxyXG4gKlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcclxuICpcclxuICogUmVsZWFzZWQgb246IEphbnVhcnkgMzAsIDIwMjNcclxuICovXHJcblxyXG4hZnVuY3Rpb24gKGUsIHQpIHtcclxuICAgIFwib2JqZWN0XCIgPT0gdHlwZW9mIGV4cG9ydHMgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgbW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgPSB0KCkgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKHQpIDogKGUgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcyA6IGUgfHwgc2VsZikuU3dpcGVyID0gdCgpXHJcbn0odGhpcywgKGZ1bmN0aW9uICgpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIGZ1bmN0aW9uIGUoZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsICE9PSBlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgJiYgXCJjb25zdHJ1Y3RvclwiIGluIGUgJiYgZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdChzLCBhKSB7XHJcbiAgICAgICAgdm9pZCAwID09PSBzICYmIChzID0ge30pLCB2b2lkIDAgPT09IGEgJiYgKGEgPSB7fSksIE9iamVjdC5rZXlzKGEpLmZvckVhY2goKGkgPT4ge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IHNbaV0gPyBzW2ldID0gYVtpXSA6IGUoYVtpXSkgJiYgZShzW2ldKSAmJiBPYmplY3Qua2V5cyhhW2ldKS5sZW5ndGggPiAwICYmIHQoc1tpXSwgYVtpXSlcclxuICAgICAgICB9KSlcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzID0ge1xyXG4gICAgICAgIGJvZHk6IHt9LFxyXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoKSB7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCkge1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWN0aXZlRWxlbWVudDoge1xyXG4gICAgICAgICAgICBibHVyKCkge1xyXG4gICAgICAgICAgICB9LCBub2RlTmFtZTogXCJcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcXVlcnlTZWxlY3RvcjogKCkgPT4gbnVsbCxcclxuICAgICAgICBxdWVyeVNlbGVjdG9yQWxsOiAoKSA9PiBbXSxcclxuICAgICAgICBnZXRFbGVtZW50QnlJZDogKCkgPT4gbnVsbCxcclxuICAgICAgICBjcmVhdGVFdmVudDogKCkgPT4gKHtcclxuICAgICAgICAgICAgaW5pdEV2ZW50KCkge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgY3JlYXRlRWxlbWVudDogKCkgPT4gKHtcclxuICAgICAgICAgICAgY2hpbGRyZW46IFtdLCBjaGlsZE5vZGVzOiBbXSwgc3R5bGU6IHt9LCBzZXRBdHRyaWJ1dGUoKSB7XHJcbiAgICAgICAgICAgIH0sIGdldEVsZW1lbnRzQnlUYWdOYW1lOiAoKSA9PiBbXVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGNyZWF0ZUVsZW1lbnROUzogKCkgPT4gKHt9KSxcclxuICAgICAgICBpbXBvcnROb2RlOiAoKSA9PiBudWxsLFxyXG4gICAgICAgIGxvY2F0aW9uOiB7aGFzaDogXCJcIiwgaG9zdDogXCJcIiwgaG9zdG5hbWU6IFwiXCIsIGhyZWY6IFwiXCIsIG9yaWdpbjogXCJcIiwgcGF0aG5hbWU6IFwiXCIsIHByb3RvY29sOiBcIlwiLCBzZWFyY2g6IFwiXCJ9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGEoKSB7XHJcbiAgICAgICAgY29uc3QgZSA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGRvY3VtZW50ID8gZG9jdW1lbnQgOiB7fTtcclxuICAgICAgICByZXR1cm4gdChlLCBzKSwgZVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGkgPSB7XHJcbiAgICAgICAgZG9jdW1lbnQ6IHMsXHJcbiAgICAgICAgbmF2aWdhdG9yOiB7dXNlckFnZW50OiBcIlwifSxcclxuICAgICAgICBsb2NhdGlvbjoge2hhc2g6IFwiXCIsIGhvc3Q6IFwiXCIsIGhvc3RuYW1lOiBcIlwiLCBocmVmOiBcIlwiLCBvcmlnaW46IFwiXCIsIHBhdGhuYW1lOiBcIlwiLCBwcm90b2NvbDogXCJcIiwgc2VhcmNoOiBcIlwifSxcclxuICAgICAgICBoaXN0b3J5OiB7XHJcbiAgICAgICAgICAgIHJlcGxhY2VTdGF0ZSgpIHtcclxuICAgICAgICAgICAgfSwgcHVzaFN0YXRlKCkge1xyXG4gICAgICAgICAgICB9LCBnbygpIHtcclxuICAgICAgICAgICAgfSwgYmFjaygpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgQ3VzdG9tRXZlbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoKSB7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCkge1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZTogKCkgPT4gKHtnZXRQcm9wZXJ0eVZhbHVlOiAoKSA9PiBcIlwifSksXHJcbiAgICAgICAgSW1hZ2UoKSB7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBEYXRlKCkge1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2NyZWVuOiB7fSxcclxuICAgICAgICBzZXRUaW1lb3V0KCkge1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KCkge1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWF0Y2hNZWRpYTogKCkgPT4gKHt9KSxcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IGUgPT4gXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2Ygc2V0VGltZW91dCA/IChlKCksIG51bGwpIDogc2V0VGltZW91dChlLCAwKSxcclxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShlKSB7XHJcbiAgICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHNldFRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KGUpXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiByKCkge1xyXG4gICAgICAgIGNvbnN0IGUgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgPyB3aW5kb3cgOiB7fTtcclxuICAgICAgICByZXR1cm4gdChlLCBpKSwgZVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIG4gZXh0ZW5kcyBBcnJheSB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoZSkge1xyXG4gICAgICAgICAgICBcIm51bWJlclwiID09IHR5cGVvZiBlID8gc3VwZXIoZSkgOiAoc3VwZXIoLi4uZSB8fCBbXSksIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gZS5fX3Byb3RvX187XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX3Byb3RvX19cIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4gdCwgc2V0KGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdC5fX3Byb3RvX18gPSBlXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSh0aGlzKSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbChlKSB7XHJcbiAgICAgICAgdm9pZCAwID09PSBlICYmIChlID0gW10pO1xyXG4gICAgICAgIGNvbnN0IHQgPSBbXTtcclxuICAgICAgICByZXR1cm4gZS5mb3JFYWNoKChlID0+IHtcclxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShlKSA/IHQucHVzaCguLi5sKGUpKSA6IHQucHVzaChlKVxyXG4gICAgICAgIH0pKSwgdFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG8oZSwgdCkge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoZSwgdClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkKGUsIHQpIHtcclxuICAgICAgICBjb25zdCBzID0gcigpLCBpID0gYSgpO1xyXG4gICAgICAgIGxldCBsID0gW107XHJcbiAgICAgICAgaWYgKCF0ICYmIGUgaW5zdGFuY2VvZiBuKSByZXR1cm4gZTtcclxuICAgICAgICBpZiAoIWUpIHJldHVybiBuZXcgbihsKTtcclxuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzID0gZS50cmltKCk7XHJcbiAgICAgICAgICAgIGlmIChzLmluZGV4T2YoXCI8XCIpID49IDAgJiYgcy5pbmRleE9mKFwiPlwiKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZSA9IFwiZGl2XCI7XHJcbiAgICAgICAgICAgICAgICAwID09PSBzLmluZGV4T2YoXCI8bGlcIikgJiYgKGUgPSBcInVsXCIpLCAwID09PSBzLmluZGV4T2YoXCI8dHJcIikgJiYgKGUgPSBcInRib2R5XCIpLCAwICE9PSBzLmluZGV4T2YoXCI8dGRcIikgJiYgMCAhPT0gcy5pbmRleE9mKFwiPHRoXCIpIHx8IChlID0gXCJ0clwiKSwgMCA9PT0gcy5pbmRleE9mKFwiPHRib2R5XCIpICYmIChlID0gXCJ0YWJsZVwiKSwgMCA9PT0gcy5pbmRleE9mKFwiPG9wdGlvblwiKSAmJiAoZSA9IFwic2VsZWN0XCIpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IGkuY3JlYXRlRWxlbWVudChlKTtcclxuICAgICAgICAgICAgICAgIHQuaW5uZXJIVE1MID0gcztcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgdC5jaGlsZE5vZGVzLmxlbmd0aDsgZSArPSAxKSBsLnB1c2godC5jaGlsZE5vZGVzW2VdKVxyXG4gICAgICAgICAgICB9IGVsc2UgbCA9IGZ1bmN0aW9uIChlLCB0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSkgcmV0dXJuIFtlXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBbXSwgYSA9IHQucXVlcnlTZWxlY3RvckFsbChlKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgYS5sZW5ndGg7IGUgKz0gMSkgcy5wdXNoKGFbZV0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNcclxuICAgICAgICAgICAgfShlLnRyaW0oKSwgdCB8fCBpKVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZS5ub2RlVHlwZSB8fCBlID09PSBzIHx8IGUgPT09IGkpIGwucHVzaChlKTsgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xyXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIG4pIHJldHVybiBlO1xyXG4gICAgICAgICAgICBsID0gZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IG4oZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgY29uc3QgdCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IGUubGVuZ3RoOyBzICs9IDEpIC0xID09PSB0LmluZGV4T2YoZVtzXSkgJiYgdC5wdXNoKGVbc10pO1xyXG4gICAgICAgICAgICByZXR1cm4gdFxyXG4gICAgICAgIH0obCkpXHJcbiAgICB9XHJcblxyXG4gICAgZC5mbiA9IG4ucHJvdG90eXBlO1xyXG4gICAgY29uc3QgYyA9IHtcclxuICAgICAgICBhZGRDbGFzczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShlKSwgcyA9IDA7IHMgPCBlOyBzKyspIHRbc10gPSBhcmd1bWVudHNbc107XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSBsKHQubWFwKChlID0+IGUuc3BsaXQoXCIgXCIpKSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgIGUuY2xhc3NMaXN0LmFkZCguLi5hKVxyXG4gICAgICAgICAgICB9KSksIHRoaXNcclxuICAgICAgICB9LCByZW1vdmVDbGFzczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShlKSwgcyA9IDA7IHMgPCBlOyBzKyspIHRbc10gPSBhcmd1bWVudHNbc107XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSBsKHQubWFwKChlID0+IGUuc3BsaXQoXCIgXCIpKSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgIGUuY2xhc3NMaXN0LnJlbW92ZSguLi5hKVxyXG4gICAgICAgICAgICB9KSksIHRoaXNcclxuICAgICAgICB9LCBoYXNDbGFzczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShlKSwgcyA9IDA7IHMgPCBlOyBzKyspIHRbc10gPSBhcmd1bWVudHNbc107XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSBsKHQubWFwKChlID0+IGUuc3BsaXQoXCIgXCIpKSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbyh0aGlzLCAoZSA9PiBhLmZpbHRlcigodCA9PiBlLmNsYXNzTGlzdC5jb250YWlucyh0KSkpLmxlbmd0aCA+IDApKS5sZW5ndGggPiAwXHJcbiAgICAgICAgfSwgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoZSksIHMgPSAwOyBzIDwgZTsgcysrKSB0W3NdID0gYXJndW1lbnRzW3NdO1xyXG4gICAgICAgICAgICBjb25zdCBhID0gbCh0Lm1hcCgoZSA9PiBlLnNwbGl0KFwiIFwiKSkpKTtcclxuICAgICAgICAgICAgdGhpcy5mb3JFYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgIGEuZm9yRWFjaCgodCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5jbGFzc0xpc3QudG9nZ2xlKHQpXHJcbiAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgfSwgYXR0cjogZnVuY3Rpb24gKGUsIHQpIHtcclxuICAgICAgICAgICAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGggJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkgcmV0dXJuIHRoaXNbMF0gPyB0aGlzWzBdLmdldEF0dHJpYnV0ZShlKSA6IHZvaWQgMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCB0aGlzLmxlbmd0aDsgcyArPSAxKSBpZiAoMiA9PT0gYXJndW1lbnRzLmxlbmd0aCkgdGhpc1tzXS5zZXRBdHRyaWJ1dGUoZSwgdCk7IGVsc2UgZm9yIChjb25zdCB0IGluIGUpIHRoaXNbc11bdF0gPSBlW3RdLCB0aGlzW3NdLnNldEF0dHJpYnV0ZSh0LCBlW3RdKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCByZW1vdmVBdHRyOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRoaXMubGVuZ3RoOyB0ICs9IDEpIHRoaXNbdF0ucmVtb3ZlQXR0cmlidXRlKGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHRyYW5zZm9ybTogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLmxlbmd0aDsgdCArPSAxKSB0aGlzW3RdLnN0eWxlLnRyYW5zZm9ybSA9IGU7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgdHJhbnNpdGlvbjogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLmxlbmd0aDsgdCArPSAxKSB0aGlzW3RdLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IFwic3RyaW5nXCIgIT0gdHlwZW9mIGUgPyBgJHtlfW1zYCA6IGU7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgZSA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkoZSksIHMgPSAwOyBzIDwgZTsgcysrKSB0W3NdID0gYXJndW1lbnRzW3NdO1xyXG4gICAgICAgICAgICBsZXQgW2EsIGksIHIsIG5dID0gdDtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGwoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IGUudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0KSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gZS50YXJnZXQuZG9tN0V2ZW50RGF0YSB8fCBbXTtcclxuICAgICAgICAgICAgICAgIGlmIChzLmluZGV4T2YoZSkgPCAwICYmIHMudW5zaGlmdChlKSwgZCh0KS5pcyhpKSkgci5hcHBseSh0LCBzKTsgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGQodCkucGFyZW50cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQgKz0gMSkgZChlW3RdKS5pcyhpKSAmJiByLmFwcGx5KGVbdF0sIHMpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIG8oZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IGUgJiYgZS50YXJnZXQgJiYgZS50YXJnZXQuZG9tN0V2ZW50RGF0YSB8fCBbXTtcclxuICAgICAgICAgICAgICAgIHQuaW5kZXhPZihlKSA8IDAgJiYgdC51bnNoaWZ0KGUpLCByLmFwcGx5KHRoaXMsIHQpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdFsxXSAmJiAoW2EsIHIsIG5dID0gdCwgaSA9IHZvaWQgMCksIG4gfHwgKG4gPSAhMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBhLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICAgICAgbGV0IHA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgdGhpcy5sZW5ndGg7IGUgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHRoaXNbZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaSkgZm9yIChwID0gMDsgcCA8IGMubGVuZ3RoOyBwICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gY1twXTtcclxuICAgICAgICAgICAgICAgICAgICB0LmRvbTdMaXZlTGlzdGVuZXJzIHx8ICh0LmRvbTdMaXZlTGlzdGVuZXJzID0ge30pLCB0LmRvbTdMaXZlTGlzdGVuZXJzW2VdIHx8ICh0LmRvbTdMaXZlTGlzdGVuZXJzW2VdID0gW10pLCB0LmRvbTdMaXZlTGlzdGVuZXJzW2VdLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcjogcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlMaXN0ZW5lcjogbFxyXG4gICAgICAgICAgICAgICAgICAgIH0pLCB0LmFkZEV2ZW50TGlzdGVuZXIoZSwgbCwgbilcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBmb3IgKHAgPSAwOyBwIDwgYy5sZW5ndGg7IHAgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBjW3BdO1xyXG4gICAgICAgICAgICAgICAgICAgIHQuZG9tN0xpc3RlbmVycyB8fCAodC5kb203TGlzdGVuZXJzID0ge30pLCB0LmRvbTdMaXN0ZW5lcnNbZV0gfHwgKHQuZG9tN0xpc3RlbmVyc1tlXSA9IFtdKSwgdC5kb203TGlzdGVuZXJzW2VdLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcjogcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlMaXN0ZW5lcjogb1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLCB0LmFkZEV2ZW50TGlzdGVuZXIoZSwgbywgbilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIG9mZjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBlID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShlKSwgcyA9IDA7IHMgPCBlOyBzKyspIHRbc10gPSBhcmd1bWVudHNbc107XHJcbiAgICAgICAgICAgIGxldCBbYSwgaSwgciwgbl0gPSB0O1xyXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHRbMV0gJiYgKFthLCByLCBuXSA9IHQsIGkgPSB2b2lkIDApLCBuIHx8IChuID0gITEpO1xyXG4gICAgICAgICAgICBjb25zdCBsID0gYS5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgbC5sZW5ndGg7IGUgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IGxbZV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlID0gMDsgZSA8IHRoaXMubGVuZ3RoOyBlICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gdGhpc1tlXTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWkgJiYgcy5kb203TGlzdGVuZXJzID8gYSA9IHMuZG9tN0xpc3RlbmVyc1t0XSA6IGkgJiYgcy5kb203TGl2ZUxpc3RlbmVycyAmJiAoYSA9IHMuZG9tN0xpdmVMaXN0ZW5lcnNbdF0pLCBhICYmIGEubGVuZ3RoKSBmb3IgKGxldCBlID0gYS5sZW5ndGggLSAxOyBlID49IDA7IGUgLT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpID0gYVtlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgciAmJiBpLmxpc3RlbmVyID09PSByIHx8IHIgJiYgaS5saXN0ZW5lciAmJiBpLmxpc3RlbmVyLmRvbTdwcm94eSAmJiBpLmxpc3RlbmVyLmRvbTdwcm94eSA9PT0gciA/IChzLnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgaS5wcm94eUxpc3RlbmVyLCBuKSwgYS5zcGxpY2UoZSwgMSkpIDogciB8fCAocy5yZW1vdmVFdmVudExpc3RlbmVyKHQsIGkucHJveHlMaXN0ZW5lciwgbiksIGEuc3BsaWNlKGUsIDEpKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHRyaWdnZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHIoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgdCA9IGFyZ3VtZW50cy5sZW5ndGgsIHMgPSBuZXcgQXJyYXkodCksIGEgPSAwOyBhIDwgdDsgYSsrKSBzW2FdID0gYXJndW1lbnRzW2FdO1xyXG4gICAgICAgICAgICBjb25zdCBpID0gc1swXS5zcGxpdChcIiBcIiksIG4gPSBzWzFdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IGkubGVuZ3RoOyB0ICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBpW3RdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLmxlbmd0aDsgdCArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaSA9IHRoaXNbdF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuQ3VzdG9tRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IG5ldyBlLkN1c3RvbUV2ZW50KGEsIHtkZXRhaWw6IG4sIGJ1YmJsZXM6ICEwLCBjYW5jZWxhYmxlOiAhMH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpLmRvbTdFdmVudERhdGEgPSBzLmZpbHRlcigoKGUsIHQpID0+IHQgPiAwKSksIGkuZGlzcGF0Y2hFdmVudCh0KSwgaS5kb203RXZlbnREYXRhID0gW10sIGRlbGV0ZSBpLmRvbTdFdmVudERhdGFcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCB0cmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIGUgJiYgdC5vbihcInRyYW5zaXRpb25lbmRcIiwgKGZ1bmN0aW9uIHMoYSkge1xyXG4gICAgICAgICAgICAgICAgYS50YXJnZXQgPT09IHRoaXMgJiYgKGUuY2FsbCh0aGlzLCBhKSwgdC5vZmYoXCJ0cmFuc2l0aW9uZW5kXCIsIHMpKVxyXG4gICAgICAgICAgICB9KSksIHRoaXNcclxuICAgICAgICB9LCBvdXRlcldpZHRoOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSB0aGlzLnN0eWxlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzWzBdLm9mZnNldFdpZHRoICsgcGFyc2VGbG9hdChlLmdldFByb3BlcnR5VmFsdWUoXCJtYXJnaW4tcmlnaHRcIikpICsgcGFyc2VGbG9hdChlLmdldFByb3BlcnR5VmFsdWUoXCJtYXJnaW4tbGVmdFwiKSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzWzBdLm9mZnNldFdpZHRoXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGxcclxuICAgICAgICB9LCBvdXRlckhlaWdodDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gdGhpcy5zdHlsZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1swXS5vZmZzZXRIZWlnaHQgKyBwYXJzZUZsb2F0KGUuZ2V0UHJvcGVydHlWYWx1ZShcIm1hcmdpbi10b3BcIikpICsgcGFyc2VGbG9hdChlLmdldFByb3BlcnR5VmFsdWUoXCJtYXJnaW4tYm90dG9tXCIpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF0ub2Zmc2V0SGVpZ2h0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGxcclxuICAgICAgICB9LCBzdHlsZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF0gPyBlLmdldENvbXB1dGVkU3R5bGUodGhpc1swXSwgbnVsbCkgOiB7fVxyXG4gICAgICAgIH0sIG9mZnNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gcigpLCB0ID0gYSgpLCBzID0gdGhpc1swXSwgaSA9IHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG4gPSB0LmJvZHksXHJcbiAgICAgICAgICAgICAgICAgICAgbCA9IHMuY2xpZW50VG9wIHx8IG4uY2xpZW50VG9wIHx8IDAsIG8gPSBzLmNsaWVudExlZnQgfHwgbi5jbGllbnRMZWZ0IHx8IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgZCA9IHMgPT09IGUgPyBlLnNjcm9sbFkgOiBzLnNjcm9sbFRvcCwgYyA9IHMgPT09IGUgPyBlLnNjcm9sbFggOiBzLnNjcm9sbExlZnQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge3RvcDogaS50b3AgKyBkIC0gbCwgbGVmdDogaS5sZWZ0ICsgYyAtIG99XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGxcclxuICAgICAgICB9LCBjc3M6IGZ1bmN0aW9uIChlLCB0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSByKCk7XHJcbiAgICAgICAgICAgIGxldCBhO1xyXG4gICAgICAgICAgICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGEgPSAwOyBhIDwgdGhpcy5sZW5ndGg7IGEgKz0gMSkgZm9yIChjb25zdCB0IGluIGUpIHRoaXNbYV0uc3R5bGVbdF0gPSBlW3RdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpc1swXSkgcmV0dXJuIHMuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzWzBdLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKGUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKDIgPT09IGFyZ3VtZW50cy5sZW5ndGggJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChhID0gMDsgYSA8IHRoaXMubGVuZ3RoOyBhICs9IDEpIHRoaXNbYV0uc3R5bGVbZV0gPSB0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIGVhY2g6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlID8gKHRoaXMuZm9yRWFjaCgoKHQsIHMpID0+IHtcclxuICAgICAgICAgICAgICAgIGUuYXBwbHkodCwgW3QsIHNdKVxyXG4gICAgICAgICAgICB9KSksIHRoaXMpIDogdGhpc1xyXG4gICAgICAgIH0sIGh0bWw6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGUpIHJldHVybiB0aGlzWzBdID8gdGhpc1swXS5pbm5lckhUTUwgOiBudWxsO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRoaXMubGVuZ3RoOyB0ICs9IDEpIHRoaXNbdF0uaW5uZXJIVE1MID0gZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCB0ZXh0OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwID09PSBlKSByZXR1cm4gdGhpc1swXSA/IHRoaXNbMF0udGV4dENvbnRlbnQudHJpbSgpIDogbnVsbDtcclxuICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLmxlbmd0aDsgdCArPSAxKSB0aGlzW3RdLnRleHRDb250ZW50ID0gZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICB9LCBpczogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgY29uc3QgdCA9IHIoKSwgcyA9IGEoKSwgaSA9IHRoaXNbMF07XHJcbiAgICAgICAgICAgIGxldCBsLCBvO1xyXG4gICAgICAgICAgICBpZiAoIWkgfHwgdm9pZCAwID09PSBlKSByZXR1cm4gITE7XHJcbiAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaS5tYXRjaGVzKSByZXR1cm4gaS5tYXRjaGVzKGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGkud2Via2l0TWF0Y2hlc1NlbGVjdG9yKSByZXR1cm4gaS53ZWJraXRNYXRjaGVzU2VsZWN0b3IoZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaS5tc01hdGNoZXNTZWxlY3RvcikgcmV0dXJuIGkubXNNYXRjaGVzU2VsZWN0b3IoZSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGwgPSBkKGUpLCBvID0gMDsgbyA8IGwubGVuZ3RoOyBvICs9IDEpIGlmIChsW29dID09PSBpKSByZXR1cm4gITA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gITFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZSA9PT0gcykgcmV0dXJuIGkgPT09IHM7XHJcbiAgICAgICAgICAgIGlmIChlID09PSB0KSByZXR1cm4gaSA9PT0gdDtcclxuICAgICAgICAgICAgaWYgKGUubm9kZVR5cGUgfHwgZSBpbnN0YW5jZW9mIG4pIHtcclxuICAgICAgICAgICAgICAgIGZvciAobCA9IGUubm9kZVR5cGUgPyBbZV0gOiBlLCBvID0gMDsgbyA8IGwubGVuZ3RoOyBvICs9IDEpIGlmIChsW29dID09PSBpKSByZXR1cm4gITA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gITFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gITFcclxuICAgICAgICB9LCBpbmRleDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBsZXQgZSwgdCA9IHRoaXNbMF07XHJcbiAgICAgICAgICAgIGlmICh0KSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGUgPSAwOyBudWxsICE9PSAodCA9IHQucHJldmlvdXNTaWJsaW5nKTspIDEgPT09IHQubm9kZVR5cGUgJiYgKGUgKz0gMSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZXE6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGUpIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gdGhpcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChlID4gdCAtIDEpIHJldHVybiBkKFtdKTtcclxuICAgICAgICAgICAgaWYgKGUgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gdCArIGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZChzIDwgMCA/IFtdIDogW3RoaXNbc11dKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkKFt0aGlzW2VdXSlcclxuICAgICAgICB9LCBhcHBlbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbGV0IGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSBhKCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcyArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBlID0gcyA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBzID8gdm9pZCAwIDogYXJndW1lbnRzW3NdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCB0aGlzLmxlbmd0aDsgcyArPSAxKSBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSB0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChhLmlubmVySFRNTCA9IGU7IGEuZmlyc3RDaGlsZDspIHRoaXNbc10uYXBwZW5kQ2hpbGQoYS5maXJzdENoaWxkKVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlIGluc3RhbmNlb2YgbikgZm9yIChsZXQgdCA9IDA7IHQgPCBlLmxlbmd0aDsgdCArPSAxKSB0aGlzW3NdLmFwcGVuZENoaWxkKGVbdF0pOyBlbHNlIHRoaXNbc10uYXBwZW5kQ2hpbGQoZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIH0sIHByZXBlbmQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSBhKCk7XHJcbiAgICAgICAgICAgIGxldCBzLCBpO1xyXG4gICAgICAgICAgICBmb3IgKHMgPSAwOyBzIDwgdGhpcy5sZW5ndGg7IHMgKz0gMSkgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSB0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGEuaW5uZXJIVE1MID0gZSwgaSA9IGEuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkgdGhpc1tzXS5pbnNlcnRCZWZvcmUoYS5jaGlsZE5vZGVzW2ldLCB0aGlzW3NdLmNoaWxkTm9kZXNbMF0pXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIG4pIGZvciAoaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSArPSAxKSB0aGlzW3NdLmluc2VydEJlZm9yZShlW2ldLCB0aGlzW3NdLmNoaWxkTm9kZXNbMF0pOyBlbHNlIHRoaXNbc10uaW5zZXJ0QmVmb3JlKGUsIHRoaXNbc10uY2hpbGROb2Rlc1swXSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfSwgbmV4dDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gMCA/IGUgPyB0aGlzWzBdLm5leHRFbGVtZW50U2libGluZyAmJiBkKHRoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nKS5pcyhlKSA/IGQoW3RoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nXSkgOiBkKFtdKSA6IHRoaXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nID8gZChbdGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmddKSA6IGQoW10pIDogZChbXSlcclxuICAgICAgICB9LCBuZXh0QWxsOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gW107XHJcbiAgICAgICAgICAgIGxldCBzID0gdGhpc1swXTtcclxuICAgICAgICAgICAgaWYgKCFzKSByZXR1cm4gZChbXSk7XHJcbiAgICAgICAgICAgIGZvciAoOyBzLm5leHRFbGVtZW50U2libGluZzspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBzLm5leHRFbGVtZW50U2libGluZztcclxuICAgICAgICAgICAgICAgIGUgPyBkKGEpLmlzKGUpICYmIHQucHVzaChhKSA6IHQucHVzaChhKSwgcyA9IGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZCh0KVxyXG4gICAgICAgIH0sIHByZXY6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzWzBdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUgPyB0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgZCh0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcpLmlzKGUpID8gZChbdC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nXSkgOiBkKFtdKSA6IHQucHJldmlvdXNFbGVtZW50U2libGluZyA/IGQoW3QucHJldmlvdXNFbGVtZW50U2libGluZ10pIDogZChbXSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZChbXSlcclxuICAgICAgICB9LCBwcmV2QWxsOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gW107XHJcbiAgICAgICAgICAgIGxldCBzID0gdGhpc1swXTtcclxuICAgICAgICAgICAgaWYgKCFzKSByZXR1cm4gZChbXSk7XHJcbiAgICAgICAgICAgIGZvciAoOyBzLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gcy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xyXG4gICAgICAgICAgICAgICAgZSA/IGQoYSkuaXMoZSkgJiYgdC5wdXNoKGEpIDogdC5wdXNoKGEpLCBzID0gYVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkKHQpXHJcbiAgICAgICAgfSwgcGFyZW50OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgdGhpcy5sZW5ndGg7IHMgKz0gMSkgbnVsbCAhPT0gdGhpc1tzXS5wYXJlbnROb2RlICYmIChlID8gZCh0aGlzW3NdLnBhcmVudE5vZGUpLmlzKGUpICYmIHQucHVzaCh0aGlzW3NdLnBhcmVudE5vZGUpIDogdC5wdXNoKHRoaXNbc10ucGFyZW50Tm9kZSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gZCh0KVxyXG4gICAgICAgIH0sIHBhcmVudHM6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCB0aGlzLmxlbmd0aDsgcyArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYSA9IHRoaXNbc10ucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgIGZvciAoOyBhOykgZSA/IGQoYSkuaXMoZSkgJiYgdC5wdXNoKGEpIDogdC5wdXNoKGEpLCBhID0gYS5wYXJlbnROb2RlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGQodClcclxuICAgICAgICB9LCBjbG9zZXN0OiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBsZXQgdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IGUgPyBkKFtdKSA6ICh0LmlzKGUpIHx8ICh0ID0gdC5wYXJlbnRzKGUpLmVxKDApKSwgdClcclxuICAgICAgICB9LCBmaW5kOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgdGhpcy5sZW5ndGg7IHMgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IHRoaXNbc10ucXVlcnlTZWxlY3RvckFsbChlKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgYS5sZW5ndGg7IGUgKz0gMSkgdC5wdXNoKGFbZV0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGQodClcclxuICAgICAgICB9LCBjaGlsZHJlbjogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgY29uc3QgdCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IHRoaXMubGVuZ3RoOyBzICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzW3NdLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBhLmxlbmd0aDsgcyArPSAxKSBlICYmICFkKGFbc10pLmlzKGUpIHx8IHQucHVzaChhW3NdKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkKHQpXHJcbiAgICAgICAgfSwgZmlsdGVyOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZChvKHRoaXMsIGUpKVxyXG4gICAgICAgIH0sIHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBlID0gMDsgZSA8IHRoaXMubGVuZ3RoOyBlICs9IDEpIHRoaXNbZV0ucGFyZW50Tm9kZSAmJiB0aGlzW2VdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpc1tlXSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBwKGUsIHQpIHtcclxuICAgICAgICByZXR1cm4gdm9pZCAwID09PSB0ICYmICh0ID0gMCksIHNldFRpbWVvdXQoZSwgdClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1KCkge1xyXG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaChlLCB0KSB7XHJcbiAgICAgICAgdm9pZCAwID09PSB0ICYmICh0ID0gXCJ4XCIpO1xyXG4gICAgICAgIGNvbnN0IHMgPSByKCk7XHJcbiAgICAgICAgbGV0IGEsIGksIG47XHJcbiAgICAgICAgY29uc3QgbCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSByKCk7XHJcbiAgICAgICAgICAgIGxldCBzO1xyXG4gICAgICAgICAgICByZXR1cm4gdC5nZXRDb21wdXRlZFN0eWxlICYmIChzID0gdC5nZXRDb21wdXRlZFN0eWxlKGUsIG51bGwpKSwgIXMgJiYgZS5jdXJyZW50U3R5bGUgJiYgKHMgPSBlLmN1cnJlbnRTdHlsZSksIHMgfHwgKHMgPSBlLnN0eWxlKSwgc1xyXG4gICAgICAgIH0oZSk7XHJcbiAgICAgICAgcmV0dXJuIHMuV2ViS2l0Q1NTTWF0cml4ID8gKGkgPSBsLnRyYW5zZm9ybSB8fCBsLndlYmtpdFRyYW5zZm9ybSwgaS5zcGxpdChcIixcIikubGVuZ3RoID4gNiAmJiAoaSA9IGkuc3BsaXQoXCIsIFwiKS5tYXAoKGUgPT4gZS5yZXBsYWNlKFwiLFwiLCBcIi5cIikpKS5qb2luKFwiLCBcIikpLCBuID0gbmV3IHMuV2ViS2l0Q1NTTWF0cml4KFwibm9uZVwiID09PSBpID8gXCJcIiA6IGkpKSA6IChuID0gbC5Nb3pUcmFuc2Zvcm0gfHwgbC5PVHJhbnNmb3JtIHx8IGwuTXNUcmFuc2Zvcm0gfHwgbC5tc1RyYW5zZm9ybSB8fCBsLnRyYW5zZm9ybSB8fCBsLmdldFByb3BlcnR5VmFsdWUoXCJ0cmFuc2Zvcm1cIikucmVwbGFjZShcInRyYW5zbGF0ZShcIiwgXCJtYXRyaXgoMSwgMCwgMCwgMSxcIiksIGEgPSBuLnRvU3RyaW5nKCkuc3BsaXQoXCIsXCIpKSwgXCJ4XCIgPT09IHQgJiYgKGkgPSBzLldlYktpdENTU01hdHJpeCA/IG4ubTQxIDogMTYgPT09IGEubGVuZ3RoID8gcGFyc2VGbG9hdChhWzEyXSkgOiBwYXJzZUZsb2F0KGFbNF0pKSwgXCJ5XCIgPT09IHQgJiYgKGkgPSBzLldlYktpdENTU01hdHJpeCA/IG4ubTQyIDogMTYgPT09IGEubGVuZ3RoID8gcGFyc2VGbG9hdChhWzEzXSkgOiBwYXJzZUZsb2F0KGFbNV0pKSwgaSB8fCAwXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbShlKSB7XHJcbiAgICAgICAgcmV0dXJuIFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgJiYgbnVsbCAhPT0gZSAmJiBlLmNvbnN0cnVjdG9yICYmIFwiT2JqZWN0XCIgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LCAtMSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmKGUpIHtcclxuICAgICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ICYmIHZvaWQgMCAhPT0gd2luZG93LkhUTUxFbGVtZW50ID8gZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IDogZSAmJiAoMSA9PT0gZS5ub2RlVHlwZSB8fCAxMSA9PT0gZS5ub2RlVHlwZSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnKCkge1xyXG4gICAgICAgIGNvbnN0IGUgPSBPYmplY3QoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdm9pZCAwIDogYXJndW1lbnRzWzBdKSwgdCA9IFtcIl9fcHJvdG9fX1wiLCBcImNvbnN0cnVjdG9yXCIsIFwicHJvdG90eXBlXCJdO1xyXG4gICAgICAgIGZvciAobGV0IHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcyArPSAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSBzIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IHMgPyB2b2lkIDAgOiBhcmd1bWVudHNbc107XHJcbiAgICAgICAgICAgIGlmIChudWxsICE9IGEgJiYgIWYoYSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBPYmplY3Qua2V5cyhPYmplY3QoYSkpLmZpbHRlcigoZSA9PiB0LmluZGV4T2YoZSkgPCAwKSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0ID0gMCwgaSA9IHMubGVuZ3RoOyB0IDwgaTsgdCArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaSA9IHNbdF0sIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGEsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gciAmJiByLmVudW1lcmFibGUgJiYgKG0oZVtpXSkgJiYgbShhW2ldKSA/IGFbaV0uX19zd2lwZXJfXyA/IGVbaV0gPSBhW2ldIDogZyhlW2ldLCBhW2ldKSA6ICFtKGVbaV0pICYmIG0oYVtpXSkgPyAoZVtpXSA9IHt9LCBhW2ldLl9fc3dpcGVyX18gPyBlW2ldID0gYVtpXSA6IGcoZVtpXSwgYVtpXSkpIDogZVtpXSA9IGFbaV0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB2KGUsIHQsIHMpIHtcclxuICAgICAgICBlLnN0eWxlLnNldFByb3BlcnR5KHQsIHMpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdyhlKSB7XHJcbiAgICAgICAgbGV0IHtzd2lwZXI6IHQsIHRhcmdldFBvc2l0aW9uOiBzLCBzaWRlOiBhfSA9IGU7XHJcbiAgICAgICAgY29uc3QgaSA9IHIoKSwgbiA9IC10LnRyYW5zbGF0ZTtcclxuICAgICAgICBsZXQgbCwgbyA9IG51bGw7XHJcbiAgICAgICAgY29uc3QgZCA9IHQucGFyYW1zLnNwZWVkO1xyXG4gICAgICAgIHQud3JhcHBlckVsLnN0eWxlLnNjcm9sbFNuYXBUeXBlID0gXCJub25lXCIsIGkuY2FuY2VsQW5pbWF0aW9uRnJhbWUodC5jc3NNb2RlRnJhbWVJRCk7XHJcbiAgICAgICAgY29uc3QgYyA9IHMgPiBuID8gXCJuZXh0XCIgOiBcInByZXZcIiwgcCA9IChlLCB0KSA9PiBcIm5leHRcIiA9PT0gYyAmJiBlID49IHQgfHwgXCJwcmV2XCIgPT09IGMgJiYgZSA8PSB0LCB1ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBsID0gKG5ldyBEYXRlKS5nZXRUaW1lKCksIG51bGwgPT09IG8gJiYgKG8gPSBsKTtcclxuICAgICAgICAgICAgY29uc3QgZSA9IE1hdGgubWF4KE1hdGgubWluKChsIC0gbykgLyBkLCAxKSwgMCksIHIgPSAuNSAtIE1hdGguY29zKGUgKiBNYXRoLlBJKSAvIDI7XHJcbiAgICAgICAgICAgIGxldCBjID0gbiArIHIgKiAocyAtIG4pO1xyXG4gICAgICAgICAgICBpZiAocChjLCBzKSAmJiAoYyA9IHMpLCB0LndyYXBwZXJFbC5zY3JvbGxUbyh7W2FdOiBjfSksIHAoYywgcykpIHJldHVybiB0LndyYXBwZXJFbC5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCIsIHQud3JhcHBlckVsLnN0eWxlLnNjcm9sbFNuYXBUeXBlID0gXCJcIiwgc2V0VGltZW91dCgoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdC53cmFwcGVyRWwuc3R5bGUub3ZlcmZsb3cgPSBcIlwiLCB0LndyYXBwZXJFbC5zY3JvbGxUbyh7W2FdOiBjfSlcclxuICAgICAgICAgICAgfSkpLCB2b2lkIGkuY2FuY2VsQW5pbWF0aW9uRnJhbWUodC5jc3NNb2RlRnJhbWVJRCk7XHJcbiAgICAgICAgICAgIHQuY3NzTW9kZUZyYW1lSUQgPSBpLnJlcXVlc3RBbmltYXRpb25GcmFtZSh1KVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdSgpXHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGIsIHgsIHk7XHJcblxyXG4gICAgZnVuY3Rpb24gRSgpIHtcclxuICAgICAgICByZXR1cm4gYiB8fCAoYiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHIoKSwgdCA9IGEoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHNtb290aFNjcm9sbDogdC5kb2N1bWVudEVsZW1lbnQgJiYgXCJzY3JvbGxCZWhhdmlvclwiIGluIHQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLFxyXG4gICAgICAgICAgICAgICAgdG91Y2g6ICEhKFwib250b3VjaHN0YXJ0XCIgaW4gZSB8fCBlLkRvY3VtZW50VG91Y2ggJiYgdCBpbnN0YW5jZW9mIGUuRG9jdW1lbnRUb3VjaCksXHJcbiAgICAgICAgICAgICAgICBwYXNzaXZlTGlzdGVuZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdCA9ICExO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIFwicGFzc2l2ZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9ICEwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0UGFzc2l2ZUxpc3RlbmVyXCIsIG51bGwsIHMpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdFxyXG4gICAgICAgICAgICAgICAgfSgpLFxyXG4gICAgICAgICAgICAgICAgZ2VzdHVyZXM6IFwib25nZXN0dXJlc3RhcnRcIiBpbiBlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KCkpLCBiXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gQyhlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gZSAmJiAoZSA9IHt9KSwgeCB8fCAoeCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGxldCB7dXNlckFnZW50OiB0fSA9IHZvaWQgMCA9PT0gZSA/IHt9IDogZTtcclxuICAgICAgICAgICAgY29uc3QgcyA9IEUoKSwgYSA9IHIoKSwgaSA9IGEubmF2aWdhdG9yLnBsYXRmb3JtLCBuID0gdCB8fCBhLm5hdmlnYXRvci51c2VyQWdlbnQsXHJcbiAgICAgICAgICAgICAgICBsID0ge2lvczogITEsIGFuZHJvaWQ6ICExfSwgbyA9IGEuc2NyZWVuLndpZHRoLCBkID0gYS5zY3JlZW4uaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgYyA9IG4ubWF0Y2goLyhBbmRyb2lkKTs/W1xcc1xcL10rKFtcXGQuXSspPy8pO1xyXG4gICAgICAgICAgICBsZXQgcCA9IG4ubWF0Y2goLyhpUGFkKS4qT1NcXHMoW1xcZF9dKykvKTtcclxuICAgICAgICAgICAgY29uc3QgdSA9IG4ubWF0Y2goLyhpUG9kKSguKk9TXFxzKFtcXGRfXSspKT8vKSwgaCA9ICFwICYmIG4ubWF0Y2goLyhpUGhvbmVcXHNPU3xpT1MpXFxzKFtcXGRfXSspLyksXHJcbiAgICAgICAgICAgICAgICBtID0gXCJXaW4zMlwiID09PSBpO1xyXG4gICAgICAgICAgICBsZXQgZiA9IFwiTWFjSW50ZWxcIiA9PT0gaTtcclxuICAgICAgICAgICAgcmV0dXJuICFwICYmIGYgJiYgcy50b3VjaCAmJiBbXCIxMDI0eDEzNjZcIiwgXCIxMzY2eDEwMjRcIiwgXCI4MzR4MTE5NFwiLCBcIjExOTR4ODM0XCIsIFwiODM0eDExMTJcIiwgXCIxMTEyeDgzNFwiLCBcIjc2OHgxMDI0XCIsIFwiMTAyNHg3NjhcIiwgXCI4MjB4MTE4MFwiLCBcIjExODB4ODIwXCIsIFwiODEweDEwODBcIiwgXCIxMDgweDgxMFwiXS5pbmRleE9mKGAke299eCR7ZH1gKSA+PSAwICYmIChwID0gbi5tYXRjaCgvKFZlcnNpb24pXFwvKFtcXGQuXSspLyksIHAgfHwgKHAgPSBbMCwgMSwgXCIxM18wXzBcIl0pLCBmID0gITEpLCBjICYmICFtICYmIChsLm9zID0gXCJhbmRyb2lkXCIsIGwuYW5kcm9pZCA9ICEwKSwgKHAgfHwgaCB8fCB1KSAmJiAobC5vcyA9IFwiaW9zXCIsIGwuaW9zID0gITApLCBsXHJcbiAgICAgICAgfShlKSksIHhcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBUKCkge1xyXG4gICAgICAgIHJldHVybiB5IHx8ICh5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gcigpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgaXNTYWZhcmk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gZS5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQuaW5kZXhPZihcInNhZmFyaVwiKSA+PSAwICYmIHQuaW5kZXhPZihcImNocm9tZVwiKSA8IDAgJiYgdC5pbmRleE9mKFwiYW5kcm9pZFwiKSA8IDBcclxuICAgICAgICAgICAgICAgIH0oKSwgaXNXZWJWaWV3OiAvKGlQaG9uZXxpUG9kfGlQYWQpLipBcHBsZVdlYktpdCg/IS4qU2FmYXJpKS9pLnRlc3QoZS5uYXZpZ2F0b3IudXNlckFnZW50KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSgpKSwgeVxyXG4gICAgfVxyXG5cclxuICAgIE9iamVjdC5rZXlzKGMpLmZvckVhY2goKGUgPT4ge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkLmZuLCBlLCB7dmFsdWU6IGNbZV0sIHdyaXRhYmxlOiAhMH0pXHJcbiAgICB9KSk7XHJcbiAgICB2YXIgJCA9IHtcclxuICAgICAgICBvbihlLCB0LCBzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoIWEuZXZlbnRzTGlzdGVuZXJzIHx8IGEuZGVzdHJveWVkKSByZXR1cm4gYTtcclxuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCkgcmV0dXJuIGE7XHJcbiAgICAgICAgICAgIGNvbnN0IGkgPSBzID8gXCJ1bnNoaWZ0XCIgOiBcInB1c2hcIjtcclxuICAgICAgICAgICAgcmV0dXJuIGUuc3BsaXQoXCIgXCIpLmZvckVhY2goKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgYS5ldmVudHNMaXN0ZW5lcnNbZV0gfHwgKGEuZXZlbnRzTGlzdGVuZXJzW2VdID0gW10pLCBhLmV2ZW50c0xpc3RlbmVyc1tlXVtpXSh0KVxyXG4gICAgICAgICAgICB9KSksIGFcclxuICAgICAgICB9LCBvbmNlKGUsIHQsIHMpIHtcclxuICAgICAgICAgICAgY29uc3QgYSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICghYS5ldmVudHNMaXN0ZW5lcnMgfHwgYS5kZXN0cm95ZWQpIHJldHVybiBhO1xyXG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0KSByZXR1cm4gYTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGkoKSB7XHJcbiAgICAgICAgICAgICAgICBhLm9mZihlLCBpKSwgaS5fX2VtaXR0ZXJQcm94eSAmJiBkZWxldGUgaS5fX2VtaXR0ZXJQcm94eTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gbmV3IEFycmF5KHMpLCBuID0gMDsgbiA8IHM7IG4rKykgcltuXSA9IGFyZ3VtZW50c1tuXTtcclxuICAgICAgICAgICAgICAgIHQuYXBwbHkoYSwgcilcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGkuX19lbWl0dGVyUHJveHkgPSB0LCBhLm9uKGUsIGksIHMpXHJcbiAgICAgICAgfSwgb25BbnkoZSwgdCkge1xyXG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKCFzLmV2ZW50c0xpc3RlbmVycyB8fCBzLmRlc3Ryb3llZCkgcmV0dXJuIHM7XHJcbiAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiBzO1xyXG4gICAgICAgICAgICBjb25zdCBhID0gdCA/IFwidW5zaGlmdFwiIDogXCJwdXNoXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBzLmV2ZW50c0FueUxpc3RlbmVycy5pbmRleE9mKGUpIDwgMCAmJiBzLmV2ZW50c0FueUxpc3RlbmVyc1thXShlKSwgc1xyXG4gICAgICAgIH0sIG9mZkFueShlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoIXQuZXZlbnRzTGlzdGVuZXJzIHx8IHQuZGVzdHJveWVkKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKCF0LmV2ZW50c0FueUxpc3RlbmVycykgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0LmV2ZW50c0FueUxpc3RlbmVycy5pbmRleE9mKGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gcyA+PSAwICYmIHQuZXZlbnRzQW55TGlzdGVuZXJzLnNwbGljZShzLCAxKSwgdFxyXG4gICAgICAgIH0sIG9mZihlLCB0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gIXMuZXZlbnRzTGlzdGVuZXJzIHx8IHMuZGVzdHJveWVkID8gcyA6IHMuZXZlbnRzTGlzdGVuZXJzID8gKGUuc3BsaXQoXCIgXCIpLmZvckVhY2goKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwID09PSB0ID8gcy5ldmVudHNMaXN0ZW5lcnNbZV0gPSBbXSA6IHMuZXZlbnRzTGlzdGVuZXJzW2VdICYmIHMuZXZlbnRzTGlzdGVuZXJzW2VdLmZvckVhY2goKChhLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgKGEgPT09IHQgfHwgYS5fX2VtaXR0ZXJQcm94eSAmJiBhLl9fZW1pdHRlclByb3h5ID09PSB0KSAmJiBzLmV2ZW50c0xpc3RlbmVyc1tlXS5zcGxpY2UoaSwgMSlcclxuICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICB9KSksIHMpIDogc1xyXG4gICAgICAgIH0sIGVtaXQoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoIWUuZXZlbnRzTGlzdGVuZXJzIHx8IGUuZGVzdHJveWVkKSByZXR1cm4gZTtcclxuICAgICAgICAgICAgaWYgKCFlLmV2ZW50c0xpc3RlbmVycykgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgIGxldCB0LCBzLCBhO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IG5ldyBBcnJheShpKSwgbiA9IDA7IG4gPCBpOyBuKyspIHJbbl0gPSBhcmd1bWVudHNbbl07XHJcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIHJbMF0gfHwgQXJyYXkuaXNBcnJheShyWzBdKSA/ICh0ID0gclswXSwgcyA9IHIuc2xpY2UoMSwgci5sZW5ndGgpLCBhID0gZSkgOiAodCA9IHJbMF0uZXZlbnRzLCBzID0gclswXS5kYXRhLCBhID0gclswXS5jb250ZXh0IHx8IGUpLCBzLnVuc2hpZnQoYSk7XHJcbiAgICAgICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh0KSA/IHQgOiB0LnNwbGl0KFwiIFwiKSkuZm9yRWFjaCgodCA9PiB7XHJcbiAgICAgICAgICAgICAgICBlLmV2ZW50c0FueUxpc3RlbmVycyAmJiBlLmV2ZW50c0FueUxpc3RlbmVycy5sZW5ndGggJiYgZS5ldmVudHNBbnlMaXN0ZW5lcnMuZm9yRWFjaCgoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5hcHBseShhLCBbdCwgLi4uc10pXHJcbiAgICAgICAgICAgICAgICB9KSksIGUuZXZlbnRzTGlzdGVuZXJzICYmIGUuZXZlbnRzTGlzdGVuZXJzW3RdICYmIGUuZXZlbnRzTGlzdGVuZXJzW3RdLmZvckVhY2goKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGUuYXBwbHkoYSwgcylcclxuICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICB9KSksIGVcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIFMgPSB7XHJcbiAgICAgICAgdXBkYXRlU2l6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHQsIHM7XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSBlLiRlbDtcclxuICAgICAgICAgICAgdCA9IHZvaWQgMCAhPT0gZS5wYXJhbXMud2lkdGggJiYgbnVsbCAhPT0gZS5wYXJhbXMud2lkdGggPyBlLnBhcmFtcy53aWR0aCA6IGFbMF0uY2xpZW50V2lkdGgsIHMgPSB2b2lkIDAgIT09IGUucGFyYW1zLmhlaWdodCAmJiBudWxsICE9PSBlLnBhcmFtcy5oZWlnaHQgPyBlLnBhcmFtcy5oZWlnaHQgOiBhWzBdLmNsaWVudEhlaWdodCwgMCA9PT0gdCAmJiBlLmlzSG9yaXpvbnRhbCgpIHx8IDAgPT09IHMgJiYgZS5pc1ZlcnRpY2FsKCkgfHwgKHQgPSB0IC0gcGFyc2VJbnQoYS5jc3MoXCJwYWRkaW5nLWxlZnRcIikgfHwgMCwgMTApIC0gcGFyc2VJbnQoYS5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIpIHx8IDAsIDEwKSwgcyA9IHMgLSBwYXJzZUludChhLmNzcyhcInBhZGRpbmctdG9wXCIpIHx8IDAsIDEwKSAtIHBhcnNlSW50KGEuY3NzKFwicGFkZGluZy1ib3R0b21cIikgfHwgMCwgMTApLCBOdW1iZXIuaXNOYU4odCkgJiYgKHQgPSAwKSwgTnVtYmVyLmlzTmFOKHMpICYmIChzID0gMCksIE9iamVjdC5hc3NpZ24oZSwge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHQsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHMsXHJcbiAgICAgICAgICAgICAgICBzaXplOiBlLmlzSG9yaXpvbnRhbCgpID8gdCA6IHNcclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgfSwgdXBkYXRlU2xpZGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gdCh0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5pc0hvcml6b250YWwoKSA/IHQgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IFwiaGVpZ2h0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tdG9wXCI6IFwibWFyZ2luLWxlZnRcIixcclxuICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1ib3R0b20gXCI6IFwibWFyZ2luLXJpZ2h0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tbGVmdFwiOiBcIm1hcmdpbi10b3BcIixcclxuICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1yaWdodFwiOiBcIm1hcmdpbi1ib3R0b21cIixcclxuICAgICAgICAgICAgICAgICAgICBcInBhZGRpbmctbGVmdFwiOiBcInBhZGRpbmctdG9wXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nLXJpZ2h0XCI6IFwicGFkZGluZy1ib3R0b21cIixcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogXCJtYXJnaW5Cb3R0b21cIlxyXG4gICAgICAgICAgICAgICAgfVt0XVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzKGUsIHMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGUuZ2V0UHJvcGVydHlWYWx1ZSh0KHMpKSB8fCAwKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBhID0gZS5wYXJhbXMsIHskd3JhcHBlckVsOiBpLCBzaXplOiByLCBydGxUcmFuc2xhdGU6IG4sIHdyb25nUlRMOiBsfSA9IGUsXHJcbiAgICAgICAgICAgICAgICBvID0gZS52aXJ0dWFsICYmIGEudmlydHVhbC5lbmFibGVkLCBkID0gbyA/IGUudmlydHVhbC5zbGlkZXMubGVuZ3RoIDogZS5zbGlkZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgYyA9IGkuY2hpbGRyZW4oYC4ke2UucGFyYW1zLnNsaWRlQ2xhc3N9YCksIHAgPSBvID8gZS52aXJ0dWFsLnNsaWRlcy5sZW5ndGggOiBjLmxlbmd0aDtcclxuICAgICAgICAgICAgbGV0IHUgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgaCA9IFtdLCBtID0gW107XHJcbiAgICAgICAgICAgIGxldCBmID0gYS5zbGlkZXNPZmZzZXRCZWZvcmU7XHJcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZiAmJiAoZiA9IGEuc2xpZGVzT2Zmc2V0QmVmb3JlLmNhbGwoZSkpO1xyXG4gICAgICAgICAgICBsZXQgZyA9IGEuc2xpZGVzT2Zmc2V0QWZ0ZXI7XHJcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZyAmJiAoZyA9IGEuc2xpZGVzT2Zmc2V0QWZ0ZXIuY2FsbChlKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHcgPSBlLnNuYXBHcmlkLmxlbmd0aCwgYiA9IGUuc2xpZGVzR3JpZC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGxldCB4ID0gYS5zcGFjZUJldHdlZW4sIHkgPSAtZiwgRSA9IDAsIEMgPSAwO1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwID09PSByKSByZXR1cm47XHJcbiAgICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIHggJiYgeC5pbmRleE9mKFwiJVwiKSA+PSAwICYmICh4ID0gcGFyc2VGbG9hdCh4LnJlcGxhY2UoXCIlXCIsIFwiXCIpKSAvIDEwMCAqIHIpLCBlLnZpcnR1YWxTaXplID0gLXgsIG4gPyBjLmNzcyh7XHJcbiAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tOiBcIlwiLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBcIlwiXHJcbiAgICAgICAgICAgIH0pIDogYy5jc3Moe1xyXG4gICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b206IFwiXCIsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IFwiXCJcclxuICAgICAgICAgICAgfSksIGEuY2VudGVyZWRTbGlkZXMgJiYgYS5jc3NNb2RlICYmICh2KGUud3JhcHBlckVsLCBcIi0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1iZWZvcmVcIiwgXCJcIiksIHYoZS53cmFwcGVyRWwsIFwiLS1zd2lwZXItY2VudGVyZWQtb2Zmc2V0LWFmdGVyXCIsIFwiXCIpKTtcclxuICAgICAgICAgICAgY29uc3QgVCA9IGEuZ3JpZCAmJiBhLmdyaWQucm93cyA+IDEgJiYgZS5ncmlkO1xyXG4gICAgICAgICAgICBsZXQgJDtcclxuICAgICAgICAgICAgVCAmJiBlLmdyaWQuaW5pdFNsaWRlcyhwKTtcclxuICAgICAgICAgICAgY29uc3QgUyA9IFwiYXV0b1wiID09PSBhLnNsaWRlc1BlclZpZXcgJiYgYS5icmVha3BvaW50cyAmJiBPYmplY3Qua2V5cyhhLmJyZWFrcG9pbnRzKS5maWx0ZXIoKGUgPT4gdm9pZCAwICE9PSBhLmJyZWFrcG9pbnRzW2VdLnNsaWRlc1BlclZpZXcpKS5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHA7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgJCA9IDA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gYy5lcShpKTtcclxuICAgICAgICAgICAgICAgIGlmIChUICYmIGUuZ3JpZC51cGRhdGVTbGlkZShpLCBuLCBwLCB0KSwgXCJub25lXCIgIT09IG4uY3NzKFwiZGlzcGxheVwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChcImF1dG9cIiA9PT0gYS5zbGlkZXNQZXJWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFMgJiYgKGNbaV0uc3R5bGVbdChcIndpZHRoXCIpXSA9IFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gZ2V0Q29tcHV0ZWRTdHlsZShuWzBdKSwgbCA9IG5bMF0uc3R5bGUudHJhbnNmb3JtLCBvID0gblswXS5zdHlsZS53ZWJraXRUcmFuc2Zvcm07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsICYmIChuWzBdLnN0eWxlLnRyYW5zZm9ybSA9IFwibm9uZVwiKSwgbyAmJiAoblswXS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBcIm5vbmVcIiksIGEucm91bmRMZW5ndGhzKSAkID0gZS5pc0hvcml6b250YWwoKSA/IG4ub3V0ZXJXaWR0aCghMCkgOiBuLm91dGVySGVpZ2h0KCEwKTsgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gcyhyLCBcIndpZHRoXCIpLCB0ID0gcyhyLCBcInBhZGRpbmctbGVmdFwiKSwgYSA9IHMociwgXCJwYWRkaW5nLXJpZ2h0XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBzKHIsIFwibWFyZ2luLWxlZnRcIiksIGwgPSBzKHIsIFwibWFyZ2luLXJpZ2h0XCIpLCBvID0gci5nZXRQcm9wZXJ0eVZhbHVlKFwiYm94LXNpemluZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvICYmIFwiYm9yZGVyLWJveFwiID09PSBvKSAkID0gZSArIGkgKyBsOyBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7Y2xpZW50V2lkdGg6IHMsIG9mZnNldFdpZHRoOiByfSA9IG5bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCA9IGUgKyB0ICsgYSArIGkgKyBsICsgKHIgLSBzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgJiYgKG5bMF0uc3R5bGUudHJhbnNmb3JtID0gbCksIG8gJiYgKG5bMF0uc3R5bGUud2Via2l0VHJhbnNmb3JtID0gbyksIGEucm91bmRMZW5ndGhzICYmICgkID0gTWF0aC5mbG9vcigkKSlcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgJCA9IChyIC0gKGEuc2xpZGVzUGVyVmlldyAtIDEpICogeCkgLyBhLnNsaWRlc1BlclZpZXcsIGEucm91bmRMZW5ndGhzICYmICgkID0gTWF0aC5mbG9vcigkKSksIGNbaV0gJiYgKGNbaV0uc3R5bGVbdChcIndpZHRoXCIpXSA9IGAkeyR9cHhgKTtcclxuICAgICAgICAgICAgICAgICAgICBjW2ldICYmIChjW2ldLnN3aXBlclNsaWRlU2l6ZSA9ICQpLCBtLnB1c2goJCksIGEuY2VudGVyZWRTbGlkZXMgPyAoeSA9IHkgKyAkIC8gMiArIEUgLyAyICsgeCwgMCA9PT0gRSAmJiAwICE9PSBpICYmICh5ID0geSAtIHIgLyAyIC0geCksIDAgPT09IGkgJiYgKHkgPSB5IC0gciAvIDIgLSB4KSwgTWF0aC5hYnMoeSkgPCAuMDAxICYmICh5ID0gMCksIGEucm91bmRMZW5ndGhzICYmICh5ID0gTWF0aC5mbG9vcih5KSksIEMgJSBhLnNsaWRlc1Blckdyb3VwID09IDAgJiYgdS5wdXNoKHkpLCBoLnB1c2goeSkpIDogKGEucm91bmRMZW5ndGhzICYmICh5ID0gTWF0aC5mbG9vcih5KSksIChDIC0gTWF0aC5taW4oZS5wYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwLCBDKSkgJSBlLnBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PSAwICYmIHUucHVzaCh5KSwgaC5wdXNoKHkpLCB5ID0geSArICQgKyB4KSwgZS52aXJ0dWFsU2l6ZSArPSAkICsgeCwgRSA9ICQsIEMgKz0gMVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlLnZpcnR1YWxTaXplID0gTWF0aC5tYXgoZS52aXJ0dWFsU2l6ZSwgcikgKyBnLCBuICYmIGwgJiYgKFwic2xpZGVcIiA9PT0gYS5lZmZlY3QgfHwgXCJjb3ZlcmZsb3dcIiA9PT0gYS5lZmZlY3QpICYmIGkuY3NzKHt3aWR0aDogYCR7ZS52aXJ0dWFsU2l6ZSArIGEuc3BhY2VCZXR3ZWVufXB4YH0pLCBhLnNldFdyYXBwZXJTaXplICYmIGkuY3NzKHtbdChcIndpZHRoXCIpXTogYCR7ZS52aXJ0dWFsU2l6ZSArIGEuc3BhY2VCZXR3ZWVufXB4YH0pLCBUICYmIGUuZ3JpZC51cGRhdGVXcmFwcGVyU2l6ZSgkLCB1LCB0KSwgIWEuY2VudGVyZWRTbGlkZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgdS5sZW5ndGg7IHMgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gdVtzXTtcclxuICAgICAgICAgICAgICAgICAgICBhLnJvdW5kTGVuZ3RocyAmJiAoaSA9IE1hdGguZmxvb3IoaSkpLCB1W3NdIDw9IGUudmlydHVhbFNpemUgLSByICYmIHQucHVzaChpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdSA9IHQsIE1hdGguZmxvb3IoZS52aXJ0dWFsU2l6ZSAtIHIpIC0gTWF0aC5mbG9vcih1W3UubGVuZ3RoIC0gMV0pID4gMSAmJiB1LnB1c2goZS52aXJ0dWFsU2l6ZSAtIHIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKDAgPT09IHUubGVuZ3RoICYmICh1ID0gWzBdKSwgMCAhPT0gYS5zcGFjZUJldHdlZW4pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBlLmlzSG9yaXpvbnRhbCgpICYmIG4gPyBcIm1hcmdpbkxlZnRcIiA6IHQoXCJtYXJnaW5SaWdodFwiKTtcclxuICAgICAgICAgICAgICAgIGMuZmlsdGVyKCgoZSwgdCkgPT4gIWEuY3NzTW9kZSB8fCB0ICE9PSBjLmxlbmd0aCAtIDEpKS5jc3Moe1tzXTogYCR7eH1weGB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhLmNlbnRlcmVkU2xpZGVzICYmIGEuY2VudGVyZWRTbGlkZXNCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBlID0gMDtcclxuICAgICAgICAgICAgICAgIG0uZm9yRWFjaCgodCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZSArPSB0ICsgKGEuc3BhY2VCZXR3ZWVuID8gYS5zcGFjZUJldHdlZW4gOiAwKVxyXG4gICAgICAgICAgICAgICAgfSkpLCBlIC09IGEuc3BhY2VCZXR3ZWVuO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IGUgLSByO1xyXG4gICAgICAgICAgICAgICAgdSA9IHUubWFwKChlID0+IGUgPCAwID8gLWYgOiBlID4gdCA/IHQgKyBnIDogZSkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGEuY2VudGVySW5zdWZmaWNpZW50U2xpZGVzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAobS5mb3JFYWNoKCh0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBlICs9IHQgKyAoYS5zcGFjZUJldHdlZW4gPyBhLnNwYWNlQmV0d2VlbiA6IDApXHJcbiAgICAgICAgICAgICAgICB9KSksIGUgLT0gYS5zcGFjZUJldHdlZW4sIGUgPCByKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IChyIC0gZSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHUuZm9yRWFjaCgoKGUsIHMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdVtzXSA9IGUgLSB0XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpLCBoLmZvckVhY2goKChlLCBzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhbc10gPSBlICsgdFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChPYmplY3QuYXNzaWduKGUsIHtcclxuICAgICAgICAgICAgICAgIHNsaWRlczogYyxcclxuICAgICAgICAgICAgICAgIHNuYXBHcmlkOiB1LFxyXG4gICAgICAgICAgICAgICAgc2xpZGVzR3JpZDogaCxcclxuICAgICAgICAgICAgICAgIHNsaWRlc1NpemVzR3JpZDogbVxyXG4gICAgICAgICAgICB9KSwgYS5jZW50ZXJlZFNsaWRlcyAmJiBhLmNzc01vZGUgJiYgIWEuY2VudGVyZWRTbGlkZXNCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgIHYoZS53cmFwcGVyRWwsIFwiLS1zd2lwZXItY2VudGVyZWQtb2Zmc2V0LWJlZm9yZVwiLCAtdVswXSArIFwicHhcIiksIHYoZS53cmFwcGVyRWwsIFwiLS1zd2lwZXItY2VudGVyZWQtb2Zmc2V0LWFmdGVyXCIsIGUuc2l6ZSAvIDIgLSBtW20ubGVuZ3RoIC0gMV0gLyAyICsgXCJweFwiKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSAtZS5zbmFwR3JpZFswXSwgcyA9IC1lLnNsaWRlc0dyaWRbMF07XHJcbiAgICAgICAgICAgICAgICBlLnNuYXBHcmlkID0gZS5zbmFwR3JpZC5tYXAoKGUgPT4gZSArIHQpKSwgZS5zbGlkZXNHcmlkID0gZS5zbGlkZXNHcmlkLm1hcCgoZSA9PiBlICsgcykpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHAgIT09IGQgJiYgZS5lbWl0KFwic2xpZGVzTGVuZ3RoQ2hhbmdlXCIpLCB1Lmxlbmd0aCAhPT0gdyAmJiAoZS5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBlLmNoZWNrT3ZlcmZsb3coKSwgZS5lbWl0KFwic25hcEdyaWRMZW5ndGhDaGFuZ2VcIikpLCBoLmxlbmd0aCAhPT0gYiAmJiBlLmVtaXQoXCJzbGlkZXNHcmlkTGVuZ3RoQ2hhbmdlXCIpLCBhLndhdGNoU2xpZGVzUHJvZ3Jlc3MgJiYgZS51cGRhdGVTbGlkZXNPZmZzZXQoKSwgIShvIHx8IGEuY3NzTW9kZSB8fCBcInNsaWRlXCIgIT09IGEuZWZmZWN0ICYmIFwiZmFkZVwiICE9PSBhLmVmZmVjdCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBgJHthLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9YmFja2ZhY2UtaGlkZGVuYCwgcyA9IGUuJGVsLmhhc0NsYXNzKHQpO1xyXG4gICAgICAgICAgICAgICAgcCA8PSBhLm1heEJhY2tmYWNlSGlkZGVuU2xpZGVzID8gcyB8fCBlLiRlbC5hZGRDbGFzcyh0KSA6IHMgJiYgZS4kZWwucmVtb3ZlQ2xhc3ModClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHVwZGF0ZUF1dG9IZWlnaHQ6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLCBzID0gW10sIGEgPSB0LnZpcnR1YWwgJiYgdC5wYXJhbXMudmlydHVhbC5lbmFibGVkO1xyXG4gICAgICAgICAgICBsZXQgaSwgciA9IDA7XHJcbiAgICAgICAgICAgIFwibnVtYmVyXCIgPT0gdHlwZW9mIGUgPyB0LnNldFRyYW5zaXRpb24oZSkgOiAhMCA9PT0gZSAmJiB0LnNldFRyYW5zaXRpb24odC5wYXJhbXMuc3BlZWQpO1xyXG4gICAgICAgICAgICBjb25zdCBuID0gZSA9PiBhID8gdC5zbGlkZXMuZmlsdGVyKCh0ID0+IHBhcnNlSW50KHQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIiksIDEwKSA9PT0gZSkpWzBdIDogdC5zbGlkZXMuZXEoZSlbMF07XHJcbiAgICAgICAgICAgIGlmIChcImF1dG9cIiAhPT0gdC5wYXJhbXMuc2xpZGVzUGVyVmlldyAmJiB0LnBhcmFtcy5zbGlkZXNQZXJWaWV3ID4gMSkgaWYgKHQucGFyYW1zLmNlbnRlcmVkU2xpZGVzKSAodC52aXNpYmxlU2xpZGVzIHx8IGQoW10pKS5lYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgIHMucHVzaChlKVxyXG4gICAgICAgICAgICB9KSk7IGVsc2UgZm9yIChpID0gMDsgaSA8IE1hdGguY2VpbCh0LnBhcmFtcy5zbGlkZXNQZXJWaWV3KTsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gdC5hY3RpdmVJbmRleCArIGk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZSA+IHQuc2xpZGVzLmxlbmd0aCAmJiAhYSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBzLnB1c2gobihlKSlcclxuICAgICAgICAgICAgfSBlbHNlIHMucHVzaChuKHQuYWN0aXZlSW5kZXgpKTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHMubGVuZ3RoOyBpICs9IDEpIGlmICh2b2lkIDAgIT09IHNbaV0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBzW2ldLm9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgICAgIHIgPSBlID4gciA/IGUgOiByXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKHIgfHwgMCA9PT0gcikgJiYgdC4kd3JhcHBlckVsLmNzcyhcImhlaWdodFwiLCBgJHtyfXB4YClcclxuICAgICAgICB9LCB1cGRhdGVTbGlkZXNPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHRoaXMsIHQgPSBlLnNsaWRlcztcclxuICAgICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCB0Lmxlbmd0aDsgcyArPSAxKSB0W3NdLnN3aXBlclNsaWRlT2Zmc2V0ID0gZS5pc0hvcml6b250YWwoKSA/IHRbc10ub2Zmc2V0TGVmdCA6IHRbc10ub2Zmc2V0VG9wXHJcbiAgICAgICAgfSwgdXBkYXRlU2xpZGVzUHJvZ3Jlc3M6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IHRoaXMgJiYgdGhpcy50cmFuc2xhdGUgfHwgMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLCBzID0gdC5wYXJhbXMsIHtzbGlkZXM6IGEsIHJ0bFRyYW5zbGF0ZTogaSwgc25hcEdyaWQ6IHJ9ID0gdDtcclxuICAgICAgICAgICAgaWYgKDAgPT09IGEubGVuZ3RoKSByZXR1cm47XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gYVswXS5zd2lwZXJTbGlkZU9mZnNldCAmJiB0LnVwZGF0ZVNsaWRlc09mZnNldCgpO1xyXG4gICAgICAgICAgICBsZXQgbiA9IC1lO1xyXG4gICAgICAgICAgICBpICYmIChuID0gZSksIGEucmVtb3ZlQ2xhc3Mocy5zbGlkZVZpc2libGVDbGFzcyksIHQudmlzaWJsZVNsaWRlc0luZGV4ZXMgPSBbXSwgdC52aXNpYmxlU2xpZGVzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgYS5sZW5ndGg7IGUgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbCA9IGFbZV07XHJcbiAgICAgICAgICAgICAgICBsZXQgbyA9IGwuc3dpcGVyU2xpZGVPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBzLmNzc01vZGUgJiYgcy5jZW50ZXJlZFNsaWRlcyAmJiAobyAtPSBhWzBdLnN3aXBlclNsaWRlT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSAobiArIChzLmNlbnRlcmVkU2xpZGVzID8gdC5taW5UcmFuc2xhdGUoKSA6IDApIC0gbykgLyAobC5zd2lwZXJTbGlkZVNpemUgKyBzLnNwYWNlQmV0d2VlbiksXHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IChuIC0gclswXSArIChzLmNlbnRlcmVkU2xpZGVzID8gdC5taW5UcmFuc2xhdGUoKSA6IDApIC0gbykgLyAobC5zd2lwZXJTbGlkZVNpemUgKyBzLnNwYWNlQmV0d2VlbiksXHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IC0obiAtIG8pLCB1ID0gcCArIHQuc2xpZGVzU2l6ZXNHcmlkW2VdO1xyXG4gICAgICAgICAgICAgICAgKHAgPj0gMCAmJiBwIDwgdC5zaXplIC0gMSB8fCB1ID4gMSAmJiB1IDw9IHQuc2l6ZSB8fCBwIDw9IDAgJiYgdSA+PSB0LnNpemUpICYmICh0LnZpc2libGVTbGlkZXMucHVzaChsKSwgdC52aXNpYmxlU2xpZGVzSW5kZXhlcy5wdXNoKGUpLCBhLmVxKGUpLmFkZENsYXNzKHMuc2xpZGVWaXNpYmxlQ2xhc3MpKSwgbC5wcm9ncmVzcyA9IGkgPyAtZCA6IGQsIGwub3JpZ2luYWxQcm9ncmVzcyA9IGkgPyAtYyA6IGNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0LnZpc2libGVTbGlkZXMgPSBkKHQudmlzaWJsZVNsaWRlcylcclxuICAgICAgICB9LCB1cGRhdGVQcm9ncmVzczogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgY29uc3QgdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSB0LnJ0bFRyYW5zbGF0ZSA/IC0xIDogMTtcclxuICAgICAgICAgICAgICAgIGUgPSB0ICYmIHQudHJhbnNsYXRlICYmIHQudHJhbnNsYXRlICogcyB8fCAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcyA9IHQucGFyYW1zLCBhID0gdC5tYXhUcmFuc2xhdGUoKSAtIHQubWluVHJhbnNsYXRlKCk7XHJcbiAgICAgICAgICAgIGxldCB7cHJvZ3Jlc3M6IGksIGlzQmVnaW5uaW5nOiByLCBpc0VuZDogbn0gPSB0O1xyXG4gICAgICAgICAgICBjb25zdCBsID0gciwgbyA9IG47XHJcbiAgICAgICAgICAgIDAgPT09IGEgPyAoaSA9IDAsIHIgPSAhMCwgbiA9ICEwKSA6IChpID0gKGUgLSB0Lm1pblRyYW5zbGF0ZSgpKSAvIGEsIHIgPSBpIDw9IDAsIG4gPSBpID49IDEpLCBPYmplY3QuYXNzaWduKHQsIHtcclxuICAgICAgICAgICAgICAgIHByb2dyZXNzOiBpLFxyXG4gICAgICAgICAgICAgICAgaXNCZWdpbm5pbmc6IHIsXHJcbiAgICAgICAgICAgICAgICBpc0VuZDogblxyXG4gICAgICAgICAgICB9KSwgKHMud2F0Y2hTbGlkZXNQcm9ncmVzcyB8fCBzLmNlbnRlcmVkU2xpZGVzICYmIHMuYXV0b0hlaWdodCkgJiYgdC51cGRhdGVTbGlkZXNQcm9ncmVzcyhlKSwgciAmJiAhbCAmJiB0LmVtaXQoXCJyZWFjaEJlZ2lubmluZyB0b0VkZ2VcIiksIG4gJiYgIW8gJiYgdC5lbWl0KFwicmVhY2hFbmQgdG9FZGdlXCIpLCAobCAmJiAhciB8fCBvICYmICFuKSAmJiB0LmVtaXQoXCJmcm9tRWRnZVwiKSwgdC5lbWl0KFwicHJvZ3Jlc3NcIiwgaSlcclxuICAgICAgICB9LCB1cGRhdGVTbGlkZXNDbGFzc2VzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0aGlzLCB7c2xpZGVzOiB0LCBwYXJhbXM6IHMsICR3cmFwcGVyRWw6IGEsIGFjdGl2ZUluZGV4OiBpLCByZWFsSW5kZXg6IHJ9ID0gZSxcclxuICAgICAgICAgICAgICAgIG4gPSBlLnZpcnR1YWwgJiYgcy52aXJ0dWFsLmVuYWJsZWQ7XHJcbiAgICAgICAgICAgIGxldCBsO1xyXG4gICAgICAgICAgICB0LnJlbW92ZUNsYXNzKGAke3Muc2xpZGVBY3RpdmVDbGFzc30gJHtzLnNsaWRlTmV4dENsYXNzfSAke3Muc2xpZGVQcmV2Q2xhc3N9ICR7cy5zbGlkZUR1cGxpY2F0ZUFjdGl2ZUNsYXNzfSAke3Muc2xpZGVEdXBsaWNhdGVOZXh0Q2xhc3N9ICR7cy5zbGlkZUR1cGxpY2F0ZVByZXZDbGFzc31gKSwgbCA9IG4gPyBlLiR3cmFwcGVyRWwuZmluZChgLiR7cy5zbGlkZUNsYXNzfVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7aX1cIl1gKSA6IHQuZXEoaSksIGwuYWRkQ2xhc3Mocy5zbGlkZUFjdGl2ZUNsYXNzKSwgcy5sb29wICYmIChsLmhhc0NsYXNzKHMuc2xpZGVEdXBsaWNhdGVDbGFzcykgPyBhLmNoaWxkcmVuKGAuJHtzLnNsaWRlQ2xhc3N9Om5vdCguJHtzLnNsaWRlRHVwbGljYXRlQ2xhc3N9KVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7cn1cIl1gKS5hZGRDbGFzcyhzLnNsaWRlRHVwbGljYXRlQWN0aXZlQ2xhc3MpIDogYS5jaGlsZHJlbihgLiR7cy5zbGlkZUNsYXNzfS4ke3Muc2xpZGVEdXBsaWNhdGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3J9XCJdYCkuYWRkQ2xhc3Mocy5zbGlkZUR1cGxpY2F0ZUFjdGl2ZUNsYXNzKSk7XHJcbiAgICAgICAgICAgIGxldCBvID0gbC5uZXh0QWxsKGAuJHtzLnNsaWRlQ2xhc3N9YCkuZXEoMCkuYWRkQ2xhc3Mocy5zbGlkZU5leHRDbGFzcyk7XHJcbiAgICAgICAgICAgIHMubG9vcCAmJiAwID09PSBvLmxlbmd0aCAmJiAobyA9IHQuZXEoMCksIG8uYWRkQ2xhc3Mocy5zbGlkZU5leHRDbGFzcykpO1xyXG4gICAgICAgICAgICBsZXQgZCA9IGwucHJldkFsbChgLiR7cy5zbGlkZUNsYXNzfWApLmVxKDApLmFkZENsYXNzKHMuc2xpZGVQcmV2Q2xhc3MpO1xyXG4gICAgICAgICAgICBzLmxvb3AgJiYgMCA9PT0gZC5sZW5ndGggJiYgKGQgPSB0LmVxKC0xKSwgZC5hZGRDbGFzcyhzLnNsaWRlUHJldkNsYXNzKSksIHMubG9vcCAmJiAoby5oYXNDbGFzcyhzLnNsaWRlRHVwbGljYXRlQ2xhc3MpID8gYS5jaGlsZHJlbihgLiR7cy5zbGlkZUNsYXNzfTpub3QoLiR7cy5zbGlkZUR1cGxpY2F0ZUNsYXNzfSlbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke28uYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpfVwiXWApLmFkZENsYXNzKHMuc2xpZGVEdXBsaWNhdGVOZXh0Q2xhc3MpIDogYS5jaGlsZHJlbihgLiR7cy5zbGlkZUNsYXNzfS4ke3Muc2xpZGVEdXBsaWNhdGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke28uYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpfVwiXWApLmFkZENsYXNzKHMuc2xpZGVEdXBsaWNhdGVOZXh0Q2xhc3MpLCBkLmhhc0NsYXNzKHMuc2xpZGVEdXBsaWNhdGVDbGFzcykgPyBhLmNoaWxkcmVuKGAuJHtzLnNsaWRlQ2xhc3N9Om5vdCguJHtzLnNsaWRlRHVwbGljYXRlQ2xhc3N9KVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7ZC5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIil9XCJdYCkuYWRkQ2xhc3Mocy5zbGlkZUR1cGxpY2F0ZVByZXZDbGFzcykgOiBhLmNoaWxkcmVuKGAuJHtzLnNsaWRlQ2xhc3N9LiR7cy5zbGlkZUR1cGxpY2F0ZUNsYXNzfVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7ZC5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIil9XCJdYCkuYWRkQ2xhc3Mocy5zbGlkZUR1cGxpY2F0ZVByZXZDbGFzcykpLCBlLmVtaXRTbGlkZXNDbGFzc2VzKClcclxuICAgICAgICB9LCB1cGRhdGVBY3RpdmVJbmRleDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMsIHMgPSB0LnJ0bFRyYW5zbGF0ZSA/IHQudHJhbnNsYXRlIDogLXQudHJhbnNsYXRlLCB7XHJcbiAgICAgICAgICAgICAgICBzbGlkZXNHcmlkOiBhLFxyXG4gICAgICAgICAgICAgICAgc25hcEdyaWQ6IGksXHJcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHIsXHJcbiAgICAgICAgICAgICAgICBhY3RpdmVJbmRleDogbixcclxuICAgICAgICAgICAgICAgIHJlYWxJbmRleDogbCxcclxuICAgICAgICAgICAgICAgIHNuYXBJbmRleDogb1xyXG4gICAgICAgICAgICB9ID0gdDtcclxuICAgICAgICAgICAgbGV0IGQsIGMgPSBlO1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwID09PSBjKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlID0gMDsgZSA8IGEubGVuZ3RoOyBlICs9IDEpIHZvaWQgMCAhPT0gYVtlICsgMV0gPyBzID49IGFbZV0gJiYgcyA8IGFbZSArIDFdIC0gKGFbZSArIDFdIC0gYVtlXSkgLyAyID8gYyA9IGUgOiBzID49IGFbZV0gJiYgcyA8IGFbZSArIDFdICYmIChjID0gZSArIDEpIDogcyA+PSBhW2VdICYmIChjID0gZSk7XHJcbiAgICAgICAgICAgICAgICByLm5vcm1hbGl6ZVNsaWRlSW5kZXggJiYgKGMgPCAwIHx8IHZvaWQgMCA9PT0gYykgJiYgKGMgPSAwKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpLmluZGV4T2YocykgPj0gMCkgZCA9IGkuaW5kZXhPZihzKTsgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gTWF0aC5taW4oci5zbGlkZXNQZXJHcm91cFNraXAsIGMpO1xyXG4gICAgICAgICAgICAgICAgZCA9IGUgKyBNYXRoLmZsb29yKChjIC0gZSkgLyByLnNsaWRlc1Blckdyb3VwKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkID49IGkubGVuZ3RoICYmIChkID0gaS5sZW5ndGggLSAxKSwgYyA9PT0gbikgcmV0dXJuIHZvaWQgKGQgIT09IG8gJiYgKHQuc25hcEluZGV4ID0gZCwgdC5lbWl0KFwic25hcEluZGV4Q2hhbmdlXCIpKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHAgPSBwYXJzZUludCh0LnNsaWRlcy5lcShjKS5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIikgfHwgYywgMTApO1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHQsIHtcclxuICAgICAgICAgICAgICAgIHNuYXBJbmRleDogZCxcclxuICAgICAgICAgICAgICAgIHJlYWxJbmRleDogcCxcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzSW5kZXg6IG4sXHJcbiAgICAgICAgICAgICAgICBhY3RpdmVJbmRleDogY1xyXG4gICAgICAgICAgICB9KSwgdC5lbWl0KFwiYWN0aXZlSW5kZXhDaGFuZ2VcIiksIHQuZW1pdChcInNuYXBJbmRleENoYW5nZVwiKSwgbCAhPT0gcCAmJiB0LmVtaXQoXCJyZWFsSW5kZXhDaGFuZ2VcIiksICh0LmluaXRpYWxpemVkIHx8IHQucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCkgJiYgdC5lbWl0KFwic2xpZGVDaGFuZ2VcIilcclxuICAgICAgICB9LCB1cGRhdGVDbGlja2VkU2xpZGU6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLCBzID0gdC5wYXJhbXMsIGEgPSBkKGUpLmNsb3Nlc3QoYC4ke3Muc2xpZGVDbGFzc31gKVswXTtcclxuICAgICAgICAgICAgbGV0IGksIHIgPSAhMTtcclxuICAgICAgICAgICAgaWYgKGEpIGZvciAobGV0IGUgPSAwOyBlIDwgdC5zbGlkZXMubGVuZ3RoOyBlICs9IDEpIGlmICh0LnNsaWRlc1tlXSA9PT0gYSkge1xyXG4gICAgICAgICAgICAgICAgciA9ICEwLCBpID0gZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFhIHx8ICFyKSByZXR1cm4gdC5jbGlja2VkU2xpZGUgPSB2b2lkIDAsIHZvaWQgKHQuY2xpY2tlZEluZGV4ID0gdm9pZCAwKTtcclxuICAgICAgICAgICAgdC5jbGlja2VkU2xpZGUgPSBhLCB0LnZpcnR1YWwgJiYgdC5wYXJhbXMudmlydHVhbC5lbmFibGVkID8gdC5jbGlja2VkSW5kZXggPSBwYXJzZUludChkKGEpLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSwgMTApIDogdC5jbGlja2VkSW5kZXggPSBpLCBzLnNsaWRlVG9DbGlja2VkU2xpZGUgJiYgdm9pZCAwICE9PSB0LmNsaWNrZWRJbmRleCAmJiB0LmNsaWNrZWRJbmRleCAhPT0gdC5hY3RpdmVJbmRleCAmJiB0LnNsaWRlVG9DbGlja2VkU2xpZGUoKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgTSA9IHtcclxuICAgICAgICBnZXRUcmFuc2xhdGU6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IHRoaXMuaXNIb3Jpem9udGFsKCkgPyBcInhcIiA6IFwieVwiKTtcclxuICAgICAgICAgICAgY29uc3Qge3BhcmFtczogdCwgcnRsVHJhbnNsYXRlOiBzLCB0cmFuc2xhdGU6IGEsICR3cmFwcGVyRWw6IGl9ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHQudmlydHVhbFRyYW5zbGF0ZSkgcmV0dXJuIHMgPyAtYSA6IGE7XHJcbiAgICAgICAgICAgIGlmICh0LmNzc01vZGUpIHJldHVybiBhO1xyXG4gICAgICAgICAgICBsZXQgciA9IGgoaVswXSwgZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzICYmIChyID0gLXIpLCByIHx8IDBcclxuICAgICAgICB9LCBzZXRUcmFuc2xhdGU6IGZ1bmN0aW9uIChlLCB0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLCB7cnRsVHJhbnNsYXRlOiBhLCBwYXJhbXM6IGksICR3cmFwcGVyRWw6IHIsIHdyYXBwZXJFbDogbiwgcHJvZ3Jlc3M6IGx9ID0gcztcclxuICAgICAgICAgICAgbGV0IG8sIGQgPSAwLCBjID0gMDtcclxuICAgICAgICAgICAgcy5pc0hvcml6b250YWwoKSA/IGQgPSBhID8gLWUgOiBlIDogYyA9IGUsIGkucm91bmRMZW5ndGhzICYmIChkID0gTWF0aC5mbG9vcihkKSwgYyA9IE1hdGguZmxvb3IoYykpLCBpLmNzc01vZGUgPyBuW3MuaXNIb3Jpem9udGFsKCkgPyBcInNjcm9sbExlZnRcIiA6IFwic2Nyb2xsVG9wXCJdID0gcy5pc0hvcml6b250YWwoKSA/IC1kIDogLWMgOiBpLnZpcnR1YWxUcmFuc2xhdGUgfHwgci50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7ZH1weCwgJHtjfXB4LCAwcHgpYCksIHMucHJldmlvdXNUcmFuc2xhdGUgPSBzLnRyYW5zbGF0ZSwgcy50cmFuc2xhdGUgPSBzLmlzSG9yaXpvbnRhbCgpID8gZCA6IGM7XHJcbiAgICAgICAgICAgIGNvbnN0IHAgPSBzLm1heFRyYW5zbGF0ZSgpIC0gcy5taW5UcmFuc2xhdGUoKTtcclxuICAgICAgICAgICAgbyA9IDAgPT09IHAgPyAwIDogKGUgLSBzLm1pblRyYW5zbGF0ZSgpKSAvIHAsIG8gIT09IGwgJiYgcy51cGRhdGVQcm9ncmVzcyhlKSwgcy5lbWl0KFwic2V0VHJhbnNsYXRlXCIsIHMudHJhbnNsYXRlLCB0KVxyXG4gICAgICAgIH0sIG1pblRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gLXRoaXMuc25hcEdyaWRbMF1cclxuICAgICAgICB9LCBtYXhUcmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnNuYXBHcmlkW3RoaXMuc25hcEdyaWQubGVuZ3RoIC0gMV1cclxuICAgICAgICB9LCB0cmFuc2xhdGVUbzogZnVuY3Rpb24gKGUsIHQsIHMsIGEsIGkpIHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBlICYmIChlID0gMCksIHZvaWQgMCA9PT0gdCAmJiAodCA9IHRoaXMucGFyYW1zLnNwZWVkKSwgdm9pZCAwID09PSBzICYmIChzID0gITApLCB2b2lkIDAgPT09IGEgJiYgKGEgPSAhMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLCB7cGFyYW1zOiBuLCB3cmFwcGVyRWw6IGx9ID0gcjtcclxuICAgICAgICAgICAgaWYgKHIuYW5pbWF0aW5nICYmIG4ucHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uKSByZXR1cm4gITE7XHJcbiAgICAgICAgICAgIGNvbnN0IG8gPSByLm1pblRyYW5zbGF0ZSgpLCBkID0gci5tYXhUcmFuc2xhdGUoKTtcclxuICAgICAgICAgICAgbGV0IGM7XHJcbiAgICAgICAgICAgIGlmIChjID0gYSAmJiBlID4gbyA/IG8gOiBhICYmIGUgPCBkID8gZCA6IGUsIHIudXBkYXRlUHJvZ3Jlc3MoYyksIG4uY3NzTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHIuaXNIb3Jpem9udGFsKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoMCA9PT0gdCkgbFtlID8gXCJzY3JvbGxMZWZ0XCIgOiBcInNjcm9sbFRvcFwiXSA9IC1jOyBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXIuc3VwcG9ydC5zbW9vdGhTY3JvbGwpIHJldHVybiB3KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpcGVyOiByLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQb3NpdGlvbjogLWMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGU6IGUgPyBcImxlZnRcIiA6IFwidG9wXCJcclxuICAgICAgICAgICAgICAgICAgICB9KSwgITA7XHJcbiAgICAgICAgICAgICAgICAgICAgbC5zY3JvbGxUbyh7W2UgPyBcImxlZnRcIiA6IFwidG9wXCJdOiAtYywgYmVoYXZpb3I6IFwic21vb3RoXCJ9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDAgPT09IHQgPyAoci5zZXRUcmFuc2l0aW9uKDApLCByLnNldFRyYW5zbGF0ZShjKSwgcyAmJiAoci5lbWl0KFwiYmVmb3JlVHJhbnNpdGlvblN0YXJ0XCIsIHQsIGkpLCByLmVtaXQoXCJ0cmFuc2l0aW9uRW5kXCIpKSkgOiAoci5zZXRUcmFuc2l0aW9uKHQpLCByLnNldFRyYW5zbGF0ZShjKSwgcyAmJiAoci5lbWl0KFwiYmVmb3JlVHJhbnNpdGlvblN0YXJ0XCIsIHQsIGkpLCByLmVtaXQoXCJ0cmFuc2l0aW9uU3RhcnRcIikpLCByLmFuaW1hdGluZyB8fCAoci5hbmltYXRpbmcgPSAhMCwgci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgfHwgKHIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIHIgJiYgIXIuZGVzdHJveWVkICYmIGUudGFyZ2V0ID09PSB0aGlzICYmIChyLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpLCByLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndlYmtpdFRyYW5zaXRpb25FbmRcIiwgci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpLCByLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCA9IG51bGwsIGRlbGV0ZSByLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCwgcyAmJiByLmVtaXQoXCJ0cmFuc2l0aW9uRW5kXCIpKVxyXG4gICAgICAgICAgICB9KSwgci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIHIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKSwgci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIsIHIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKSkpLCAhMFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gUChlKSB7XHJcbiAgICAgICAgbGV0IHtzd2lwZXI6IHQsIHJ1bkNhbGxiYWNrczogcywgZGlyZWN0aW9uOiBhLCBzdGVwOiBpfSA9IGU7XHJcbiAgICAgICAgY29uc3Qge2FjdGl2ZUluZGV4OiByLCBwcmV2aW91c0luZGV4OiBufSA9IHQ7XHJcbiAgICAgICAgbGV0IGwgPSBhO1xyXG4gICAgICAgIGlmIChsIHx8IChsID0gciA+IG4gPyBcIm5leHRcIiA6IHIgPCBuID8gXCJwcmV2XCIgOiBcInJlc2V0XCIpLCB0LmVtaXQoYHRyYW5zaXRpb24ke2l9YCksIHMgJiYgciAhPT0gbikge1xyXG4gICAgICAgICAgICBpZiAoXCJyZXNldFwiID09PSBsKSByZXR1cm4gdm9pZCB0LmVtaXQoYHNsaWRlUmVzZXRUcmFuc2l0aW9uJHtpfWApO1xyXG4gICAgICAgICAgICB0LmVtaXQoYHNsaWRlQ2hhbmdlVHJhbnNpdGlvbiR7aX1gKSwgXCJuZXh0XCIgPT09IGwgPyB0LmVtaXQoYHNsaWRlTmV4dFRyYW5zaXRpb24ke2l9YCkgOiB0LmVtaXQoYHNsaWRlUHJldlRyYW5zaXRpb24ke2l9YClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGsgPSB7XHJcbiAgICAgICAgc2xpZGVUbzogZnVuY3Rpb24gKGUsIHQsIHMsIGEsIGkpIHtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZSAmJiAoZSA9IDApLCB2b2lkIDAgPT09IHQgJiYgKHQgPSB0aGlzLnBhcmFtcy5zcGVlZCksIHZvaWQgMCA9PT0gcyAmJiAocyA9ICEwKSwgXCJudW1iZXJcIiAhPSB0eXBlb2YgZSAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBlKSB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnaW5kZXgnIGFyZ3VtZW50IGNhbm5vdCBoYXZlIHR5cGUgb3RoZXIgdGhhbiAnbnVtYmVyJyBvciAnc3RyaW5nJy4gWyR7dHlwZW9mIGV9XSBnaXZlbi5gKTtcclxuICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBwYXJzZUludChlLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKHQpKSB0aHJvdyBuZXcgRXJyb3IoYFRoZSBwYXNzZWQtaW4gJ2luZGV4JyAoc3RyaW5nKSBjb3VsZG4ndCBiZSBjb252ZXJ0ZWQgdG8gJ251bWJlcicuIFske2V9XSBnaXZlbi5gKTtcclxuICAgICAgICAgICAgICAgIGUgPSB0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgciA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBuID0gZTtcclxuICAgICAgICAgICAgbiA8IDAgJiYgKG4gPSAwKTtcclxuICAgICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBsLFxyXG4gICAgICAgICAgICAgICAgc25hcEdyaWQ6IG8sXHJcbiAgICAgICAgICAgICAgICBzbGlkZXNHcmlkOiBkLFxyXG4gICAgICAgICAgICAgICAgcHJldmlvdXNJbmRleDogYyxcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUluZGV4OiBwLFxyXG4gICAgICAgICAgICAgICAgcnRsVHJhbnNsYXRlOiB1LFxyXG4gICAgICAgICAgICAgICAgd3JhcHBlckVsOiBoLFxyXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogbVxyXG4gICAgICAgICAgICB9ID0gcjtcclxuICAgICAgICAgICAgaWYgKHIuYW5pbWF0aW5nICYmIGwucHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uIHx8ICFtICYmICFhICYmICFpKSByZXR1cm4gITE7XHJcbiAgICAgICAgICAgIGNvbnN0IGYgPSBNYXRoLm1pbihyLnBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsIG4pO1xyXG4gICAgICAgICAgICBsZXQgZyA9IGYgKyBNYXRoLmZsb29yKChuIC0gZikgLyByLnBhcmFtcy5zbGlkZXNQZXJHcm91cCk7XHJcbiAgICAgICAgICAgIGcgPj0gby5sZW5ndGggJiYgKGcgPSBvLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICBjb25zdCB2ID0gLW9bZ107XHJcbiAgICAgICAgICAgIGlmIChsLm5vcm1hbGl6ZVNsaWRlSW5kZXgpIGZvciAobGV0IGUgPSAwOyBlIDwgZC5sZW5ndGg7IGUgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IC1NYXRoLmZsb29yKDEwMCAqIHYpLCBzID0gTWF0aC5mbG9vcigxMDAgKiBkW2VdKSwgYSA9IE1hdGguZmxvb3IoMTAwICogZFtlICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSBkW2UgKyAxXSA/IHQgPj0gcyAmJiB0IDwgYSAtIChhIC0gcykgLyAyID8gbiA9IGUgOiB0ID49IHMgJiYgdCA8IGEgJiYgKG4gPSBlICsgMSkgOiB0ID49IHMgJiYgKG4gPSBlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyLmluaXRpYWxpemVkICYmIG4gIT09IHApIHtcclxuICAgICAgICAgICAgICAgIGlmICghci5hbGxvd1NsaWRlTmV4dCAmJiB2IDwgci50cmFuc2xhdGUgJiYgdiA8IHIubWluVHJhbnNsYXRlKCkpIHJldHVybiAhMTtcclxuICAgICAgICAgICAgICAgIGlmICghci5hbGxvd1NsaWRlUHJldiAmJiB2ID4gci50cmFuc2xhdGUgJiYgdiA+IHIubWF4VHJhbnNsYXRlKCkgJiYgKHAgfHwgMCkgIT09IG4pIHJldHVybiAhMVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBiO1xyXG4gICAgICAgICAgICBpZiAobiAhPT0gKGMgfHwgMCkgJiYgcyAmJiByLmVtaXQoXCJiZWZvcmVTbGlkZUNoYW5nZVN0YXJ0XCIpLCByLnVwZGF0ZVByb2dyZXNzKHYpLCBiID0gbiA+IHAgPyBcIm5leHRcIiA6IG4gPCBwID8gXCJwcmV2XCIgOiBcInJlc2V0XCIsIHUgJiYgLXYgPT09IHIudHJhbnNsYXRlIHx8ICF1ICYmIHYgPT09IHIudHJhbnNsYXRlKSByZXR1cm4gci51cGRhdGVBY3RpdmVJbmRleChuKSwgbC5hdXRvSGVpZ2h0ICYmIHIudXBkYXRlQXV0b0hlaWdodCgpLCByLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKSwgXCJzbGlkZVwiICE9PSBsLmVmZmVjdCAmJiByLnNldFRyYW5zbGF0ZSh2KSwgXCJyZXNldFwiICE9PSBiICYmIChyLnRyYW5zaXRpb25TdGFydChzLCBiKSwgci50cmFuc2l0aW9uRW5kKHMsIGIpKSwgITE7XHJcbiAgICAgICAgICAgIGlmIChsLmNzc01vZGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSByLmlzSG9yaXpvbnRhbCgpLCBzID0gdSA/IHYgOiAtdjtcclxuICAgICAgICAgICAgICAgIGlmICgwID09PSB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IHIudmlydHVhbCAmJiByLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdCAmJiAoci53cmFwcGVyRWwuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSBcIm5vbmVcIiwgci5faW1tZWRpYXRlVmlydHVhbCA9ICEwKSwgaFtlID8gXCJzY3JvbGxMZWZ0XCIgOiBcInNjcm9sbFRvcFwiXSA9IHMsIHQgJiYgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIud3JhcHBlckVsLnN0eWxlLnNjcm9sbFNuYXBUeXBlID0gXCJcIiwgci5fc3dpcGVySW1tZWRpYXRlVmlydHVhbCA9ICExXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghci5zdXBwb3J0LnNtb290aFNjcm9sbCkgcmV0dXJuIHcoe3N3aXBlcjogciwgdGFyZ2V0UG9zaXRpb246IHMsIHNpZGU6IGUgPyBcImxlZnRcIiA6IFwidG9wXCJ9KSwgITA7XHJcbiAgICAgICAgICAgICAgICAgICAgaC5zY3JvbGxUbyh7W2UgPyBcImxlZnRcIiA6IFwidG9wXCJdOiBzLCBiZWhhdmlvcjogXCJzbW9vdGhcIn0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gITBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gci5zZXRUcmFuc2l0aW9uKHQpLCByLnNldFRyYW5zbGF0ZSh2KSwgci51cGRhdGVBY3RpdmVJbmRleChuKSwgci51cGRhdGVTbGlkZXNDbGFzc2VzKCksIHIuZW1pdChcImJlZm9yZVRyYW5zaXRpb25TdGFydFwiLCB0LCBhKSwgci50cmFuc2l0aW9uU3RhcnQocywgYiksIDAgPT09IHQgPyByLnRyYW5zaXRpb25FbmQocywgYikgOiByLmFuaW1hdGluZyB8fCAoci5hbmltYXRpbmcgPSAhMCwgci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCB8fCAoci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICByICYmICFyLmRlc3Ryb3llZCAmJiBlLnRhcmdldCA9PT0gdGhpcyAmJiAoci4kd3JhcHBlckVsWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIHIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpLCByLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndlYmtpdFRyYW5zaXRpb25FbmRcIiwgci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCksIHIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgPSBudWxsLCBkZWxldGUgci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCwgci50cmFuc2l0aW9uRW5kKHMsIGIpKVxyXG4gICAgICAgICAgICB9KSwgci4kd3JhcHBlckVsWzBdLmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIHIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpLCByLiR3cmFwcGVyRWxbMF0uYWRkRXZlbnRMaXN0ZW5lcihcIndlYmtpdFRyYW5zaXRpb25FbmRcIiwgci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCkpLCAhMFxyXG4gICAgICAgIH0sIHNsaWRlVG9Mb29wOiBmdW5jdGlvbiAoZSwgdCwgcywgYSkge1xyXG4gICAgICAgICAgICBpZiAodm9pZCAwID09PSBlICYmIChlID0gMCksIHZvaWQgMCA9PT0gdCAmJiAodCA9IHRoaXMucGFyYW1zLnNwZWVkKSwgdm9pZCAwID09PSBzICYmIChzID0gITApLCBcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gcGFyc2VJbnQoZSwgMTApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZSh0KSkgdGhyb3cgbmV3IEVycm9yKGBUaGUgcGFzc2VkLWluICdpbmRleCcgKHN0cmluZykgY291bGRuJ3QgYmUgY29udmVydGVkIHRvICdudW1iZXInLiBbJHtlfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgICAgICAgICBlID0gdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGkgPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgciA9IGU7XHJcbiAgICAgICAgICAgIHJldHVybiBpLnBhcmFtcy5sb29wICYmIChyICs9IGkubG9vcGVkU2xpZGVzKSwgaS5zbGlkZVRvKHIsIHQsIHMsIGEpXHJcbiAgICAgICAgfSwgc2xpZGVOZXh0OiBmdW5jdGlvbiAoZSwgdCwgcykge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSB0aGlzLnBhcmFtcy5zcGVlZCksIHZvaWQgMCA9PT0gdCAmJiAodCA9ICEwKTtcclxuICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMsIHthbmltYXRpbmc6IGksIGVuYWJsZWQ6IHIsIHBhcmFtczogbn0gPSBhO1xyXG4gICAgICAgICAgICBpZiAoIXIpIHJldHVybiBhO1xyXG4gICAgICAgICAgICBsZXQgbCA9IG4uc2xpZGVzUGVyR3JvdXA7XHJcbiAgICAgICAgICAgIFwiYXV0b1wiID09PSBuLnNsaWRlc1BlclZpZXcgJiYgMSA9PT0gbi5zbGlkZXNQZXJHcm91cCAmJiBuLnNsaWRlc1Blckdyb3VwQXV0byAmJiAobCA9IE1hdGgubWF4KGEuc2xpZGVzUGVyVmlld0R5bmFtaWMoXCJjdXJyZW50XCIsICEwKSwgMSkpO1xyXG4gICAgICAgICAgICBjb25zdCBvID0gYS5hY3RpdmVJbmRleCA8IG4uc2xpZGVzUGVyR3JvdXBTa2lwID8gMSA6IGw7XHJcbiAgICAgICAgICAgIGlmIChuLmxvb3ApIHtcclxuICAgICAgICAgICAgICAgIGlmIChpICYmIG4ubG9vcFByZXZlbnRzU2xpZGUpIHJldHVybiAhMTtcclxuICAgICAgICAgICAgICAgIGEubG9vcEZpeCgpLCBhLl9jbGllbnRMZWZ0ID0gYS4kd3JhcHBlckVsWzBdLmNsaWVudExlZnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbi5yZXdpbmQgJiYgYS5pc0VuZCA/IGEuc2xpZGVUbygwLCBlLCB0LCBzKSA6IGEuc2xpZGVUbyhhLmFjdGl2ZUluZGV4ICsgbywgZSwgdCwgcylcclxuICAgICAgICB9LCBzbGlkZVByZXY6IGZ1bmN0aW9uIChlLCB0LCBzKSB7XHJcbiAgICAgICAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9IHRoaXMucGFyYW1zLnNwZWVkKSwgdm9pZCAwID09PSB0ICYmICh0ID0gITApO1xyXG4gICAgICAgICAgICBjb25zdCBhID0gdGhpcywge3BhcmFtczogaSwgYW5pbWF0aW5nOiByLCBzbmFwR3JpZDogbiwgc2xpZGVzR3JpZDogbCwgcnRsVHJhbnNsYXRlOiBvLCBlbmFibGVkOiBkfSA9IGE7XHJcbiAgICAgICAgICAgIGlmICghZCkgcmV0dXJuIGE7XHJcbiAgICAgICAgICAgIGlmIChpLmxvb3ApIHtcclxuICAgICAgICAgICAgICAgIGlmIChyICYmIGkubG9vcFByZXZlbnRzU2xpZGUpIHJldHVybiAhMTtcclxuICAgICAgICAgICAgICAgIGEubG9vcEZpeCgpLCBhLl9jbGllbnRMZWZ0ID0gYS4kd3JhcHBlckVsWzBdLmNsaWVudExlZnRcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gYyhlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZSA8IDAgPyAtTWF0aC5mbG9vcihNYXRoLmFicyhlKSkgOiBNYXRoLmZsb29yKGUpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHAgPSBjKG8gPyBhLnRyYW5zbGF0ZSA6IC1hLnRyYW5zbGF0ZSksIHUgPSBuLm1hcCgoZSA9PiBjKGUpKSk7XHJcbiAgICAgICAgICAgIGxldCBoID0gblt1LmluZGV4T2YocCkgLSAxXTtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gaCAmJiBpLmNzc01vZGUpIHtcclxuICAgICAgICAgICAgICAgIGxldCBlO1xyXG4gICAgICAgICAgICAgICAgbi5mb3JFYWNoKCgodCwgcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHAgPj0gdCAmJiAoZSA9IHMpXHJcbiAgICAgICAgICAgICAgICB9KSksIHZvaWQgMCAhPT0gZSAmJiAoaCA9IG5bZSA+IDAgPyBlIC0gMSA6IGVdKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBtID0gMDtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gaCAmJiAobSA9IGwuaW5kZXhPZihoKSwgbSA8IDAgJiYgKG0gPSBhLmFjdGl2ZUluZGV4IC0gMSksIFwiYXV0b1wiID09PSBpLnNsaWRlc1BlclZpZXcgJiYgMSA9PT0gaS5zbGlkZXNQZXJHcm91cCAmJiBpLnNsaWRlc1Blckdyb3VwQXV0byAmJiAobSA9IG0gLSBhLnNsaWRlc1BlclZpZXdEeW5hbWljKFwicHJldmlvdXNcIiwgITApICsgMSwgbSA9IE1hdGgubWF4KG0sIDApKSksIGkucmV3aW5kICYmIGEuaXNCZWdpbm5pbmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBhLnBhcmFtcy52aXJ0dWFsICYmIGEucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCAmJiBhLnZpcnR1YWwgPyBhLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCAtIDEgOiBhLnNsaWRlcy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuc2xpZGVUbyhpLCBlLCB0LCBzKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhLnNsaWRlVG8obSwgZSwgdCwgcylcclxuICAgICAgICB9LCBzbGlkZVJlc2V0OiBmdW5jdGlvbiAoZSwgdCwgcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSBlICYmIChlID0gdGhpcy5wYXJhbXMuc3BlZWQpLCB2b2lkIDAgPT09IHQgJiYgKHQgPSAhMCksIHRoaXMuc2xpZGVUbyh0aGlzLmFjdGl2ZUluZGV4LCBlLCB0LCBzKVxyXG4gICAgICAgIH0sIHNsaWRlVG9DbG9zZXN0OiBmdW5jdGlvbiAoZSwgdCwgcywgYSkge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSB0aGlzLnBhcmFtcy5zcGVlZCksIHZvaWQgMCA9PT0gdCAmJiAodCA9ICEwKSwgdm9pZCAwID09PSBhICYmIChhID0gLjUpO1xyXG4gICAgICAgICAgICBjb25zdCBpID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHIgPSBpLmFjdGl2ZUluZGV4O1xyXG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oaS5wYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwLCByKSwgbCA9IG4gKyBNYXRoLmZsb29yKChyIC0gbikgLyBpLnBhcmFtcy5zbGlkZXNQZXJHcm91cCksXHJcbiAgICAgICAgICAgICAgICBvID0gaS5ydGxUcmFuc2xhdGUgPyBpLnRyYW5zbGF0ZSA6IC1pLnRyYW5zbGF0ZTtcclxuICAgICAgICAgICAgaWYgKG8gPj0gaS5zbmFwR3JpZFtsXSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IGkuc25hcEdyaWRbbF07XHJcbiAgICAgICAgICAgICAgICBvIC0gZSA+IChpLnNuYXBHcmlkW2wgKyAxXSAtIGUpICogYSAmJiAociArPSBpLnBhcmFtcy5zbGlkZXNQZXJHcm91cClcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBpLnNuYXBHcmlkW2wgLSAxXTtcclxuICAgICAgICAgICAgICAgIG8gLSBlIDw9IChpLnNuYXBHcmlkW2xdIC0gZSkgKiBhICYmIChyIC09IGkucGFyYW1zLnNsaWRlc1Blckdyb3VwKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByID0gTWF0aC5tYXgociwgMCksIHIgPSBNYXRoLm1pbihyLCBpLnNsaWRlc0dyaWQubGVuZ3RoIC0gMSksIGkuc2xpZGVUbyhyLCBlLCB0LCBzKVxyXG4gICAgICAgIH0sIHNsaWRlVG9DbGlja2VkU2xpZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHRoaXMsIHtwYXJhbXM6IHQsICR3cmFwcGVyRWw6IHN9ID0gZSxcclxuICAgICAgICAgICAgICAgIGEgPSBcImF1dG9cIiA9PT0gdC5zbGlkZXNQZXJWaWV3ID8gZS5zbGlkZXNQZXJWaWV3RHluYW1pYygpIDogdC5zbGlkZXNQZXJWaWV3O1xyXG4gICAgICAgICAgICBsZXQgaSwgciA9IGUuY2xpY2tlZEluZGV4O1xyXG4gICAgICAgICAgICBpZiAodC5sb29wKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5hbmltYXRpbmcpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGkgPSBwYXJzZUludChkKGUuY2xpY2tlZFNsaWRlKS5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIiksIDEwKSwgdC5jZW50ZXJlZFNsaWRlcyA/IHIgPCBlLmxvb3BlZFNsaWRlcyAtIGEgLyAyIHx8IHIgPiBlLnNsaWRlcy5sZW5ndGggLSBlLmxvb3BlZFNsaWRlcyArIGEgLyAyID8gKGUubG9vcEZpeCgpLCByID0gcy5jaGlsZHJlbihgLiR7dC5zbGlkZUNsYXNzfVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7aX1cIl06bm90KC4ke3Quc2xpZGVEdXBsaWNhdGVDbGFzc30pYCkuZXEoMCkuaW5kZXgoKSwgcCgoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGUuc2xpZGVUbyhyKVxyXG4gICAgICAgICAgICAgICAgfSkpKSA6IGUuc2xpZGVUbyhyKSA6IHIgPiBlLnNsaWRlcy5sZW5ndGggLSBhID8gKGUubG9vcEZpeCgpLCByID0gcy5jaGlsZHJlbihgLiR7dC5zbGlkZUNsYXNzfVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7aX1cIl06bm90KC4ke3Quc2xpZGVEdXBsaWNhdGVDbGFzc30pYCkuZXEoMCkuaW5kZXgoKSwgcCgoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGUuc2xpZGVUbyhyKVxyXG4gICAgICAgICAgICAgICAgfSkpKSA6IGUuc2xpZGVUbyhyKVxyXG4gICAgICAgICAgICB9IGVsc2UgZS5zbGlkZVRvKHIpXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciB6ID0ge1xyXG4gICAgICAgIGxvb3BDcmVhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHRoaXMsIHQgPSBhKCksIHtwYXJhbXM6IHMsICR3cmFwcGVyRWw6IGl9ID0gZSxcclxuICAgICAgICAgICAgICAgIHIgPSBpLmNoaWxkcmVuKCkubGVuZ3RoID4gMCA/IGQoaS5jaGlsZHJlbigpWzBdLnBhcmVudE5vZGUpIDogaTtcclxuICAgICAgICAgICAgci5jaGlsZHJlbihgLiR7cy5zbGlkZUNsYXNzfS4ke3Muc2xpZGVEdXBsaWNhdGVDbGFzc31gKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgbGV0IG4gPSByLmNoaWxkcmVuKGAuJHtzLnNsaWRlQ2xhc3N9YCk7XHJcbiAgICAgICAgICAgIGlmIChzLmxvb3BGaWxsR3JvdXBXaXRoQmxhbmspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBzLnNsaWRlc1Blckdyb3VwIC0gbi5sZW5ndGggJSBzLnNsaWRlc1Blckdyb3VwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUgIT09IHMuc2xpZGVzUGVyR3JvdXApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGU7IGEgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gZCh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLmFkZENsYXNzKGAke3Muc2xpZGVDbGFzc30gJHtzLnNsaWRlQmxhbmtDbGFzc31gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgci5hcHBlbmQoZSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IHIuY2hpbGRyZW4oYC4ke3Muc2xpZGVDbGFzc31gKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFwiYXV0b1wiICE9PSBzLnNsaWRlc1BlclZpZXcgfHwgcy5sb29wZWRTbGlkZXMgfHwgKHMubG9vcGVkU2xpZGVzID0gbi5sZW5ndGgpLCBlLmxvb3BlZFNsaWRlcyA9IE1hdGguY2VpbChwYXJzZUZsb2F0KHMubG9vcGVkU2xpZGVzIHx8IHMuc2xpZGVzUGVyVmlldywgMTApKSwgZS5sb29wZWRTbGlkZXMgKz0gcy5sb29wQWRkaXRpb25hbFNsaWRlcywgZS5sb29wZWRTbGlkZXMgPiBuLmxlbmd0aCAmJiBlLnBhcmFtcy5sb29wZWRTbGlkZXNMaW1pdCAmJiAoZS5sb29wZWRTbGlkZXMgPSBuLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGwgPSBbXSwgbyA9IFtdO1xyXG4gICAgICAgICAgICBuLmVhY2goKChlLCB0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBkKGUpLmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiLCB0KVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgZS5sb29wZWRTbGlkZXM7IHQgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHQgLSBNYXRoLmZsb29yKHQgLyBuLmxlbmd0aCkgKiBuLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIG8ucHVzaChuLmVxKGUpWzBdKSwgbC51bnNoaWZ0KG4uZXEobi5sZW5ndGggLSBlIC0gMSlbMF0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgZSA9IDA7IGUgPCBvLmxlbmd0aDsgZSArPSAxKSByLmFwcGVuZChkKG9bZV0uY2xvbmVOb2RlKCEwKSkuYWRkQ2xhc3Mocy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGUgPSBsLmxlbmd0aCAtIDE7IGUgPj0gMDsgZSAtPSAxKSByLnByZXBlbmQoZChsW2VdLmNsb25lTm9kZSghMCkpLmFkZENsYXNzKHMuc2xpZGVEdXBsaWNhdGVDbGFzcykpXHJcbiAgICAgICAgfSwgbG9vcEZpeDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdGhpcztcclxuICAgICAgICAgICAgZS5lbWl0KFwiYmVmb3JlTG9vcEZpeFwiKTtcclxuICAgICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlSW5kZXg6IHQsXHJcbiAgICAgICAgICAgICAgICBzbGlkZXM6IHMsXHJcbiAgICAgICAgICAgICAgICBsb29wZWRTbGlkZXM6IGEsXHJcbiAgICAgICAgICAgICAgICBhbGxvd1NsaWRlUHJldjogaSxcclxuICAgICAgICAgICAgICAgIGFsbG93U2xpZGVOZXh0OiByLFxyXG4gICAgICAgICAgICAgICAgc25hcEdyaWQ6IG4sXHJcbiAgICAgICAgICAgICAgICBydGxUcmFuc2xhdGU6IGxcclxuICAgICAgICAgICAgfSA9IGU7XHJcbiAgICAgICAgICAgIGxldCBvO1xyXG4gICAgICAgICAgICBlLmFsbG93U2xpZGVQcmV2ID0gITAsIGUuYWxsb3dTbGlkZU5leHQgPSAhMDtcclxuICAgICAgICAgICAgY29uc3QgZCA9IC1uW3RdIC0gZS5nZXRUcmFuc2xhdGUoKTtcclxuICAgICAgICAgICAgaWYgKHQgPCBhKSB7XHJcbiAgICAgICAgICAgICAgICBvID0gcy5sZW5ndGggLSAzICogYSArIHQsIG8gKz0gYTtcclxuICAgICAgICAgICAgICAgIGUuc2xpZGVUbyhvLCAwLCAhMSwgITApICYmIDAgIT09IGQgJiYgZS5zZXRUcmFuc2xhdGUoKGwgPyAtZS50cmFuc2xhdGUgOiBlLnRyYW5zbGF0ZSkgLSBkKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHQgPj0gcy5sZW5ndGggLSBhKSB7XHJcbiAgICAgICAgICAgICAgICBvID0gLXMubGVuZ3RoICsgdCArIGEsIG8gKz0gYTtcclxuICAgICAgICAgICAgICAgIGUuc2xpZGVUbyhvLCAwLCAhMSwgITApICYmIDAgIT09IGQgJiYgZS5zZXRUcmFuc2xhdGUoKGwgPyAtZS50cmFuc2xhdGUgOiBlLnRyYW5zbGF0ZSkgLSBkKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGUuYWxsb3dTbGlkZVByZXYgPSBpLCBlLmFsbG93U2xpZGVOZXh0ID0gciwgZS5lbWl0KFwibG9vcEZpeFwiKVxyXG4gICAgICAgIH0sIGxvb3BEZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHskd3JhcHBlckVsOiBlLCBwYXJhbXM6IHQsIHNsaWRlczogc30gPSB0aGlzO1xyXG4gICAgICAgICAgICBlLmNoaWxkcmVuKGAuJHt0LnNsaWRlQ2xhc3N9LiR7dC5zbGlkZUR1cGxpY2F0ZUNsYXNzfSwuJHt0LnNsaWRlQ2xhc3N9LiR7dC5zbGlkZUJsYW5rQ2xhc3N9YCkucmVtb3ZlKCksIHMucmVtb3ZlQXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBMKGUpIHtcclxuICAgICAgICBjb25zdCB0ID0gdGhpcywgcyA9IGEoKSwgaSA9IHIoKSwgbiA9IHQudG91Y2hFdmVudHNEYXRhLCB7cGFyYW1zOiBsLCB0b3VjaGVzOiBvLCBlbmFibGVkOiBjfSA9IHQ7XHJcbiAgICAgICAgaWYgKCFjKSByZXR1cm47XHJcbiAgICAgICAgaWYgKHQuYW5pbWF0aW5nICYmIGwucHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uKSByZXR1cm47XHJcbiAgICAgICAgIXQuYW5pbWF0aW5nICYmIGwuY3NzTW9kZSAmJiBsLmxvb3AgJiYgdC5sb29wRml4KCk7XHJcbiAgICAgICAgbGV0IHAgPSBlO1xyXG4gICAgICAgIHAub3JpZ2luYWxFdmVudCAmJiAocCA9IHAub3JpZ2luYWxFdmVudCk7XHJcbiAgICAgICAgbGV0IGggPSBkKHAudGFyZ2V0KTtcclxuICAgICAgICBpZiAoXCJ3cmFwcGVyXCIgPT09IGwudG91Y2hFdmVudHNUYXJnZXQgJiYgIWguY2xvc2VzdCh0LndyYXBwZXJFbCkubGVuZ3RoKSByZXR1cm47XHJcbiAgICAgICAgaWYgKG4uaXNUb3VjaEV2ZW50ID0gXCJ0b3VjaHN0YXJ0XCIgPT09IHAudHlwZSwgIW4uaXNUb3VjaEV2ZW50ICYmIFwid2hpY2hcIiBpbiBwICYmIDMgPT09IHAud2hpY2gpIHJldHVybjtcclxuICAgICAgICBpZiAoIW4uaXNUb3VjaEV2ZW50ICYmIFwiYnV0dG9uXCIgaW4gcCAmJiBwLmJ1dHRvbiA+IDApIHJldHVybjtcclxuICAgICAgICBpZiAobi5pc1RvdWNoZWQgJiYgbi5pc01vdmVkKSByZXR1cm47XHJcbiAgICAgICAgY29uc3QgbSA9ICEhbC5ub1N3aXBpbmdDbGFzcyAmJiBcIlwiICE9PSBsLm5vU3dpcGluZ0NsYXNzLCBmID0gZS5jb21wb3NlZFBhdGggPyBlLmNvbXBvc2VkUGF0aCgpIDogZS5wYXRoO1xyXG4gICAgICAgIG0gJiYgcC50YXJnZXQgJiYgcC50YXJnZXQuc2hhZG93Um9vdCAmJiBmICYmIChoID0gZChmWzBdKSk7XHJcbiAgICAgICAgY29uc3QgZyA9IGwubm9Td2lwaW5nU2VsZWN0b3IgPyBsLm5vU3dpcGluZ1NlbGVjdG9yIDogYC4ke2wubm9Td2lwaW5nQ2xhc3N9YCxcclxuICAgICAgICAgICAgdiA9ICEoIXAudGFyZ2V0IHx8ICFwLnRhcmdldC5zaGFkb3dSb290KTtcclxuICAgICAgICBpZiAobC5ub1N3aXBpbmcgJiYgKHYgPyBmdW5jdGlvbiAoZSwgdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSB0ICYmICh0ID0gdGhpcyksIGZ1bmN0aW9uIHQocykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzIHx8IHMgPT09IGEoKSB8fCBzID09PSByKCkpIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgcy5hc3NpZ25lZFNsb3QgJiYgKHMgPSBzLmFzc2lnbmVkU2xvdCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gcy5jbG9zZXN0KGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgfHwgcy5nZXRSb290Tm9kZSA/IGkgfHwgdChzLmdldFJvb3ROb2RlKCkuaG9zdCkgOiBudWxsXHJcbiAgICAgICAgICAgIH0odClcclxuICAgICAgICB9KGcsIGhbMF0pIDogaC5jbG9zZXN0KGcpWzBdKSkgcmV0dXJuIHZvaWQgKHQuYWxsb3dDbGljayA9ICEwKTtcclxuICAgICAgICBpZiAobC5zd2lwZUhhbmRsZXIgJiYgIWguY2xvc2VzdChsLnN3aXBlSGFuZGxlcilbMF0pIHJldHVybjtcclxuICAgICAgICBvLmN1cnJlbnRYID0gXCJ0b3VjaHN0YXJ0XCIgPT09IHAudHlwZSA/IHAudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IHAucGFnZVgsIG8uY3VycmVudFkgPSBcInRvdWNoc3RhcnRcIiA9PT0gcC50eXBlID8gcC50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogcC5wYWdlWTtcclxuICAgICAgICBjb25zdCB3ID0gby5jdXJyZW50WCwgYiA9IG8uY3VycmVudFksIHggPSBsLmVkZ2VTd2lwZURldGVjdGlvbiB8fCBsLmlPU0VkZ2VTd2lwZURldGVjdGlvbixcclxuICAgICAgICAgICAgeSA9IGwuZWRnZVN3aXBlVGhyZXNob2xkIHx8IGwuaU9TRWRnZVN3aXBlVGhyZXNob2xkO1xyXG4gICAgICAgIGlmICh4ICYmICh3IDw9IHkgfHwgdyA+PSBpLmlubmVyV2lkdGggLSB5KSkge1xyXG4gICAgICAgICAgICBpZiAoXCJwcmV2ZW50XCIgIT09IHgpIHJldHVybjtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChPYmplY3QuYXNzaWduKG4sIHtcclxuICAgICAgICAgICAgaXNUb3VjaGVkOiAhMCxcclxuICAgICAgICAgICAgaXNNb3ZlZDogITEsXHJcbiAgICAgICAgICAgIGFsbG93VG91Y2hDYWxsYmFja3M6ICEwLFxyXG4gICAgICAgICAgICBpc1Njcm9sbGluZzogdm9pZCAwLFxyXG4gICAgICAgICAgICBzdGFydE1vdmluZzogdm9pZCAwXHJcbiAgICAgICAgfSksIG8uc3RhcnRYID0gdywgby5zdGFydFkgPSBiLCBuLnRvdWNoU3RhcnRUaW1lID0gdSgpLCB0LmFsbG93Q2xpY2sgPSAhMCwgdC51cGRhdGVTaXplKCksIHQuc3dpcGVEaXJlY3Rpb24gPSB2b2lkIDAsIGwudGhyZXNob2xkID4gMCAmJiAobi5hbGxvd1RocmVzaG9sZE1vdmUgPSAhMSksIFwidG91Y2hzdGFydFwiICE9PSBwLnR5cGUpIHtcclxuICAgICAgICAgICAgbGV0IGUgPSAhMDtcclxuICAgICAgICAgICAgaC5pcyhuLmZvY3VzYWJsZUVsZW1lbnRzKSAmJiAoZSA9ICExLCBcIlNFTEVDVFwiID09PSBoWzBdLm5vZGVOYW1lICYmIChuLmlzVG91Y2hlZCA9ICExKSksIHMuYWN0aXZlRWxlbWVudCAmJiBkKHMuYWN0aXZlRWxlbWVudCkuaXMobi5mb2N1c2FibGVFbGVtZW50cykgJiYgcy5hY3RpdmVFbGVtZW50ICE9PSBoWzBdICYmIHMuYWN0aXZlRWxlbWVudC5ibHVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSBlICYmIHQuYWxsb3dUb3VjaE1vdmUgJiYgbC50b3VjaFN0YXJ0UHJldmVudERlZmF1bHQ7XHJcbiAgICAgICAgICAgICFsLnRvdWNoU3RhcnRGb3JjZVByZXZlbnREZWZhdWx0ICYmICFhIHx8IGhbMF0uaXNDb250ZW50RWRpdGFibGUgfHwgcC5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHQucGFyYW1zLmZyZWVNb2RlICYmIHQucGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQgJiYgdC5mcmVlTW9kZSAmJiB0LmFuaW1hdGluZyAmJiAhbC5jc3NNb2RlICYmIHQuZnJlZU1vZGUub25Ub3VjaFN0YXJ0KCksIHQuZW1pdChcInRvdWNoU3RhcnRcIiwgcClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBPKGUpIHtcclxuICAgICAgICBjb25zdCB0ID0gYSgpLCBzID0gdGhpcywgaSA9IHMudG91Y2hFdmVudHNEYXRhLCB7cGFyYW1zOiByLCB0b3VjaGVzOiBuLCBydGxUcmFuc2xhdGU6IGwsIGVuYWJsZWQ6IG99ID0gcztcclxuICAgICAgICBpZiAoIW8pIHJldHVybjtcclxuICAgICAgICBsZXQgYyA9IGU7XHJcbiAgICAgICAgaWYgKGMub3JpZ2luYWxFdmVudCAmJiAoYyA9IGMub3JpZ2luYWxFdmVudCksICFpLmlzVG91Y2hlZCkgcmV0dXJuIHZvaWQgKGkuc3RhcnRNb3ZpbmcgJiYgaS5pc1Njcm9sbGluZyAmJiBzLmVtaXQoXCJ0b3VjaE1vdmVPcHBvc2l0ZVwiLCBjKSk7XHJcbiAgICAgICAgaWYgKGkuaXNUb3VjaEV2ZW50ICYmIFwidG91Y2htb3ZlXCIgIT09IGMudHlwZSkgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IHAgPSBcInRvdWNobW92ZVwiID09PSBjLnR5cGUgJiYgYy50YXJnZXRUb3VjaGVzICYmIChjLnRhcmdldFRvdWNoZXNbMF0gfHwgYy5jaGFuZ2VkVG91Y2hlc1swXSksXHJcbiAgICAgICAgICAgIGggPSBcInRvdWNobW92ZVwiID09PSBjLnR5cGUgPyBwLnBhZ2VYIDogYy5wYWdlWCwgbSA9IFwidG91Y2htb3ZlXCIgPT09IGMudHlwZSA/IHAucGFnZVkgOiBjLnBhZ2VZO1xyXG4gICAgICAgIGlmIChjLnByZXZlbnRlZEJ5TmVzdGVkU3dpcGVyKSByZXR1cm4gbi5zdGFydFggPSBoLCB2b2lkIChuLnN0YXJ0WSA9IG0pO1xyXG4gICAgICAgIGlmICghcy5hbGxvd1RvdWNoTW92ZSkgcmV0dXJuIGQoYy50YXJnZXQpLmlzKGkuZm9jdXNhYmxlRWxlbWVudHMpIHx8IChzLmFsbG93Q2xpY2sgPSAhMSksIHZvaWQgKGkuaXNUb3VjaGVkICYmIChPYmplY3QuYXNzaWduKG4sIHtcclxuICAgICAgICAgICAgc3RhcnRYOiBoLFxyXG4gICAgICAgICAgICBzdGFydFk6IG0sXHJcbiAgICAgICAgICAgIGN1cnJlbnRYOiBoLFxyXG4gICAgICAgICAgICBjdXJyZW50WTogbVxyXG4gICAgICAgIH0pLCBpLnRvdWNoU3RhcnRUaW1lID0gdSgpKSk7XHJcbiAgICAgICAgaWYgKGkuaXNUb3VjaEV2ZW50ICYmIHIudG91Y2hSZWxlYXNlT25FZGdlcyAmJiAhci5sb29wKSBpZiAocy5pc1ZlcnRpY2FsKCkpIHtcclxuICAgICAgICAgICAgaWYgKG0gPCBuLnN0YXJ0WSAmJiBzLnRyYW5zbGF0ZSA8PSBzLm1heFRyYW5zbGF0ZSgpIHx8IG0gPiBuLnN0YXJ0WSAmJiBzLnRyYW5zbGF0ZSA+PSBzLm1pblRyYW5zbGF0ZSgpKSByZXR1cm4gaS5pc1RvdWNoZWQgPSAhMSwgdm9pZCAoaS5pc01vdmVkID0gITEpXHJcbiAgICAgICAgfSBlbHNlIGlmIChoIDwgbi5zdGFydFggJiYgcy50cmFuc2xhdGUgPD0gcy5tYXhUcmFuc2xhdGUoKSB8fCBoID4gbi5zdGFydFggJiYgcy50cmFuc2xhdGUgPj0gcy5taW5UcmFuc2xhdGUoKSkgcmV0dXJuO1xyXG4gICAgICAgIGlmIChpLmlzVG91Y2hFdmVudCAmJiB0LmFjdGl2ZUVsZW1lbnQgJiYgYy50YXJnZXQgPT09IHQuYWN0aXZlRWxlbWVudCAmJiBkKGMudGFyZ2V0KS5pcyhpLmZvY3VzYWJsZUVsZW1lbnRzKSkgcmV0dXJuIGkuaXNNb3ZlZCA9ICEwLCB2b2lkIChzLmFsbG93Q2xpY2sgPSAhMSk7XHJcbiAgICAgICAgaWYgKGkuYWxsb3dUb3VjaENhbGxiYWNrcyAmJiBzLmVtaXQoXCJ0b3VjaE1vdmVcIiwgYyksIGMudGFyZ2V0VG91Y2hlcyAmJiBjLnRhcmdldFRvdWNoZXMubGVuZ3RoID4gMSkgcmV0dXJuO1xyXG4gICAgICAgIG4uY3VycmVudFggPSBoLCBuLmN1cnJlbnRZID0gbTtcclxuICAgICAgICBjb25zdCBmID0gbi5jdXJyZW50WCAtIG4uc3RhcnRYLCBnID0gbi5jdXJyZW50WSAtIG4uc3RhcnRZO1xyXG4gICAgICAgIGlmIChzLnBhcmFtcy50aHJlc2hvbGQgJiYgTWF0aC5zcXJ0KGYgKiogMiArIGcgKiogMikgPCBzLnBhcmFtcy50aHJlc2hvbGQpIHJldHVybjtcclxuICAgICAgICBpZiAodm9pZCAwID09PSBpLmlzU2Nyb2xsaW5nKSB7XHJcbiAgICAgICAgICAgIGxldCBlO1xyXG4gICAgICAgICAgICBzLmlzSG9yaXpvbnRhbCgpICYmIG4uY3VycmVudFkgPT09IG4uc3RhcnRZIHx8IHMuaXNWZXJ0aWNhbCgpICYmIG4uY3VycmVudFggPT09IG4uc3RhcnRYID8gaS5pc1Njcm9sbGluZyA9ICExIDogZiAqIGYgKyBnICogZyA+PSAyNSAmJiAoZSA9IDE4MCAqIE1hdGguYXRhbjIoTWF0aC5hYnMoZyksIE1hdGguYWJzKGYpKSAvIE1hdGguUEksIGkuaXNTY3JvbGxpbmcgPSBzLmlzSG9yaXpvbnRhbCgpID8gZSA+IHIudG91Y2hBbmdsZSA6IDkwIC0gZSA+IHIudG91Y2hBbmdsZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGkuaXNTY3JvbGxpbmcgJiYgcy5lbWl0KFwidG91Y2hNb3ZlT3Bwb3NpdGVcIiwgYyksIHZvaWQgMCA9PT0gaS5zdGFydE1vdmluZyAmJiAobi5jdXJyZW50WCA9PT0gbi5zdGFydFggJiYgbi5jdXJyZW50WSA9PT0gbi5zdGFydFkgfHwgKGkuc3RhcnRNb3ZpbmcgPSAhMCkpLCBpLmlzU2Nyb2xsaW5nKSByZXR1cm4gdm9pZCAoaS5pc1RvdWNoZWQgPSAhMSk7XHJcbiAgICAgICAgaWYgKCFpLnN0YXJ0TW92aW5nKSByZXR1cm47XHJcbiAgICAgICAgcy5hbGxvd0NsaWNrID0gITEsICFyLmNzc01vZGUgJiYgYy5jYW5jZWxhYmxlICYmIGMucHJldmVudERlZmF1bHQoKSwgci50b3VjaE1vdmVTdG9wUHJvcGFnYXRpb24gJiYgIXIubmVzdGVkICYmIGMuc3RvcFByb3BhZ2F0aW9uKCksIGkuaXNNb3ZlZCB8fCAoci5sb29wICYmICFyLmNzc01vZGUgJiYgcy5sb29wRml4KCksIGkuc3RhcnRUcmFuc2xhdGUgPSBzLmdldFRyYW5zbGF0ZSgpLCBzLnNldFRyYW5zaXRpb24oMCksIHMuYW5pbWF0aW5nICYmIHMuJHdyYXBwZXJFbC50cmlnZ2VyKFwid2Via2l0VHJhbnNpdGlvbkVuZCB0cmFuc2l0aW9uZW5kXCIpLCBpLmFsbG93TW9tZW50dW1Cb3VuY2UgPSAhMSwgIXIuZ3JhYkN1cnNvciB8fCAhMCAhPT0gcy5hbGxvd1NsaWRlTmV4dCAmJiAhMCAhPT0gcy5hbGxvd1NsaWRlUHJldiB8fCBzLnNldEdyYWJDdXJzb3IoITApLCBzLmVtaXQoXCJzbGlkZXJGaXJzdE1vdmVcIiwgYykpLCBzLmVtaXQoXCJzbGlkZXJNb3ZlXCIsIGMpLCBpLmlzTW92ZWQgPSAhMDtcclxuICAgICAgICBsZXQgdiA9IHMuaXNIb3Jpem9udGFsKCkgPyBmIDogZztcclxuICAgICAgICBuLmRpZmYgPSB2LCB2ICo9IHIudG91Y2hSYXRpbywgbCAmJiAodiA9IC12KSwgcy5zd2lwZURpcmVjdGlvbiA9IHYgPiAwID8gXCJwcmV2XCIgOiBcIm5leHRcIiwgaS5jdXJyZW50VHJhbnNsYXRlID0gdiArIGkuc3RhcnRUcmFuc2xhdGU7XHJcbiAgICAgICAgbGV0IHcgPSAhMCwgYiA9IHIucmVzaXN0YW5jZVJhdGlvO1xyXG4gICAgICAgIGlmIChyLnRvdWNoUmVsZWFzZU9uRWRnZXMgJiYgKGIgPSAwKSwgdiA+IDAgJiYgaS5jdXJyZW50VHJhbnNsYXRlID4gcy5taW5UcmFuc2xhdGUoKSA/ICh3ID0gITEsIHIucmVzaXN0YW5jZSAmJiAoaS5jdXJyZW50VHJhbnNsYXRlID0gcy5taW5UcmFuc2xhdGUoKSAtIDEgKyAoLXMubWluVHJhbnNsYXRlKCkgKyBpLnN0YXJ0VHJhbnNsYXRlICsgdikgKiogYikpIDogdiA8IDAgJiYgaS5jdXJyZW50VHJhbnNsYXRlIDwgcy5tYXhUcmFuc2xhdGUoKSAmJiAodyA9ICExLCByLnJlc2lzdGFuY2UgJiYgKGkuY3VycmVudFRyYW5zbGF0ZSA9IHMubWF4VHJhbnNsYXRlKCkgKyAxIC0gKHMubWF4VHJhbnNsYXRlKCkgLSBpLnN0YXJ0VHJhbnNsYXRlIC0gdikgKiogYikpLCB3ICYmIChjLnByZXZlbnRlZEJ5TmVzdGVkU3dpcGVyID0gITApLCAhcy5hbGxvd1NsaWRlTmV4dCAmJiBcIm5leHRcIiA9PT0gcy5zd2lwZURpcmVjdGlvbiAmJiBpLmN1cnJlbnRUcmFuc2xhdGUgPCBpLnN0YXJ0VHJhbnNsYXRlICYmIChpLmN1cnJlbnRUcmFuc2xhdGUgPSBpLnN0YXJ0VHJhbnNsYXRlKSwgIXMuYWxsb3dTbGlkZVByZXYgJiYgXCJwcmV2XCIgPT09IHMuc3dpcGVEaXJlY3Rpb24gJiYgaS5jdXJyZW50VHJhbnNsYXRlID4gaS5zdGFydFRyYW5zbGF0ZSAmJiAoaS5jdXJyZW50VHJhbnNsYXRlID0gaS5zdGFydFRyYW5zbGF0ZSksIHMuYWxsb3dTbGlkZVByZXYgfHwgcy5hbGxvd1NsaWRlTmV4dCB8fCAoaS5jdXJyZW50VHJhbnNsYXRlID0gaS5zdGFydFRyYW5zbGF0ZSksIHIudGhyZXNob2xkID4gMCkge1xyXG4gICAgICAgICAgICBpZiAoIShNYXRoLmFicyh2KSA+IHIudGhyZXNob2xkIHx8IGkuYWxsb3dUaHJlc2hvbGRNb3ZlKSkgcmV0dXJuIHZvaWQgKGkuY3VycmVudFRyYW5zbGF0ZSA9IGkuc3RhcnRUcmFuc2xhdGUpO1xyXG4gICAgICAgICAgICBpZiAoIWkuYWxsb3dUaHJlc2hvbGRNb3ZlKSByZXR1cm4gaS5hbGxvd1RocmVzaG9sZE1vdmUgPSAhMCwgbi5zdGFydFggPSBuLmN1cnJlbnRYLCBuLnN0YXJ0WSA9IG4uY3VycmVudFksIGkuY3VycmVudFRyYW5zbGF0ZSA9IGkuc3RhcnRUcmFuc2xhdGUsIHZvaWQgKG4uZGlmZiA9IHMuaXNIb3Jpem9udGFsKCkgPyBuLmN1cnJlbnRYIC0gbi5zdGFydFggOiBuLmN1cnJlbnRZIC0gbi5zdGFydFkpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHIuZm9sbG93RmluZ2VyICYmICFyLmNzc01vZGUgJiYgKChyLmZyZWVNb2RlICYmIHIuZnJlZU1vZGUuZW5hYmxlZCAmJiBzLmZyZWVNb2RlIHx8IHIud2F0Y2hTbGlkZXNQcm9ncmVzcykgJiYgKHMudXBkYXRlQWN0aXZlSW5kZXgoKSwgcy51cGRhdGVTbGlkZXNDbGFzc2VzKCkpLCBzLnBhcmFtcy5mcmVlTW9kZSAmJiByLmZyZWVNb2RlLmVuYWJsZWQgJiYgcy5mcmVlTW9kZSAmJiBzLmZyZWVNb2RlLm9uVG91Y2hNb3ZlKCksIHMudXBkYXRlUHJvZ3Jlc3MoaS5jdXJyZW50VHJhbnNsYXRlKSwgcy5zZXRUcmFuc2xhdGUoaS5jdXJyZW50VHJhbnNsYXRlKSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBJKGUpIHtcclxuICAgICAgICBjb25zdCB0ID0gdGhpcywgcyA9IHQudG91Y2hFdmVudHNEYXRhLCB7cGFyYW1zOiBhLCB0b3VjaGVzOiBpLCBydGxUcmFuc2xhdGU6IHIsIHNsaWRlc0dyaWQ6IG4sIGVuYWJsZWQ6IGx9ID0gdDtcclxuICAgICAgICBpZiAoIWwpIHJldHVybjtcclxuICAgICAgICBsZXQgbyA9IGU7XHJcbiAgICAgICAgaWYgKG8ub3JpZ2luYWxFdmVudCAmJiAobyA9IG8ub3JpZ2luYWxFdmVudCksIHMuYWxsb3dUb3VjaENhbGxiYWNrcyAmJiB0LmVtaXQoXCJ0b3VjaEVuZFwiLCBvKSwgcy5hbGxvd1RvdWNoQ2FsbGJhY2tzID0gITEsICFzLmlzVG91Y2hlZCkgcmV0dXJuIHMuaXNNb3ZlZCAmJiBhLmdyYWJDdXJzb3IgJiYgdC5zZXRHcmFiQ3Vyc29yKCExKSwgcy5pc01vdmVkID0gITEsIHZvaWQgKHMuc3RhcnRNb3ZpbmcgPSAhMSk7XHJcbiAgICAgICAgYS5ncmFiQ3Vyc29yICYmIHMuaXNNb3ZlZCAmJiBzLmlzVG91Y2hlZCAmJiAoITAgPT09IHQuYWxsb3dTbGlkZU5leHQgfHwgITAgPT09IHQuYWxsb3dTbGlkZVByZXYpICYmIHQuc2V0R3JhYkN1cnNvcighMSk7XHJcbiAgICAgICAgY29uc3QgZCA9IHUoKSwgYyA9IGQgLSBzLnRvdWNoU3RhcnRUaW1lO1xyXG4gICAgICAgIGlmICh0LmFsbG93Q2xpY2spIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IG8ucGF0aCB8fCBvLmNvbXBvc2VkUGF0aCAmJiBvLmNvbXBvc2VkUGF0aCgpO1xyXG4gICAgICAgICAgICB0LnVwZGF0ZUNsaWNrZWRTbGlkZShlICYmIGVbMF0gfHwgby50YXJnZXQpLCB0LmVtaXQoXCJ0YXAgY2xpY2tcIiwgbyksIGMgPCAzMDAgJiYgZCAtIHMubGFzdENsaWNrVGltZSA8IDMwMCAmJiB0LmVtaXQoXCJkb3VibGVUYXAgZG91YmxlQ2xpY2tcIiwgbylcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHMubGFzdENsaWNrVGltZSA9IHUoKSwgcCgoKCkgPT4ge1xyXG4gICAgICAgICAgICB0LmRlc3Ryb3llZCB8fCAodC5hbGxvd0NsaWNrID0gITApXHJcbiAgICAgICAgfSkpLCAhcy5pc1RvdWNoZWQgfHwgIXMuaXNNb3ZlZCB8fCAhdC5zd2lwZURpcmVjdGlvbiB8fCAwID09PSBpLmRpZmYgfHwgcy5jdXJyZW50VHJhbnNsYXRlID09PSBzLnN0YXJ0VHJhbnNsYXRlKSByZXR1cm4gcy5pc1RvdWNoZWQgPSAhMSwgcy5pc01vdmVkID0gITEsIHZvaWQgKHMuc3RhcnRNb3ZpbmcgPSAhMSk7XHJcbiAgICAgICAgbGV0IGg7XHJcbiAgICAgICAgaWYgKHMuaXNUb3VjaGVkID0gITEsIHMuaXNNb3ZlZCA9ICExLCBzLnN0YXJ0TW92aW5nID0gITEsIGggPSBhLmZvbGxvd0ZpbmdlciA/IHIgPyB0LnRyYW5zbGF0ZSA6IC10LnRyYW5zbGF0ZSA6IC1zLmN1cnJlbnRUcmFuc2xhdGUsIGEuY3NzTW9kZSkgcmV0dXJuO1xyXG4gICAgICAgIGlmICh0LnBhcmFtcy5mcmVlTW9kZSAmJiBhLmZyZWVNb2RlLmVuYWJsZWQpIHJldHVybiB2b2lkIHQuZnJlZU1vZGUub25Ub3VjaEVuZCh7Y3VycmVudFBvczogaH0pO1xyXG4gICAgICAgIGxldCBtID0gMCwgZiA9IHQuc2xpZGVzU2l6ZXNHcmlkWzBdO1xyXG4gICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgbi5sZW5ndGg7IGUgKz0gZSA8IGEuc2xpZGVzUGVyR3JvdXBTa2lwID8gMSA6IGEuc2xpZGVzUGVyR3JvdXApIHtcclxuICAgICAgICAgICAgY29uc3QgdCA9IGUgPCBhLnNsaWRlc1Blckdyb3VwU2tpcCAtIDEgPyAxIDogYS5zbGlkZXNQZXJHcm91cDtcclxuICAgICAgICAgICAgdm9pZCAwICE9PSBuW2UgKyB0XSA/IGggPj0gbltlXSAmJiBoIDwgbltlICsgdF0gJiYgKG0gPSBlLCBmID0gbltlICsgdF0gLSBuW2VdKSA6IGggPj0gbltlXSAmJiAobSA9IGUsIGYgPSBuW24ubGVuZ3RoIC0gMV0gLSBuW24ubGVuZ3RoIC0gMl0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBnID0gbnVsbCwgdiA9IG51bGw7XHJcbiAgICAgICAgYS5yZXdpbmQgJiYgKHQuaXNCZWdpbm5pbmcgPyB2ID0gdC5wYXJhbXMudmlydHVhbCAmJiB0LnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgJiYgdC52aXJ0dWFsID8gdC52aXJ0dWFsLnNsaWRlcy5sZW5ndGggLSAxIDogdC5zbGlkZXMubGVuZ3RoIC0gMSA6IHQuaXNFbmQgJiYgKGcgPSAwKSk7XHJcbiAgICAgICAgY29uc3QgdyA9IChoIC0gblttXSkgLyBmLCBiID0gbSA8IGEuc2xpZGVzUGVyR3JvdXBTa2lwIC0gMSA/IDEgOiBhLnNsaWRlc1Blckdyb3VwO1xyXG4gICAgICAgIGlmIChjID4gYS5sb25nU3dpcGVzTXMpIHtcclxuICAgICAgICAgICAgaWYgKCFhLmxvbmdTd2lwZXMpIHJldHVybiB2b2lkIHQuc2xpZGVUbyh0LmFjdGl2ZUluZGV4KTtcclxuICAgICAgICAgICAgXCJuZXh0XCIgPT09IHQuc3dpcGVEaXJlY3Rpb24gJiYgKHcgPj0gYS5sb25nU3dpcGVzUmF0aW8gPyB0LnNsaWRlVG8oYS5yZXdpbmQgJiYgdC5pc0VuZCA/IGcgOiBtICsgYikgOiB0LnNsaWRlVG8obSkpLCBcInByZXZcIiA9PT0gdC5zd2lwZURpcmVjdGlvbiAmJiAodyA+IDEgLSBhLmxvbmdTd2lwZXNSYXRpbyA/IHQuc2xpZGVUbyhtICsgYikgOiBudWxsICE9PSB2ICYmIHcgPCAwICYmIE1hdGguYWJzKHcpID4gYS5sb25nU3dpcGVzUmF0aW8gPyB0LnNsaWRlVG8odikgOiB0LnNsaWRlVG8obSkpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFhLnNob3J0U3dpcGVzKSByZXR1cm4gdm9pZCB0LnNsaWRlVG8odC5hY3RpdmVJbmRleCk7XHJcbiAgICAgICAgICAgIHQubmF2aWdhdGlvbiAmJiAoby50YXJnZXQgPT09IHQubmF2aWdhdGlvbi5uZXh0RWwgfHwgby50YXJnZXQgPT09IHQubmF2aWdhdGlvbi5wcmV2RWwpID8gby50YXJnZXQgPT09IHQubmF2aWdhdGlvbi5uZXh0RWwgPyB0LnNsaWRlVG8obSArIGIpIDogdC5zbGlkZVRvKG0pIDogKFwibmV4dFwiID09PSB0LnN3aXBlRGlyZWN0aW9uICYmIHQuc2xpZGVUbyhudWxsICE9PSBnID8gZyA6IG0gKyBiKSwgXCJwcmV2XCIgPT09IHQuc3dpcGVEaXJlY3Rpb24gJiYgdC5zbGlkZVRvKG51bGwgIT09IHYgPyB2IDogbSkpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEEoKSB7XHJcbiAgICAgICAgY29uc3QgZSA9IHRoaXMsIHtwYXJhbXM6IHQsIGVsOiBzfSA9IGU7XHJcbiAgICAgICAgaWYgKHMgJiYgMCA9PT0gcy5vZmZzZXRXaWR0aCkgcmV0dXJuO1xyXG4gICAgICAgIHQuYnJlYWtwb2ludHMgJiYgZS5zZXRCcmVha3BvaW50KCk7XHJcbiAgICAgICAgY29uc3Qge2FsbG93U2xpZGVOZXh0OiBhLCBhbGxvd1NsaWRlUHJldjogaSwgc25hcEdyaWQ6IHJ9ID0gZTtcclxuICAgICAgICBlLmFsbG93U2xpZGVOZXh0ID0gITAsIGUuYWxsb3dTbGlkZVByZXYgPSAhMCwgZS51cGRhdGVTaXplKCksIGUudXBkYXRlU2xpZGVzKCksIGUudXBkYXRlU2xpZGVzQ2xhc3NlcygpLCAoXCJhdXRvXCIgPT09IHQuc2xpZGVzUGVyVmlldyB8fCB0LnNsaWRlc1BlclZpZXcgPiAxKSAmJiBlLmlzRW5kICYmICFlLmlzQmVnaW5uaW5nICYmICFlLnBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IGUuc2xpZGVUbyhlLnNsaWRlcy5sZW5ndGggLSAxLCAwLCAhMSwgITApIDogZS5zbGlkZVRvKGUuYWN0aXZlSW5kZXgsIDAsICExLCAhMCksIGUuYXV0b3BsYXkgJiYgZS5hdXRvcGxheS5ydW5uaW5nICYmIGUuYXV0b3BsYXkucGF1c2VkICYmIGUuYXV0b3BsYXkucnVuKCksIGUuYWxsb3dTbGlkZVByZXYgPSBpLCBlLmFsbG93U2xpZGVOZXh0ID0gYSwgZS5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiByICE9PSBlLnNuYXBHcmlkICYmIGUuY2hlY2tPdmVyZmxvdygpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gRChlKSB7XHJcbiAgICAgICAgY29uc3QgdCA9IHRoaXM7XHJcbiAgICAgICAgdC5lbmFibGVkICYmICh0LmFsbG93Q2xpY2sgfHwgKHQucGFyYW1zLnByZXZlbnRDbGlja3MgJiYgZS5wcmV2ZW50RGVmYXVsdCgpLCB0LnBhcmFtcy5wcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb24gJiYgdC5hbmltYXRpbmcgJiYgKGUuc3RvcFByb3BhZ2F0aW9uKCksIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkpKSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBHKCkge1xyXG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLCB7d3JhcHBlckVsOiB0LCBydGxUcmFuc2xhdGU6IHMsIGVuYWJsZWQ6IGF9ID0gZTtcclxuICAgICAgICBpZiAoIWEpIHJldHVybjtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICBlLnByZXZpb3VzVHJhbnNsYXRlID0gZS50cmFuc2xhdGUsIGUuaXNIb3Jpem9udGFsKCkgPyBlLnRyYW5zbGF0ZSA9IC10LnNjcm9sbExlZnQgOiBlLnRyYW5zbGF0ZSA9IC10LnNjcm9sbFRvcCwgMCA9PT0gZS50cmFuc2xhdGUgJiYgKGUudHJhbnNsYXRlID0gMCksIGUudXBkYXRlQWN0aXZlSW5kZXgoKSwgZS51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XHJcbiAgICAgICAgY29uc3QgciA9IGUubWF4VHJhbnNsYXRlKCkgLSBlLm1pblRyYW5zbGF0ZSgpO1xyXG4gICAgICAgIGkgPSAwID09PSByID8gMCA6IChlLnRyYW5zbGF0ZSAtIGUubWluVHJhbnNsYXRlKCkpIC8gciwgaSAhPT0gZS5wcm9ncmVzcyAmJiBlLnVwZGF0ZVByb2dyZXNzKHMgPyAtZS50cmFuc2xhdGUgOiBlLnRyYW5zbGF0ZSksIGUuZW1pdChcInNldFRyYW5zbGF0ZVwiLCBlLnRyYW5zbGF0ZSwgITEpXHJcbiAgICB9XHJcblxyXG4gICAgbGV0IE4gPSAhMTtcclxuXHJcbiAgICBmdW5jdGlvbiBCKCkge1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IEggPSAoZSwgdCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHMgPSBhKCksIHtwYXJhbXM6IGksIHRvdWNoRXZlbnRzOiByLCBlbDogbiwgd3JhcHBlckVsOiBsLCBkZXZpY2U6IG8sIHN1cHBvcnQ6IGR9ID0gZSwgYyA9ICEhaS5uZXN0ZWQsXHJcbiAgICAgICAgICAgIHAgPSBcIm9uXCIgPT09IHQgPyBcImFkZEV2ZW50TGlzdGVuZXJcIiA6IFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiLCB1ID0gdDtcclxuICAgICAgICBpZiAoZC50b3VjaCkge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gIShcInRvdWNoc3RhcnRcIiAhPT0gci5zdGFydCB8fCAhZC5wYXNzaXZlTGlzdGVuZXIgfHwgIWkucGFzc2l2ZUxpc3RlbmVycykgJiYge1xyXG4gICAgICAgICAgICAgICAgcGFzc2l2ZTogITAsXHJcbiAgICAgICAgICAgICAgICBjYXB0dXJlOiAhMVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBuW3BdKHIuc3RhcnQsIGUub25Ub3VjaFN0YXJ0LCB0KSwgbltwXShyLm1vdmUsIGUub25Ub3VjaE1vdmUsIGQucGFzc2l2ZUxpc3RlbmVyID8ge1xyXG4gICAgICAgICAgICAgICAgcGFzc2l2ZTogITEsXHJcbiAgICAgICAgICAgICAgICBjYXB0dXJlOiBjXHJcbiAgICAgICAgICAgIH0gOiBjKSwgbltwXShyLmVuZCwgZS5vblRvdWNoRW5kLCB0KSwgci5jYW5jZWwgJiYgbltwXShyLmNhbmNlbCwgZS5vblRvdWNoRW5kLCB0KVxyXG4gICAgICAgIH0gZWxzZSBuW3BdKHIuc3RhcnQsIGUub25Ub3VjaFN0YXJ0LCAhMSksIHNbcF0oci5tb3ZlLCBlLm9uVG91Y2hNb3ZlLCBjKSwgc1twXShyLmVuZCwgZS5vblRvdWNoRW5kLCAhMSk7XHJcbiAgICAgICAgKGkucHJldmVudENsaWNrcyB8fCBpLnByZXZlbnRDbGlja3NQcm9wYWdhdGlvbikgJiYgbltwXShcImNsaWNrXCIsIGUub25DbGljaywgITApLCBpLmNzc01vZGUgJiYgbFtwXShcInNjcm9sbFwiLCBlLm9uU2Nyb2xsKSwgaS51cGRhdGVPbldpbmRvd1Jlc2l6ZSA/IGVbdV0oby5pb3MgfHwgby5hbmRyb2lkID8gXCJyZXNpemUgb3JpZW50YXRpb25jaGFuZ2Ugb2JzZXJ2ZXJVcGRhdGVcIiA6IFwicmVzaXplIG9ic2VydmVyVXBkYXRlXCIsIEEsICEwKSA6IGVbdV0oXCJvYnNlcnZlclVwZGF0ZVwiLCBBLCAhMClcclxuICAgIH07XHJcbiAgICB2YXIgWCA9IHtcclxuICAgICAgICBhdHRhY2hFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHRoaXMsIHQgPSBhKCksIHtwYXJhbXM6IHMsIHN1cHBvcnQ6IGl9ID0gZTtcclxuICAgICAgICAgICAgZS5vblRvdWNoU3RhcnQgPSBMLmJpbmQoZSksIGUub25Ub3VjaE1vdmUgPSBPLmJpbmQoZSksIGUub25Ub3VjaEVuZCA9IEkuYmluZChlKSwgcy5jc3NNb2RlICYmIChlLm9uU2Nyb2xsID0gRy5iaW5kKGUpKSwgZS5vbkNsaWNrID0gRC5iaW5kKGUpLCBpLnRvdWNoICYmICFOICYmICh0LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIEIpLCBOID0gITApLCBIKGUsIFwib25cIilcclxuICAgICAgICB9LCBkZXRhY2hFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgSCh0aGlzLCBcIm9mZlwiKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBZID0gKGUsIHQpID0+IGUuZ3JpZCAmJiB0LmdyaWQgJiYgdC5ncmlkLnJvd3MgPiAxO1xyXG4gICAgdmFyIFIgPSB7XHJcbiAgICAgICAgYWRkQ2xhc3NlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdGhpcywge2NsYXNzTmFtZXM6IHQsIHBhcmFtczogcywgcnRsOiBhLCAkZWw6IGksIGRldmljZTogciwgc3VwcG9ydDogbn0gPSBlLCBsID0gZnVuY3Rpb24gKGUsIHQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlLmZvckVhY2goKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgPyBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChhID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVthXSAmJiBzLnB1c2godCArIGEpXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSAmJiBzLnB1c2godCArIGUpXHJcbiAgICAgICAgICAgICAgICB9KSksIHNcclxuICAgICAgICAgICAgfShbXCJpbml0aWFsaXplZFwiLCBzLmRpcmVjdGlvbiwge1wicG9pbnRlci1ldmVudHNcIjogIW4udG91Y2h9LCB7XCJmcmVlLW1vZGVcIjogZS5wYXJhbXMuZnJlZU1vZGUgJiYgcy5mcmVlTW9kZS5lbmFibGVkfSwge2F1dG9oZWlnaHQ6IHMuYXV0b0hlaWdodH0sIHtydGw6IGF9LCB7Z3JpZDogcy5ncmlkICYmIHMuZ3JpZC5yb3dzID4gMX0sIHtcImdyaWQtY29sdW1uXCI6IHMuZ3JpZCAmJiBzLmdyaWQucm93cyA+IDEgJiYgXCJjb2x1bW5cIiA9PT0gcy5ncmlkLmZpbGx9LCB7YW5kcm9pZDogci5hbmRyb2lkfSwge2lvczogci5pb3N9LCB7XCJjc3MtbW9kZVwiOiBzLmNzc01vZGV9LCB7Y2VudGVyZWQ6IHMuY3NzTW9kZSAmJiBzLmNlbnRlcmVkU2xpZGVzfSwge1wid2F0Y2gtcHJvZ3Jlc3NcIjogcy53YXRjaFNsaWRlc1Byb2dyZXNzfV0sIHMuY29udGFpbmVyTW9kaWZpZXJDbGFzcyk7XHJcbiAgICAgICAgICAgIHQucHVzaCguLi5sKSwgaS5hZGRDbGFzcyhbLi4udF0uam9pbihcIiBcIikpLCBlLmVtaXRDb250YWluZXJDbGFzc2VzKClcclxuICAgICAgICB9LCByZW1vdmVDbGFzc2VzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHskZWw6IGUsIGNsYXNzTmFtZXM6IHR9ID0gdGhpcztcclxuICAgICAgICAgICAgZS5yZW1vdmVDbGFzcyh0LmpvaW4oXCIgXCIpKSwgdGhpcy5lbWl0Q29udGFpbmVyQ2xhc3NlcygpXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBXID0ge1xyXG4gICAgICAgIGluaXQ6ICEwLFxyXG4gICAgICAgIGRpcmVjdGlvbjogXCJob3Jpem9udGFsXCIsXHJcbiAgICAgICAgdG91Y2hFdmVudHNUYXJnZXQ6IFwid3JhcHBlclwiLFxyXG4gICAgICAgIGluaXRpYWxTbGlkZTogMCxcclxuICAgICAgICBzcGVlZDogMzAwLFxyXG4gICAgICAgIGNzc01vZGU6ICExLFxyXG4gICAgICAgIHVwZGF0ZU9uV2luZG93UmVzaXplOiAhMCxcclxuICAgICAgICByZXNpemVPYnNlcnZlcjogITAsXHJcbiAgICAgICAgbmVzdGVkOiAhMSxcclxuICAgICAgICBjcmVhdGVFbGVtZW50czogITEsXHJcbiAgICAgICAgZW5hYmxlZDogITAsXHJcbiAgICAgICAgZm9jdXNhYmxlRWxlbWVudHM6IFwiaW5wdXQsIHNlbGVjdCwgb3B0aW9uLCB0ZXh0YXJlYSwgYnV0dG9uLCB2aWRlbywgbGFiZWxcIixcclxuICAgICAgICB3aWR0aDogbnVsbCxcclxuICAgICAgICBoZWlnaHQ6IG51bGwsXHJcbiAgICAgICAgcHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uOiAhMSxcclxuICAgICAgICB1c2VyQWdlbnQ6IG51bGwsXHJcbiAgICAgICAgdXJsOiBudWxsLFxyXG4gICAgICAgIGVkZ2VTd2lwZURldGVjdGlvbjogITEsXHJcbiAgICAgICAgZWRnZVN3aXBlVGhyZXNob2xkOiAyMCxcclxuICAgICAgICBhdXRvSGVpZ2h0OiAhMSxcclxuICAgICAgICBzZXRXcmFwcGVyU2l6ZTogITEsXHJcbiAgICAgICAgdmlydHVhbFRyYW5zbGF0ZTogITEsXHJcbiAgICAgICAgZWZmZWN0OiBcInNsaWRlXCIsXHJcbiAgICAgICAgYnJlYWtwb2ludHM6IHZvaWQgMCxcclxuICAgICAgICBicmVha3BvaW50c0Jhc2U6IFwid2luZG93XCIsXHJcbiAgICAgICAgc3BhY2VCZXR3ZWVuOiAwLFxyXG4gICAgICAgIHNsaWRlc1BlclZpZXc6IDEsXHJcbiAgICAgICAgc2xpZGVzUGVyR3JvdXA6IDEsXHJcbiAgICAgICAgc2xpZGVzUGVyR3JvdXBTa2lwOiAwLFxyXG4gICAgICAgIHNsaWRlc1Blckdyb3VwQXV0bzogITEsXHJcbiAgICAgICAgY2VudGVyZWRTbGlkZXM6ICExLFxyXG4gICAgICAgIGNlbnRlcmVkU2xpZGVzQm91bmRzOiAhMSxcclxuICAgICAgICBzbGlkZXNPZmZzZXRCZWZvcmU6IDAsXHJcbiAgICAgICAgc2xpZGVzT2Zmc2V0QWZ0ZXI6IDAsXHJcbiAgICAgICAgbm9ybWFsaXplU2xpZGVJbmRleDogITAsXHJcbiAgICAgICAgY2VudGVySW5zdWZmaWNpZW50U2xpZGVzOiAhMSxcclxuICAgICAgICB3YXRjaE92ZXJmbG93OiAhMCxcclxuICAgICAgICByb3VuZExlbmd0aHM6ICExLFxyXG4gICAgICAgIHRvdWNoUmF0aW86IDEsXHJcbiAgICAgICAgdG91Y2hBbmdsZTogNDUsXHJcbiAgICAgICAgc2ltdWxhdGVUb3VjaDogITAsXHJcbiAgICAgICAgc2hvcnRTd2lwZXM6ICEwLFxyXG4gICAgICAgIGxvbmdTd2lwZXM6ICEwLFxyXG4gICAgICAgIGxvbmdTd2lwZXNSYXRpbzogLjUsXHJcbiAgICAgICAgbG9uZ1N3aXBlc01zOiAzMDAsXHJcbiAgICAgICAgZm9sbG93RmluZ2VyOiAhMCxcclxuICAgICAgICBhbGxvd1RvdWNoTW92ZTogITAsXHJcbiAgICAgICAgdGhyZXNob2xkOiAwLFxyXG4gICAgICAgIHRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbjogITEsXHJcbiAgICAgICAgdG91Y2hTdGFydFByZXZlbnREZWZhdWx0OiAhMCxcclxuICAgICAgICB0b3VjaFN0YXJ0Rm9yY2VQcmV2ZW50RGVmYXVsdDogITEsXHJcbiAgICAgICAgdG91Y2hSZWxlYXNlT25FZGdlczogITEsXHJcbiAgICAgICAgdW5pcXVlTmF2RWxlbWVudHM6ICEwLFxyXG4gICAgICAgIHJlc2lzdGFuY2U6ICEwLFxyXG4gICAgICAgIHJlc2lzdGFuY2VSYXRpbzogLjg1LFxyXG4gICAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6ICExLFxyXG4gICAgICAgIGdyYWJDdXJzb3I6ICExLFxyXG4gICAgICAgIHByZXZlbnRDbGlja3M6ICEwLFxyXG4gICAgICAgIHByZXZlbnRDbGlja3NQcm9wYWdhdGlvbjogITAsXHJcbiAgICAgICAgc2xpZGVUb0NsaWNrZWRTbGlkZTogITEsXHJcbiAgICAgICAgcHJlbG9hZEltYWdlczogITAsXHJcbiAgICAgICAgdXBkYXRlT25JbWFnZXNSZWFkeTogITAsXHJcbiAgICAgICAgbG9vcDogITEsXHJcbiAgICAgICAgbG9vcEFkZGl0aW9uYWxTbGlkZXM6IDAsXHJcbiAgICAgICAgbG9vcGVkU2xpZGVzOiBudWxsLFxyXG4gICAgICAgIGxvb3BlZFNsaWRlc0xpbWl0OiAhMCxcclxuICAgICAgICBsb29wRmlsbEdyb3VwV2l0aEJsYW5rOiAhMSxcclxuICAgICAgICBsb29wUHJldmVudHNTbGlkZTogITAsXHJcbiAgICAgICAgcmV3aW5kOiAhMSxcclxuICAgICAgICBhbGxvd1NsaWRlUHJldjogITAsXHJcbiAgICAgICAgYWxsb3dTbGlkZU5leHQ6ICEwLFxyXG4gICAgICAgIHN3aXBlSGFuZGxlcjogbnVsbCxcclxuICAgICAgICBub1N3aXBpbmc6ICEwLFxyXG4gICAgICAgIG5vU3dpcGluZ0NsYXNzOiBcInN3aXBlci1uby1zd2lwaW5nXCIsXHJcbiAgICAgICAgbm9Td2lwaW5nU2VsZWN0b3I6IG51bGwsXHJcbiAgICAgICAgcGFzc2l2ZUxpc3RlbmVyczogITAsXHJcbiAgICAgICAgbWF4QmFja2ZhY2VIaWRkZW5TbGlkZXM6IDEwLFxyXG4gICAgICAgIGNvbnRhaW5lck1vZGlmaWVyQ2xhc3M6IFwic3dpcGVyLVwiLFxyXG4gICAgICAgIHNsaWRlQ2xhc3M6IFwic3dpcGVyLXNsaWRlXCIsXHJcbiAgICAgICAgc2xpZGVCbGFua0NsYXNzOiBcInN3aXBlci1zbGlkZS1pbnZpc2libGUtYmxhbmtcIixcclxuICAgICAgICBzbGlkZUFjdGl2ZUNsYXNzOiBcInN3aXBlci1zbGlkZS1hY3RpdmVcIixcclxuICAgICAgICBzbGlkZUR1cGxpY2F0ZUFjdGl2ZUNsYXNzOiBcInN3aXBlci1zbGlkZS1kdXBsaWNhdGUtYWN0aXZlXCIsXHJcbiAgICAgICAgc2xpZGVWaXNpYmxlQ2xhc3M6IFwic3dpcGVyLXNsaWRlLXZpc2libGVcIixcclxuICAgICAgICBzbGlkZUR1cGxpY2F0ZUNsYXNzOiBcInN3aXBlci1zbGlkZS1kdXBsaWNhdGVcIixcclxuICAgICAgICBzbGlkZU5leHRDbGFzczogXCJzd2lwZXItc2xpZGUtbmV4dFwiLFxyXG4gICAgICAgIHNsaWRlRHVwbGljYXRlTmV4dENsYXNzOiBcInN3aXBlci1zbGlkZS1kdXBsaWNhdGUtbmV4dFwiLFxyXG4gICAgICAgIHNsaWRlUHJldkNsYXNzOiBcInN3aXBlci1zbGlkZS1wcmV2XCIsXHJcbiAgICAgICAgc2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3M6IFwic3dpcGVyLXNsaWRlLWR1cGxpY2F0ZS1wcmV2XCIsXHJcbiAgICAgICAgd3JhcHBlckNsYXNzOiBcInN3aXBlci13cmFwcGVyXCIsXHJcbiAgICAgICAgcnVuQ2FsbGJhY2tzT25Jbml0OiAhMCxcclxuICAgICAgICBfZW1pdENsYXNzZXM6ICExXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHEoZSwgdCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IHMgJiYgKHMgPSB7fSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSBPYmplY3Qua2V5cyhzKVswXSwgaSA9IHNbYV07XHJcbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT0gdHlwZW9mIGkgJiYgbnVsbCAhPT0gaSA/IChbXCJuYXZpZ2F0aW9uXCIsIFwicGFnaW5hdGlvblwiLCBcInNjcm9sbGJhclwiXS5pbmRleE9mKGEpID49IDAgJiYgITAgPT09IGVbYV0gJiYgKGVbYV0gPSB7YXV0bzogITB9KSwgYSBpbiBlICYmIFwiZW5hYmxlZFwiIGluIGkgPyAoITAgPT09IGVbYV0gJiYgKGVbYV0gPSB7ZW5hYmxlZDogITB9KSwgXCJvYmplY3RcIiAhPSB0eXBlb2YgZVthXSB8fCBcImVuYWJsZWRcIiBpbiBlW2FdIHx8IChlW2FdLmVuYWJsZWQgPSAhMCksIGVbYV0gfHwgKGVbYV0gPSB7ZW5hYmxlZDogITF9KSwgZyh0LCBzKSkgOiBnKHQsIHMpKSA6IGcodCwgcylcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaiA9IHtcclxuICAgICAgICBldmVudHNFbWl0dGVyOiAkLCB1cGRhdGU6IFMsIHRyYW5zbGF0ZTogTSwgdHJhbnNpdGlvbjoge1xyXG4gICAgICAgICAgICBzZXRUcmFuc2l0aW9uOiBmdW5jdGlvbiAoZSwgdCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBzLnBhcmFtcy5jc3NNb2RlIHx8IHMuJHdyYXBwZXJFbC50cmFuc2l0aW9uKGUpLCBzLmVtaXQoXCJzZXRUcmFuc2l0aW9uXCIsIGUsIHQpXHJcbiAgICAgICAgICAgIH0sIHRyYW5zaXRpb25TdGFydDogZnVuY3Rpb24gKGUsIHQpIHtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9ICEwKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLCB7cGFyYW1zOiBhfSA9IHM7XHJcbiAgICAgICAgICAgICAgICBhLmNzc01vZGUgfHwgKGEuYXV0b0hlaWdodCAmJiBzLnVwZGF0ZUF1dG9IZWlnaHQoKSwgUCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpcGVyOiBzLFxyXG4gICAgICAgICAgICAgICAgICAgIHJ1bkNhbGxiYWNrczogZSxcclxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IHQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogXCJTdGFydFwiXHJcbiAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgfSwgdHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKGUsIHQpIHtcclxuICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gZSAmJiAoZSA9ICEwKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLCB7cGFyYW1zOiBhfSA9IHM7XHJcbiAgICAgICAgICAgICAgICBzLmFuaW1hdGluZyA9ICExLCBhLmNzc01vZGUgfHwgKHMuc2V0VHJhbnNpdGlvbigwKSwgUCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpcGVyOiBzLFxyXG4gICAgICAgICAgICAgICAgICAgIHJ1bkNhbGxiYWNrczogZSxcclxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb246IHQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogXCJFbmRcIlxyXG4gICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBzbGlkZTogaywgbG9vcDogeiwgZ3JhYkN1cnNvcjoge1xyXG4gICAgICAgICAgICBzZXRHcmFiQ3Vyc29yOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBpZiAodC5zdXBwb3J0LnRvdWNoIHx8ICF0LnBhcmFtcy5zaW11bGF0ZVRvdWNoIHx8IHQucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgdC5pc0xvY2tlZCB8fCB0LnBhcmFtcy5jc3NNb2RlKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gXCJjb250YWluZXJcIiA9PT0gdC5wYXJhbXMudG91Y2hFdmVudHNUYXJnZXQgPyB0LmVsIDogdC53cmFwcGVyRWw7XHJcbiAgICAgICAgICAgICAgICBzLnN0eWxlLmN1cnNvciA9IFwibW92ZVwiLCBzLnN0eWxlLmN1cnNvciA9IGUgPyBcImdyYWJiaW5nXCIgOiBcImdyYWJcIlxyXG4gICAgICAgICAgICB9LCB1bnNldEdyYWJDdXJzb3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgZS5zdXBwb3J0LnRvdWNoIHx8IGUucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgZS5pc0xvY2tlZCB8fCBlLnBhcmFtcy5jc3NNb2RlIHx8IChlW1wiY29udGFpbmVyXCIgPT09IGUucGFyYW1zLnRvdWNoRXZlbnRzVGFyZ2V0ID8gXCJlbFwiIDogXCJ3cmFwcGVyRWxcIl0uc3R5bGUuY3Vyc29yID0gXCJcIilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGV2ZW50czogWCwgYnJlYWtwb2ludHM6IHtcclxuICAgICAgICAgICAgc2V0QnJlYWtwb2ludDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHRoaXMsIHthY3RpdmVJbmRleDogdCwgaW5pdGlhbGl6ZWQ6IHMsIGxvb3BlZFNsaWRlczogYSA9IDAsIHBhcmFtczogaSwgJGVsOiByfSA9IGUsXHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IGkuYnJlYWtwb2ludHM7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW4gfHwgbiAmJiAwID09PSBPYmplY3Qua2V5cyhuKS5sZW5ndGgpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGwgPSBlLmdldEJyZWFrcG9pbnQobiwgZS5wYXJhbXMuYnJlYWtwb2ludHNCYXNlLCBlLmVsKTtcclxuICAgICAgICAgICAgICAgIGlmICghbCB8fCBlLmN1cnJlbnRCcmVha3BvaW50ID09PSBsKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvID0gKGwgaW4gbiA/IG5bbF0gOiB2b2lkIDApIHx8IGUub3JpZ2luYWxQYXJhbXMsIGQgPSBZKGUsIGkpLCBjID0gWShlLCBvKSwgcCA9IGkuZW5hYmxlZDtcclxuICAgICAgICAgICAgICAgIGQgJiYgIWMgPyAoci5yZW1vdmVDbGFzcyhgJHtpLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9Z3JpZCAke2kuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ncmlkLWNvbHVtbmApLCBlLmVtaXRDb250YWluZXJDbGFzc2VzKCkpIDogIWQgJiYgYyAmJiAoci5hZGRDbGFzcyhgJHtpLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9Z3JpZGApLCAoby5ncmlkLmZpbGwgJiYgXCJjb2x1bW5cIiA9PT0gby5ncmlkLmZpbGwgfHwgIW8uZ3JpZC5maWxsICYmIFwiY29sdW1uXCIgPT09IGkuZ3JpZC5maWxsKSAmJiByLmFkZENsYXNzKGAke2kuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ncmlkLWNvbHVtbmApLCBlLmVtaXRDb250YWluZXJDbGFzc2VzKCkpLCBbXCJuYXZpZ2F0aW9uXCIsIFwicGFnaW5hdGlvblwiLCBcInNjcm9sbGJhclwiXS5mb3JFYWNoKCh0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gaVt0XSAmJiBpW3RdLmVuYWJsZWQsIGEgPSBvW3RdICYmIG9bdF0uZW5hYmxlZDtcclxuICAgICAgICAgICAgICAgICAgICBzICYmICFhICYmIGVbdF0uZGlzYWJsZSgpLCAhcyAmJiBhICYmIGVbdF0uZW5hYmxlKClcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHUgPSBvLmRpcmVjdGlvbiAmJiBvLmRpcmVjdGlvbiAhPT0gaS5kaXJlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgaCA9IGkubG9vcCAmJiAoby5zbGlkZXNQZXJWaWV3ICE9PSBpLnNsaWRlc1BlclZpZXcgfHwgdSk7XHJcbiAgICAgICAgICAgICAgICB1ICYmIHMgJiYgZS5jaGFuZ2VEaXJlY3Rpb24oKSwgZyhlLnBhcmFtcywgbyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gZS5wYXJhbXMuZW5hYmxlZDtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbG93VG91Y2hNb3ZlOiBlLnBhcmFtcy5hbGxvd1RvdWNoTW92ZSxcclxuICAgICAgICAgICAgICAgICAgICBhbGxvd1NsaWRlTmV4dDogZS5wYXJhbXMuYWxsb3dTbGlkZU5leHQsXHJcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dTbGlkZVByZXY6IGUucGFyYW1zLmFsbG93U2xpZGVQcmV2XHJcbiAgICAgICAgICAgICAgICB9KSwgcCAmJiAhbSA/IGUuZGlzYWJsZSgpIDogIXAgJiYgbSAmJiBlLmVuYWJsZSgpLCBlLmN1cnJlbnRCcmVha3BvaW50ID0gbCwgZS5lbWl0KFwiX2JlZm9yZUJyZWFrcG9pbnRcIiwgbyksIGggJiYgcyAmJiAoZS5sb29wRGVzdHJveSgpLCBlLmxvb3BDcmVhdGUoKSwgZS51cGRhdGVTbGlkZXMoKSwgZS5zbGlkZVRvKHQgLSBhICsgZS5sb29wZWRTbGlkZXMsIDAsICExKSksIGUuZW1pdChcImJyZWFrcG9pbnRcIiwgbylcclxuICAgICAgICAgICAgfSwgZ2V0QnJlYWtwb2ludDogZnVuY3Rpb24gKGUsIHQsIHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IHQgJiYgKHQgPSBcIndpbmRvd1wiKSwgIWUgfHwgXCJjb250YWluZXJcIiA9PT0gdCAmJiAhcykgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgbGV0IGEgPSAhMTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSByKCksIG4gPSBcIndpbmRvd1wiID09PSB0ID8gaS5pbm5lckhlaWdodCA6IHMuY2xpZW50SGVpZ2h0LCBsID0gT2JqZWN0LmtleXMoZSkubWFwKChlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSAmJiAwID09PSBlLmluZGV4T2YoXCJAXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBwYXJzZUZsb2F0KGUuc3Vic3RyKDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt2YWx1ZTogbiAqIHQsIHBvaW50OiBlfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge3ZhbHVlOiBlLCBwb2ludDogZX1cclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIGwuc29ydCgoKGUsIHQpID0+IHBhcnNlSW50KGUudmFsdWUsIDEwKSAtIHBhcnNlSW50KHQudmFsdWUsIDEwKSkpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZSA9IDA7IGUgPCBsLmxlbmd0aDsgZSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qge3BvaW50OiByLCB2YWx1ZTogbn0gPSBsW2VdO1xyXG4gICAgICAgICAgICAgICAgICAgIFwid2luZG93XCIgPT09IHQgPyBpLm1hdGNoTWVkaWEoYChtaW4td2lkdGg6ICR7bn1weClgKS5tYXRjaGVzICYmIChhID0gcikgOiBuIDw9IHMuY2xpZW50V2lkdGggJiYgKGEgPSByKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgfHwgXCJtYXhcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgY2hlY2tPdmVyZmxvdzoge1xyXG4gICAgICAgICAgICBjaGVja092ZXJmbG93OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gdGhpcywge2lzTG9ja2VkOiB0LCBwYXJhbXM6IHN9ID0gZSwge3NsaWRlc09mZnNldEJlZm9yZTogYX0gPSBzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gZS5zbGlkZXMubGVuZ3RoIC0gMSwgcyA9IGUuc2xpZGVzR3JpZFt0XSArIGUuc2xpZGVzU2l6ZXNHcmlkW3RdICsgMiAqIGE7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5pc0xvY2tlZCA9IGUuc2l6ZSA+IHNcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBlLmlzTG9ja2VkID0gMSA9PT0gZS5zbmFwR3JpZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAhMCA9PT0gcy5hbGxvd1NsaWRlTmV4dCAmJiAoZS5hbGxvd1NsaWRlTmV4dCA9ICFlLmlzTG9ja2VkKSwgITAgPT09IHMuYWxsb3dTbGlkZVByZXYgJiYgKGUuYWxsb3dTbGlkZVByZXYgPSAhZS5pc0xvY2tlZCksIHQgJiYgdCAhPT0gZS5pc0xvY2tlZCAmJiAoZS5pc0VuZCA9ICExKSwgdCAhPT0gZS5pc0xvY2tlZCAmJiBlLmVtaXQoZS5pc0xvY2tlZCA/IFwibG9ja1wiIDogXCJ1bmxvY2tcIilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGNsYXNzZXM6IFIsIGltYWdlczoge1xyXG4gICAgICAgICAgICBsb2FkSW1hZ2U6IGZ1bmN0aW9uIChlLCB0LCBzLCBhLCBpLCBuKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsID0gcigpO1xyXG4gICAgICAgICAgICAgICAgbGV0IG87XHJcblxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYygpIHtcclxuICAgICAgICAgICAgICAgICAgICBuICYmIG4oKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGQoZSkucGFyZW50KFwicGljdHVyZVwiKVswXSB8fCBlLmNvbXBsZXRlICYmIGkgPyBjKCkgOiB0ID8gKG8gPSBuZXcgbC5JbWFnZSwgby5vbmxvYWQgPSBjLCBvLm9uZXJyb3IgPSBjLCBhICYmIChvLnNpemVzID0gYSksIHMgJiYgKG8uc3Jjc2V0ID0gcyksIHQgJiYgKG8uc3JjID0gdCkpIDogYygpXHJcbiAgICAgICAgICAgIH0sIHByZWxvYWRJbWFnZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPSBlICYmIGUgJiYgIWUuZGVzdHJveWVkICYmICh2b2lkIDAgIT09IGUuaW1hZ2VzTG9hZGVkICYmIChlLmltYWdlc0xvYWRlZCArPSAxKSwgZS5pbWFnZXNMb2FkZWQgPT09IGUuaW1hZ2VzVG9Mb2FkLmxlbmd0aCAmJiAoZS5wYXJhbXMudXBkYXRlT25JbWFnZXNSZWFkeSAmJiBlLnVwZGF0ZSgpLCBlLmVtaXQoXCJpbWFnZXNSZWFkeVwiKSkpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZS5pbWFnZXNUb0xvYWQgPSBlLiRlbC5maW5kKFwiaW1nXCIpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBlLmltYWdlc1RvTG9hZC5sZW5ndGg7IHMgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBlLmltYWdlc1RvTG9hZFtzXTtcclxuICAgICAgICAgICAgICAgICAgICBlLmxvYWRJbWFnZShhLCBhLmN1cnJlbnRTcmMgfHwgYS5nZXRBdHRyaWJ1dGUoXCJzcmNcIiksIGEuc3Jjc2V0IHx8IGEuZ2V0QXR0cmlidXRlKFwic3Jjc2V0XCIpLCBhLnNpemVzIHx8IGEuZ2V0QXR0cmlidXRlKFwic2l6ZXNcIiksICEwLCB0KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgXyA9IHt9O1xyXG5cclxuICAgIGNsYXNzIFYge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBsZXQgZSwgdDtcclxuICAgICAgICAgICAgZm9yICh2YXIgcyA9IGFyZ3VtZW50cy5sZW5ndGgsIGEgPSBuZXcgQXJyYXkocyksIGkgPSAwOyBpIDwgczsgaSsrKSBhW2ldID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoMSA9PT0gYS5sZW5ndGggJiYgYVswXS5jb25zdHJ1Y3RvciAmJiBcIk9iamVjdFwiID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYVswXSkuc2xpY2UoOCwgLTEpID8gdCA9IGFbMF0gOiBbZSwgdF0gPSBhLCB0IHx8ICh0ID0ge30pLCB0ID0gZyh7fSwgdCksIGUgJiYgIXQuZWwgJiYgKHQuZWwgPSBlKSwgdC5lbCAmJiBkKHQuZWwpLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBbXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkKHQuZWwpLmVhY2goKHMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBnKHt9LCB0LCB7ZWw6IHN9KTtcclxuICAgICAgICAgICAgICAgICAgICBlLnB1c2gobmV3IFYoYSkpXHJcbiAgICAgICAgICAgICAgICB9KSksIGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByID0gdGhpcztcclxuICAgICAgICAgICAgci5fX3N3aXBlcl9fID0gITAsIHIuc3VwcG9ydCA9IEUoKSwgci5kZXZpY2UgPSBDKHt1c2VyQWdlbnQ6IHQudXNlckFnZW50fSksIHIuYnJvd3NlciA9IFQoKSwgci5ldmVudHNMaXN0ZW5lcnMgPSB7fSwgci5ldmVudHNBbnlMaXN0ZW5lcnMgPSBbXSwgci5tb2R1bGVzID0gWy4uLnIuX19tb2R1bGVzX19dLCB0Lm1vZHVsZXMgJiYgQXJyYXkuaXNBcnJheSh0Lm1vZHVsZXMpICYmIHIubW9kdWxlcy5wdXNoKC4uLnQubW9kdWxlcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG4gPSB7fTtcclxuICAgICAgICAgICAgci5tb2R1bGVzLmZvckVhY2goKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpcGVyOiByLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZFBhcmFtczogcSh0LCBuKSxcclxuICAgICAgICAgICAgICAgICAgICBvbjogci5vbi5iaW5kKHIpLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uY2U6IHIub25jZS5iaW5kKHIpLFxyXG4gICAgICAgICAgICAgICAgICAgIG9mZjogci5vZmYuYmluZChyKSxcclxuICAgICAgICAgICAgICAgICAgICBlbWl0OiByLmVtaXQuYmluZChyKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBjb25zdCBsID0gZyh7fSwgVywgbik7XHJcbiAgICAgICAgICAgIHJldHVybiByLnBhcmFtcyA9IGcoe30sIGwsIF8sIHQpLCByLm9yaWdpbmFsUGFyYW1zID0gZyh7fSwgci5wYXJhbXMpLCByLnBhc3NlZFBhcmFtcyA9IGcoe30sIHQpLCByLnBhcmFtcyAmJiByLnBhcmFtcy5vbiAmJiBPYmplY3Qua2V5cyhyLnBhcmFtcy5vbikuZm9yRWFjaCgoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICByLm9uKGUsIHIucGFyYW1zLm9uW2VdKVxyXG4gICAgICAgICAgICB9KSksIHIucGFyYW1zICYmIHIucGFyYW1zLm9uQW55ICYmIHIub25Bbnkoci5wYXJhbXMub25BbnkpLCByLiQgPSBkLCBPYmplY3QuYXNzaWduKHIsIHtcclxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHIucGFyYW1zLmVuYWJsZWQsXHJcbiAgICAgICAgICAgICAgICBlbDogZSxcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgc2xpZGVzOiBkKCksXHJcbiAgICAgICAgICAgICAgICBzbGlkZXNHcmlkOiBbXSxcclxuICAgICAgICAgICAgICAgIHNuYXBHcmlkOiBbXSxcclxuICAgICAgICAgICAgICAgIHNsaWRlc1NpemVzR3JpZDogW10sXHJcbiAgICAgICAgICAgICAgICBpc0hvcml6b250YWw6ICgpID0+IFwiaG9yaXpvbnRhbFwiID09PSByLnBhcmFtcy5kaXJlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsOiAoKSA9PiBcInZlcnRpY2FsXCIgPT09IHIucGFyYW1zLmRpcmVjdGlvbixcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUluZGV4OiAwLFxyXG4gICAgICAgICAgICAgICAgcmVhbEluZGV4OiAwLFxyXG4gICAgICAgICAgICAgICAgaXNCZWdpbm5pbmc6ICEwLFxyXG4gICAgICAgICAgICAgICAgaXNFbmQ6ICExLFxyXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlOiAwLFxyXG4gICAgICAgICAgICAgICAgcHJldmlvdXNUcmFuc2xhdGU6IDAsXHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzczogMCxcclxuICAgICAgICAgICAgICAgIHZlbG9jaXR5OiAwLFxyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW5nOiAhMSxcclxuICAgICAgICAgICAgICAgIGFsbG93U2xpZGVOZXh0OiByLnBhcmFtcy5hbGxvd1NsaWRlTmV4dCxcclxuICAgICAgICAgICAgICAgIGFsbG93U2xpZGVQcmV2OiByLnBhcmFtcy5hbGxvd1NsaWRlUHJldixcclxuICAgICAgICAgICAgICAgIHRvdWNoRXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IFtcInRvdWNoc3RhcnRcIiwgXCJ0b3VjaG1vdmVcIiwgXCJ0b3VjaGVuZFwiLCBcInRvdWNoY2FuY2VsXCJdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gW1wicG9pbnRlcmRvd25cIiwgXCJwb2ludGVybW92ZVwiLCBcInBvaW50ZXJ1cFwiXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gci50b3VjaEV2ZW50c1RvdWNoID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZVswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZTogZVsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBlWzJdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGVbM11cclxuICAgICAgICAgICAgICAgICAgICB9LCByLnRvdWNoRXZlbnRzRGVza3RvcCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHRbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmU6IHRbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogdFsyXVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHIuc3VwcG9ydC50b3VjaCB8fCAhci5wYXJhbXMuc2ltdWxhdGVUb3VjaCA/IHIudG91Y2hFdmVudHNUb3VjaCA6IHIudG91Y2hFdmVudHNEZXNrdG9wXHJcbiAgICAgICAgICAgICAgICB9KCksXHJcbiAgICAgICAgICAgICAgICB0b3VjaEV2ZW50c0RhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICBpc1RvdWNoZWQ6IHZvaWQgMCxcclxuICAgICAgICAgICAgICAgICAgICBpc01vdmVkOiB2b2lkIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUb3VjaENhbGxiYWNrczogdm9pZCAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoU3RhcnRUaW1lOiB2b2lkIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNTY3JvbGxpbmc6IHZvaWQgMCxcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJhbnNsYXRlOiB2b2lkIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUcmFuc2xhdGU6IHZvaWQgMCxcclxuICAgICAgICAgICAgICAgICAgICBhbGxvd1RocmVzaG9sZE1vdmU6IHZvaWQgMCxcclxuICAgICAgICAgICAgICAgICAgICBmb2N1c2FibGVFbGVtZW50czogci5wYXJhbXMuZm9jdXNhYmxlRWxlbWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdENsaWNrVGltZTogdSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrVGltZW91dDogdm9pZCAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHZlbG9jaXRpZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGFsbG93TW9tZW50dW1Cb3VuY2U6IHZvaWQgMCxcclxuICAgICAgICAgICAgICAgICAgICBpc1RvdWNoRXZlbnQ6IHZvaWQgMCxcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE1vdmluZzogdm9pZCAwXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYWxsb3dDbGljazogITAsXHJcbiAgICAgICAgICAgICAgICBhbGxvd1RvdWNoTW92ZTogci5wYXJhbXMuYWxsb3dUb3VjaE1vdmUsXHJcbiAgICAgICAgICAgICAgICB0b3VjaGVzOiB7c3RhcnRYOiAwLCBzdGFydFk6IDAsIGN1cnJlbnRYOiAwLCBjdXJyZW50WTogMCwgZGlmZjogMH0sXHJcbiAgICAgICAgICAgICAgICBpbWFnZXNUb0xvYWQ6IFtdLFxyXG4gICAgICAgICAgICAgICAgaW1hZ2VzTG9hZGVkOiAwXHJcbiAgICAgICAgICAgIH0pLCByLmVtaXQoXCJfc3dpcGVyXCIpLCByLnBhcmFtcy5pbml0ICYmIHIuaW5pdCgpLCByXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlbmFibGUoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0aGlzO1xyXG4gICAgICAgICAgICBlLmVuYWJsZWQgfHwgKGUuZW5hYmxlZCA9ICEwLCBlLnBhcmFtcy5ncmFiQ3Vyc29yICYmIGUuc2V0R3JhYkN1cnNvcigpLCBlLmVtaXQoXCJlbmFibGVcIikpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkaXNhYmxlKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdGhpcztcclxuICAgICAgICAgICAgZS5lbmFibGVkICYmIChlLmVuYWJsZWQgPSAhMSwgZS5wYXJhbXMuZ3JhYkN1cnNvciAmJiBlLnVuc2V0R3JhYkN1cnNvcigpLCBlLmVtaXQoXCJkaXNhYmxlXCIpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0UHJvZ3Jlc3MoZSwgdCkge1xyXG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcztcclxuICAgICAgICAgICAgZSA9IE1hdGgubWluKE1hdGgubWF4KGUsIDApLCAxKTtcclxuICAgICAgICAgICAgY29uc3QgYSA9IHMubWluVHJhbnNsYXRlKCksIGkgPSAocy5tYXhUcmFuc2xhdGUoKSAtIGEpICogZSArIGE7XHJcbiAgICAgICAgICAgIHMudHJhbnNsYXRlVG8oaSwgdm9pZCAwID09PSB0ID8gMCA6IHQpLCBzLnVwZGF0ZUFjdGl2ZUluZGV4KCksIHMudXBkYXRlU2xpZGVzQ2xhc3NlcygpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlbWl0Q29udGFpbmVyQ2xhc3NlcygpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICghZS5wYXJhbXMuX2VtaXRDbGFzc2VzIHx8ICFlLmVsKSByZXR1cm47XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSBlLmVsLmNsYXNzTmFtZS5zcGxpdChcIiBcIikuZmlsdGVyKCh0ID0+IDAgPT09IHQuaW5kZXhPZihcInN3aXBlclwiKSB8fCAwID09PSB0LmluZGV4T2YoZS5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcykpKTtcclxuICAgICAgICAgICAgZS5lbWl0KFwiX2NvbnRhaW5lckNsYXNzZXNcIiwgdC5qb2luKFwiIFwiKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdldFNsaWRlQ2xhc3NlcyhlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gdC5kZXN0cm95ZWQgPyBcIlwiIDogZS5jbGFzc05hbWUuc3BsaXQoXCIgXCIpLmZpbHRlcigoZSA9PiAwID09PSBlLmluZGV4T2YoXCJzd2lwZXItc2xpZGVcIikgfHwgMCA9PT0gZS5pbmRleE9mKHQucGFyYW1zLnNsaWRlQ2xhc3MpKSkuam9pbihcIiBcIilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVtaXRTbGlkZXNDbGFzc2VzKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKCFlLnBhcmFtcy5fZW1pdENsYXNzZXMgfHwgIWUuZWwpIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgdCA9IFtdO1xyXG4gICAgICAgICAgICBlLnNsaWRlcy5lYWNoKChzID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBlLmdldFNsaWRlQ2xhc3NlcyhzKTtcclxuICAgICAgICAgICAgICAgIHQucHVzaCh7c2xpZGVFbDogcywgY2xhc3NOYW1lczogYX0pLCBlLmVtaXQoXCJfc2xpZGVDbGFzc1wiLCBzLCBhKVxyXG4gICAgICAgICAgICB9KSksIGUuZW1pdChcIl9zbGlkZUNsYXNzZXNcIiwgdClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNsaWRlc1BlclZpZXdEeW5hbWljKGUsIHQpIHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBlICYmIChlID0gXCJjdXJyZW50XCIpLCB2b2lkIDAgPT09IHQgJiYgKHQgPSAhMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHtwYXJhbXM6IHMsIHNsaWRlczogYSwgc2xpZGVzR3JpZDogaSwgc2xpZGVzU2l6ZXNHcmlkOiByLCBzaXplOiBuLCBhY3RpdmVJbmRleDogbH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgbyA9IDE7XHJcbiAgICAgICAgICAgIGlmIChzLmNlbnRlcmVkU2xpZGVzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZSwgdCA9IGFbbF0uc3dpcGVyU2xpZGVTaXplO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcyA9IGwgKyAxOyBzIDwgYS5sZW5ndGg7IHMgKz0gMSkgYVtzXSAmJiAhZSAmJiAodCArPSBhW3NdLnN3aXBlclNsaWRlU2l6ZSwgbyArPSAxLCB0ID4gbiAmJiAoZSA9ICEwKSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzID0gbCAtIDE7IHMgPj0gMDsgcyAtPSAxKSBhW3NdICYmICFlICYmICh0ICs9IGFbc10uc3dpcGVyU2xpZGVTaXplLCBvICs9IDEsIHQgPiBuICYmIChlID0gITApKVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiY3VycmVudFwiID09PSBlKSBmb3IgKGxldCBlID0gbCArIDE7IGUgPCBhLmxlbmd0aDsgZSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAodCA/IGlbZV0gKyByW2VdIC0gaVtsXSA8IG4gOiBpW2VdIC0gaVtsXSA8IG4pICYmIChvICs9IDEpXHJcbiAgICAgICAgICAgIH0gZWxzZSBmb3IgKGxldCBlID0gbCAtIDE7IGUgPj0gMDsgZSAtPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpW2xdIC0gaVtlXSA8IG4gJiYgKG8gKz0gMSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdXBkYXRlKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKCFlIHx8IGUuZGVzdHJveWVkKSByZXR1cm47XHJcbiAgICAgICAgICAgIGNvbnN0IHtzbmFwR3JpZDogdCwgcGFyYW1zOiBzfSA9IGU7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBhKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IGUucnRsVHJhbnNsYXRlID8gLTEgKiBlLnRyYW5zbGF0ZSA6IGUudHJhbnNsYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBNYXRoLm1pbihNYXRoLm1heCh0LCBlLm1heFRyYW5zbGF0ZSgpKSwgZS5taW5UcmFuc2xhdGUoKSk7XHJcbiAgICAgICAgICAgICAgICBlLnNldFRyYW5zbGF0ZShzKSwgZS51cGRhdGVBY3RpdmVJbmRleCgpLCBlLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgaTtcclxuICAgICAgICAgICAgcy5icmVha3BvaW50cyAmJiBlLnNldEJyZWFrcG9pbnQoKSwgZS51cGRhdGVTaXplKCksIGUudXBkYXRlU2xpZGVzKCksIGUudXBkYXRlUHJvZ3Jlc3MoKSwgZS51cGRhdGVTbGlkZXNDbGFzc2VzKCksIGUucGFyYW1zLmZyZWVNb2RlICYmIGUucGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQgPyAoYSgpLCBlLnBhcmFtcy5hdXRvSGVpZ2h0ICYmIGUudXBkYXRlQXV0b0hlaWdodCgpKSA6IChpID0gKFwiYXV0b1wiID09PSBlLnBhcmFtcy5zbGlkZXNQZXJWaWV3IHx8IGUucGFyYW1zLnNsaWRlc1BlclZpZXcgPiAxKSAmJiBlLmlzRW5kICYmICFlLnBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IGUuc2xpZGVUbyhlLnNsaWRlcy5sZW5ndGggLSAxLCAwLCAhMSwgITApIDogZS5zbGlkZVRvKGUuYWN0aXZlSW5kZXgsIDAsICExLCAhMCksIGkgfHwgYSgpKSwgcy53YXRjaE92ZXJmbG93ICYmIHQgIT09IGUuc25hcEdyaWQgJiYgZS5jaGVja092ZXJmbG93KCksIGUuZW1pdChcInVwZGF0ZVwiKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hhbmdlRGlyZWN0aW9uKGUsIHQpIHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSB0ICYmICh0ID0gITApO1xyXG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcywgYSA9IHMucGFyYW1zLmRpcmVjdGlvbjtcclxuICAgICAgICAgICAgcmV0dXJuIGUgfHwgKGUgPSBcImhvcml6b250YWxcIiA9PT0gYSA/IFwidmVydGljYWxcIiA6IFwiaG9yaXpvbnRhbFwiKSwgZSA9PT0gYSB8fCBcImhvcml6b250YWxcIiAhPT0gZSAmJiBcInZlcnRpY2FsXCIgIT09IGUgfHwgKHMuJGVsLnJlbW92ZUNsYXNzKGAke3MucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9JHthfWApLmFkZENsYXNzKGAke3MucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9JHtlfWApLCBzLmVtaXRDb250YWluZXJDbGFzc2VzKCksIHMucGFyYW1zLmRpcmVjdGlvbiA9IGUsIHMuc2xpZGVzLmVhY2goKHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgXCJ2ZXJ0aWNhbFwiID09PSBlID8gdC5zdHlsZS53aWR0aCA9IFwiXCIgOiB0LnN0eWxlLmhlaWdodCA9IFwiXCJcclxuICAgICAgICAgICAgfSkpLCBzLmVtaXQoXCJjaGFuZ2VEaXJlY3Rpb25cIiksIHQgJiYgcy51cGRhdGUoKSksIHNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNoYW5nZUxhbmd1YWdlRGlyZWN0aW9uKGUpIHtcclxuICAgICAgICAgICAgY29uc3QgdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHQucnRsICYmIFwicnRsXCIgPT09IGUgfHwgIXQucnRsICYmIFwibHRyXCIgPT09IGUgfHwgKHQucnRsID0gXCJydGxcIiA9PT0gZSwgdC5ydGxUcmFuc2xhdGUgPSBcImhvcml6b250YWxcIiA9PT0gdC5wYXJhbXMuZGlyZWN0aW9uICYmIHQucnRsLCB0LnJ0bCA/ICh0LiRlbC5hZGRDbGFzcyhgJHt0LnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfXJ0bGApLCB0LmVsLmRpciA9IFwicnRsXCIpIDogKHQuJGVsLnJlbW92ZUNsYXNzKGAke3QucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9cnRsYCksIHQuZWwuZGlyID0gXCJsdHJcIiksIHQudXBkYXRlKCkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtb3VudChlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAodC5tb3VudGVkKSByZXR1cm4gITA7XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSBkKGUgfHwgdC5wYXJhbXMuZWwpO1xyXG4gICAgICAgICAgICBpZiAoIShlID0gc1swXSkpIHJldHVybiAhMTtcclxuICAgICAgICAgICAgZS5zd2lwZXIgPSB0O1xyXG4gICAgICAgICAgICBjb25zdCBpID0gKCkgPT4gYC4keyh0LnBhcmFtcy53cmFwcGVyQ2xhc3MgfHwgXCJcIikudHJpbSgpLnNwbGl0KFwiIFwiKS5qb2luKFwiLlwiKX1gO1xyXG4gICAgICAgICAgICBsZXQgciA9ICgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZSAmJiBlLnNoYWRvd1Jvb3QgJiYgZS5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gZChlLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihpKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5jaGlsZHJlbiA9IGUgPT4gcy5jaGlsZHJlbihlKSwgdFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHMuY2hpbGRyZW4gPyBzLmNoaWxkcmVuKGkoKSkgOiBkKHMpLmNoaWxkcmVuKGkoKSlcclxuICAgICAgICAgICAgfSkoKTtcclxuICAgICAgICAgICAgaWYgKDAgPT09IHIubGVuZ3RoICYmIHQucGFyYW1zLmNyZWF0ZUVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gYSgpLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgICAgICByID0gZChlKSwgZS5jbGFzc05hbWUgPSB0LnBhcmFtcy53cmFwcGVyQ2xhc3MsIHMuYXBwZW5kKGUpLCBzLmNoaWxkcmVuKGAuJHt0LnBhcmFtcy5zbGlkZUNsYXNzfWApLmVhY2goKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHIuYXBwZW5kKGUpXHJcbiAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih0LCB7XHJcbiAgICAgICAgICAgICAgICAkZWw6IHMsXHJcbiAgICAgICAgICAgICAgICBlbDogZSxcclxuICAgICAgICAgICAgICAgICR3cmFwcGVyRWw6IHIsXHJcbiAgICAgICAgICAgICAgICB3cmFwcGVyRWw6IHJbMF0sXHJcbiAgICAgICAgICAgICAgICBtb3VudGVkOiAhMCxcclxuICAgICAgICAgICAgICAgIHJ0bDogXCJydGxcIiA9PT0gZS5kaXIudG9Mb3dlckNhc2UoKSB8fCBcInJ0bFwiID09PSBzLmNzcyhcImRpcmVjdGlvblwiKSxcclxuICAgICAgICAgICAgICAgIHJ0bFRyYW5zbGF0ZTogXCJob3Jpem9udGFsXCIgPT09IHQucGFyYW1zLmRpcmVjdGlvbiAmJiAoXCJydGxcIiA9PT0gZS5kaXIudG9Mb3dlckNhc2UoKSB8fCBcInJ0bFwiID09PSBzLmNzcyhcImRpcmVjdGlvblwiKSksXHJcbiAgICAgICAgICAgICAgICB3cm9uZ1JUTDogXCItd2Via2l0LWJveFwiID09PSByLmNzcyhcImRpc3BsYXlcIilcclxuICAgICAgICAgICAgfSksICEwXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbml0KGUpIHtcclxuICAgICAgICAgICAgY29uc3QgdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh0LmluaXRpYWxpemVkKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgcmV0dXJuICExID09PSB0Lm1vdW50KGUpIHx8ICh0LmVtaXQoXCJiZWZvcmVJbml0XCIpLCB0LnBhcmFtcy5icmVha3BvaW50cyAmJiB0LnNldEJyZWFrcG9pbnQoKSwgdC5hZGRDbGFzc2VzKCksIHQucGFyYW1zLmxvb3AgJiYgdC5sb29wQ3JlYXRlKCksIHQudXBkYXRlU2l6ZSgpLCB0LnVwZGF0ZVNsaWRlcygpLCB0LnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHQuY2hlY2tPdmVyZmxvdygpLCB0LnBhcmFtcy5ncmFiQ3Vyc29yICYmIHQuZW5hYmxlZCAmJiB0LnNldEdyYWJDdXJzb3IoKSwgdC5wYXJhbXMucHJlbG9hZEltYWdlcyAmJiB0LnByZWxvYWRJbWFnZXMoKSwgdC5wYXJhbXMubG9vcCA/IHQuc2xpZGVUbyh0LnBhcmFtcy5pbml0aWFsU2xpZGUgKyB0Lmxvb3BlZFNsaWRlcywgMCwgdC5wYXJhbXMucnVuQ2FsbGJhY2tzT25Jbml0LCAhMSwgITApIDogdC5zbGlkZVRvKHQucGFyYW1zLmluaXRpYWxTbGlkZSwgMCwgdC5wYXJhbXMucnVuQ2FsbGJhY2tzT25Jbml0LCAhMSwgITApLCB0LmF0dGFjaEV2ZW50cygpLCB0LmluaXRpYWxpemVkID0gITAsIHQuZW1pdChcImluaXRcIiksIHQuZW1pdChcImFmdGVySW5pdFwiKSksIHRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRlc3Ryb3koZSwgdCkge1xyXG4gICAgICAgICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSAhMCksIHZvaWQgMCA9PT0gdCAmJiAodCA9ICEwKTtcclxuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXMsIHtwYXJhbXM6IGEsICRlbDogaSwgJHdyYXBwZXJFbDogciwgc2xpZGVzOiBufSA9IHM7XHJcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IHMucGFyYW1zIHx8IHMuZGVzdHJveWVkIHx8IChzLmVtaXQoXCJiZWZvcmVEZXN0cm95XCIpLCBzLmluaXRpYWxpemVkID0gITEsIHMuZGV0YWNoRXZlbnRzKCksIGEubG9vcCAmJiBzLmxvb3BEZXN0cm95KCksIHQgJiYgKHMucmVtb3ZlQ2xhc3NlcygpLCBpLnJlbW92ZUF0dHIoXCJzdHlsZVwiKSwgci5yZW1vdmVBdHRyKFwic3R5bGVcIiksIG4gJiYgbi5sZW5ndGggJiYgbi5yZW1vdmVDbGFzcyhbYS5zbGlkZVZpc2libGVDbGFzcywgYS5zbGlkZUFjdGl2ZUNsYXNzLCBhLnNsaWRlTmV4dENsYXNzLCBhLnNsaWRlUHJldkNsYXNzXS5qb2luKFwiIFwiKSkucmVtb3ZlQXR0cihcInN0eWxlXCIpLnJlbW92ZUF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSksIHMuZW1pdChcImRlc3Ryb3lcIiksIE9iamVjdC5rZXlzKHMuZXZlbnRzTGlzdGVuZXJzKS5mb3JFYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgIHMub2ZmKGUpXHJcbiAgICAgICAgICAgIH0pKSwgITEgIT09IGUgJiYgKHMuJGVsWzBdLnN3aXBlciA9IG51bGwsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gZTtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHQpLmZvckVhY2goKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRbZV0gPSBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdFtlXVxyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgfShzKSksIHMuZGVzdHJveWVkID0gITApLCBudWxsXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgZXh0ZW5kRGVmYXVsdHMoZSkge1xyXG4gICAgICAgICAgICBnKF8sIGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgZ2V0IGV4dGVuZGVkRGVmYXVsdHMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgZ2V0IGRlZmF1bHRzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gV1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGljIGluc3RhbGxNb2R1bGUoZSkge1xyXG4gICAgICAgICAgICBWLnByb3RvdHlwZS5fX21vZHVsZXNfXyB8fCAoVi5wcm90b3R5cGUuX19tb2R1bGVzX18gPSBbXSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSBWLnByb3RvdHlwZS5fX21vZHVsZXNfXztcclxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlICYmIHQuaW5kZXhPZihlKSA8IDAgJiYgdC5wdXNoKGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgdXNlKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZSkgPyAoZS5mb3JFYWNoKChlID0+IFYuaW5zdGFsbE1vZHVsZShlKSkpLCBWKSA6IChWLmluc3RhbGxNb2R1bGUoZSksIFYpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEYoZSwgdCwgcywgaSkge1xyXG4gICAgICAgIGNvbnN0IHIgPSBhKCk7XHJcbiAgICAgICAgcmV0dXJuIGUucGFyYW1zLmNyZWF0ZUVsZW1lbnRzICYmIE9iamVjdC5rZXlzKGkpLmZvckVhY2goKGEgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXNbYV0gJiYgITAgPT09IHMuYXV0bykge1xyXG4gICAgICAgICAgICAgICAgbGV0IG4gPSBlLiRlbC5jaGlsZHJlbihgLiR7aVthXX1gKVswXTtcclxuICAgICAgICAgICAgICAgIG4gfHwgKG4gPSByLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIG4uY2xhc3NOYW1lID0gaVthXSwgZS4kZWwuYXBwZW5kKG4pKSwgc1thXSA9IG4sIHRbYV0gPSBuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSksIHNcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBVKGUpIHtcclxuICAgICAgICByZXR1cm4gdm9pZCAwID09PSBlICYmIChlID0gXCJcIiksIGAuJHtlLnRyaW0oKS5yZXBsYWNlKC8oW1xcLjohXFwvXSkvZywgXCJcXFxcJDFcIikucmVwbGFjZSgvIC9nLCBcIi5cIil9YFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEsoZSkge1xyXG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLCB7JHdyYXBwZXJFbDogcywgcGFyYW1zOiBhfSA9IHQ7XHJcbiAgICAgICAgaWYgKGEubG9vcCAmJiB0Lmxvb3BEZXN0cm95KCksIFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgJiYgXCJsZW5ndGhcIiBpbiBlKSBmb3IgKGxldCB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0ICs9IDEpIGVbdF0gJiYgcy5hcHBlbmQoZVt0XSk7IGVsc2Ugcy5hcHBlbmQoZSk7XHJcbiAgICAgICAgYS5sb29wICYmIHQubG9vcENyZWF0ZSgpLCBhLm9ic2VydmVyIHx8IHQudXBkYXRlKClcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBaKGUpIHtcclxuICAgICAgICBjb25zdCB0ID0gdGhpcywge3BhcmFtczogcywgJHdyYXBwZXJFbDogYSwgYWN0aXZlSW5kZXg6IGl9ID0gdDtcclxuICAgICAgICBzLmxvb3AgJiYgdC5sb29wRGVzdHJveSgpO1xyXG4gICAgICAgIGxldCByID0gaSArIDE7XHJcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgJiYgXCJsZW5ndGhcIiBpbiBlKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQgKz0gMSkgZVt0XSAmJiBhLnByZXBlbmQoZVt0XSk7XHJcbiAgICAgICAgICAgIHIgPSBpICsgZS5sZW5ndGhcclxuICAgICAgICB9IGVsc2UgYS5wcmVwZW5kKGUpO1xyXG4gICAgICAgIHMubG9vcCAmJiB0Lmxvb3BDcmVhdGUoKSwgcy5vYnNlcnZlciB8fCB0LnVwZGF0ZSgpLCB0LnNsaWRlVG8ociwgMCwgITEpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gUShlLCB0KSB7XHJcbiAgICAgICAgY29uc3QgcyA9IHRoaXMsIHskd3JhcHBlckVsOiBhLCBwYXJhbXM6IGksIGFjdGl2ZUluZGV4OiByfSA9IHM7XHJcbiAgICAgICAgbGV0IG4gPSByO1xyXG4gICAgICAgIGkubG9vcCAmJiAobiAtPSBzLmxvb3BlZFNsaWRlcywgcy5sb29wRGVzdHJveSgpLCBzLnNsaWRlcyA9IGEuY2hpbGRyZW4oYC4ke2kuc2xpZGVDbGFzc31gKSk7XHJcbiAgICAgICAgY29uc3QgbCA9IHMuc2xpZGVzLmxlbmd0aDtcclxuICAgICAgICBpZiAoZSA8PSAwKSByZXR1cm4gdm9pZCBzLnByZXBlbmRTbGlkZSh0KTtcclxuICAgICAgICBpZiAoZSA+PSBsKSByZXR1cm4gdm9pZCBzLmFwcGVuZFNsaWRlKHQpO1xyXG4gICAgICAgIGxldCBvID0gbiA+IGUgPyBuICsgMSA6IG47XHJcbiAgICAgICAgY29uc3QgZCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IHQgPSBsIC0gMTsgdCA+PSBlOyB0IC09IDEpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHMuc2xpZGVzLmVxKHQpO1xyXG4gICAgICAgICAgICBlLnJlbW92ZSgpLCBkLnVuc2hpZnQoZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIHQgJiYgXCJsZW5ndGhcIiBpbiB0KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgdC5sZW5ndGg7IGUgKz0gMSkgdFtlXSAmJiBhLmFwcGVuZCh0W2VdKTtcclxuICAgICAgICAgICAgbyA9IG4gPiBlID8gbiArIHQubGVuZ3RoIDogblxyXG4gICAgICAgIH0gZWxzZSBhLmFwcGVuZCh0KTtcclxuICAgICAgICBmb3IgKGxldCBlID0gMDsgZSA8IGQubGVuZ3RoOyBlICs9IDEpIGEuYXBwZW5kKGRbZV0pO1xyXG4gICAgICAgIGkubG9vcCAmJiBzLmxvb3BDcmVhdGUoKSwgaS5vYnNlcnZlciB8fCBzLnVwZGF0ZSgpLCBpLmxvb3AgPyBzLnNsaWRlVG8obyArIHMubG9vcGVkU2xpZGVzLCAwLCAhMSkgOiBzLnNsaWRlVG8obywgMCwgITEpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gSihlKSB7XHJcbiAgICAgICAgY29uc3QgdCA9IHRoaXMsIHtwYXJhbXM6IHMsICR3cmFwcGVyRWw6IGEsIGFjdGl2ZUluZGV4OiBpfSA9IHQ7XHJcbiAgICAgICAgbGV0IHIgPSBpO1xyXG4gICAgICAgIHMubG9vcCAmJiAociAtPSB0Lmxvb3BlZFNsaWRlcywgdC5sb29wRGVzdHJveSgpLCB0LnNsaWRlcyA9IGEuY2hpbGRyZW4oYC4ke3Muc2xpZGVDbGFzc31gKSk7XHJcbiAgICAgICAgbGV0IG4sIGwgPSByO1xyXG4gICAgICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBlICYmIFwibGVuZ3RoXCIgaW4gZSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IGUubGVuZ3RoOyBzICs9IDEpIG4gPSBlW3NdLCB0LnNsaWRlc1tuXSAmJiB0LnNsaWRlcy5lcShuKS5yZW1vdmUoKSwgbiA8IGwgJiYgKGwgLT0gMSk7XHJcbiAgICAgICAgICAgIGwgPSBNYXRoLm1heChsLCAwKVxyXG4gICAgICAgIH0gZWxzZSBuID0gZSwgdC5zbGlkZXNbbl0gJiYgdC5zbGlkZXMuZXEobikucmVtb3ZlKCksIG4gPCBsICYmIChsIC09IDEpLCBsID0gTWF0aC5tYXgobCwgMCk7XHJcbiAgICAgICAgcy5sb29wICYmIHQubG9vcENyZWF0ZSgpLCBzLm9ic2VydmVyIHx8IHQudXBkYXRlKCksIHMubG9vcCA/IHQuc2xpZGVUbyhsICsgdC5sb29wZWRTbGlkZXMsIDAsICExKSA6IHQuc2xpZGVUbyhsLCAwLCAhMSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlZSgpIHtcclxuICAgICAgICBjb25zdCBlID0gdGhpcywgdCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgZS5zbGlkZXMubGVuZ3RoOyBzICs9IDEpIHQucHVzaChzKTtcclxuICAgICAgICBlLnJlbW92ZVNsaWRlKHQpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdGUoZSkge1xyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgZWZmZWN0OiB0LFxyXG4gICAgICAgICAgICBzd2lwZXI6IHMsXHJcbiAgICAgICAgICAgIG9uOiBhLFxyXG4gICAgICAgICAgICBzZXRUcmFuc2xhdGU6IGksXHJcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb246IHIsXHJcbiAgICAgICAgICAgIG92ZXJ3cml0ZVBhcmFtczogbixcclxuICAgICAgICAgICAgcGVyc3BlY3RpdmU6IGwsXHJcbiAgICAgICAgICAgIHJlY3JlYXRlU2hhZG93czogbyxcclxuICAgICAgICAgICAgZ2V0RWZmZWN0UGFyYW1zOiBkXHJcbiAgICAgICAgfSA9IGU7XHJcbiAgICAgICAgbGV0IGM7XHJcbiAgICAgICAgYShcImJlZm9yZUluaXRcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHMucGFyYW1zLmVmZmVjdCAhPT0gdCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBzLmNsYXNzTmFtZXMucHVzaChgJHtzLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfSR7dH1gKSwgbCAmJiBsKCkgJiYgcy5jbGFzc05hbWVzLnB1c2goYCR7cy5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc30zZGApO1xyXG4gICAgICAgICAgICBjb25zdCBlID0gbiA/IG4oKSA6IHt9O1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHMucGFyYW1zLCBlKSwgT2JqZWN0LmFzc2lnbihzLm9yaWdpbmFsUGFyYW1zLCBlKVxyXG4gICAgICAgIH0pKSwgYShcInNldFRyYW5zbGF0ZVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBzLnBhcmFtcy5lZmZlY3QgPT09IHQgJiYgaSgpXHJcbiAgICAgICAgfSkpLCBhKFwic2V0VHJhbnNpdGlvblwiLCAoKGUsIGEpID0+IHtcclxuICAgICAgICAgICAgcy5wYXJhbXMuZWZmZWN0ID09PSB0ICYmIHIoYSlcclxuICAgICAgICB9KSksIGEoXCJ0cmFuc2l0aW9uRW5kXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzLnBhcmFtcy5lZmZlY3QgPT09IHQgJiYgbykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkIHx8ICFkKCkuc2xpZGVTaGFkb3dzKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBzLnNsaWRlcy5lYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzLiQoZSkuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXRvcCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHQsIC5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbSwgLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdFwiKS5yZW1vdmUoKVxyXG4gICAgICAgICAgICAgICAgfSkpLCBvKClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKSwgYShcInZpcnR1YWxVcGRhdGVcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgcy5wYXJhbXMuZWZmZWN0ID09PSB0ICYmIChzLnNsaWRlcy5sZW5ndGggfHwgKGMgPSAhMCksIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYyAmJiBzLnNsaWRlcyAmJiBzLnNsaWRlcy5sZW5ndGggJiYgKGkoKSwgYyA9ICExKVxyXG4gICAgICAgICAgICB9KSkpXHJcbiAgICAgICAgfSkpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2UoZSwgdCkge1xyXG4gICAgICAgIHJldHVybiBlLnRyYW5zZm9ybUVsID8gdC5maW5kKGUudHJhbnNmb3JtRWwpLmNzcyh7XHJcbiAgICAgICAgICAgIFwiYmFja2ZhY2UtdmlzaWJpbGl0eVwiOiBcImhpZGRlblwiLFxyXG4gICAgICAgICAgICBcIi13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eVwiOiBcImhpZGRlblwiXHJcbiAgICAgICAgfSkgOiB0XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWUoZSkge1xyXG4gICAgICAgIGxldCB7c3dpcGVyOiB0LCBkdXJhdGlvbjogcywgdHJhbnNmb3JtRWw6IGEsIGFsbFNsaWRlczogaX0gPSBlO1xyXG4gICAgICAgIGNvbnN0IHtzbGlkZXM6IHIsIGFjdGl2ZUluZGV4OiBuLCAkd3JhcHBlckVsOiBsfSA9IHQ7XHJcbiAgICAgICAgaWYgKHQucGFyYW1zLnZpcnR1YWxUcmFuc2xhdGUgJiYgMCAhPT0gcykge1xyXG4gICAgICAgICAgICBsZXQgZSwgcyA9ICExO1xyXG4gICAgICAgICAgICBlID0gaSA/IGEgPyByLmZpbmQoYSkgOiByIDogYSA/IHIuZXEobikuZmluZChhKSA6IHIuZXEobiksIGUudHJhbnNpdGlvbkVuZCgoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHMpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGlmICghdCB8fCB0LmRlc3Ryb3llZCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgcyA9ICEwLCB0LmFuaW1hdGluZyA9ICExO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IFtcIndlYmtpdFRyYW5zaXRpb25FbmRcIiwgXCJ0cmFuc2l0aW9uZW5kXCJdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCBlLmxlbmd0aDsgdCArPSAxKSBsLnRyaWdnZXIoZVt0XSlcclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGllKGUsIHQsIHMpIHtcclxuICAgICAgICBjb25zdCBhID0gXCJzd2lwZXItc2xpZGUtc2hhZG93XCIgKyAocyA/IGAtJHtzfWAgOiBcIlwiKSwgaSA9IGUudHJhbnNmb3JtRWwgPyB0LmZpbmQoZS50cmFuc2Zvcm1FbCkgOiB0O1xyXG4gICAgICAgIGxldCByID0gaS5jaGlsZHJlbihgLiR7YX1gKTtcclxuICAgICAgICByZXR1cm4gci5sZW5ndGggfHwgKHIgPSBkKGA8ZGl2IGNsYXNzPVwic3dpcGVyLXNsaWRlLXNoYWRvdyR7cyA/IGAtJHtzfWAgOiBcIlwifVwiPjwvZGl2PmApLCBpLmFwcGVuZChyKSksIHJcclxuICAgIH1cclxuXHJcbiAgICBPYmplY3Qua2V5cyhqKS5mb3JFYWNoKChlID0+IHtcclxuICAgICAgICBPYmplY3Qua2V5cyhqW2VdKS5mb3JFYWNoKCh0ID0+IHtcclxuICAgICAgICAgICAgVi5wcm90b3R5cGVbdF0gPSBqW2VdW3RdXHJcbiAgICAgICAgfSkpXHJcbiAgICB9KSksIFYudXNlKFtmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGxldCB7c3dpcGVyOiB0LCBvbjogcywgZW1pdDogYX0gPSBlO1xyXG4gICAgICAgIGNvbnN0IGkgPSByKCk7XHJcbiAgICAgICAgbGV0IG4gPSBudWxsLCBsID0gbnVsbDtcclxuICAgICAgICBjb25zdCBvID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0ICYmICF0LmRlc3Ryb3llZCAmJiB0LmluaXRpYWxpemVkICYmIChhKFwiYmVmb3JlUmVzaXplXCIpLCBhKFwicmVzaXplXCIpKVxyXG4gICAgICAgIH0sIGQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHQgJiYgIXQuZGVzdHJveWVkICYmIHQuaW5pdGlhbGl6ZWQgJiYgYShcIm9yaWVudGF0aW9uY2hhbmdlXCIpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBzKFwiaW5pdFwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICB0LnBhcmFtcy5yZXNpemVPYnNlcnZlciAmJiB2b2lkIDAgIT09IGkuUmVzaXplT2JzZXJ2ZXIgPyB0ICYmICF0LmRlc3Ryb3llZCAmJiB0LmluaXRpYWxpemVkICYmIChuID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlID0+IHtcclxuICAgICAgICAgICAgICAgIGwgPSBpLnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHt3aWR0aDogcywgaGVpZ2h0OiBhfSA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSBzLCByID0gYTtcclxuICAgICAgICAgICAgICAgICAgICBlLmZvckVhY2goKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQge2NvbnRlbnRCb3hTaXplOiBzLCBjb250ZW50UmVjdDogYSwgdGFyZ2V0OiBufSA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gJiYgbiAhPT0gdC5lbCB8fCAoaSA9IGEgPyBhLndpZHRoIDogKHNbMF0gfHwgcykuaW5saW5lU2l6ZSwgciA9IGEgPyBhLmhlaWdodCA6IChzWzBdIHx8IHMpLmJsb2NrU2l6ZSlcclxuICAgICAgICAgICAgICAgICAgICB9KSksIGkgPT09IHMgJiYgciA9PT0gYSB8fCBvKClcclxuICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICB9KSksIG4ub2JzZXJ2ZSh0LmVsKSkgOiAoaS5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG8pLCBpLmFkZEV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLCBkKSlcclxuICAgICAgICB9KSksIHMoXCJkZXN0cm95XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGwgJiYgaS5jYW5jZWxBbmltYXRpb25GcmFtZShsKSwgbiAmJiBuLnVub2JzZXJ2ZSAmJiB0LmVsICYmIChuLnVub2JzZXJ2ZSh0LmVsKSwgbiA9IG51bGwpLCBpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgbyksIGkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIGQpXHJcbiAgICAgICAgfSkpXHJcbiAgICB9LCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGxldCB7c3dpcGVyOiB0LCBleHRlbmRQYXJhbXM6IHMsIG9uOiBhLCBlbWl0OiBpfSA9IGU7XHJcbiAgICAgICAgY29uc3QgbiA9IFtdLCBsID0gcigpLCBvID0gZnVuY3Rpb24gKGUsIHQpIHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSB0ICYmICh0ID0ge30pO1xyXG4gICAgICAgICAgICBjb25zdCBzID0gbmV3IChsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgbC5XZWJraXRNdXRhdGlvbk9ic2VydmVyKSgoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoMSA9PT0gZS5sZW5ndGgpIHJldHVybiB2b2lkIGkoXCJvYnNlcnZlclVwZGF0ZVwiLCBlWzBdKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaShcIm9ic2VydmVyVXBkYXRlXCIsIGVbMF0pXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyBsLnJlcXVlc3RBbmltYXRpb25GcmFtZSh0KSA6IGwuc2V0VGltZW91dCh0LCAwKVxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHMub2JzZXJ2ZShlLCB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB2b2lkIDAgPT09IHQuYXR0cmlidXRlcyB8fCB0LmF0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgICAgICBjaGlsZExpc3Q6IHZvaWQgMCA9PT0gdC5jaGlsZExpc3QgfHwgdC5jaGlsZExpc3QsXHJcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJEYXRhOiB2b2lkIDAgPT09IHQuY2hhcmFjdGVyRGF0YSB8fCB0LmNoYXJhY3RlckRhdGFcclxuICAgICAgICAgICAgfSksIG4ucHVzaChzKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcyh7b2JzZXJ2ZXI6ICExLCBvYnNlcnZlUGFyZW50czogITEsIG9ic2VydmVTbGlkZUNoaWxkcmVuOiAhMX0pLCBhKFwiaW5pdFwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodC5wYXJhbXMub2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0LnBhcmFtcy5vYnNlcnZlUGFyZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSB0LiRlbC5wYXJlbnRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCBlLmxlbmd0aDsgdCArPSAxKSBvKGVbdF0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvKHQuJGVsWzBdLCB7Y2hpbGRMaXN0OiB0LnBhcmFtcy5vYnNlcnZlU2xpZGVDaGlsZHJlbn0pLCBvKHQuJHdyYXBwZXJFbFswXSwge2F0dHJpYnV0ZXM6ICExfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKSwgYShcImRlc3Ryb3lcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgbi5mb3JFYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgIGUuZGlzY29ubmVjdCgpXHJcbiAgICAgICAgICAgIH0pKSwgbi5zcGxpY2UoMCwgbi5sZW5ndGgpXHJcbiAgICAgICAgfSkpXHJcbiAgICB9XSk7XHJcbiAgICBjb25zdCByZSA9IFtmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGxldCB0LCB7c3dpcGVyOiBzLCBleHRlbmRQYXJhbXM6IGEsIG9uOiBpLCBlbWl0OiByfSA9IGU7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG4oZSwgdCkge1xyXG4gICAgICAgICAgICBjb25zdCBhID0gcy5wYXJhbXMudmlydHVhbDtcclxuICAgICAgICAgICAgaWYgKGEuY2FjaGUgJiYgcy52aXJ0dWFsLmNhY2hlW3RdKSByZXR1cm4gcy52aXJ0dWFsLmNhY2hlW3RdO1xyXG4gICAgICAgICAgICBjb25zdCBpID0gYS5yZW5kZXJTbGlkZSA/IGQoYS5yZW5kZXJTbGlkZS5jYWxsKHMsIGUsIHQpKSA6IGQoYDxkaXYgY2xhc3M9XCIke3MucGFyYW1zLnNsaWRlQ2xhc3N9XCIgZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3R9XCI+JHtlfTwvZGl2PmApO1xyXG4gICAgICAgICAgICByZXR1cm4gaS5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIikgfHwgaS5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIiwgdCksIGEuY2FjaGUgJiYgKHMudmlydHVhbC5jYWNoZVt0XSA9IGkpLCBpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBsKGUpIHtcclxuICAgICAgICAgICAgY29uc3Qge3NsaWRlc1BlclZpZXc6IHQsIHNsaWRlc1Blckdyb3VwOiBhLCBjZW50ZXJlZFNsaWRlczogaX0gPSBzLnBhcmFtcywge1xyXG4gICAgICAgICAgICAgICAgYWRkU2xpZGVzQmVmb3JlOiBsLFxyXG4gICAgICAgICAgICAgICAgYWRkU2xpZGVzQWZ0ZXI6IG9cclxuICAgICAgICAgICAgfSA9IHMucGFyYW1zLnZpcnR1YWwsIHtmcm9tOiBkLCB0bzogYywgc2xpZGVzOiBwLCBzbGlkZXNHcmlkOiB1LCBvZmZzZXQ6IGh9ID0gcy52aXJ0dWFsO1xyXG4gICAgICAgICAgICBzLnBhcmFtcy5jc3NNb2RlIHx8IHMudXBkYXRlQWN0aXZlSW5kZXgoKTtcclxuICAgICAgICAgICAgY29uc3QgbSA9IHMuYWN0aXZlSW5kZXggfHwgMDtcclxuICAgICAgICAgICAgbGV0IGYsIGcsIHY7XHJcbiAgICAgICAgICAgIGYgPSBzLnJ0bFRyYW5zbGF0ZSA/IFwicmlnaHRcIiA6IHMuaXNIb3Jpem9udGFsKCkgPyBcImxlZnRcIiA6IFwidG9wXCIsIGkgPyAoZyA9IE1hdGguZmxvb3IodCAvIDIpICsgYSArIG8sIHYgPSBNYXRoLmZsb29yKHQgLyAyKSArIGEgKyBsKSA6IChnID0gdCArIChhIC0gMSkgKyBvLCB2ID0gYSArIGwpO1xyXG4gICAgICAgICAgICBjb25zdCB3ID0gTWF0aC5tYXgoKG0gfHwgMCkgLSB2LCAwKSwgYiA9IE1hdGgubWluKChtIHx8IDApICsgZywgcC5sZW5ndGggLSAxKSxcclxuICAgICAgICAgICAgICAgIHggPSAocy5zbGlkZXNHcmlkW3ddIHx8IDApIC0gKHMuc2xpZGVzR3JpZFswXSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHkoKSB7XHJcbiAgICAgICAgICAgICAgICBzLnVwZGF0ZVNsaWRlcygpLCBzLnVwZGF0ZVByb2dyZXNzKCksIHMudXBkYXRlU2xpZGVzQ2xhc3NlcygpLCBzLmxhenkgJiYgcy5wYXJhbXMubGF6eS5lbmFibGVkICYmIHMubGF6eS5sb2FkKCksIHIoXCJ2aXJ0dWFsVXBkYXRlXCIpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChPYmplY3QuYXNzaWduKHMudmlydHVhbCwge1xyXG4gICAgICAgICAgICAgICAgZnJvbTogdyxcclxuICAgICAgICAgICAgICAgIHRvOiBiLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB4LFxyXG4gICAgICAgICAgICAgICAgc2xpZGVzR3JpZDogcy5zbGlkZXNHcmlkXHJcbiAgICAgICAgICAgIH0pLCBkID09PSB3ICYmIGMgPT09IGIgJiYgIWUpIHJldHVybiBzLnNsaWRlc0dyaWQgIT09IHUgJiYgeCAhPT0gaCAmJiBzLnNsaWRlcy5jc3MoZiwgYCR7eH1weGApLCBzLnVwZGF0ZVByb2dyZXNzKCksIHZvaWQgcihcInZpcnR1YWxVcGRhdGVcIik7XHJcbiAgICAgICAgICAgIGlmIChzLnBhcmFtcy52aXJ0dWFsLnJlbmRlckV4dGVybmFsKSByZXR1cm4gcy5wYXJhbXMudmlydHVhbC5yZW5kZXJFeHRlcm5hbC5jYWxsKHMsIHtcclxuICAgICAgICAgICAgICAgIG9mZnNldDogeCxcclxuICAgICAgICAgICAgICAgIGZyb206IHcsXHJcbiAgICAgICAgICAgICAgICB0bzogYixcclxuICAgICAgICAgICAgICAgIHNsaWRlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0ID0gdzsgdCA8PSBiOyB0ICs9IDEpIGUucHVzaChwW3RdKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZVxyXG4gICAgICAgICAgICAgICAgfSgpXHJcbiAgICAgICAgICAgIH0pLCB2b2lkIChzLnBhcmFtcy52aXJ0dWFsLnJlbmRlckV4dGVybmFsVXBkYXRlID8geSgpIDogcihcInZpcnR1YWxVcGRhdGVcIikpO1xyXG4gICAgICAgICAgICBjb25zdCBFID0gW10sIEMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKGUpIHMuJHdyYXBwZXJFbC5maW5kKGAuJHtzLnBhcmFtcy5zbGlkZUNsYXNzfWApLnJlbW92ZSgpOyBlbHNlIGZvciAobGV0IGUgPSBkOyBlIDw9IGM7IGUgKz0gMSkgKGUgPCB3IHx8IGUgPiBiKSAmJiBzLiR3cmFwcGVyRWwuZmluZChgLiR7cy5wYXJhbXMuc2xpZGVDbGFzc31bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2V9XCJdYCkucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgcC5sZW5ndGg7IHQgKz0gMSkgdCA+PSB3ICYmIHQgPD0gYiAmJiAodm9pZCAwID09PSBjIHx8IGUgPyBDLnB1c2godCkgOiAodCA+IGMgJiYgQy5wdXNoKHQpLCB0IDwgZCAmJiBFLnB1c2godCkpKTtcclxuICAgICAgICAgICAgQy5mb3JFYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgIHMuJHdyYXBwZXJFbC5hcHBlbmQobihwW2VdLCBlKSlcclxuICAgICAgICAgICAgfSkpLCBFLnNvcnQoKChlLCB0KSA9PiB0IC0gZSkpLmZvckVhY2goKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgcy4kd3JhcHBlckVsLnByZXBlbmQobihwW2VdLCBlKSlcclxuICAgICAgICAgICAgfSkpLCBzLiR3cmFwcGVyRWwuY2hpbGRyZW4oXCIuc3dpcGVyLXNsaWRlXCIpLmNzcyhmLCBgJHt4fXB4YCksIHkoKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYSh7XHJcbiAgICAgICAgICAgIHZpcnR1YWw6IHtcclxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6ICExLFxyXG4gICAgICAgICAgICAgICAgc2xpZGVzOiBbXSxcclxuICAgICAgICAgICAgICAgIGNhY2hlOiAhMCxcclxuICAgICAgICAgICAgICAgIHJlbmRlclNsaWRlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyRXh0ZXJuYWw6IG51bGwsXHJcbiAgICAgICAgICAgICAgICByZW5kZXJFeHRlcm5hbFVwZGF0ZTogITAsXHJcbiAgICAgICAgICAgICAgICBhZGRTbGlkZXNCZWZvcmU6IDAsXHJcbiAgICAgICAgICAgICAgICBhZGRTbGlkZXNBZnRlcjogMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksIHMudmlydHVhbCA9IHtcclxuICAgICAgICAgICAgY2FjaGU6IHt9LFxyXG4gICAgICAgICAgICBmcm9tOiB2b2lkIDAsXHJcbiAgICAgICAgICAgIHRvOiB2b2lkIDAsXHJcbiAgICAgICAgICAgIHNsaWRlczogW10sXHJcbiAgICAgICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICAgICAgc2xpZGVzR3JpZDogW11cclxuICAgICAgICB9LCBpKFwiYmVmb3JlSW5pdFwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBzLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgJiYgKHMudmlydHVhbC5zbGlkZXMgPSBzLnBhcmFtcy52aXJ0dWFsLnNsaWRlcywgcy5jbGFzc05hbWVzLnB1c2goYCR7cy5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc312aXJ0dWFsYCksIHMucGFyYW1zLndhdGNoU2xpZGVzUHJvZ3Jlc3MgPSAhMCwgcy5vcmlnaW5hbFBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gITAsIHMucGFyYW1zLmluaXRpYWxTbGlkZSB8fCBsKCkpXHJcbiAgICAgICAgfSkpLCBpKFwic2V0VHJhbnNsYXRlXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHMucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCAmJiAocy5wYXJhbXMuY3NzTW9kZSAmJiAhcy5faW1tZWRpYXRlVmlydHVhbCA/IChjbGVhclRpbWVvdXQodCksIHQgPSBzZXRUaW1lb3V0KCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsKClcclxuICAgICAgICAgICAgfSksIDEwMCkpIDogbCgpKVxyXG4gICAgICAgIH0pKSwgaShcImluaXQgdXBkYXRlIHJlc2l6ZVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBzLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgJiYgcy5wYXJhbXMuY3NzTW9kZSAmJiB2KHMud3JhcHBlckVsLCBcIi0tc3dpcGVyLXZpcnR1YWwtc2l6ZVwiLCBgJHtzLnZpcnR1YWxTaXplfXB4YClcclxuICAgICAgICB9KSksIE9iamVjdC5hc3NpZ24ocy52aXJ0dWFsLCB7XHJcbiAgICAgICAgICAgIGFwcGVuZFNsaWRlOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgJiYgXCJsZW5ndGhcIiBpbiBlKSBmb3IgKGxldCB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0ICs9IDEpIGVbdF0gJiYgcy52aXJ0dWFsLnNsaWRlcy5wdXNoKGVbdF0pOyBlbHNlIHMudmlydHVhbC5zbGlkZXMucHVzaChlKTtcclxuICAgICAgICAgICAgICAgIGwoITApXHJcbiAgICAgICAgICAgIH0sIHByZXBlbmRTbGlkZTogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBzLmFjdGl2ZUluZGV4O1xyXG4gICAgICAgICAgICAgICAgbGV0IGEgPSB0ICsgMSwgaSA9IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQgKz0gMSkgZVt0XSAmJiBzLnZpcnR1YWwuc2xpZGVzLnVuc2hpZnQoZVt0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IHQgKyBlLmxlbmd0aCwgaSA9IGUubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Ugcy52aXJ0dWFsLnNsaWRlcy51bnNoaWZ0KGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHMucGFyYW1zLnZpcnR1YWwuY2FjaGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gcy52aXJ0dWFsLmNhY2hlLCB0ID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgocyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBlW3NdLCByID0gYS5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgJiYgYS5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIiwgcGFyc2VJbnQociwgMTApICsgaSksIHRbcGFyc2VJbnQocywgMTApICsgaV0gPSBhXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpLCBzLnZpcnR1YWwuY2FjaGUgPSB0XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsKCEwKSwgcy5zbGlkZVRvKGEsIDApXHJcbiAgICAgICAgICAgIH0sIHJlbW92ZVNsaWRlOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG51bGwgPT0gZSkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgbGV0IHQgPSBzLmFjdGl2ZUluZGV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIGZvciAobGV0IGEgPSBlLmxlbmd0aCAtIDE7IGEgPj0gMDsgYSAtPSAxKSBzLnZpcnR1YWwuc2xpZGVzLnNwbGljZShlW2FdLCAxKSwgcy5wYXJhbXMudmlydHVhbC5jYWNoZSAmJiBkZWxldGUgcy52aXJ0dWFsLmNhY2hlW2VbYV1dLCBlW2FdIDwgdCAmJiAodCAtPSAxKSwgdCA9IE1hdGgubWF4KHQsIDApOyBlbHNlIHMudmlydHVhbC5zbGlkZXMuc3BsaWNlKGUsIDEpLCBzLnBhcmFtcy52aXJ0dWFsLmNhY2hlICYmIGRlbGV0ZSBzLnZpcnR1YWwuY2FjaGVbZV0sIGUgPCB0ICYmICh0IC09IDEpLCB0ID0gTWF0aC5tYXgodCwgMCk7XHJcbiAgICAgICAgICAgICAgICBsKCEwKSwgcy5zbGlkZVRvKHQsIDApXHJcbiAgICAgICAgICAgIH0sIHJlbW92ZUFsbFNsaWRlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcy52aXJ0dWFsLnNsaWRlcyA9IFtdLCBzLnBhcmFtcy52aXJ0dWFsLmNhY2hlICYmIChzLnZpcnR1YWwuY2FjaGUgPSB7fSksIGwoITApLCBzLnNsaWRlVG8oMCwgMClcclxuICAgICAgICAgICAgfSwgdXBkYXRlOiBsXHJcbiAgICAgICAgfSlcclxuICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgbGV0IHtzd2lwZXI6IHQsIGV4dGVuZFBhcmFtczogcywgb246IGksIGVtaXQ6IG59ID0gZTtcclxuICAgICAgICBjb25zdCBsID0gYSgpLCBvID0gcigpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBjKGUpIHtcclxuICAgICAgICAgICAgaWYgKCF0LmVuYWJsZWQpIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3Qge3J0bFRyYW5zbGF0ZTogc30gPSB0O1xyXG4gICAgICAgICAgICBsZXQgYSA9IGU7XHJcbiAgICAgICAgICAgIGEub3JpZ2luYWxFdmVudCAmJiAoYSA9IGEub3JpZ2luYWxFdmVudCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGkgPSBhLmtleUNvZGUgfHwgYS5jaGFyQ29kZSwgciA9IHQucGFyYW1zLmtleWJvYXJkLnBhZ2VVcERvd24sIGQgPSByICYmIDMzID09PSBpLCBjID0gciAmJiAzNCA9PT0gaSxcclxuICAgICAgICAgICAgICAgIHAgPSAzNyA9PT0gaSwgdSA9IDM5ID09PSBpLCBoID0gMzggPT09IGksIG0gPSA0MCA9PT0gaTtcclxuICAgICAgICAgICAgaWYgKCF0LmFsbG93U2xpZGVOZXh0ICYmICh0LmlzSG9yaXpvbnRhbCgpICYmIHUgfHwgdC5pc1ZlcnRpY2FsKCkgJiYgbSB8fCBjKSkgcmV0dXJuICExO1xyXG4gICAgICAgICAgICBpZiAoIXQuYWxsb3dTbGlkZVByZXYgJiYgKHQuaXNIb3Jpem9udGFsKCkgJiYgcCB8fCB0LmlzVmVydGljYWwoKSAmJiBoIHx8IGQpKSByZXR1cm4gITE7XHJcbiAgICAgICAgICAgIGlmICghKGEuc2hpZnRLZXkgfHwgYS5hbHRLZXkgfHwgYS5jdHJsS2V5IHx8IGEubWV0YUtleSB8fCBsLmFjdGl2ZUVsZW1lbnQgJiYgbC5hY3RpdmVFbGVtZW50Lm5vZGVOYW1lICYmIChcImlucHV0XCIgPT09IGwuYWN0aXZlRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIHx8IFwidGV4dGFyZWFcIiA9PT0gbC5hY3RpdmVFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHQucGFyYW1zLmtleWJvYXJkLm9ubHlJblZpZXdwb3J0ICYmIChkIHx8IGMgfHwgcCB8fCB1IHx8IGggfHwgbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZSA9ICExO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0LiRlbC5wYXJlbnRzKGAuJHt0LnBhcmFtcy5zbGlkZUNsYXNzfWApLmxlbmd0aCA+IDAgJiYgMCA9PT0gdC4kZWwucGFyZW50cyhgLiR7dC5wYXJhbXMuc2xpZGVBY3RpdmVDbGFzc31gKS5sZW5ndGgpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gdC4kZWwsIGkgPSBhWzBdLmNsaWVudFdpZHRoLCByID0gYVswXS5jbGllbnRIZWlnaHQsIG4gPSBvLmlubmVyV2lkdGgsIGwgPSBvLmlubmVySGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gdC4kZWwub2Zmc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcyAmJiAoZC5sZWZ0IC09IHQuJGVsWzBdLnNjcm9sbExlZnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBbW2QubGVmdCwgZC50b3BdLCBbZC5sZWZ0ICsgaSwgZC50b3BdLCBbZC5sZWZ0LCBkLnRvcCArIHJdLCBbZC5sZWZ0ICsgaSwgZC50b3AgKyByXV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCBjLmxlbmd0aDsgdCArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBjW3RdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc1swXSA+PSAwICYmIHNbMF0gPD0gbiAmJiBzWzFdID49IDAgJiYgc1sxXSA8PSBsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gc1swXSAmJiAwID09PSBzWzFdKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSAhMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZSkgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0LmlzSG9yaXpvbnRhbCgpID8gKChkIHx8IGMgfHwgcCB8fCB1KSAmJiAoYS5wcmV2ZW50RGVmYXVsdCA/IGEucHJldmVudERlZmF1bHQoKSA6IGEucmV0dXJuVmFsdWUgPSAhMSksICgoYyB8fCB1KSAmJiAhcyB8fCAoZCB8fCBwKSAmJiBzKSAmJiB0LnNsaWRlTmV4dCgpLCAoKGQgfHwgcCkgJiYgIXMgfHwgKGMgfHwgdSkgJiYgcykgJiYgdC5zbGlkZVByZXYoKSkgOiAoKGQgfHwgYyB8fCBoIHx8IG0pICYmIChhLnByZXZlbnREZWZhdWx0ID8gYS5wcmV2ZW50RGVmYXVsdCgpIDogYS5yZXR1cm5WYWx1ZSA9ICExKSwgKGMgfHwgbSkgJiYgdC5zbGlkZU5leHQoKSwgKGQgfHwgaCkgJiYgdC5zbGlkZVByZXYoKSksIG4oXCJrZXlQcmVzc1wiLCBpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBwKCkge1xyXG4gICAgICAgICAgICB0LmtleWJvYXJkLmVuYWJsZWQgfHwgKGQobCkub24oXCJrZXlkb3duXCIsIGMpLCB0LmtleWJvYXJkLmVuYWJsZWQgPSAhMClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHUoKSB7XHJcbiAgICAgICAgICAgIHQua2V5Ym9hcmQuZW5hYmxlZCAmJiAoZChsKS5vZmYoXCJrZXlkb3duXCIsIGMpLCB0LmtleWJvYXJkLmVuYWJsZWQgPSAhMSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHQua2V5Ym9hcmQgPSB7ZW5hYmxlZDogITF9LCBzKHtrZXlib2FyZDoge2VuYWJsZWQ6ICExLCBvbmx5SW5WaWV3cG9ydDogITAsIHBhZ2VVcERvd246ICEwfX0pLCBpKFwiaW5pdFwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICB0LnBhcmFtcy5rZXlib2FyZC5lbmFibGVkICYmIHAoKVxyXG4gICAgICAgIH0pKSwgaShcImRlc3Ryb3lcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC5rZXlib2FyZC5lbmFibGVkICYmIHUoKVxyXG4gICAgICAgIH0pKSwgT2JqZWN0LmFzc2lnbih0LmtleWJvYXJkLCB7ZW5hYmxlOiBwLCBkaXNhYmxlOiB1fSlcclxuICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgbGV0IHtzd2lwZXI6IHQsIGV4dGVuZFBhcmFtczogcywgb246IGEsIGVtaXQ6IGl9ID0gZTtcclxuICAgICAgICBjb25zdCBuID0gcigpO1xyXG4gICAgICAgIGxldCBsO1xyXG4gICAgICAgIHMoe1xyXG4gICAgICAgICAgICBtb3VzZXdoZWVsOiB7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiAhMSxcclxuICAgICAgICAgICAgICAgIHJlbGVhc2VPbkVkZ2VzOiAhMSxcclxuICAgICAgICAgICAgICAgIGludmVydDogITEsXHJcbiAgICAgICAgICAgICAgICBmb3JjZVRvQXhpczogITEsXHJcbiAgICAgICAgICAgICAgICBzZW5zaXRpdml0eTogMSxcclxuICAgICAgICAgICAgICAgIGV2ZW50c1RhcmdldDogXCJjb250YWluZXJcIixcclxuICAgICAgICAgICAgICAgIHRocmVzaG9sZERlbHRhOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkVGltZTogbnVsbFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksIHQubW91c2V3aGVlbCA9IHtlbmFibGVkOiAhMX07XHJcbiAgICAgICAgbGV0IG8sIGMgPSB1KCk7XHJcbiAgICAgICAgY29uc3QgaCA9IFtdO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBtKCkge1xyXG4gICAgICAgICAgICB0LmVuYWJsZWQgJiYgKHQubW91c2VFbnRlcmVkID0gITApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBmKCkge1xyXG4gICAgICAgICAgICB0LmVuYWJsZWQgJiYgKHQubW91c2VFbnRlcmVkID0gITEpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEodC5wYXJhbXMubW91c2V3aGVlbC50aHJlc2hvbGREZWx0YSAmJiBlLmRlbHRhIDwgdC5wYXJhbXMubW91c2V3aGVlbC50aHJlc2hvbGREZWx0YSkgJiYgKCEodC5wYXJhbXMubW91c2V3aGVlbC50aHJlc2hvbGRUaW1lICYmIHUoKSAtIGMgPCB0LnBhcmFtcy5tb3VzZXdoZWVsLnRocmVzaG9sZFRpbWUpICYmIChlLmRlbHRhID49IDYgJiYgdSgpIC0gYyA8IDYwIHx8IChlLmRpcmVjdGlvbiA8IDAgPyB0LmlzRW5kICYmICF0LnBhcmFtcy5sb29wIHx8IHQuYW5pbWF0aW5nIHx8ICh0LnNsaWRlTmV4dCgpLCBpKFwic2Nyb2xsXCIsIGUucmF3KSkgOiB0LmlzQmVnaW5uaW5nICYmICF0LnBhcmFtcy5sb29wIHx8IHQuYW5pbWF0aW5nIHx8ICh0LnNsaWRlUHJldigpLCBpKFwic2Nyb2xsXCIsIGUucmF3KSksIGMgPSAobmV3IG4uRGF0ZSkuZ2V0VGltZSgpLCAhMSkpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdihlKSB7XHJcbiAgICAgICAgICAgIGxldCBzID0gZSwgYSA9ICEwO1xyXG4gICAgICAgICAgICBpZiAoIXQuZW5hYmxlZCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCByID0gdC5wYXJhbXMubW91c2V3aGVlbDtcclxuICAgICAgICAgICAgdC5wYXJhbXMuY3NzTW9kZSAmJiBzLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGxldCBuID0gdC4kZWw7XHJcbiAgICAgICAgICAgIGlmIChcImNvbnRhaW5lclwiICE9PSB0LnBhcmFtcy5tb3VzZXdoZWVsLmV2ZW50c1RhcmdldCAmJiAobiA9IGQodC5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZXQpKSwgIXQubW91c2VFbnRlcmVkICYmICFuWzBdLmNvbnRhaW5zKHMudGFyZ2V0KSAmJiAhci5yZWxlYXNlT25FZGdlcykgcmV0dXJuICEwO1xyXG4gICAgICAgICAgICBzLm9yaWdpbmFsRXZlbnQgJiYgKHMgPSBzLm9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgICAgICBsZXQgYyA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IG0gPSB0LnJ0bFRyYW5zbGF0ZSA/IC0xIDogMSwgZiA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdCA9IDAsIHMgPSAwLCBhID0gMCwgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJkZXRhaWxcIiBpbiBlICYmIChzID0gZS5kZXRhaWwpLCBcIndoZWVsRGVsdGFcIiBpbiBlICYmIChzID0gLWUud2hlZWxEZWx0YSAvIDEyMCksIFwid2hlZWxEZWx0YVlcIiBpbiBlICYmIChzID0gLWUud2hlZWxEZWx0YVkgLyAxMjApLCBcIndoZWVsRGVsdGFYXCIgaW4gZSAmJiAodCA9IC1lLndoZWVsRGVsdGFYIC8gMTIwKSwgXCJheGlzXCIgaW4gZSAmJiBlLmF4aXMgPT09IGUuSE9SSVpPTlRBTF9BWElTICYmICh0ID0gcywgcyA9IDApLCBhID0gMTAgKiB0LCBpID0gMTAgKiBzLCBcImRlbHRhWVwiIGluIGUgJiYgKGkgPSBlLmRlbHRhWSksIFwiZGVsdGFYXCIgaW4gZSAmJiAoYSA9IGUuZGVsdGFYKSwgZS5zaGlmdEtleSAmJiAhYSAmJiAoYSA9IGksIGkgPSAwKSwgKGEgfHwgaSkgJiYgZS5kZWx0YU1vZGUgJiYgKDEgPT09IGUuZGVsdGFNb2RlID8gKGEgKj0gNDAsIGkgKj0gNDApIDogKGEgKj0gODAwLCBpICo9IDgwMCkpLCBhICYmICF0ICYmICh0ID0gYSA8IDEgPyAtMSA6IDEpLCBpICYmICFzICYmIChzID0gaSA8IDEgPyAtMSA6IDEpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3Bpblg6IHQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Bpblk6IHMsXHJcbiAgICAgICAgICAgICAgICAgICAgcGl4ZWxYOiBhLFxyXG4gICAgICAgICAgICAgICAgICAgIHBpeGVsWTogaVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KHMpO1xyXG4gICAgICAgICAgICBpZiAoci5mb3JjZVRvQXhpcykgaWYgKHQuaXNIb3Jpem9udGFsKCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghKE1hdGguYWJzKGYucGl4ZWxYKSA+IE1hdGguYWJzKGYucGl4ZWxZKSkpIHJldHVybiAhMDtcclxuICAgICAgICAgICAgICAgIGMgPSAtZi5waXhlbFggKiBtXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShNYXRoLmFicyhmLnBpeGVsWSkgPiBNYXRoLmFicyhmLnBpeGVsWCkpKSByZXR1cm4gITA7XHJcbiAgICAgICAgICAgICAgICBjID0gLWYucGl4ZWxZXHJcbiAgICAgICAgICAgIH0gZWxzZSBjID0gTWF0aC5hYnMoZi5waXhlbFgpID4gTWF0aC5hYnMoZi5waXhlbFkpID8gLWYucGl4ZWxYICogbSA6IC1mLnBpeGVsWTtcclxuICAgICAgICAgICAgaWYgKDAgPT09IGMpIHJldHVybiAhMDtcclxuICAgICAgICAgICAgci5pbnZlcnQgJiYgKGMgPSAtYyk7XHJcbiAgICAgICAgICAgIGxldCB2ID0gdC5nZXRUcmFuc2xhdGUoKSArIGMgKiByLnNlbnNpdGl2aXR5O1xyXG4gICAgICAgICAgICBpZiAodiA+PSB0Lm1pblRyYW5zbGF0ZSgpICYmICh2ID0gdC5taW5UcmFuc2xhdGUoKSksIHYgPD0gdC5tYXhUcmFuc2xhdGUoKSAmJiAodiA9IHQubWF4VHJhbnNsYXRlKCkpLCBhID0gISF0LnBhcmFtcy5sb29wIHx8ICEodiA9PT0gdC5taW5UcmFuc2xhdGUoKSB8fCB2ID09PSB0Lm1heFRyYW5zbGF0ZSgpKSwgYSAmJiB0LnBhcmFtcy5uZXN0ZWQgJiYgcy5zdG9wUHJvcGFnYXRpb24oKSwgdC5wYXJhbXMuZnJlZU1vZGUgJiYgdC5wYXJhbXMuZnJlZU1vZGUuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHt0aW1lOiB1KCksIGRlbHRhOiBNYXRoLmFicyhjKSwgZGlyZWN0aW9uOiBNYXRoLnNpZ24oYyl9LFxyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBvICYmIGUudGltZSA8IG8udGltZSArIDUwMCAmJiBlLmRlbHRhIDw9IG8uZGVsdGEgJiYgZS5kaXJlY3Rpb24gPT09IG8uZGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbyA9IHZvaWQgMCwgdC5wYXJhbXMubG9vcCAmJiB0Lmxvb3BGaXgoKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbiA9IHQuZ2V0VHJhbnNsYXRlKCkgKyBjICogci5zZW5zaXRpdml0eTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkID0gdC5pc0JlZ2lubmluZywgdSA9IHQuaXNFbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPj0gdC5taW5UcmFuc2xhdGUoKSAmJiAobiA9IHQubWluVHJhbnNsYXRlKCkpLCBuIDw9IHQubWF4VHJhbnNsYXRlKCkgJiYgKG4gPSB0Lm1heFRyYW5zbGF0ZSgpKSwgdC5zZXRUcmFuc2l0aW9uKDApLCB0LnNldFRyYW5zbGF0ZShuKSwgdC51cGRhdGVQcm9ncmVzcygpLCB0LnVwZGF0ZUFjdGl2ZUluZGV4KCksIHQudXBkYXRlU2xpZGVzQ2xhc3NlcygpLCAoIWQgJiYgdC5pc0JlZ2lubmluZyB8fCAhdSAmJiB0LmlzRW5kKSAmJiB0LnVwZGF0ZVNsaWRlc0NsYXNzZXMoKSwgdC5wYXJhbXMuZnJlZU1vZGUuc3RpY2t5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChsKSwgbCA9IHZvaWQgMCwgaC5sZW5ndGggPj0gMTUgJiYgaC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gaC5sZW5ndGggPyBoW2gubGVuZ3RoIC0gMV0gOiB2b2lkIDAsIGEgPSBoWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaC5wdXNoKGUpLCBzICYmIChlLmRlbHRhID4gcy5kZWx0YSB8fCBlLmRpcmVjdGlvbiAhPT0gcy5kaXJlY3Rpb24pKSBoLnNwbGljZSgwKTsgZWxzZSBpZiAoaC5sZW5ndGggPj0gMTUgJiYgZS50aW1lIC0gYS50aW1lIDwgNTAwICYmIGEuZGVsdGEgLSBlLmRlbHRhID49IDEgJiYgZS5kZWx0YSA8PSA2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gYyA+IDAgPyAuOCA6IC4yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IGUsIGguc3BsaWNlKDApLCBsID0gcCgoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuc2xpZGVUb0Nsb3Nlc3QodC5wYXJhbXMuc3BlZWQsICEwLCB2b2lkIDAsIHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsIHx8IChsID0gcCgoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IGUsIGguc3BsaWNlKDApLCB0LnNsaWRlVG9DbG9zZXN0KHQucGFyYW1zLnNwZWVkLCAhMCwgdm9pZCAwLCAuNSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIDUwMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhIHx8IGkoXCJzY3JvbGxcIiwgcyksIHQucGFyYW1zLmF1dG9wbGF5ICYmIHQucGFyYW1zLmF1dG9wbGF5RGlzYWJsZU9uSW50ZXJhY3Rpb24gJiYgdC5hdXRvcGxheS5zdG9wKCksIG4gPT09IHQubWluVHJhbnNsYXRlKCkgfHwgbiA9PT0gdC5tYXhUcmFuc2xhdGUoKSkgcmV0dXJuICEwXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0ge3RpbWU6IHUoKSwgZGVsdGE6IE1hdGguYWJzKGMpLCBkaXJlY3Rpb246IE1hdGguc2lnbihjKSwgcmF3OiBlfTtcclxuICAgICAgICAgICAgICAgIGgubGVuZ3RoID49IDIgJiYgaC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGgubGVuZ3RoID8gaFtoLmxlbmd0aCAtIDFdIDogdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGgucHVzaChzKSwgYSA/IChzLmRpcmVjdGlvbiAhPT0gYS5kaXJlY3Rpb24gfHwgcy5kZWx0YSA+IGEuZGVsdGEgfHwgcy50aW1lID4gYS50aW1lICsgMTUwKSAmJiBnKHMpIDogZyhzKSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gdC5wYXJhbXMubW91c2V3aGVlbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5kaXJlY3Rpb24gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0LmlzRW5kICYmICF0LnBhcmFtcy5sb29wICYmIHMucmVsZWFzZU9uRWRnZXMpIHJldHVybiAhMFxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodC5pc0JlZ2lubmluZyAmJiAhdC5wYXJhbXMubG9vcCAmJiBzLnJlbGVhc2VPbkVkZ2VzKSByZXR1cm4gITA7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExXHJcbiAgICAgICAgICAgICAgICB9KHMpKSByZXR1cm4gITBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcy5wcmV2ZW50RGVmYXVsdCA/IHMucHJldmVudERlZmF1bHQoKSA6IHMucmV0dXJuVmFsdWUgPSAhMSwgITFcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHcoZSkge1xyXG4gICAgICAgICAgICBsZXQgcyA9IHQuJGVsO1xyXG4gICAgICAgICAgICBcImNvbnRhaW5lclwiICE9PSB0LnBhcmFtcy5tb3VzZXdoZWVsLmV2ZW50c1RhcmdldCAmJiAocyA9IGQodC5wYXJhbXMubW91c2V3aGVlbC5ldmVudHNUYXJnZXQpKSwgc1tlXShcIm1vdXNlZW50ZXJcIiwgbSksIHNbZV0oXCJtb3VzZWxlYXZlXCIsIGYpLCBzW2VdKFwid2hlZWxcIiwgdilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0LnBhcmFtcy5jc3NNb2RlID8gKHQud3JhcHBlckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCB2KSwgITApIDogIXQubW91c2V3aGVlbC5lbmFibGVkICYmICh3KFwib25cIiksIHQubW91c2V3aGVlbC5lbmFibGVkID0gITAsICEwKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24geCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHQucGFyYW1zLmNzc01vZGUgPyAodC53cmFwcGVyRWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdiksICEwKSA6ICEhdC5tb3VzZXdoZWVsLmVuYWJsZWQgJiYgKHcoXCJvZmZcIiksIHQubW91c2V3aGVlbC5lbmFibGVkID0gITEsICEwKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYShcImluaXRcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgIXQucGFyYW1zLm1vdXNld2hlZWwuZW5hYmxlZCAmJiB0LnBhcmFtcy5jc3NNb2RlICYmIHgoKSwgdC5wYXJhbXMubW91c2V3aGVlbC5lbmFibGVkICYmIGIoKVxyXG4gICAgICAgIH0pKSwgYShcImRlc3Ryb3lcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC5wYXJhbXMuY3NzTW9kZSAmJiBiKCksIHQubW91c2V3aGVlbC5lbmFibGVkICYmIHgoKVxyXG4gICAgICAgIH0pKSwgT2JqZWN0LmFzc2lnbih0Lm1vdXNld2hlZWwsIHtlbmFibGU6IGIsIGRpc2FibGU6IHh9KVxyXG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBsZXQge3N3aXBlcjogdCwgZXh0ZW5kUGFyYW1zOiBzLCBvbjogYSwgZW1pdDogaX0gPSBlO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByKGUpIHtcclxuICAgICAgICAgICAgbGV0IHM7XHJcbiAgICAgICAgICAgIHJldHVybiBlICYmIChzID0gZChlKSwgdC5wYXJhbXMudW5pcXVlTmF2RWxlbWVudHMgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSAmJiBzLmxlbmd0aCA+IDEgJiYgMSA9PT0gdC4kZWwuZmluZChlKS5sZW5ndGggJiYgKHMgPSB0LiRlbC5maW5kKGUpKSksIHNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG4oZSwgcykge1xyXG4gICAgICAgICAgICBjb25zdCBhID0gdC5wYXJhbXMubmF2aWdhdGlvbjtcclxuICAgICAgICAgICAgZSAmJiBlLmxlbmd0aCA+IDAgJiYgKGVbcyA/IFwiYWRkQ2xhc3NcIiA6IFwicmVtb3ZlQ2xhc3NcIl0oYS5kaXNhYmxlZENsYXNzKSwgZVswXSAmJiBcIkJVVFRPTlwiID09PSBlWzBdLnRhZ05hbWUgJiYgKGVbMF0uZGlzYWJsZWQgPSBzKSwgdC5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiB0LmVuYWJsZWQgJiYgZVt0LmlzTG9ja2VkID8gXCJhZGRDbGFzc1wiIDogXCJyZW1vdmVDbGFzc1wiXShhLmxvY2tDbGFzcykpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBsKCkge1xyXG4gICAgICAgICAgICBpZiAodC5wYXJhbXMubG9vcCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCB7JG5leHRFbDogZSwgJHByZXZFbDogc30gPSB0Lm5hdmlnYXRpb247XHJcbiAgICAgICAgICAgIG4ocywgdC5pc0JlZ2lubmluZyAmJiAhdC5wYXJhbXMucmV3aW5kKSwgbihlLCB0LmlzRW5kICYmICF0LnBhcmFtcy5yZXdpbmQpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBvKGUpIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpLCAoIXQuaXNCZWdpbm5pbmcgfHwgdC5wYXJhbXMubG9vcCB8fCB0LnBhcmFtcy5yZXdpbmQpICYmICh0LnNsaWRlUHJldigpLCBpKFwibmF2aWdhdGlvblByZXZcIikpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjKGUpIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpLCAoIXQuaXNFbmQgfHwgdC5wYXJhbXMubG9vcCB8fCB0LnBhcmFtcy5yZXdpbmQpICYmICh0LnNsaWRlTmV4dCgpLCBpKFwibmF2aWdhdGlvbk5leHRcIikpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBwKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdC5wYXJhbXMubmF2aWdhdGlvbjtcclxuICAgICAgICAgICAgaWYgKHQucGFyYW1zLm5hdmlnYXRpb24gPSBGKHQsIHQub3JpZ2luYWxQYXJhbXMubmF2aWdhdGlvbiwgdC5wYXJhbXMubmF2aWdhdGlvbiwge1xyXG4gICAgICAgICAgICAgICAgbmV4dEVsOiBcInN3aXBlci1idXR0b24tbmV4dFwiLFxyXG4gICAgICAgICAgICAgICAgcHJldkVsOiBcInN3aXBlci1idXR0b24tcHJldlwiXHJcbiAgICAgICAgICAgIH0pLCAhZS5uZXh0RWwgJiYgIWUucHJldkVsKSByZXR1cm47XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSByKGUubmV4dEVsKSwgYSA9IHIoZS5wcmV2RWwpO1xyXG4gICAgICAgICAgICBzICYmIHMubGVuZ3RoID4gMCAmJiBzLm9uKFwiY2xpY2tcIiwgYyksIGEgJiYgYS5sZW5ndGggPiAwICYmIGEub24oXCJjbGlja1wiLCBvKSwgT2JqZWN0LmFzc2lnbih0Lm5hdmlnYXRpb24sIHtcclxuICAgICAgICAgICAgICAgICRuZXh0RWw6IHMsXHJcbiAgICAgICAgICAgICAgICBuZXh0RWw6IHMgJiYgc1swXSxcclxuICAgICAgICAgICAgICAgICRwcmV2RWw6IGEsXHJcbiAgICAgICAgICAgICAgICBwcmV2RWw6IGEgJiYgYVswXVxyXG4gICAgICAgICAgICB9KSwgdC5lbmFibGVkIHx8IChzICYmIHMuYWRkQ2xhc3MoZS5sb2NrQ2xhc3MpLCBhICYmIGEuYWRkQ2xhc3MoZS5sb2NrQ2xhc3MpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdSgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyRuZXh0RWw6IGUsICRwcmV2RWw6IHN9ID0gdC5uYXZpZ2F0aW9uO1xyXG4gICAgICAgICAgICBlICYmIGUubGVuZ3RoICYmIChlLm9mZihcImNsaWNrXCIsIGMpLCBlLnJlbW92ZUNsYXNzKHQucGFyYW1zLm5hdmlnYXRpb24uZGlzYWJsZWRDbGFzcykpLCBzICYmIHMubGVuZ3RoICYmIChzLm9mZihcImNsaWNrXCIsIG8pLCBzLnJlbW92ZUNsYXNzKHQucGFyYW1zLm5hdmlnYXRpb24uZGlzYWJsZWRDbGFzcykpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzKHtcclxuICAgICAgICAgICAgbmF2aWdhdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgbmV4dEVsOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcHJldkVsOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgaGlkZU9uQ2xpY2s6ICExLFxyXG4gICAgICAgICAgICAgICAgZGlzYWJsZWRDbGFzczogXCJzd2lwZXItYnV0dG9uLWRpc2FibGVkXCIsXHJcbiAgICAgICAgICAgICAgICBoaWRkZW5DbGFzczogXCJzd2lwZXItYnV0dG9uLWhpZGRlblwiLFxyXG4gICAgICAgICAgICAgICAgbG9ja0NsYXNzOiBcInN3aXBlci1idXR0b24tbG9ja1wiLFxyXG4gICAgICAgICAgICAgICAgbmF2aWdhdGlvbkRpc2FibGVkQ2xhc3M6IFwic3dpcGVyLW5hdmlnYXRpb24tZGlzYWJsZWRcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksIHQubmF2aWdhdGlvbiA9IHtuZXh0RWw6IG51bGwsICRuZXh0RWw6IG51bGwsIHByZXZFbDogbnVsbCwgJHByZXZFbDogbnVsbH0sIGEoXCJpbml0XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgICExID09PSB0LnBhcmFtcy5uYXZpZ2F0aW9uLmVuYWJsZWQgPyBoKCkgOiAocCgpLCBsKCkpXHJcbiAgICAgICAgfSkpLCBhKFwidG9FZGdlIGZyb21FZGdlIGxvY2sgdW5sb2NrXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGwoKVxyXG4gICAgICAgIH0pKSwgYShcImRlc3Ryb3lcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdSgpXHJcbiAgICAgICAgfSkpLCBhKFwiZW5hYmxlIGRpc2FibGVcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyRuZXh0RWw6IGUsICRwcmV2RWw6IHN9ID0gdC5uYXZpZ2F0aW9uO1xyXG4gICAgICAgICAgICBlICYmIGVbdC5lbmFibGVkID8gXCJyZW1vdmVDbGFzc1wiIDogXCJhZGRDbGFzc1wiXSh0LnBhcmFtcy5uYXZpZ2F0aW9uLmxvY2tDbGFzcyksIHMgJiYgc1t0LmVuYWJsZWQgPyBcInJlbW92ZUNsYXNzXCIgOiBcImFkZENsYXNzXCJdKHQucGFyYW1zLm5hdmlnYXRpb24ubG9ja0NsYXNzKVxyXG4gICAgICAgIH0pKSwgYShcImNsaWNrXCIsICgoZSwgcykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7JG5leHRFbDogYSwgJHByZXZFbDogcn0gPSB0Lm5hdmlnYXRpb24sIG4gPSBzLnRhcmdldDtcclxuICAgICAgICAgICAgaWYgKHQucGFyYW1zLm5hdmlnYXRpb24uaGlkZU9uQ2xpY2sgJiYgIWQobikuaXMocikgJiYgIWQobikuaXMoYSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0LnBhZ2luYXRpb24gJiYgdC5wYXJhbXMucGFnaW5hdGlvbiAmJiB0LnBhcmFtcy5wYWdpbmF0aW9uLmNsaWNrYWJsZSAmJiAodC5wYWdpbmF0aW9uLmVsID09PSBuIHx8IHQucGFnaW5hdGlvbi5lbC5jb250YWlucyhuKSkpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGxldCBlO1xyXG4gICAgICAgICAgICAgICAgYSA/IGUgPSBhLmhhc0NsYXNzKHQucGFyYW1zLm5hdmlnYXRpb24uaGlkZGVuQ2xhc3MpIDogciAmJiAoZSA9IHIuaGFzQ2xhc3ModC5wYXJhbXMubmF2aWdhdGlvbi5oaWRkZW5DbGFzcykpLCBpKCEwID09PSBlID8gXCJuYXZpZ2F0aW9uU2hvd1wiIDogXCJuYXZpZ2F0aW9uSGlkZVwiKSwgYSAmJiBhLnRvZ2dsZUNsYXNzKHQucGFyYW1zLm5hdmlnYXRpb24uaGlkZGVuQ2xhc3MpLCByICYmIHIudG9nZ2xlQ2xhc3ModC5wYXJhbXMubmF2aWdhdGlvbi5oaWRkZW5DbGFzcylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBjb25zdCBoID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0LiRlbC5hZGRDbGFzcyh0LnBhcmFtcy5uYXZpZ2F0aW9uLm5hdmlnYXRpb25EaXNhYmxlZENsYXNzKSwgdSgpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHQubmF2aWdhdGlvbiwge1xyXG4gICAgICAgICAgICBlbmFibGU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHQuJGVsLnJlbW92ZUNsYXNzKHQucGFyYW1zLm5hdmlnYXRpb24ubmF2aWdhdGlvbkRpc2FibGVkQ2xhc3MpLCBwKCksIGwoKVxyXG4gICAgICAgICAgICB9LCBkaXNhYmxlOiBoLCB1cGRhdGU6IGwsIGluaXQ6IHAsIGRlc3Ryb3k6IHVcclxuICAgICAgICB9KVxyXG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBsZXQge3N3aXBlcjogdCwgZXh0ZW5kUGFyYW1zOiBzLCBvbjogYSwgZW1pdDogaX0gPSBlO1xyXG4gICAgICAgIGNvbnN0IHIgPSBcInN3aXBlci1wYWdpbmF0aW9uXCI7XHJcbiAgICAgICAgbGV0IG47XHJcbiAgICAgICAgcyh7XHJcbiAgICAgICAgICAgIHBhZ2luYXRpb246IHtcclxuICAgICAgICAgICAgICAgIGVsOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgYnVsbGV0RWxlbWVudDogXCJzcGFuXCIsXHJcbiAgICAgICAgICAgICAgICBjbGlja2FibGU6ICExLFxyXG4gICAgICAgICAgICAgICAgaGlkZU9uQ2xpY2s6ICExLFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyQnVsbGV0OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyUHJvZ3Jlc3NiYXI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICByZW5kZXJGcmFjdGlvbjogbnVsbCxcclxuICAgICAgICAgICAgICAgIHJlbmRlckN1c3RvbTogbnVsbCxcclxuICAgICAgICAgICAgICAgIHByb2dyZXNzYmFyT3Bwb3NpdGU6ICExLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJidWxsZXRzXCIsXHJcbiAgICAgICAgICAgICAgICBkeW5hbWljQnVsbGV0czogITEsXHJcbiAgICAgICAgICAgICAgICBkeW5hbWljTWFpbkJ1bGxldHM6IDEsXHJcbiAgICAgICAgICAgICAgICBmb3JtYXRGcmFjdGlvbkN1cnJlbnQ6IGUgPT4gZSxcclxuICAgICAgICAgICAgICAgIGZvcm1hdEZyYWN0aW9uVG90YWw6IGUgPT4gZSxcclxuICAgICAgICAgICAgICAgIGJ1bGxldENsYXNzOiBgJHtyfS1idWxsZXRgLFxyXG4gICAgICAgICAgICAgICAgYnVsbGV0QWN0aXZlQ2xhc3M6IGAke3J9LWJ1bGxldC1hY3RpdmVgLFxyXG4gICAgICAgICAgICAgICAgbW9kaWZpZXJDbGFzczogYCR7cn0tYCxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRDbGFzczogYCR7cn0tY3VycmVudGAsXHJcbiAgICAgICAgICAgICAgICB0b3RhbENsYXNzOiBgJHtyfS10b3RhbGAsXHJcbiAgICAgICAgICAgICAgICBoaWRkZW5DbGFzczogYCR7cn0taGlkZGVuYCxcclxuICAgICAgICAgICAgICAgIHByb2dyZXNzYmFyRmlsbENsYXNzOiBgJHtyfS1wcm9ncmVzc2Jhci1maWxsYCxcclxuICAgICAgICAgICAgICAgIHByb2dyZXNzYmFyT3Bwb3NpdGVDbGFzczogYCR7cn0tcHJvZ3Jlc3NiYXItb3Bwb3NpdGVgLFxyXG4gICAgICAgICAgICAgICAgY2xpY2thYmxlQ2xhc3M6IGAke3J9LWNsaWNrYWJsZWAsXHJcbiAgICAgICAgICAgICAgICBsb2NrQ2xhc3M6IGAke3J9LWxvY2tgLFxyXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbENsYXNzOiBgJHtyfS1ob3Jpem9udGFsYCxcclxuICAgICAgICAgICAgICAgIHZlcnRpY2FsQ2xhc3M6IGAke3J9LXZlcnRpY2FsYCxcclxuICAgICAgICAgICAgICAgIHBhZ2luYXRpb25EaXNhYmxlZENsYXNzOiBgJHtyfS1kaXNhYmxlZGBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLCB0LnBhZ2luYXRpb24gPSB7ZWw6IG51bGwsICRlbDogbnVsbCwgYnVsbGV0czogW119O1xyXG4gICAgICAgIGxldCBsID0gMDtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbygpIHtcclxuICAgICAgICAgICAgcmV0dXJuICF0LnBhcmFtcy5wYWdpbmF0aW9uLmVsIHx8ICF0LnBhZ2luYXRpb24uZWwgfHwgIXQucGFnaW5hdGlvbi4kZWwgfHwgMCA9PT0gdC5wYWdpbmF0aW9uLiRlbC5sZW5ndGhcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGMoZSwgcykge1xyXG4gICAgICAgICAgICBjb25zdCB7YnVsbGV0QWN0aXZlQ2xhc3M6IGF9ID0gdC5wYXJhbXMucGFnaW5hdGlvbjtcclxuICAgICAgICAgICAgZVtzXSgpLmFkZENsYXNzKGAke2F9LSR7c31gKVtzXSgpLmFkZENsYXNzKGAke2F9LSR7c30tJHtzfWApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBwKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdC5ydGwsIHMgPSB0LnBhcmFtcy5wYWdpbmF0aW9uO1xyXG4gICAgICAgICAgICBpZiAobygpKSByZXR1cm47XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSB0LnZpcnR1YWwgJiYgdC5wYXJhbXMudmlydHVhbC5lbmFibGVkID8gdC52aXJ0dWFsLnNsaWRlcy5sZW5ndGggOiB0LnNsaWRlcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICByID0gdC5wYWdpbmF0aW9uLiRlbDtcclxuICAgICAgICAgICAgbGV0IHA7XHJcbiAgICAgICAgICAgIGNvbnN0IHUgPSB0LnBhcmFtcy5sb29wID8gTWF0aC5jZWlsKChhIC0gMiAqIHQubG9vcGVkU2xpZGVzKSAvIHQucGFyYW1zLnNsaWRlc1Blckdyb3VwKSA6IHQuc25hcEdyaWQubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAodC5wYXJhbXMubG9vcCA/IChwID0gTWF0aC5jZWlsKCh0LmFjdGl2ZUluZGV4IC0gdC5sb29wZWRTbGlkZXMpIC8gdC5wYXJhbXMuc2xpZGVzUGVyR3JvdXApLCBwID4gYSAtIDEgLSAyICogdC5sb29wZWRTbGlkZXMgJiYgKHAgLT0gYSAtIDIgKiB0Lmxvb3BlZFNsaWRlcyksIHAgPiB1IC0gMSAmJiAocCAtPSB1KSwgcCA8IDAgJiYgXCJidWxsZXRzXCIgIT09IHQucGFyYW1zLnBhZ2luYXRpb25UeXBlICYmIChwID0gdSArIHApKSA6IHAgPSB2b2lkIDAgIT09IHQuc25hcEluZGV4ID8gdC5zbmFwSW5kZXggOiB0LmFjdGl2ZUluZGV4IHx8IDAsIFwiYnVsbGV0c1wiID09PSBzLnR5cGUgJiYgdC5wYWdpbmF0aW9uLmJ1bGxldHMgJiYgdC5wYWdpbmF0aW9uLmJ1bGxldHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IHQucGFnaW5hdGlvbi5idWxsZXRzO1xyXG4gICAgICAgICAgICAgICAgbGV0IGksIG8sIHU7XHJcbiAgICAgICAgICAgICAgICBpZiAocy5keW5hbWljQnVsbGV0cyAmJiAobiA9IGEuZXEoMClbdC5pc0hvcml6b250YWwoKSA/IFwib3V0ZXJXaWR0aFwiIDogXCJvdXRlckhlaWdodFwiXSghMCksIHIuY3NzKHQuaXNIb3Jpem9udGFsKCkgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiLCBuICogKHMuZHluYW1pY01haW5CdWxsZXRzICsgNCkgKyBcInB4XCIpLCBzLmR5bmFtaWNNYWluQnVsbGV0cyA+IDEgJiYgdm9pZCAwICE9PSB0LnByZXZpb3VzSW5kZXggJiYgKGwgKz0gcCAtICh0LnByZXZpb3VzSW5kZXggLSB0Lmxvb3BlZFNsaWRlcyB8fCAwKSwgbCA+IHMuZHluYW1pY01haW5CdWxsZXRzIC0gMSA/IGwgPSBzLmR5bmFtaWNNYWluQnVsbGV0cyAtIDEgOiBsIDwgMCAmJiAobCA9IDApKSwgaSA9IE1hdGgubWF4KHAgLSBsLCAwKSwgbyA9IGkgKyAoTWF0aC5taW4oYS5sZW5ndGgsIHMuZHluYW1pY01haW5CdWxsZXRzKSAtIDEpLCB1ID0gKG8gKyBpKSAvIDIpLCBhLnJlbW92ZUNsYXNzKFtcIlwiLCBcIi1uZXh0XCIsIFwiLW5leHQtbmV4dFwiLCBcIi1wcmV2XCIsIFwiLXByZXYtcHJldlwiLCBcIi1tYWluXCJdLm1hcCgoZSA9PiBgJHtzLmJ1bGxldEFjdGl2ZUNsYXNzfSR7ZX1gKSkuam9pbihcIiBcIikpLCByLmxlbmd0aCA+IDEpIGEuZWFjaCgoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGQoZSksIGEgPSB0LmluZGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9PT0gcCAmJiB0LmFkZENsYXNzKHMuYnVsbGV0QWN0aXZlQ2xhc3MpLCBzLmR5bmFtaWNCdWxsZXRzICYmIChhID49IGkgJiYgYSA8PSBvICYmIHQuYWRkQ2xhc3MoYCR7cy5idWxsZXRBY3RpdmVDbGFzc30tbWFpbmApLCBhID09PSBpICYmIGModCwgXCJwcmV2XCIpLCBhID09PSBvICYmIGModCwgXCJuZXh0XCIpKVxyXG4gICAgICAgICAgICAgICAgfSkpOyBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gYS5lcShwKSwgciA9IGUuaW5kZXgoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5hZGRDbGFzcyhzLmJ1bGxldEFjdGl2ZUNsYXNzKSwgcy5keW5hbWljQnVsbGV0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gYS5lcShpKSwgbiA9IGEuZXEobyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGUgPSBpOyBlIDw9IG87IGUgKz0gMSkgYS5lcShlKS5hZGRDbGFzcyhgJHtzLmJ1bGxldEFjdGl2ZUNsYXNzfS1tYWluYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0LnBhcmFtcy5sb29wKSBpZiAociA+PSBhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZSA9IHMuZHluYW1pY01haW5CdWxsZXRzOyBlID49IDA7IGUgLT0gMSkgYS5lcShhLmxlbmd0aCAtIGUpLmFkZENsYXNzKGAke3MuYnVsbGV0QWN0aXZlQ2xhc3N9LW1haW5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuZXEoYS5sZW5ndGggLSBzLmR5bmFtaWNNYWluQnVsbGV0cyAtIDEpLmFkZENsYXNzKGAke3MuYnVsbGV0QWN0aXZlQ2xhc3N9LXByZXZgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgYyhlLCBcInByZXZcIiksIGMobiwgXCJuZXh0XCIpOyBlbHNlIGMoZSwgXCJwcmV2XCIpLCBjKG4sIFwibmV4dFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzLmR5bmFtaWNCdWxsZXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaSA9IE1hdGgubWluKGEubGVuZ3RoLCBzLmR5bmFtaWNNYWluQnVsbGV0cyArIDQpLCByID0gKG4gKiBpIC0gbikgLyAyIC0gdSAqIG4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBlID8gXCJyaWdodFwiIDogXCJsZWZ0XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5jc3ModC5pc0hvcml6b250YWwoKSA/IGwgOiBcInRvcFwiLCBgJHtyfXB4YClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoXCJmcmFjdGlvblwiID09PSBzLnR5cGUgJiYgKHIuZmluZChVKHMuY3VycmVudENsYXNzKSkudGV4dChzLmZvcm1hdEZyYWN0aW9uQ3VycmVudChwICsgMSkpLCByLmZpbmQoVShzLnRvdGFsQ2xhc3MpKS50ZXh0KHMuZm9ybWF0RnJhY3Rpb25Ub3RhbCh1KSkpLCBcInByb2dyZXNzYmFyXCIgPT09IHMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGU7XHJcbiAgICAgICAgICAgICAgICBlID0gcy5wcm9ncmVzc2Jhck9wcG9zaXRlID8gdC5pc0hvcml6b250YWwoKSA/IFwidmVydGljYWxcIiA6IFwiaG9yaXpvbnRhbFwiIDogdC5pc0hvcml6b250YWwoKSA/IFwiaG9yaXpvbnRhbFwiIDogXCJ2ZXJ0aWNhbFwiO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IChwICsgMSkgLyB1O1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAxLCBuID0gMTtcclxuICAgICAgICAgICAgICAgIFwiaG9yaXpvbnRhbFwiID09PSBlID8gaSA9IGEgOiBuID0gYSwgci5maW5kKFUocy5wcm9ncmVzc2JhckZpbGxDbGFzcykpLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlWCgke2l9KSBzY2FsZVkoJHtufSlgKS50cmFuc2l0aW9uKHQucGFyYW1zLnNwZWVkKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFwiY3VzdG9tXCIgPT09IHMudHlwZSAmJiBzLnJlbmRlckN1c3RvbSA/IChyLmh0bWwocy5yZW5kZXJDdXN0b20odCwgcCArIDEsIHUpKSwgaShcInBhZ2luYXRpb25SZW5kZXJcIiwgclswXSkpIDogaShcInBhZ2luYXRpb25VcGRhdGVcIiwgclswXSksIHQucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgdC5lbmFibGVkICYmIHJbdC5pc0xvY2tlZCA/IFwiYWRkQ2xhc3NcIiA6IFwicmVtb3ZlQ2xhc3NcIl0ocy5sb2NrQ2xhc3MpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB1KCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdC5wYXJhbXMucGFnaW5hdGlvbjtcclxuICAgICAgICAgICAgaWYgKG8oKSkgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCBzID0gdC52aXJ0dWFsICYmIHQucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCA/IHQudmlydHVhbC5zbGlkZXMubGVuZ3RoIDogdC5zbGlkZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgYSA9IHQucGFnaW5hdGlvbi4kZWw7XHJcbiAgICAgICAgICAgIGxldCByID0gXCJcIjtcclxuICAgICAgICAgICAgaWYgKFwiYnVsbGV0c1wiID09PSBlLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gdC5wYXJhbXMubG9vcCA/IE1hdGguY2VpbCgocyAtIDIgKiB0Lmxvb3BlZFNsaWRlcykgLyB0LnBhcmFtcy5zbGlkZXNQZXJHcm91cCkgOiB0LnNuYXBHcmlkLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHQucGFyYW1zLmZyZWVNb2RlICYmIHQucGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQgJiYgIXQucGFyYW1zLmxvb3AgJiYgaSA+IHMgJiYgKGkgPSBzKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgaTsgcyArPSAxKSBlLnJlbmRlckJ1bGxldCA/IHIgKz0gZS5yZW5kZXJCdWxsZXQuY2FsbCh0LCBzLCBlLmJ1bGxldENsYXNzKSA6IHIgKz0gYDwke2UuYnVsbGV0RWxlbWVudH0gY2xhc3M9XCIke2UuYnVsbGV0Q2xhc3N9XCI+PC8ke2UuYnVsbGV0RWxlbWVudH0+YDtcclxuICAgICAgICAgICAgICAgIGEuaHRtbChyKSwgdC5wYWdpbmF0aW9uLmJ1bGxldHMgPSBhLmZpbmQoVShlLmJ1bGxldENsYXNzKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcImZyYWN0aW9uXCIgPT09IGUudHlwZSAmJiAociA9IGUucmVuZGVyRnJhY3Rpb24gPyBlLnJlbmRlckZyYWN0aW9uLmNhbGwodCwgZS5jdXJyZW50Q2xhc3MsIGUudG90YWxDbGFzcykgOiBgPHNwYW4gY2xhc3M9XCIke2UuY3VycmVudENsYXNzfVwiPjwvc3Bhbj4gLyA8c3BhbiBjbGFzcz1cIiR7ZS50b3RhbENsYXNzfVwiPjwvc3Bhbj5gLCBhLmh0bWwocikpLCBcInByb2dyZXNzYmFyXCIgPT09IGUudHlwZSAmJiAociA9IGUucmVuZGVyUHJvZ3Jlc3NiYXIgPyBlLnJlbmRlclByb2dyZXNzYmFyLmNhbGwodCwgZS5wcm9ncmVzc2JhckZpbGxDbGFzcykgOiBgPHNwYW4gY2xhc3M9XCIke2UucHJvZ3Jlc3NiYXJGaWxsQ2xhc3N9XCI+PC9zcGFuPmAsIGEuaHRtbChyKSksIFwiY3VzdG9tXCIgIT09IGUudHlwZSAmJiBpKFwicGFnaW5hdGlvblJlbmRlclwiLCB0LnBhZ2luYXRpb24uJGVsWzBdKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaCgpIHtcclxuICAgICAgICAgICAgdC5wYXJhbXMucGFnaW5hdGlvbiA9IEYodCwgdC5vcmlnaW5hbFBhcmFtcy5wYWdpbmF0aW9uLCB0LnBhcmFtcy5wYWdpbmF0aW9uLCB7ZWw6IFwic3dpcGVyLXBhZ2luYXRpb25cIn0pO1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdC5wYXJhbXMucGFnaW5hdGlvbjtcclxuICAgICAgICAgICAgaWYgKCFlLmVsKSByZXR1cm47XHJcbiAgICAgICAgICAgIGxldCBzID0gZChlLmVsKTtcclxuICAgICAgICAgICAgMCAhPT0gcy5sZW5ndGggJiYgKHQucGFyYW1zLnVuaXF1ZU5hdkVsZW1lbnRzICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUuZWwgJiYgcy5sZW5ndGggPiAxICYmIChzID0gdC4kZWwuZmluZChlLmVsKSwgcy5sZW5ndGggPiAxICYmIChzID0gcy5maWx0ZXIoKGUgPT4gZChlKS5wYXJlbnRzKFwiLnN3aXBlclwiKVswXSA9PT0gdC5lbCkpKSksIFwiYnVsbGV0c1wiID09PSBlLnR5cGUgJiYgZS5jbGlja2FibGUgJiYgcy5hZGRDbGFzcyhlLmNsaWNrYWJsZUNsYXNzKSwgcy5hZGRDbGFzcyhlLm1vZGlmaWVyQ2xhc3MgKyBlLnR5cGUpLCBzLmFkZENsYXNzKHQuaXNIb3Jpem9udGFsKCkgPyBlLmhvcml6b250YWxDbGFzcyA6IGUudmVydGljYWxDbGFzcyksIFwiYnVsbGV0c1wiID09PSBlLnR5cGUgJiYgZS5keW5hbWljQnVsbGV0cyAmJiAocy5hZGRDbGFzcyhgJHtlLm1vZGlmaWVyQ2xhc3N9JHtlLnR5cGV9LWR5bmFtaWNgKSwgbCA9IDAsIGUuZHluYW1pY01haW5CdWxsZXRzIDwgMSAmJiAoZS5keW5hbWljTWFpbkJ1bGxldHMgPSAxKSksIFwicHJvZ3Jlc3NiYXJcIiA9PT0gZS50eXBlICYmIGUucHJvZ3Jlc3NiYXJPcHBvc2l0ZSAmJiBzLmFkZENsYXNzKGUucHJvZ3Jlc3NiYXJPcHBvc2l0ZUNsYXNzKSwgZS5jbGlja2FibGUgJiYgcy5vbihcImNsaWNrXCIsIFUoZS5idWxsZXRDbGFzcyksIChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHMgPSBkKHRoaXMpLmluZGV4KCkgKiB0LnBhcmFtcy5zbGlkZXNQZXJHcm91cDtcclxuICAgICAgICAgICAgICAgIHQucGFyYW1zLmxvb3AgJiYgKHMgKz0gdC5sb29wZWRTbGlkZXMpLCB0LnNsaWRlVG8ocylcclxuICAgICAgICAgICAgfSkpLCBPYmplY3QuYXNzaWduKHQucGFnaW5hdGlvbiwgeyRlbDogcywgZWw6IHNbMF19KSwgdC5lbmFibGVkIHx8IHMuYWRkQ2xhc3MoZS5sb2NrQ2xhc3MpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbSgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHQucGFyYW1zLnBhZ2luYXRpb247XHJcbiAgICAgICAgICAgIGlmIChvKCkpIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgcyA9IHQucGFnaW5hdGlvbi4kZWw7XHJcbiAgICAgICAgICAgIHMucmVtb3ZlQ2xhc3MoZS5oaWRkZW5DbGFzcyksIHMucmVtb3ZlQ2xhc3MoZS5tb2RpZmllckNsYXNzICsgZS50eXBlKSwgcy5yZW1vdmVDbGFzcyh0LmlzSG9yaXpvbnRhbCgpID8gZS5ob3Jpem9udGFsQ2xhc3MgOiBlLnZlcnRpY2FsQ2xhc3MpLCB0LnBhZ2luYXRpb24uYnVsbGV0cyAmJiB0LnBhZ2luYXRpb24uYnVsbGV0cy5yZW1vdmVDbGFzcyAmJiB0LnBhZ2luYXRpb24uYnVsbGV0cy5yZW1vdmVDbGFzcyhlLmJ1bGxldEFjdGl2ZUNsYXNzKSwgZS5jbGlja2FibGUgJiYgcy5vZmYoXCJjbGlja1wiLCBVKGUuYnVsbGV0Q2xhc3MpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYShcImluaXRcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgITEgPT09IHQucGFyYW1zLnBhZ2luYXRpb24uZW5hYmxlZCA/IGYoKSA6IChoKCksIHUoKSwgcCgpKVxyXG4gICAgICAgIH0pKSwgYShcImFjdGl2ZUluZGV4Q2hhbmdlXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgICh0LnBhcmFtcy5sb29wIHx8IHZvaWQgMCA9PT0gdC5zbmFwSW5kZXgpICYmIHAoKVxyXG4gICAgICAgIH0pKSwgYShcInNuYXBJbmRleENoYW5nZVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICB0LnBhcmFtcy5sb29wIHx8IHAoKVxyXG4gICAgICAgIH0pKSwgYShcInNsaWRlc0xlbmd0aENoYW5nZVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICB0LnBhcmFtcy5sb29wICYmICh1KCksIHAoKSlcclxuICAgICAgICB9KSksIGEoXCJzbmFwR3JpZExlbmd0aENoYW5nZVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICB0LnBhcmFtcy5sb29wIHx8ICh1KCksIHAoKSlcclxuICAgICAgICB9KSksIGEoXCJkZXN0cm95XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIG0oKVxyXG4gICAgICAgIH0pKSwgYShcImVuYWJsZSBkaXNhYmxlXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHskZWw6IGV9ID0gdC5wYWdpbmF0aW9uO1xyXG4gICAgICAgICAgICBlICYmIGVbdC5lbmFibGVkID8gXCJyZW1vdmVDbGFzc1wiIDogXCJhZGRDbGFzc1wiXSh0LnBhcmFtcy5wYWdpbmF0aW9uLmxvY2tDbGFzcylcclxuICAgICAgICB9KSksIGEoXCJsb2NrIHVubG9ja1wiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBwKClcclxuICAgICAgICB9KSksIGEoXCJjbGlja1wiLCAoKGUsIHMpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYSA9IHMudGFyZ2V0LCB7JGVsOiByfSA9IHQucGFnaW5hdGlvbjtcclxuICAgICAgICAgICAgaWYgKHQucGFyYW1zLnBhZ2luYXRpb24uZWwgJiYgdC5wYXJhbXMucGFnaW5hdGlvbi5oaWRlT25DbGljayAmJiByICYmIHIubGVuZ3RoID4gMCAmJiAhZChhKS5oYXNDbGFzcyh0LnBhcmFtcy5wYWdpbmF0aW9uLmJ1bGxldENsYXNzKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHQubmF2aWdhdGlvbiAmJiAodC5uYXZpZ2F0aW9uLm5leHRFbCAmJiBhID09PSB0Lm5hdmlnYXRpb24ubmV4dEVsIHx8IHQubmF2aWdhdGlvbi5wcmV2RWwgJiYgYSA9PT0gdC5uYXZpZ2F0aW9uLnByZXZFbCkpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSByLmhhc0NsYXNzKHQucGFyYW1zLnBhZ2luYXRpb24uaGlkZGVuQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaSghMCA9PT0gZSA/IFwicGFnaW5hdGlvblNob3dcIiA6IFwicGFnaW5hdGlvbkhpZGVcIiksIHIudG9nZ2xlQ2xhc3ModC5wYXJhbXMucGFnaW5hdGlvbi5oaWRkZW5DbGFzcylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBjb25zdCBmID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0LiRlbC5hZGRDbGFzcyh0LnBhcmFtcy5wYWdpbmF0aW9uLnBhZ2luYXRpb25EaXNhYmxlZENsYXNzKSwgdC5wYWdpbmF0aW9uLiRlbCAmJiB0LnBhZ2luYXRpb24uJGVsLmFkZENsYXNzKHQucGFyYW1zLnBhZ2luYXRpb24ucGFnaW5hdGlvbkRpc2FibGVkQ2xhc3MpLCBtKClcclxuICAgICAgICB9O1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24odC5wYWdpbmF0aW9uLCB7XHJcbiAgICAgICAgICAgIGVuYWJsZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdC4kZWwucmVtb3ZlQ2xhc3ModC5wYXJhbXMucGFnaW5hdGlvbi5wYWdpbmF0aW9uRGlzYWJsZWRDbGFzcyksIHQucGFnaW5hdGlvbi4kZWwgJiYgdC5wYWdpbmF0aW9uLiRlbC5yZW1vdmVDbGFzcyh0LnBhcmFtcy5wYWdpbmF0aW9uLnBhZ2luYXRpb25EaXNhYmxlZENsYXNzKSwgaCgpLCB1KCksIHAoKVxyXG4gICAgICAgICAgICB9LCBkaXNhYmxlOiBmLCByZW5kZXI6IHUsIHVwZGF0ZTogcCwgaW5pdDogaCwgZGVzdHJveTogbVxyXG4gICAgICAgIH0pXHJcbiAgICB9LCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGxldCB7c3dpcGVyOiB0LCBleHRlbmRQYXJhbXM6IHMsIG9uOiBpLCBlbWl0OiByfSA9IGU7XHJcbiAgICAgICAgY29uc3QgbiA9IGEoKTtcclxuICAgICAgICBsZXQgbCwgbywgYywgdSwgaCA9ICExLCBtID0gbnVsbCwgZiA9IG51bGw7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGcoKSB7XHJcbiAgICAgICAgICAgIGlmICghdC5wYXJhbXMuc2Nyb2xsYmFyLmVsIHx8ICF0LnNjcm9sbGJhci5lbCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCB7c2Nyb2xsYmFyOiBlLCBydGxUcmFuc2xhdGU6IHMsIHByb2dyZXNzOiBhfSA9IHQsIHskZHJhZ0VsOiBpLCAkZWw6IHJ9ID0gZSwgbiA9IHQucGFyYW1zLnNjcm9sbGJhcjtcclxuICAgICAgICAgICAgbGV0IGwgPSBvLCBkID0gKGMgLSBvKSAqIGE7XHJcbiAgICAgICAgICAgIHMgPyAoZCA9IC1kLCBkID4gMCA/IChsID0gbyAtIGQsIGQgPSAwKSA6IC1kICsgbyA+IGMgJiYgKGwgPSBjICsgZCkpIDogZCA8IDAgPyAobCA9IG8gKyBkLCBkID0gMCkgOiBkICsgbyA+IGMgJiYgKGwgPSBjIC0gZCksIHQuaXNIb3Jpem9udGFsKCkgPyAoaS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7ZH1weCwgMCwgMClgKSwgaVswXS5zdHlsZS53aWR0aCA9IGAke2x9cHhgKSA6IChpLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoMHB4LCAke2R9cHgsIDApYCksIGlbMF0uc3R5bGUuaGVpZ2h0ID0gYCR7bH1weGApLCBuLmhpZGUgJiYgKGNsZWFyVGltZW91dChtKSwgclswXS5zdHlsZS5vcGFjaXR5ID0gMSwgbSA9IHNldFRpbWVvdXQoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJbMF0uc3R5bGUub3BhY2l0eSA9IDAsIHIudHJhbnNpdGlvbig0MDApXHJcbiAgICAgICAgICAgIH0pLCAxZTMpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdigpIHtcclxuICAgICAgICAgICAgaWYgKCF0LnBhcmFtcy5zY3JvbGxiYXIuZWwgfHwgIXQuc2Nyb2xsYmFyLmVsKSByZXR1cm47XHJcbiAgICAgICAgICAgIGNvbnN0IHtzY3JvbGxiYXI6IGV9ID0gdCwgeyRkcmFnRWw6IHMsICRlbDogYX0gPSBlO1xyXG4gICAgICAgICAgICBzWzBdLnN0eWxlLndpZHRoID0gXCJcIiwgc1swXS5zdHlsZS5oZWlnaHQgPSBcIlwiLCBjID0gdC5pc0hvcml6b250YWwoKSA/IGFbMF0ub2Zmc2V0V2lkdGggOiBhWzBdLm9mZnNldEhlaWdodCwgdSA9IHQuc2l6ZSAvICh0LnZpcnR1YWxTaXplICsgdC5wYXJhbXMuc2xpZGVzT2Zmc2V0QmVmb3JlIC0gKHQucGFyYW1zLmNlbnRlcmVkU2xpZGVzID8gdC5zbmFwR3JpZFswXSA6IDApKSwgbyA9IFwiYXV0b1wiID09PSB0LnBhcmFtcy5zY3JvbGxiYXIuZHJhZ1NpemUgPyBjICogdSA6IHBhcnNlSW50KHQucGFyYW1zLnNjcm9sbGJhci5kcmFnU2l6ZSwgMTApLCB0LmlzSG9yaXpvbnRhbCgpID8gc1swXS5zdHlsZS53aWR0aCA9IGAke299cHhgIDogc1swXS5zdHlsZS5oZWlnaHQgPSBgJHtvfXB4YCwgYVswXS5zdHlsZS5kaXNwbGF5ID0gdSA+PSAxID8gXCJub25lXCIgOiBcIlwiLCB0LnBhcmFtcy5zY3JvbGxiYXIuaGlkZSAmJiAoYVswXS5zdHlsZS5vcGFjaXR5ID0gMCksIHQucGFyYW1zLndhdGNoT3ZlcmZsb3cgJiYgdC5lbmFibGVkICYmIGUuJGVsW3QuaXNMb2NrZWQgPyBcImFkZENsYXNzXCIgOiBcInJlbW92ZUNsYXNzXCJdKHQucGFyYW1zLnNjcm9sbGJhci5sb2NrQ2xhc3MpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB3KGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHQuaXNIb3Jpem9udGFsKCkgPyBcInRvdWNoc3RhcnRcIiA9PT0gZS50eXBlIHx8IFwidG91Y2htb3ZlXCIgPT09IGUudHlwZSA/IGUudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRYIDogZS5jbGllbnRYIDogXCJ0b3VjaHN0YXJ0XCIgPT09IGUudHlwZSB8fCBcInRvdWNobW92ZVwiID09PSBlLnR5cGUgPyBlLnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WSA6IGUuY2xpZW50WVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYihlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHtzY3JvbGxiYXI6IHMsIHJ0bFRyYW5zbGF0ZTogYX0gPSB0LCB7JGVsOiBpfSA9IHM7XHJcbiAgICAgICAgICAgIGxldCByO1xyXG4gICAgICAgICAgICByID0gKHcoZSkgLSBpLm9mZnNldCgpW3QuaXNIb3Jpem9udGFsKCkgPyBcImxlZnRcIiA6IFwidG9wXCJdIC0gKG51bGwgIT09IGwgPyBsIDogbyAvIDIpKSAvIChjIC0gbyksIHIgPSBNYXRoLm1heChNYXRoLm1pbihyLCAxKSwgMCksIGEgJiYgKHIgPSAxIC0gcik7XHJcbiAgICAgICAgICAgIGNvbnN0IG4gPSB0Lm1pblRyYW5zbGF0ZSgpICsgKHQubWF4VHJhbnNsYXRlKCkgLSB0Lm1pblRyYW5zbGF0ZSgpKSAqIHI7XHJcbiAgICAgICAgICAgIHQudXBkYXRlUHJvZ3Jlc3MobiksIHQuc2V0VHJhbnNsYXRlKG4pLCB0LnVwZGF0ZUFjdGl2ZUluZGV4KCksIHQudXBkYXRlU2xpZGVzQ2xhc3NlcygpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB4KGUpIHtcclxuICAgICAgICAgICAgY29uc3QgcyA9IHQucGFyYW1zLnNjcm9sbGJhciwge3Njcm9sbGJhcjogYSwgJHdyYXBwZXJFbDogaX0gPSB0LCB7JGVsOiBuLCAkZHJhZ0VsOiBvfSA9IGE7XHJcbiAgICAgICAgICAgIGggPSAhMCwgbCA9IGUudGFyZ2V0ID09PSBvWzBdIHx8IGUudGFyZ2V0ID09PSBvID8gdyhlKSAtIGUudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW3QuaXNIb3Jpem9udGFsKCkgPyBcImxlZnRcIiA6IFwidG9wXCJdIDogbnVsbCwgZS5wcmV2ZW50RGVmYXVsdCgpLCBlLnN0b3BQcm9wYWdhdGlvbigpLCBpLnRyYW5zaXRpb24oMTAwKSwgby50cmFuc2l0aW9uKDEwMCksIGIoZSksIGNsZWFyVGltZW91dChmKSwgbi50cmFuc2l0aW9uKDApLCBzLmhpZGUgJiYgbi5jc3MoXCJvcGFjaXR5XCIsIDEpLCB0LnBhcmFtcy5jc3NNb2RlICYmIHQuJHdyYXBwZXJFbC5jc3MoXCJzY3JvbGwtc25hcC10eXBlXCIsIFwibm9uZVwiKSwgcihcInNjcm9sbGJhckRyYWdTdGFydFwiLCBlKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24geShlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHtzY3JvbGxiYXI6IHMsICR3cmFwcGVyRWw6IGF9ID0gdCwgeyRlbDogaSwgJGRyYWdFbDogbn0gPSBzO1xyXG4gICAgICAgICAgICBoICYmIChlLnByZXZlbnREZWZhdWx0ID8gZS5wcmV2ZW50RGVmYXVsdCgpIDogZS5yZXR1cm5WYWx1ZSA9ICExLCBiKGUpLCBhLnRyYW5zaXRpb24oMCksIGkudHJhbnNpdGlvbigwKSwgbi50cmFuc2l0aW9uKDApLCByKFwic2Nyb2xsYmFyRHJhZ01vdmVcIiwgZSkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBFKGUpIHtcclxuICAgICAgICAgICAgY29uc3QgcyA9IHQucGFyYW1zLnNjcm9sbGJhciwge3Njcm9sbGJhcjogYSwgJHdyYXBwZXJFbDogaX0gPSB0LCB7JGVsOiBufSA9IGE7XHJcbiAgICAgICAgICAgIGggJiYgKGggPSAhMSwgdC5wYXJhbXMuY3NzTW9kZSAmJiAodC4kd3JhcHBlckVsLmNzcyhcInNjcm9sbC1zbmFwLXR5cGVcIiwgXCJcIiksIGkudHJhbnNpdGlvbihcIlwiKSksIHMuaGlkZSAmJiAoY2xlYXJUaW1lb3V0KGYpLCBmID0gcCgoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbi5jc3MoXCJvcGFjaXR5XCIsIDApLCBuLnRyYW5zaXRpb24oNDAwKVxyXG4gICAgICAgICAgICB9KSwgMWUzKSksIHIoXCJzY3JvbGxiYXJEcmFnRW5kXCIsIGUpLCBzLnNuYXBPblJlbGVhc2UgJiYgdC5zbGlkZVRvQ2xvc2VzdCgpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gQyhlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHtzY3JvbGxiYXI6IHMsIHRvdWNoRXZlbnRzVG91Y2g6IGEsIHRvdWNoRXZlbnRzRGVza3RvcDogaSwgcGFyYW1zOiByLCBzdXBwb3J0OiBsfSA9IHQsIG8gPSBzLiRlbDtcclxuICAgICAgICAgICAgaWYgKCFvKSByZXR1cm47XHJcbiAgICAgICAgICAgIGNvbnN0IGQgPSBvWzBdLCBjID0gISghbC5wYXNzaXZlTGlzdGVuZXIgfHwgIXIucGFzc2l2ZUxpc3RlbmVycykgJiYge3Bhc3NpdmU6ICExLCBjYXB0dXJlOiAhMX0sXHJcbiAgICAgICAgICAgICAgICBwID0gISghbC5wYXNzaXZlTGlzdGVuZXIgfHwgIXIucGFzc2l2ZUxpc3RlbmVycykgJiYge3Bhc3NpdmU6ICEwLCBjYXB0dXJlOiAhMX07XHJcbiAgICAgICAgICAgIGlmICghZCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCB1ID0gXCJvblwiID09PSBlID8gXCJhZGRFdmVudExpc3RlbmVyXCIgOiBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIjtcclxuICAgICAgICAgICAgbC50b3VjaCA/IChkW3VdKGEuc3RhcnQsIHgsIGMpLCBkW3VdKGEubW92ZSwgeSwgYyksIGRbdV0oYS5lbmQsIEUsIHApKSA6IChkW3VdKGkuc3RhcnQsIHgsIGMpLCBuW3VdKGkubW92ZSwgeSwgYyksIG5bdV0oaS5lbmQsIEUsIHApKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gVCgpIHtcclxuICAgICAgICAgICAgY29uc3Qge3Njcm9sbGJhcjogZSwgJGVsOiBzfSA9IHQ7XHJcbiAgICAgICAgICAgIHQucGFyYW1zLnNjcm9sbGJhciA9IEYodCwgdC5vcmlnaW5hbFBhcmFtcy5zY3JvbGxiYXIsIHQucGFyYW1zLnNjcm9sbGJhciwge2VsOiBcInN3aXBlci1zY3JvbGxiYXJcIn0pO1xyXG4gICAgICAgICAgICBjb25zdCBhID0gdC5wYXJhbXMuc2Nyb2xsYmFyO1xyXG4gICAgICAgICAgICBpZiAoIWEuZWwpIHJldHVybjtcclxuICAgICAgICAgICAgbGV0IGkgPSBkKGEuZWwpO1xyXG4gICAgICAgICAgICB0LnBhcmFtcy51bmlxdWVOYXZFbGVtZW50cyAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBhLmVsICYmIGkubGVuZ3RoID4gMSAmJiAxID09PSBzLmZpbmQoYS5lbCkubGVuZ3RoICYmIChpID0gcy5maW5kKGEuZWwpKSwgaS5hZGRDbGFzcyh0LmlzSG9yaXpvbnRhbCgpID8gYS5ob3Jpem9udGFsQ2xhc3MgOiBhLnZlcnRpY2FsQ2xhc3MpO1xyXG4gICAgICAgICAgICBsZXQgciA9IGkuZmluZChgLiR7dC5wYXJhbXMuc2Nyb2xsYmFyLmRyYWdDbGFzc31gKTtcclxuICAgICAgICAgICAgMCA9PT0gci5sZW5ndGggJiYgKHIgPSBkKGA8ZGl2IGNsYXNzPVwiJHt0LnBhcmFtcy5zY3JvbGxiYXIuZHJhZ0NsYXNzfVwiPjwvZGl2PmApLCBpLmFwcGVuZChyKSksIE9iamVjdC5hc3NpZ24oZSwge1xyXG4gICAgICAgICAgICAgICAgJGVsOiBpLFxyXG4gICAgICAgICAgICAgICAgZWw6IGlbMF0sXHJcbiAgICAgICAgICAgICAgICAkZHJhZ0VsOiByLFxyXG4gICAgICAgICAgICAgICAgZHJhZ0VsOiByWzBdXHJcbiAgICAgICAgICAgIH0pLCBhLmRyYWdnYWJsZSAmJiB0LnBhcmFtcy5zY3JvbGxiYXIuZWwgJiYgdC5zY3JvbGxiYXIuZWwgJiYgQyhcIm9uXCIpLCBpICYmIGlbdC5lbmFibGVkID8gXCJyZW1vdmVDbGFzc1wiIDogXCJhZGRDbGFzc1wiXSh0LnBhcmFtcy5zY3JvbGxiYXIubG9ja0NsYXNzKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gJCgpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHQucGFyYW1zLnNjcm9sbGJhciwgcyA9IHQuc2Nyb2xsYmFyLiRlbDtcclxuICAgICAgICAgICAgcyAmJiBzLnJlbW92ZUNsYXNzKHQuaXNIb3Jpem9udGFsKCkgPyBlLmhvcml6b250YWxDbGFzcyA6IGUudmVydGljYWxDbGFzcyksIHQucGFyYW1zLnNjcm9sbGJhci5lbCAmJiB0LnNjcm9sbGJhci5lbCAmJiBDKFwib2ZmXCIpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzKHtcclxuICAgICAgICAgICAgc2Nyb2xsYmFyOiB7XHJcbiAgICAgICAgICAgICAgICBlbDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGRyYWdTaXplOiBcImF1dG9cIixcclxuICAgICAgICAgICAgICAgIGhpZGU6ICExLFxyXG4gICAgICAgICAgICAgICAgZHJhZ2dhYmxlOiAhMSxcclxuICAgICAgICAgICAgICAgIHNuYXBPblJlbGVhc2U6ICEwLFxyXG4gICAgICAgICAgICAgICAgbG9ja0NsYXNzOiBcInN3aXBlci1zY3JvbGxiYXItbG9ja1wiLFxyXG4gICAgICAgICAgICAgICAgZHJhZ0NsYXNzOiBcInN3aXBlci1zY3JvbGxiYXItZHJhZ1wiLFxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsYmFyRGlzYWJsZWRDbGFzczogXCJzd2lwZXItc2Nyb2xsYmFyLWRpc2FibGVkXCIsXHJcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsQ2xhc3M6IFwic3dpcGVyLXNjcm9sbGJhci1ob3Jpem9udGFsXCIsXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbENsYXNzOiBcInN3aXBlci1zY3JvbGxiYXItdmVydGljYWxcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksIHQuc2Nyb2xsYmFyID0ge2VsOiBudWxsLCBkcmFnRWw6IG51bGwsICRlbDogbnVsbCwgJGRyYWdFbDogbnVsbH0sIGkoXCJpbml0XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgICExID09PSB0LnBhcmFtcy5zY3JvbGxiYXIuZW5hYmxlZCA/IFMoKSA6IChUKCksIHYoKSwgZygpKVxyXG4gICAgICAgIH0pKSwgaShcInVwZGF0ZSByZXNpemUgb2JzZXJ2ZXJVcGRhdGUgbG9jayB1bmxvY2tcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdigpXHJcbiAgICAgICAgfSkpLCBpKFwic2V0VHJhbnNsYXRlXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGcoKVxyXG4gICAgICAgIH0pKSwgaShcInNldFRyYW5zaXRpb25cIiwgKChlLCBzKSA9PiB7XHJcbiAgICAgICAgICAgICFmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgdC5wYXJhbXMuc2Nyb2xsYmFyLmVsICYmIHQuc2Nyb2xsYmFyLmVsICYmIHQuc2Nyb2xsYmFyLiRkcmFnRWwudHJhbnNpdGlvbihlKVxyXG4gICAgICAgICAgICB9KHMpXHJcbiAgICAgICAgfSkpLCBpKFwiZW5hYmxlIGRpc2FibGVcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyRlbDogZX0gPSB0LnNjcm9sbGJhcjtcclxuICAgICAgICAgICAgZSAmJiBlW3QuZW5hYmxlZCA/IFwicmVtb3ZlQ2xhc3NcIiA6IFwiYWRkQ2xhc3NcIl0odC5wYXJhbXMuc2Nyb2xsYmFyLmxvY2tDbGFzcylcclxuICAgICAgICB9KSksIGkoXCJkZXN0cm95XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgICQoKVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBjb25zdCBTID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0LiRlbC5hZGRDbGFzcyh0LnBhcmFtcy5zY3JvbGxiYXIuc2Nyb2xsYmFyRGlzYWJsZWRDbGFzcyksIHQuc2Nyb2xsYmFyLiRlbCAmJiB0LnNjcm9sbGJhci4kZWwuYWRkQ2xhc3ModC5wYXJhbXMuc2Nyb2xsYmFyLnNjcm9sbGJhckRpc2FibGVkQ2xhc3MpLCAkKClcclxuICAgICAgICB9O1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24odC5zY3JvbGxiYXIsIHtcclxuICAgICAgICAgICAgZW5hYmxlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0LiRlbC5yZW1vdmVDbGFzcyh0LnBhcmFtcy5zY3JvbGxiYXIuc2Nyb2xsYmFyRGlzYWJsZWRDbGFzcyksIHQuc2Nyb2xsYmFyLiRlbCAmJiB0LnNjcm9sbGJhci4kZWwucmVtb3ZlQ2xhc3ModC5wYXJhbXMuc2Nyb2xsYmFyLnNjcm9sbGJhckRpc2FibGVkQ2xhc3MpLCBUKCksIHYoKSwgZygpXHJcbiAgICAgICAgICAgIH0sIGRpc2FibGU6IFMsIHVwZGF0ZVNpemU6IHYsIHNldFRyYW5zbGF0ZTogZywgaW5pdDogVCwgZGVzdHJveTogJFxyXG4gICAgICAgIH0pXHJcbiAgICB9LCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGxldCB7c3dpcGVyOiB0LCBleHRlbmRQYXJhbXM6IHMsIG9uOiBhfSA9IGU7XHJcbiAgICAgICAgcyh7cGFyYWxsYXg6IHtlbmFibGVkOiAhMX19KTtcclxuICAgICAgICBjb25zdCBpID0gKGUsIHMpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qge3J0bDogYX0gPSB0LCBpID0gZChlKSwgciA9IGEgPyAtMSA6IDEsIG4gPSBpLmF0dHIoXCJkYXRhLXN3aXBlci1wYXJhbGxheFwiKSB8fCBcIjBcIjtcclxuICAgICAgICAgICAgbGV0IGwgPSBpLmF0dHIoXCJkYXRhLXN3aXBlci1wYXJhbGxheC14XCIpLCBvID0gaS5hdHRyKFwiZGF0YS1zd2lwZXItcGFyYWxsYXgteVwiKTtcclxuICAgICAgICAgICAgY29uc3QgYyA9IGkuYXR0cihcImRhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlXCIpLCBwID0gaS5hdHRyKFwiZGF0YS1zd2lwZXItcGFyYWxsYXgtb3BhY2l0eVwiKTtcclxuICAgICAgICAgICAgaWYgKGwgfHwgbyA/IChsID0gbCB8fCBcIjBcIiwgbyA9IG8gfHwgXCIwXCIpIDogdC5pc0hvcml6b250YWwoKSA/IChsID0gbiwgbyA9IFwiMFwiKSA6IChvID0gbiwgbCA9IFwiMFwiKSwgbCA9IGwuaW5kZXhPZihcIiVcIikgPj0gMCA/IHBhcnNlSW50KGwsIDEwKSAqIHMgKiByICsgXCIlXCIgOiBsICogcyAqIHIgKyBcInB4XCIsIG8gPSBvLmluZGV4T2YoXCIlXCIpID49IDAgPyBwYXJzZUludChvLCAxMCkgKiBzICsgXCIlXCIgOiBvICogcyArIFwicHhcIiwgbnVsbCAhPSBwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gcCAtIChwIC0gMSkgKiAoMSAtIE1hdGguYWJzKHMpKTtcclxuICAgICAgICAgICAgICAgIGlbMF0uc3R5bGUub3BhY2l0eSA9IGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobnVsbCA9PSBjKSBpLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoJHtsfSwgJHtvfSwgMHB4KWApOyBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBjIC0gKGMgLSAxKSAqICgxIC0gTWF0aC5hYnMocykpO1xyXG4gICAgICAgICAgICAgICAgaS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7bH0sICR7b30sIDBweCkgc2NhbGUoJHtlfSlgKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgciA9ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyRlbDogZSwgc2xpZGVzOiBzLCBwcm9ncmVzczogYSwgc25hcEdyaWQ6IHJ9ID0gdDtcclxuICAgICAgICAgICAgZS5jaGlsZHJlbihcIltkYXRhLXN3aXBlci1wYXJhbGxheF0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC14XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXldLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgtb3BhY2l0eV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1zY2FsZV1cIikuZWFjaCgoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpKGUsIGEpXHJcbiAgICAgICAgICAgIH0pKSwgcy5lYWNoKCgoZSwgcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IG4gPSBlLnByb2dyZXNzO1xyXG4gICAgICAgICAgICAgICAgdC5wYXJhbXMuc2xpZGVzUGVyR3JvdXAgPiAxICYmIFwiYXV0b1wiICE9PSB0LnBhcmFtcy5zbGlkZXNQZXJWaWV3ICYmIChuICs9IE1hdGguY2VpbChzIC8gMikgLSBhICogKHIubGVuZ3RoIC0gMSkpLCBuID0gTWF0aC5taW4oTWF0aC5tYXgobiwgLTEpLCAxKSwgZChlKS5maW5kKFwiW2RhdGEtc3dpcGVyLXBhcmFsbGF4XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteV0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC1vcGFjaXR5XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LXNjYWxlXVwiKS5lYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpKGUsIG4pXHJcbiAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBhKFwiYmVmb3JlSW5pdFwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICB0LnBhcmFtcy5wYXJhbGxheC5lbmFibGVkICYmICh0LnBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzID0gITAsIHQub3JpZ2luYWxQYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcyA9ICEwKVxyXG4gICAgICAgIH0pKSwgYShcImluaXRcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC5wYXJhbXMucGFyYWxsYXguZW5hYmxlZCAmJiByKClcclxuICAgICAgICB9KSksIGEoXCJzZXRUcmFuc2xhdGVcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC5wYXJhbXMucGFyYWxsYXguZW5hYmxlZCAmJiByKClcclxuICAgICAgICB9KSksIGEoXCJzZXRUcmFuc2l0aW9uXCIsICgoZSwgcykgPT4ge1xyXG4gICAgICAgICAgICB0LnBhcmFtcy5wYXJhbGxheC5lbmFibGVkICYmIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IGUgJiYgKGUgPSB0LnBhcmFtcy5zcGVlZCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7JGVsOiBzfSA9IHQ7XHJcbiAgICAgICAgICAgICAgICBzLmZpbmQoXCJbZGF0YS1zd2lwZXItcGFyYWxsYXhdLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgteF0sIFtkYXRhLXN3aXBlci1wYXJhbGxheC15XSwgW2RhdGEtc3dpcGVyLXBhcmFsbGF4LW9wYWNpdHldLCBbZGF0YS1zd2lwZXItcGFyYWxsYXgtc2NhbGVdXCIpLmVhY2goKHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBkKHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhID0gcGFyc2VJbnQocy5hdHRyKFwiZGF0YS1zd2lwZXItcGFyYWxsYXgtZHVyYXRpb25cIiksIDEwKSB8fCBlO1xyXG4gICAgICAgICAgICAgICAgICAgIDAgPT09IGUgJiYgKGEgPSAwKSwgcy50cmFuc2l0aW9uKGEpXHJcbiAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgfShzKVxyXG4gICAgICAgIH0pKVxyXG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBsZXQge3N3aXBlcjogdCwgZXh0ZW5kUGFyYW1zOiBzLCBvbjogYSwgZW1pdDogaX0gPSBlO1xyXG4gICAgICAgIGNvbnN0IG4gPSByKCk7XHJcbiAgICAgICAgcyh7XHJcbiAgICAgICAgICAgIHpvb206IHtcclxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6ICExLFxyXG4gICAgICAgICAgICAgICAgbWF4UmF0aW86IDMsXHJcbiAgICAgICAgICAgICAgICBtaW5SYXRpbzogMSxcclxuICAgICAgICAgICAgICAgIHRvZ2dsZTogITAsXHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJDbGFzczogXCJzd2lwZXItem9vbS1jb250YWluZXJcIixcclxuICAgICAgICAgICAgICAgIHpvb21lZFNsaWRlQ2xhc3M6IFwic3dpcGVyLXNsaWRlLXpvb21lZFwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSwgdC56b29tID0ge2VuYWJsZWQ6ICExfTtcclxuICAgICAgICBsZXQgbCwgbywgYywgcCA9IDEsIHUgPSAhMTtcclxuICAgICAgICBjb25zdCBtID0ge1xyXG4gICAgICAgICAgICAkc2xpZGVFbDogdm9pZCAwLFxyXG4gICAgICAgICAgICBzbGlkZVdpZHRoOiB2b2lkIDAsXHJcbiAgICAgICAgICAgIHNsaWRlSGVpZ2h0OiB2b2lkIDAsXHJcbiAgICAgICAgICAgICRpbWFnZUVsOiB2b2lkIDAsXHJcbiAgICAgICAgICAgICRpbWFnZVdyYXBFbDogdm9pZCAwLFxyXG4gICAgICAgICAgICBtYXhSYXRpbzogM1xyXG4gICAgICAgIH0sIGYgPSB7XHJcbiAgICAgICAgICAgIGlzVG91Y2hlZDogdm9pZCAwLFxyXG4gICAgICAgICAgICBpc01vdmVkOiB2b2lkIDAsXHJcbiAgICAgICAgICAgIGN1cnJlbnRYOiB2b2lkIDAsXHJcbiAgICAgICAgICAgIGN1cnJlbnRZOiB2b2lkIDAsXHJcbiAgICAgICAgICAgIG1pblg6IHZvaWQgMCxcclxuICAgICAgICAgICAgbWluWTogdm9pZCAwLFxyXG4gICAgICAgICAgICBtYXhYOiB2b2lkIDAsXHJcbiAgICAgICAgICAgIG1heFk6IHZvaWQgMCxcclxuICAgICAgICAgICAgd2lkdGg6IHZvaWQgMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB2b2lkIDAsXHJcbiAgICAgICAgICAgIHN0YXJ0WDogdm9pZCAwLFxyXG4gICAgICAgICAgICBzdGFydFk6IHZvaWQgMCxcclxuICAgICAgICAgICAgdG91Y2hlc1N0YXJ0OiB7fSxcclxuICAgICAgICAgICAgdG91Y2hlc0N1cnJlbnQ6IHt9XHJcbiAgICAgICAgfSwgZyA9IHt4OiB2b2lkIDAsIHk6IHZvaWQgMCwgcHJldlBvc2l0aW9uWDogdm9pZCAwLCBwcmV2UG9zaXRpb25ZOiB2b2lkIDAsIHByZXZUaW1lOiB2b2lkIDB9O1xyXG4gICAgICAgIGxldCB2ID0gMTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdyhlKSB7XHJcbiAgICAgICAgICAgIGlmIChlLnRhcmdldFRvdWNoZXMubGVuZ3RoIDwgMikgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVgsIHMgPSBlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVksIGEgPSBlLnRhcmdldFRvdWNoZXNbMV0ucGFnZVgsXHJcbiAgICAgICAgICAgICAgICBpID0gZS50YXJnZXRUb3VjaGVzWzFdLnBhZ2VZO1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KChhIC0gdCkgKiogMiArIChpIC0gcykgKiogMilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGIoZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzID0gdC5zdXBwb3J0LCBhID0gdC5wYXJhbXMuem9vbTtcclxuICAgICAgICAgICAgaWYgKG8gPSAhMSwgYyA9ICExLCAhcy5nZXN0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKFwidG91Y2hzdGFydFwiICE9PSBlLnR5cGUgfHwgXCJ0b3VjaHN0YXJ0XCIgPT09IGUudHlwZSAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoIDwgMikgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgbyA9ICEwLCBtLnNjYWxlU3RhcnQgPSB3KGUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbS4kc2xpZGVFbCAmJiBtLiRzbGlkZUVsLmxlbmd0aCB8fCAobS4kc2xpZGVFbCA9IGQoZS50YXJnZXQpLmNsb3Nlc3QoYC4ke3QucGFyYW1zLnNsaWRlQ2xhc3N9YCksIDAgPT09IG0uJHNsaWRlRWwubGVuZ3RoICYmIChtLiRzbGlkZUVsID0gdC5zbGlkZXMuZXEodC5hY3RpdmVJbmRleCkpLCBtLiRpbWFnZUVsID0gbS4kc2xpZGVFbC5maW5kKGAuJHthLmNvbnRhaW5lckNsYXNzfWApLmVxKDApLmZpbmQoXCJwaWN0dXJlLCBpbWcsIHN2ZywgY2FudmFzLCAuc3dpcGVyLXpvb20tdGFyZ2V0XCIpLmVxKDApLCBtLiRpbWFnZVdyYXBFbCA9IG0uJGltYWdlRWwucGFyZW50KGAuJHthLmNvbnRhaW5lckNsYXNzfWApLCBtLm1heFJhdGlvID0gbS4kaW1hZ2VXcmFwRWwuYXR0cihcImRhdGEtc3dpcGVyLXpvb21cIikgfHwgYS5tYXhSYXRpbywgMCAhPT0gbS4kaW1hZ2VXcmFwRWwubGVuZ3RoKSA/IChtLiRpbWFnZUVsICYmIG0uJGltYWdlRWwudHJhbnNpdGlvbigwKSwgdSA9ICEwKSA6IG0uJGltYWdlRWwgPSB2b2lkIDBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHgoZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzID0gdC5zdXBwb3J0LCBhID0gdC5wYXJhbXMuem9vbSwgaSA9IHQuem9vbTtcclxuICAgICAgICAgICAgaWYgKCFzLmdlc3R1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJ0b3VjaG1vdmVcIiAhPT0gZS50eXBlIHx8IFwidG91Y2htb3ZlXCIgPT09IGUudHlwZSAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoIDwgMikgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgYyA9ICEwLCBtLnNjYWxlTW92ZSA9IHcoZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtLiRpbWFnZUVsICYmIDAgIT09IG0uJGltYWdlRWwubGVuZ3RoID8gKHMuZ2VzdHVyZXMgPyBpLnNjYWxlID0gZS5zY2FsZSAqIHAgOiBpLnNjYWxlID0gbS5zY2FsZU1vdmUgLyBtLnNjYWxlU3RhcnQgKiBwLCBpLnNjYWxlID4gbS5tYXhSYXRpbyAmJiAoaS5zY2FsZSA9IG0ubWF4UmF0aW8gLSAxICsgKGkuc2NhbGUgLSBtLm1heFJhdGlvICsgMSkgKiogLjUpLCBpLnNjYWxlIDwgYS5taW5SYXRpbyAmJiAoaS5zY2FsZSA9IGEubWluUmF0aW8gKyAxIC0gKGEubWluUmF0aW8gLSBpLnNjYWxlICsgMSkgKiogLjUpLCBtLiRpbWFnZUVsLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlKCR7aS5zY2FsZX0pYCkpIDogXCJnZXN0dXJlY2hhbmdlXCIgPT09IGUudHlwZSAmJiBiKGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB5KGUpIHtcclxuICAgICAgICAgICAgY29uc3QgcyA9IHQuZGV2aWNlLCBhID0gdC5zdXBwb3J0LCBpID0gdC5wYXJhbXMuem9vbSwgciA9IHQuem9vbTtcclxuICAgICAgICAgICAgaWYgKCFhLmdlc3R1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW8gfHwgIWMpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGlmIChcInRvdWNoZW5kXCIgIT09IGUudHlwZSB8fCBcInRvdWNoZW5kXCIgPT09IGUudHlwZSAmJiBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA8IDIgJiYgIXMuYW5kcm9pZCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgbyA9ICExLCBjID0gITFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtLiRpbWFnZUVsICYmIDAgIT09IG0uJGltYWdlRWwubGVuZ3RoICYmIChyLnNjYWxlID0gTWF0aC5tYXgoTWF0aC5taW4oci5zY2FsZSwgbS5tYXhSYXRpbyksIGkubWluUmF0aW8pLCBtLiRpbWFnZUVsLnRyYW5zaXRpb24odC5wYXJhbXMuc3BlZWQpLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlKCR7ci5zY2FsZX0pYCksIHAgPSByLnNjYWxlLCB1ID0gITEsIDEgPT09IHIuc2NhbGUgJiYgKG0uJHNsaWRlRWwgPSB2b2lkIDApKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gRShlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0Lnpvb207XHJcbiAgICAgICAgICAgIGlmICghbS4kaW1hZ2VFbCB8fCAwID09PSBtLiRpbWFnZUVsLmxlbmd0aCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAodC5hbGxvd0NsaWNrID0gITEsICFmLmlzVG91Y2hlZCB8fCAhbS4kc2xpZGVFbCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBmLmlzTW92ZWQgfHwgKGYud2lkdGggPSBtLiRpbWFnZUVsWzBdLm9mZnNldFdpZHRoLCBmLmhlaWdodCA9IG0uJGltYWdlRWxbMF0ub2Zmc2V0SGVpZ2h0LCBmLnN0YXJ0WCA9IGgobS4kaW1hZ2VXcmFwRWxbMF0sIFwieFwiKSB8fCAwLCBmLnN0YXJ0WSA9IGgobS4kaW1hZ2VXcmFwRWxbMF0sIFwieVwiKSB8fCAwLCBtLnNsaWRlV2lkdGggPSBtLiRzbGlkZUVsWzBdLm9mZnNldFdpZHRoLCBtLnNsaWRlSGVpZ2h0ID0gbS4kc2xpZGVFbFswXS5vZmZzZXRIZWlnaHQsIG0uJGltYWdlV3JhcEVsLnRyYW5zaXRpb24oMCkpO1xyXG4gICAgICAgICAgICBjb25zdCBhID0gZi53aWR0aCAqIHMuc2NhbGUsIGkgPSBmLmhlaWdodCAqIHMuc2NhbGU7XHJcbiAgICAgICAgICAgIGlmICghKGEgPCBtLnNsaWRlV2lkdGggJiYgaSA8IG0uc2xpZGVIZWlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZi5taW5YID0gTWF0aC5taW4obS5zbGlkZVdpZHRoIC8gMiAtIGEgLyAyLCAwKSwgZi5tYXhYID0gLWYubWluWCwgZi5taW5ZID0gTWF0aC5taW4obS5zbGlkZUhlaWdodCAvIDIgLSBpIC8gMiwgMCksIGYubWF4WSA9IC1mLm1pblksIGYudG91Y2hlc0N1cnJlbnQueCA9IFwidG91Y2htb3ZlXCIgPT09IGUudHlwZSA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVgsIGYudG91Y2hlc0N1cnJlbnQueSA9IFwidG91Y2htb3ZlXCIgPT09IGUudHlwZSA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWSA6IGUucGFnZVksICFmLmlzTW92ZWQgJiYgIXUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodC5pc0hvcml6b250YWwoKSAmJiAoTWF0aC5mbG9vcihmLm1pblgpID09PSBNYXRoLmZsb29yKGYuc3RhcnRYKSAmJiBmLnRvdWNoZXNDdXJyZW50LnggPCBmLnRvdWNoZXNTdGFydC54IHx8IE1hdGguZmxvb3IoZi5tYXhYKSA9PT0gTWF0aC5mbG9vcihmLnN0YXJ0WCkgJiYgZi50b3VjaGVzQ3VycmVudC54ID4gZi50b3VjaGVzU3RhcnQueCkpIHJldHVybiB2b2lkIChmLmlzVG91Y2hlZCA9ICExKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXQuaXNIb3Jpem9udGFsKCkgJiYgKE1hdGguZmxvb3IoZi5taW5ZKSA9PT0gTWF0aC5mbG9vcihmLnN0YXJ0WSkgJiYgZi50b3VjaGVzQ3VycmVudC55IDwgZi50b3VjaGVzU3RhcnQueSB8fCBNYXRoLmZsb29yKGYubWF4WSkgPT09IE1hdGguZmxvb3IoZi5zdGFydFkpICYmIGYudG91Y2hlc0N1cnJlbnQueSA+IGYudG91Y2hlc1N0YXJ0LnkpKSByZXR1cm4gdm9pZCAoZi5pc1RvdWNoZWQgPSAhMSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGUuY2FuY2VsYWJsZSAmJiBlLnByZXZlbnREZWZhdWx0KCksIGUuc3RvcFByb3BhZ2F0aW9uKCksIGYuaXNNb3ZlZCA9ICEwLCBmLmN1cnJlbnRYID0gZi50b3VjaGVzQ3VycmVudC54IC0gZi50b3VjaGVzU3RhcnQueCArIGYuc3RhcnRYLCBmLmN1cnJlbnRZID0gZi50b3VjaGVzQ3VycmVudC55IC0gZi50b3VjaGVzU3RhcnQueSArIGYuc3RhcnRZLCBmLmN1cnJlbnRYIDwgZi5taW5YICYmIChmLmN1cnJlbnRYID0gZi5taW5YICsgMSAtIChmLm1pblggLSBmLmN1cnJlbnRYICsgMSkgKiogLjgpLCBmLmN1cnJlbnRYID4gZi5tYXhYICYmIChmLmN1cnJlbnRYID0gZi5tYXhYIC0gMSArIChmLmN1cnJlbnRYIC0gZi5tYXhYICsgMSkgKiogLjgpLCBmLmN1cnJlbnRZIDwgZi5taW5ZICYmIChmLmN1cnJlbnRZID0gZi5taW5ZICsgMSAtIChmLm1pblkgLSBmLmN1cnJlbnRZICsgMSkgKiogLjgpLCBmLmN1cnJlbnRZID4gZi5tYXhZICYmIChmLmN1cnJlbnRZID0gZi5tYXhZIC0gMSArIChmLmN1cnJlbnRZIC0gZi5tYXhZICsgMSkgKiogLjgpLCBnLnByZXZQb3NpdGlvblggfHwgKGcucHJldlBvc2l0aW9uWCA9IGYudG91Y2hlc0N1cnJlbnQueCksIGcucHJldlBvc2l0aW9uWSB8fCAoZy5wcmV2UG9zaXRpb25ZID0gZi50b3VjaGVzQ3VycmVudC55KSwgZy5wcmV2VGltZSB8fCAoZy5wcmV2VGltZSA9IERhdGUubm93KCkpLCBnLnggPSAoZi50b3VjaGVzQ3VycmVudC54IC0gZy5wcmV2UG9zaXRpb25YKSAvIChEYXRlLm5vdygpIC0gZy5wcmV2VGltZSkgLyAyLCBnLnkgPSAoZi50b3VjaGVzQ3VycmVudC55IC0gZy5wcmV2UG9zaXRpb25ZKSAvIChEYXRlLm5vdygpIC0gZy5wcmV2VGltZSkgLyAyLCBNYXRoLmFicyhmLnRvdWNoZXNDdXJyZW50LnggLSBnLnByZXZQb3NpdGlvblgpIDwgMiAmJiAoZy54ID0gMCksIE1hdGguYWJzKGYudG91Y2hlc0N1cnJlbnQueSAtIGcucHJldlBvc2l0aW9uWSkgPCAyICYmIChnLnkgPSAwKSwgZy5wcmV2UG9zaXRpb25YID0gZi50b3VjaGVzQ3VycmVudC54LCBnLnByZXZQb3NpdGlvblkgPSBmLnRvdWNoZXNDdXJyZW50LnksIGcucHJldlRpbWUgPSBEYXRlLm5vdygpLCBtLiRpbWFnZVdyYXBFbC50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKCR7Zi5jdXJyZW50WH1weCwgJHtmLmN1cnJlbnRZfXB4LDApYClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gQygpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHQuem9vbTtcclxuICAgICAgICAgICAgbS4kc2xpZGVFbCAmJiB0LnByZXZpb3VzSW5kZXggIT09IHQuYWN0aXZlSW5kZXggJiYgKG0uJGltYWdlRWwgJiYgbS4kaW1hZ2VFbC50cmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZCgwLDAsMCkgc2NhbGUoMSlcIiksIG0uJGltYWdlV3JhcEVsICYmIG0uJGltYWdlV3JhcEVsLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKDAsMCwwKVwiKSwgZS5zY2FsZSA9IDEsIHAgPSAxLCBtLiRzbGlkZUVsID0gdm9pZCAwLCBtLiRpbWFnZUVsID0gdm9pZCAwLCBtLiRpbWFnZVdyYXBFbCA9IHZvaWQgMClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIFQoZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzID0gdC56b29tLCBhID0gdC5wYXJhbXMuem9vbTtcclxuICAgICAgICAgICAgaWYgKG0uJHNsaWRlRWwgfHwgKGUgJiYgZS50YXJnZXQgJiYgKG0uJHNsaWRlRWwgPSBkKGUudGFyZ2V0KS5jbG9zZXN0KGAuJHt0LnBhcmFtcy5zbGlkZUNsYXNzfWApKSwgbS4kc2xpZGVFbCB8fCAodC5wYXJhbXMudmlydHVhbCAmJiB0LnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgJiYgdC52aXJ0dWFsID8gbS4kc2xpZGVFbCA9IHQuJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7dC5wYXJhbXMuc2xpZGVBY3RpdmVDbGFzc31gKSA6IG0uJHNsaWRlRWwgPSB0LnNsaWRlcy5lcSh0LmFjdGl2ZUluZGV4KSksIG0uJGltYWdlRWwgPSBtLiRzbGlkZUVsLmZpbmQoYC4ke2EuY29udGFpbmVyQ2xhc3N9YCkuZXEoMCkuZmluZChcInBpY3R1cmUsIGltZywgc3ZnLCBjYW52YXMsIC5zd2lwZXItem9vbS10YXJnZXRcIikuZXEoMCksIG0uJGltYWdlV3JhcEVsID0gbS4kaW1hZ2VFbC5wYXJlbnQoYC4ke2EuY29udGFpbmVyQ2xhc3N9YCkpLCAhbS4kaW1hZ2VFbCB8fCAwID09PSBtLiRpbWFnZUVsLmxlbmd0aCB8fCAhbS4kaW1hZ2VXcmFwRWwgfHwgMCA9PT0gbS4kaW1hZ2VXcmFwRWwubGVuZ3RoKSByZXR1cm47XHJcbiAgICAgICAgICAgIGxldCBpLCByLCBsLCBvLCBjLCB1LCBoLCBnLCB2LCB3LCBiLCB4LCB5LCBFLCBDLCBULCAkLCBTO1xyXG4gICAgICAgICAgICB0LnBhcmFtcy5jc3NNb2RlICYmICh0LndyYXBwZXJFbC5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCIsIHQud3JhcHBlckVsLnN0eWxlLnRvdWNoQWN0aW9uID0gXCJub25lXCIpLCBtLiRzbGlkZUVsLmFkZENsYXNzKGAke2Euem9vbWVkU2xpZGVDbGFzc31gKSwgdm9pZCAwID09PSBmLnRvdWNoZXNTdGFydC54ICYmIGUgPyAoaSA9IFwidG91Y2hlbmRcIiA9PT0gZS50eXBlID8gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVgsIHIgPSBcInRvdWNoZW5kXCIgPT09IGUudHlwZSA/IGUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgOiBlLnBhZ2VZKSA6IChpID0gZi50b3VjaGVzU3RhcnQueCwgciA9IGYudG91Y2hlc1N0YXJ0LnkpLCBzLnNjYWxlID0gbS4kaW1hZ2VXcmFwRWwuYXR0cihcImRhdGEtc3dpcGVyLXpvb21cIikgfHwgYS5tYXhSYXRpbywgcCA9IG0uJGltYWdlV3JhcEVsLmF0dHIoXCJkYXRhLXN3aXBlci16b29tXCIpIHx8IGEubWF4UmF0aW8sIGUgPyAoJCA9IG0uJHNsaWRlRWxbMF0ub2Zmc2V0V2lkdGgsIFMgPSBtLiRzbGlkZUVsWzBdLm9mZnNldEhlaWdodCwgbCA9IG0uJHNsaWRlRWwub2Zmc2V0KCkubGVmdCArIG4uc2Nyb2xsWCwgbyA9IG0uJHNsaWRlRWwub2Zmc2V0KCkudG9wICsgbi5zY3JvbGxZLCBjID0gbCArICQgLyAyIC0gaSwgdSA9IG8gKyBTIC8gMiAtIHIsIHYgPSBtLiRpbWFnZUVsWzBdLm9mZnNldFdpZHRoLCB3ID0gbS4kaW1hZ2VFbFswXS5vZmZzZXRIZWlnaHQsIGIgPSB2ICogcy5zY2FsZSwgeCA9IHcgKiBzLnNjYWxlLCB5ID0gTWF0aC5taW4oJCAvIDIgLSBiIC8gMiwgMCksIEUgPSBNYXRoLm1pbihTIC8gMiAtIHggLyAyLCAwKSwgQyA9IC15LCBUID0gLUUsIGggPSBjICogcy5zY2FsZSwgZyA9IHUgKiBzLnNjYWxlLCBoIDwgeSAmJiAoaCA9IHkpLCBoID4gQyAmJiAoaCA9IEMpLCBnIDwgRSAmJiAoZyA9IEUpLCBnID4gVCAmJiAoZyA9IFQpKSA6IChoID0gMCwgZyA9IDApLCBtLiRpbWFnZVdyYXBFbC50cmFuc2l0aW9uKDMwMCkudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke2h9cHgsICR7Z31weCwwKWApLCBtLiRpbWFnZUVsLnRyYW5zaXRpb24oMzAwKS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDAsMCwwKSBzY2FsZSgke3Muc2NhbGV9KWApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiAkKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdC56b29tLCBzID0gdC5wYXJhbXMuem9vbTtcclxuICAgICAgICAgICAgbS4kc2xpZGVFbCB8fCAodC5wYXJhbXMudmlydHVhbCAmJiB0LnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQgJiYgdC52aXJ0dWFsID8gbS4kc2xpZGVFbCA9IHQuJHdyYXBwZXJFbC5jaGlsZHJlbihgLiR7dC5wYXJhbXMuc2xpZGVBY3RpdmVDbGFzc31gKSA6IG0uJHNsaWRlRWwgPSB0LnNsaWRlcy5lcSh0LmFjdGl2ZUluZGV4KSwgbS4kaW1hZ2VFbCA9IG0uJHNsaWRlRWwuZmluZChgLiR7cy5jb250YWluZXJDbGFzc31gKS5lcSgwKS5maW5kKFwicGljdHVyZSwgaW1nLCBzdmcsIGNhbnZhcywgLnN3aXBlci16b29tLXRhcmdldFwiKS5lcSgwKSwgbS4kaW1hZ2VXcmFwRWwgPSBtLiRpbWFnZUVsLnBhcmVudChgLiR7cy5jb250YWluZXJDbGFzc31gKSksIG0uJGltYWdlRWwgJiYgMCAhPT0gbS4kaW1hZ2VFbC5sZW5ndGggJiYgbS4kaW1hZ2VXcmFwRWwgJiYgMCAhPT0gbS4kaW1hZ2VXcmFwRWwubGVuZ3RoICYmICh0LnBhcmFtcy5jc3NNb2RlICYmICh0LndyYXBwZXJFbC5zdHlsZS5vdmVyZmxvdyA9IFwiXCIsIHQud3JhcHBlckVsLnN0eWxlLnRvdWNoQWN0aW9uID0gXCJcIiksIGUuc2NhbGUgPSAxLCBwID0gMSwgbS4kaW1hZ2VXcmFwRWwudHJhbnNpdGlvbigzMDApLnRyYW5zZm9ybShcInRyYW5zbGF0ZTNkKDAsMCwwKVwiKSwgbS4kaW1hZ2VFbC50cmFuc2l0aW9uKDMwMCkudHJhbnNmb3JtKFwidHJhbnNsYXRlM2QoMCwwLDApIHNjYWxlKDEpXCIpLCBtLiRzbGlkZUVsLnJlbW92ZUNsYXNzKGAke3Muem9vbWVkU2xpZGVDbGFzc31gKSwgbS4kc2xpZGVFbCA9IHZvaWQgMClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIFMoZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzID0gdC56b29tO1xyXG4gICAgICAgICAgICBzLnNjYWxlICYmIDEgIT09IHMuc2NhbGUgPyAkKCkgOiBUKGUpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBNKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdC5zdXBwb3J0O1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcGFzc2l2ZUxpc3RlbmVyOiAhKFwidG91Y2hzdGFydFwiICE9PSB0LnRvdWNoRXZlbnRzLnN0YXJ0IHx8ICFlLnBhc3NpdmVMaXN0ZW5lciB8fCAhdC5wYXJhbXMucGFzc2l2ZUxpc3RlbmVycykgJiYge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhc3NpdmU6ICEwLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhcHR1cmU6ICExXHJcbiAgICAgICAgICAgICAgICB9LCBhY3RpdmVMaXN0ZW5lcldpdGhDYXB0dXJlOiAhZS5wYXNzaXZlTGlzdGVuZXIgfHwge3Bhc3NpdmU6ICExLCBjYXB0dXJlOiAhMH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gUCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGAuJHt0LnBhcmFtcy5zbGlkZUNsYXNzfWBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGsoZSkge1xyXG4gICAgICAgICAgICBjb25zdCB7cGFzc2l2ZUxpc3RlbmVyOiBzfSA9IE0oKSwgYSA9IFAoKTtcclxuICAgICAgICAgICAgdC4kd3JhcHBlckVsW2VdKFwiZ2VzdHVyZXN0YXJ0XCIsIGEsIGIsIHMpLCB0LiR3cmFwcGVyRWxbZV0oXCJnZXN0dXJlY2hhbmdlXCIsIGEsIHgsIHMpLCB0LiR3cmFwcGVyRWxbZV0oXCJnZXN0dXJlZW5kXCIsIGEsIHksIHMpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB6KCkge1xyXG4gICAgICAgICAgICBsIHx8IChsID0gITAsIGsoXCJvblwiKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIEwoKSB7XHJcbiAgICAgICAgICAgIGwgJiYgKGwgPSAhMSwgayhcIm9mZlwiKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIE8oKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0Lnpvb207XHJcbiAgICAgICAgICAgIGlmIChlLmVuYWJsZWQpIHJldHVybjtcclxuICAgICAgICAgICAgZS5lbmFibGVkID0gITA7XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0LnN1cHBvcnQsIHtwYXNzaXZlTGlzdGVuZXI6IGEsIGFjdGl2ZUxpc3RlbmVyV2l0aENhcHR1cmU6IGl9ID0gTSgpLCByID0gUCgpO1xyXG4gICAgICAgICAgICBzLmdlc3R1cmVzID8gKHQuJHdyYXBwZXJFbC5vbih0LnRvdWNoRXZlbnRzLnN0YXJ0LCB6LCBhKSwgdC4kd3JhcHBlckVsLm9uKHQudG91Y2hFdmVudHMuZW5kLCBMLCBhKSkgOiBcInRvdWNoc3RhcnRcIiA9PT0gdC50b3VjaEV2ZW50cy5zdGFydCAmJiAodC4kd3JhcHBlckVsLm9uKHQudG91Y2hFdmVudHMuc3RhcnQsIHIsIGIsIGEpLCB0LiR3cmFwcGVyRWwub24odC50b3VjaEV2ZW50cy5tb3ZlLCByLCB4LCBpKSwgdC4kd3JhcHBlckVsLm9uKHQudG91Y2hFdmVudHMuZW5kLCByLCB5LCBhKSwgdC50b3VjaEV2ZW50cy5jYW5jZWwgJiYgdC4kd3JhcHBlckVsLm9uKHQudG91Y2hFdmVudHMuY2FuY2VsLCByLCB5LCBhKSksIHQuJHdyYXBwZXJFbC5vbih0LnRvdWNoRXZlbnRzLm1vdmUsIGAuJHt0LnBhcmFtcy56b29tLmNvbnRhaW5lckNsYXNzfWAsIEUsIGkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBJKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gdC56b29tO1xyXG4gICAgICAgICAgICBpZiAoIWUuZW5hYmxlZCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCBzID0gdC5zdXBwb3J0O1xyXG4gICAgICAgICAgICBlLmVuYWJsZWQgPSAhMTtcclxuICAgICAgICAgICAgY29uc3Qge3Bhc3NpdmVMaXN0ZW5lcjogYSwgYWN0aXZlTGlzdGVuZXJXaXRoQ2FwdHVyZTogaX0gPSBNKCksIHIgPSBQKCk7XHJcbiAgICAgICAgICAgIHMuZ2VzdHVyZXMgPyAodC4kd3JhcHBlckVsLm9mZih0LnRvdWNoRXZlbnRzLnN0YXJ0LCB6LCBhKSwgdC4kd3JhcHBlckVsLm9mZih0LnRvdWNoRXZlbnRzLmVuZCwgTCwgYSkpIDogXCJ0b3VjaHN0YXJ0XCIgPT09IHQudG91Y2hFdmVudHMuc3RhcnQgJiYgKHQuJHdyYXBwZXJFbC5vZmYodC50b3VjaEV2ZW50cy5zdGFydCwgciwgYiwgYSksIHQuJHdyYXBwZXJFbC5vZmYodC50b3VjaEV2ZW50cy5tb3ZlLCByLCB4LCBpKSwgdC4kd3JhcHBlckVsLm9mZih0LnRvdWNoRXZlbnRzLmVuZCwgciwgeSwgYSksIHQudG91Y2hFdmVudHMuY2FuY2VsICYmIHQuJHdyYXBwZXJFbC5vZmYodC50b3VjaEV2ZW50cy5jYW5jZWwsIHIsIHksIGEpKSwgdC4kd3JhcHBlckVsLm9mZih0LnRvdWNoRXZlbnRzLm1vdmUsIGAuJHt0LnBhcmFtcy56b29tLmNvbnRhaW5lckNsYXNzfWAsIEUsIGkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodC56b29tLCBcInNjYWxlXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiAoKSA9PiB2LCBzZXQoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHYgIT09IGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gbS4kaW1hZ2VFbCA/IG0uJGltYWdlRWxbMF0gOiB2b2lkIDAsIHMgPSBtLiRzbGlkZUVsID8gbS4kc2xpZGVFbFswXSA6IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICBpKFwiem9vbUNoYW5nZVwiLCBlLCB0LCBzKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdiA9IGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLCBhKFwiaW5pdFwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICB0LnBhcmFtcy56b29tLmVuYWJsZWQgJiYgTygpXHJcbiAgICAgICAgfSkpLCBhKFwiZGVzdHJveVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBJKClcclxuICAgICAgICB9KSksIGEoXCJ0b3VjaFN0YXJ0XCIsICgoZSwgcykgPT4ge1xyXG4gICAgICAgICAgICB0Lnpvb20uZW5hYmxlZCAmJiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IHQuZGV2aWNlO1xyXG4gICAgICAgICAgICAgICAgbS4kaW1hZ2VFbCAmJiAwICE9PSBtLiRpbWFnZUVsLmxlbmd0aCAmJiAoZi5pc1RvdWNoZWQgfHwgKHMuYW5kcm9pZCAmJiBlLmNhbmNlbGFibGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpLCBmLmlzVG91Y2hlZCA9ICEwLCBmLnRvdWNoZXNTdGFydC54ID0gXCJ0b3VjaHN0YXJ0XCIgPT09IGUudHlwZSA/IGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCA6IGUucGFnZVgsIGYudG91Y2hlc1N0YXJ0LnkgPSBcInRvdWNoc3RhcnRcIiA9PT0gZS50eXBlID8gZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIDogZS5wYWdlWSkpXHJcbiAgICAgICAgICAgIH0ocylcclxuICAgICAgICB9KSksIGEoXCJ0b3VjaEVuZFwiLCAoKGUsIHMpID0+IHtcclxuICAgICAgICAgICAgdC56b29tLmVuYWJsZWQgJiYgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHQuem9vbTtcclxuICAgICAgICAgICAgICAgIGlmICghbS4kaW1hZ2VFbCB8fCAwID09PSBtLiRpbWFnZUVsLmxlbmd0aCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmLmlzVG91Y2hlZCB8fCAhZi5pc01vdmVkKSByZXR1cm4gZi5pc1RvdWNoZWQgPSAhMSwgdm9pZCAoZi5pc01vdmVkID0gITEpO1xyXG4gICAgICAgICAgICAgICAgZi5pc1RvdWNoZWQgPSAhMSwgZi5pc01vdmVkID0gITE7XHJcbiAgICAgICAgICAgICAgICBsZXQgcyA9IDMwMCwgYSA9IDMwMDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBnLnggKiBzLCByID0gZi5jdXJyZW50WCArIGksIG4gPSBnLnkgKiBhLCBsID0gZi5jdXJyZW50WSArIG47XHJcbiAgICAgICAgICAgICAgICAwICE9PSBnLnggJiYgKHMgPSBNYXRoLmFicygociAtIGYuY3VycmVudFgpIC8gZy54KSksIDAgIT09IGcueSAmJiAoYSA9IE1hdGguYWJzKChsIC0gZi5jdXJyZW50WSkgLyBnLnkpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG8gPSBNYXRoLm1heChzLCBhKTtcclxuICAgICAgICAgICAgICAgIGYuY3VycmVudFggPSByLCBmLmN1cnJlbnRZID0gbDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBmLndpZHRoICogZS5zY2FsZSwgYyA9IGYuaGVpZ2h0ICogZS5zY2FsZTtcclxuICAgICAgICAgICAgICAgIGYubWluWCA9IE1hdGgubWluKG0uc2xpZGVXaWR0aCAvIDIgLSBkIC8gMiwgMCksIGYubWF4WCA9IC1mLm1pblgsIGYubWluWSA9IE1hdGgubWluKG0uc2xpZGVIZWlnaHQgLyAyIC0gYyAvIDIsIDApLCBmLm1heFkgPSAtZi5taW5ZLCBmLmN1cnJlbnRYID0gTWF0aC5tYXgoTWF0aC5taW4oZi5jdXJyZW50WCwgZi5tYXhYKSwgZi5taW5YKSwgZi5jdXJyZW50WSA9IE1hdGgubWF4KE1hdGgubWluKGYuY3VycmVudFksIGYubWF4WSksIGYubWluWSksIG0uJGltYWdlV3JhcEVsLnRyYW5zaXRpb24obykudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke2YuY3VycmVudFh9cHgsICR7Zi5jdXJyZW50WX1weCwwKWApXHJcbiAgICAgICAgICAgIH0oKVxyXG4gICAgICAgIH0pKSwgYShcImRvdWJsZVRhcFwiLCAoKGUsIHMpID0+IHtcclxuICAgICAgICAgICAgIXQuYW5pbWF0aW5nICYmIHQucGFyYW1zLnpvb20uZW5hYmxlZCAmJiB0Lnpvb20uZW5hYmxlZCAmJiB0LnBhcmFtcy56b29tLnRvZ2dsZSAmJiBTKHMpXHJcbiAgICAgICAgfSkpLCBhKFwidHJhbnNpdGlvbkVuZFwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICB0Lnpvb20uZW5hYmxlZCAmJiB0LnBhcmFtcy56b29tLmVuYWJsZWQgJiYgQygpXHJcbiAgICAgICAgfSkpLCBhKFwic2xpZGVDaGFuZ2VcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC56b29tLmVuYWJsZWQgJiYgdC5wYXJhbXMuem9vbS5lbmFibGVkICYmIHQucGFyYW1zLmNzc01vZGUgJiYgQygpXHJcbiAgICAgICAgfSkpLCBPYmplY3QuYXNzaWduKHQuem9vbSwge2VuYWJsZTogTywgZGlzYWJsZTogSSwgaW46IFQsIG91dDogJCwgdG9nZ2xlOiBTfSlcclxuICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgbGV0IHtzd2lwZXI6IHQsIGV4dGVuZFBhcmFtczogcywgb246IGEsIGVtaXQ6IGl9ID0gZTtcclxuICAgICAgICBzKHtcclxuICAgICAgICAgICAgbGF6eToge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tJblZpZXc6ICExLFxyXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogITEsXHJcbiAgICAgICAgICAgICAgICBsb2FkUHJldk5leHQ6ICExLFxyXG4gICAgICAgICAgICAgICAgbG9hZFByZXZOZXh0QW1vdW50OiAxLFxyXG4gICAgICAgICAgICAgICAgbG9hZE9uVHJhbnNpdGlvblN0YXJ0OiAhMSxcclxuICAgICAgICAgICAgICAgIHNjcm9sbGluZ0VsZW1lbnQ6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50Q2xhc3M6IFwic3dpcGVyLWxhenlcIixcclxuICAgICAgICAgICAgICAgIGxvYWRpbmdDbGFzczogXCJzd2lwZXItbGF6eS1sb2FkaW5nXCIsXHJcbiAgICAgICAgICAgICAgICBsb2FkZWRDbGFzczogXCJzd2lwZXItbGF6eS1sb2FkZWRcIixcclxuICAgICAgICAgICAgICAgIHByZWxvYWRlckNsYXNzOiBcInN3aXBlci1sYXp5LXByZWxvYWRlclwiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSwgdC5sYXp5ID0ge307XHJcbiAgICAgICAgbGV0IG4gPSAhMSwgbCA9ICExO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBvKGUsIHMpIHtcclxuICAgICAgICAgICAgdm9pZCAwID09PSBzICYmIChzID0gITApO1xyXG4gICAgICAgICAgICBjb25zdCBhID0gdC5wYXJhbXMubGF6eTtcclxuICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZSkgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAoMCA9PT0gdC5zbGlkZXMubGVuZ3RoKSByZXR1cm47XHJcbiAgICAgICAgICAgIGNvbnN0IHIgPSB0LnZpcnR1YWwgJiYgdC5wYXJhbXMudmlydHVhbC5lbmFibGVkID8gdC4kd3JhcHBlckVsLmNoaWxkcmVuKGAuJHt0LnBhcmFtcy5zbGlkZUNsYXNzfVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7ZX1cIl1gKSA6IHQuc2xpZGVzLmVxKGUpLFxyXG4gICAgICAgICAgICAgICAgbiA9IHIuZmluZChgLiR7YS5lbGVtZW50Q2xhc3N9Om5vdCguJHthLmxvYWRlZENsYXNzfSk6bm90KC4ke2EubG9hZGluZ0NsYXNzfSlgKTtcclxuICAgICAgICAgICAgIXIuaGFzQ2xhc3MoYS5lbGVtZW50Q2xhc3MpIHx8IHIuaGFzQ2xhc3MoYS5sb2FkZWRDbGFzcykgfHwgci5oYXNDbGFzcyhhLmxvYWRpbmdDbGFzcykgfHwgbi5wdXNoKHJbMF0pLCAwICE9PSBuLmxlbmd0aCAmJiBuLmVhY2goKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbiA9IGQoZSk7XHJcbiAgICAgICAgICAgICAgICBuLmFkZENsYXNzKGEubG9hZGluZ0NsYXNzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGwgPSBuLmF0dHIoXCJkYXRhLWJhY2tncm91bmRcIiksIGMgPSBuLmF0dHIoXCJkYXRhLXNyY1wiKSwgcCA9IG4uYXR0cihcImRhdGEtc3Jjc2V0XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIHUgPSBuLmF0dHIoXCJkYXRhLXNpemVzXCIpLCBoID0gbi5wYXJlbnQoXCJwaWN0dXJlXCIpO1xyXG4gICAgICAgICAgICAgICAgdC5sb2FkSW1hZ2UoblswXSwgYyB8fCBsLCBwLCB1LCAhMSwgKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSB0ICYmIHQgJiYgKCF0IHx8IHQucGFyYW1zKSAmJiAhdC5kZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGwgPyAobi5jc3MoXCJiYWNrZ3JvdW5kLWltYWdlXCIsIGB1cmwoXCIke2x9XCIpYCksIG4ucmVtb3ZlQXR0cihcImRhdGEtYmFja2dyb3VuZFwiKSkgOiAocCAmJiAobi5hdHRyKFwic3Jjc2V0XCIsIHApLCBuLnJlbW92ZUF0dHIoXCJkYXRhLXNyY3NldFwiKSksIHUgJiYgKG4uYXR0cihcInNpemVzXCIsIHUpLCBuLnJlbW92ZUF0dHIoXCJkYXRhLXNpemVzXCIpKSwgaC5sZW5ndGggJiYgaC5jaGlsZHJlbihcInNvdXJjZVwiKS5lYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBkKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5hdHRyKFwiZGF0YS1zcmNzZXRcIikgJiYgKHQuYXR0cihcInNyY3NldFwiLCB0LmF0dHIoXCJkYXRhLXNyY3NldFwiKSksIHQucmVtb3ZlQXR0cihcImRhdGEtc3Jjc2V0XCIpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSksIGMgJiYgKG4uYXR0cihcInNyY1wiLCBjKSwgbi5yZW1vdmVBdHRyKFwiZGF0YS1zcmNcIikpKSwgbi5hZGRDbGFzcyhhLmxvYWRlZENsYXNzKS5yZW1vdmVDbGFzcyhhLmxvYWRpbmdDbGFzcyksIHIuZmluZChgLiR7YS5wcmVsb2FkZXJDbGFzc31gKS5yZW1vdmUoKSwgdC5wYXJhbXMubG9vcCAmJiBzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gci5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5oYXNDbGFzcyh0LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8odC4kd3JhcHBlckVsLmNoaWxkcmVuKGBbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke2V9XCJdOm5vdCguJHt0LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzfSlgKS5pbmRleCgpLCAhMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyh0LiR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3QucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3N9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtlfVwiXWApLmluZGV4KCksICExKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkoXCJsYXp5SW1hZ2VSZWFkeVwiLCByWzBdLCBuWzBdKSwgdC5wYXJhbXMuYXV0b0hlaWdodCAmJiB0LnVwZGF0ZUF1dG9IZWlnaHQoKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pKSwgaShcImxhenlJbWFnZUxvYWRcIiwgclswXSwgblswXSlcclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7JHdyYXBwZXJFbDogZSwgcGFyYW1zOiBzLCBzbGlkZXM6IGEsIGFjdGl2ZUluZGV4OiBpfSA9IHQsIHIgPSB0LnZpcnR1YWwgJiYgcy52aXJ0dWFsLmVuYWJsZWQsXHJcbiAgICAgICAgICAgICAgICBuID0gcy5sYXp5O1xyXG4gICAgICAgICAgICBsZXQgYyA9IHMuc2xpZGVzUGVyVmlldztcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHAodCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5jaGlsZHJlbihgLiR7cy5zbGlkZUNsYXNzfVtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7dH1cIl1gKS5sZW5ndGgpIHJldHVybiAhMFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhW3RdKSByZXR1cm4gITA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gITFcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gdShlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gciA/IGQoZSkuYXR0cihcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCIpIDogZChlKS5pbmRleCgpXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChcImF1dG9cIiA9PT0gYyAmJiAoYyA9IDApLCBsIHx8IChsID0gITApLCB0LnBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzKSBlLmNoaWxkcmVuKGAuJHtzLnNsaWRlVmlzaWJsZUNsYXNzfWApLmVhY2goKGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgbyhyID8gZChlKS5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIikgOiBkKGUpLmluZGV4KCkpXHJcbiAgICAgICAgICAgIH0pKTsgZWxzZSBpZiAoYyA+IDEpIGZvciAobGV0IGUgPSBpOyBlIDwgaSArIGM7IGUgKz0gMSkgcChlKSAmJiBvKGUpOyBlbHNlIG8oaSk7XHJcbiAgICAgICAgICAgIGlmIChuLmxvYWRQcmV2TmV4dCkgaWYgKGMgPiAxIHx8IG4ubG9hZFByZXZOZXh0QW1vdW50ICYmIG4ubG9hZFByZXZOZXh0QW1vdW50ID4gMSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IG4ubG9hZFByZXZOZXh0QW1vdW50LCB0ID0gTWF0aC5jZWlsKGMpLCBzID0gTWF0aC5taW4oaSArIHQgKyBNYXRoLm1heChlLCB0KSwgYS5sZW5ndGgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBNYXRoLm1heChpIC0gTWF0aC5tYXgodCwgZSksIDApO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZSA9IGkgKyB0OyBlIDwgczsgZSArPSAxKSBwKGUpICYmIG8oZSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlID0gcjsgZSA8IGk7IGUgKz0gMSkgcChlKSAmJiBvKGUpXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gZS5jaGlsZHJlbihgLiR7cy5zbGlkZU5leHRDbGFzc31gKTtcclxuICAgICAgICAgICAgICAgIHQubGVuZ3RoID4gMCAmJiBvKHUodCkpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGUuY2hpbGRyZW4oYC4ke3Muc2xpZGVQcmV2Q2xhc3N9YCk7XHJcbiAgICAgICAgICAgICAgICBhLmxlbmd0aCA+IDAgJiYgbyh1KGEpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBwKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gcigpO1xyXG4gICAgICAgICAgICBpZiAoIXQgfHwgdC5kZXN0cm95ZWQpIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgcyA9IHQucGFyYW1zLmxhenkuc2Nyb2xsaW5nRWxlbWVudCA/IGQodC5wYXJhbXMubGF6eS5zY3JvbGxpbmdFbGVtZW50KSA6IGQoZSksIGEgPSBzWzBdID09PSBlLFxyXG4gICAgICAgICAgICAgICAgaSA9IGEgPyBlLmlubmVyV2lkdGggOiBzWzBdLm9mZnNldFdpZHRoLCBsID0gYSA/IGUuaW5uZXJIZWlnaHQgOiBzWzBdLm9mZnNldEhlaWdodCxcclxuICAgICAgICAgICAgICAgIG8gPSB0LiRlbC5vZmZzZXQoKSwge3J0bFRyYW5zbGF0ZTogdX0gPSB0O1xyXG4gICAgICAgICAgICBsZXQgaCA9ICExO1xyXG4gICAgICAgICAgICB1ICYmIChvLmxlZnQgLT0gdC4kZWxbMF0uc2Nyb2xsTGVmdCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG0gPSBbW28ubGVmdCwgby50b3BdLCBbby5sZWZ0ICsgdC53aWR0aCwgby50b3BdLCBbby5sZWZ0LCBvLnRvcCArIHQuaGVpZ2h0XSwgW28ubGVmdCArIHQud2lkdGgsIG8udG9wICsgdC5oZWlnaHRdXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgZSA9IDA7IGUgPCBtLmxlbmd0aDsgZSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gbVtlXTtcclxuICAgICAgICAgICAgICAgIGlmICh0WzBdID49IDAgJiYgdFswXSA8PSBpICYmIHRbMV0gPj0gMCAmJiB0WzFdIDw9IGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gdFswXSAmJiAwID09PSB0WzFdKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBoID0gITBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBmID0gIShcInRvdWNoc3RhcnRcIiAhPT0gdC50b3VjaEV2ZW50cy5zdGFydCB8fCAhdC5zdXBwb3J0LnBhc3NpdmVMaXN0ZW5lciB8fCAhdC5wYXJhbXMucGFzc2l2ZUxpc3RlbmVycykgJiYge1xyXG4gICAgICAgICAgICAgICAgcGFzc2l2ZTogITAsXHJcbiAgICAgICAgICAgICAgICBjYXB0dXJlOiAhMVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBoID8gKGMoKSwgcy5vZmYoXCJzY3JvbGxcIiwgcCwgZikpIDogbiB8fCAobiA9ICEwLCBzLm9uKFwic2Nyb2xsXCIsIHAsIGYpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYShcImJlZm9yZUluaXRcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC5wYXJhbXMubGF6eS5lbmFibGVkICYmIHQucGFyYW1zLnByZWxvYWRJbWFnZXMgJiYgKHQucGFyYW1zLnByZWxvYWRJbWFnZXMgPSAhMSlcclxuICAgICAgICB9KSksIGEoXCJpbml0XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHQucGFyYW1zLmxhenkuZW5hYmxlZCAmJiAodC5wYXJhbXMubGF6eS5jaGVja0luVmlldyA/IHAoKSA6IGMoKSlcclxuICAgICAgICB9KSksIGEoXCJzY3JvbGxcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC5wYXJhbXMuZnJlZU1vZGUgJiYgdC5wYXJhbXMuZnJlZU1vZGUuZW5hYmxlZCAmJiAhdC5wYXJhbXMuZnJlZU1vZGUuc3RpY2t5ICYmIGMoKVxyXG4gICAgICAgIH0pKSwgYShcInNjcm9sbGJhckRyYWdNb3ZlIHJlc2l6ZSBfZnJlZU1vZGVOb01vbWVudHVtUmVsZWFzZVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICB0LnBhcmFtcy5sYXp5LmVuYWJsZWQgJiYgKHQucGFyYW1zLmxhenkuY2hlY2tJblZpZXcgPyBwKCkgOiBjKCkpXHJcbiAgICAgICAgfSkpLCBhKFwidHJhbnNpdGlvblN0YXJ0XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHQucGFyYW1zLmxhenkuZW5hYmxlZCAmJiAodC5wYXJhbXMubGF6eS5sb2FkT25UcmFuc2l0aW9uU3RhcnQgfHwgIXQucGFyYW1zLmxhenkubG9hZE9uVHJhbnNpdGlvblN0YXJ0ICYmICFsKSAmJiAodC5wYXJhbXMubGF6eS5jaGVja0luVmlldyA/IHAoKSA6IGMoKSlcclxuICAgICAgICB9KSksIGEoXCJ0cmFuc2l0aW9uRW5kXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHQucGFyYW1zLmxhenkuZW5hYmxlZCAmJiAhdC5wYXJhbXMubGF6eS5sb2FkT25UcmFuc2l0aW9uU3RhcnQgJiYgKHQucGFyYW1zLmxhenkuY2hlY2tJblZpZXcgPyBwKCkgOiBjKCkpXHJcbiAgICAgICAgfSkpLCBhKFwic2xpZGVDaGFuZ2VcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qge2xhenk6IGUsIGNzc01vZGU6IHMsIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6IGEsIHRvdWNoUmVsZWFzZU9uRWRnZXM6IGksIHJlc2lzdGFuY2VSYXRpbzogcn0gPSB0LnBhcmFtcztcclxuICAgICAgICAgICAgZS5lbmFibGVkICYmIChzIHx8IGEgJiYgKGkgfHwgMCA9PT0gcikpICYmIGMoKVxyXG4gICAgICAgIH0pKSwgYShcImRlc3Ryb3lcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC4kZWwgJiYgdC4kZWwuZmluZChgLiR7dC5wYXJhbXMubGF6eS5sb2FkaW5nQ2xhc3N9YCkucmVtb3ZlQ2xhc3ModC5wYXJhbXMubGF6eS5sb2FkaW5nQ2xhc3MpXHJcbiAgICAgICAgfSkpLCBPYmplY3QuYXNzaWduKHQubGF6eSwge2xvYWQ6IGMsIGxvYWRJblNsaWRlOiBvfSlcclxuICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgbGV0IHtzd2lwZXI6IHQsIGV4dGVuZFBhcmFtczogcywgb246IGF9ID0gZTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaShlLCB0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZSwgdCwgcztcclxuICAgICAgICAgICAgICAgIHJldHVybiAoYSwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodCA9IC0xLCBlID0gYS5sZW5ndGg7IGUgLSB0ID4gMTspIHMgPSBlICsgdCA+PiAxLCBhW3NdIDw9IGkgPyB0ID0gcyA6IGUgPSBzO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0oKTtcclxuICAgICAgICAgICAgbGV0IGEsIGk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggPSBlLCB0aGlzLnkgPSB0LCB0aGlzLmxhc3RJbmRleCA9IGUubGVuZ3RoIC0gMSwgdGhpcy5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZSA/IChpID0gcyh0aGlzLngsIGUpLCBhID0gaSAtIDEsIChlIC0gdGhpcy54W2FdKSAqICh0aGlzLnlbaV0gLSB0aGlzLnlbYV0pIC8gKHRoaXMueFtpXSAtIHRoaXMueFthXSkgKyB0aGlzLnlbYV0pIDogMFxyXG4gICAgICAgICAgICB9LCB0aGlzXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByKCkge1xyXG4gICAgICAgICAgICB0LmNvbnRyb2xsZXIuY29udHJvbCAmJiB0LmNvbnRyb2xsZXIuc3BsaW5lICYmICh0LmNvbnRyb2xsZXIuc3BsaW5lID0gdm9pZCAwLCBkZWxldGUgdC5jb250cm9sbGVyLnNwbGluZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHMoe1xyXG4gICAgICAgICAgICBjb250cm9sbGVyOiB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sOiB2b2lkIDAsXHJcbiAgICAgICAgICAgICAgICBpbnZlcnNlOiAhMSxcclxuICAgICAgICAgICAgICAgIGJ5OiBcInNsaWRlXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLCB0LmNvbnRyb2xsZXIgPSB7Y29udHJvbDogdm9pZCAwfSwgYShcImJlZm9yZUluaXRcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC5jb250cm9sbGVyLmNvbnRyb2wgPSB0LnBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xcclxuICAgICAgICB9KSksIGEoXCJ1cGRhdGVcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgcigpXHJcbiAgICAgICAgfSkpLCBhKFwicmVzaXplXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHIoKVxyXG4gICAgICAgIH0pKSwgYShcIm9ic2VydmVyVXBkYXRlXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHIoKVxyXG4gICAgICAgIH0pKSwgYShcInNldFRyYW5zbGF0ZVwiLCAoKGUsIHMsIGEpID0+IHtcclxuICAgICAgICAgICAgdC5jb250cm9sbGVyLmNvbnRyb2wgJiYgdC5jb250cm9sbGVyLnNldFRyYW5zbGF0ZShzLCBhKVxyXG4gICAgICAgIH0pKSwgYShcInNldFRyYW5zaXRpb25cIiwgKChlLCBzLCBhKSA9PiB7XHJcbiAgICAgICAgICAgIHQuY29udHJvbGxlci5jb250cm9sICYmIHQuY29udHJvbGxlci5zZXRUcmFuc2l0aW9uKHMsIGEpXHJcbiAgICAgICAgfSkpLCBPYmplY3QuYXNzaWduKHQuY29udHJvbGxlciwge1xyXG4gICAgICAgICAgICBzZXRUcmFuc2xhdGU6IGZ1bmN0aW9uIChlLCBzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gdC5jb250cm9sbGVyLmNvbnRyb2w7XHJcbiAgICAgICAgICAgICAgICBsZXQgciwgbjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGwgPSB0LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG8oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSB0LnJ0bFRyYW5zbGF0ZSA/IC10LnRyYW5zbGF0ZSA6IHQudHJhbnNsYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIFwic2xpZGVcIiA9PT0gdC5wYXJhbXMuY29udHJvbGxlci5ieSAmJiAoIWZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuY29udHJvbGxlci5zcGxpbmUgfHwgKHQuY29udHJvbGxlci5zcGxpbmUgPSB0LnBhcmFtcy5sb29wID8gbmV3IGkodC5zbGlkZXNHcmlkLCBlLnNsaWRlc0dyaWQpIDogbmV3IGkodC5zbmFwR3JpZCwgZS5zbmFwR3JpZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgfShlKSwgbiA9IC10LmNvbnRyb2xsZXIuc3BsaW5lLmludGVycG9sYXRlKC1zKSksIG4gJiYgXCJjb250YWluZXJcIiAhPT0gdC5wYXJhbXMuY29udHJvbGxlci5ieSB8fCAociA9IChlLm1heFRyYW5zbGF0ZSgpIC0gZS5taW5UcmFuc2xhdGUoKSkgLyAodC5tYXhUcmFuc2xhdGUoKSAtIHQubWluVHJhbnNsYXRlKCkpLCBuID0gKHMgLSB0Lm1pblRyYW5zbGF0ZSgpKSAqIHIgKyBlLm1pblRyYW5zbGF0ZSgpKSwgdC5wYXJhbXMuY29udHJvbGxlci5pbnZlcnNlICYmIChuID0gZS5tYXhUcmFuc2xhdGUoKSAtIG4pLCBlLnVwZGF0ZVByb2dyZXNzKG4pLCBlLnNldFRyYW5zbGF0ZShuLCB0KSwgZS51cGRhdGVBY3RpdmVJbmRleCgpLCBlLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSBmb3IgKGxldCBlID0gMDsgZSA8IGEubGVuZ3RoOyBlICs9IDEpIGFbZV0gIT09IHMgJiYgYVtlXSBpbnN0YW5jZW9mIGwgJiYgbyhhW2VdKTsgZWxzZSBhIGluc3RhbmNlb2YgbCAmJiBzICE9PSBhICYmIG8oYSlcclxuICAgICAgICAgICAgfSwgc2V0VHJhbnNpdGlvbjogZnVuY3Rpb24gKGUsIHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSB0LmNvbnN0cnVjdG9yLCBpID0gdC5jb250cm9sbGVyLmNvbnRyb2w7XHJcbiAgICAgICAgICAgICAgICBsZXQgcjtcclxuXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBuKHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzLnNldFRyYW5zaXRpb24oZSwgdCksIDAgIT09IGUgJiYgKHMudHJhbnNpdGlvblN0YXJ0KCksIHMucGFyYW1zLmF1dG9IZWlnaHQgJiYgcCgoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzLnVwZGF0ZUF1dG9IZWlnaHQoKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pKSwgcy4kd3JhcHBlckVsLnRyYW5zaXRpb25FbmQoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSAmJiAocy5wYXJhbXMubG9vcCAmJiBcInNsaWRlXCIgPT09IHQucGFyYW1zLmNvbnRyb2xsZXIuYnkgJiYgcy5sb29wRml4KCksIHMudHJhbnNpdGlvbkVuZCgpKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pKSlcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpKSkgZm9yIChyID0gMDsgciA8IGkubGVuZ3RoOyByICs9IDEpIGlbcl0gIT09IHMgJiYgaVtyXSBpbnN0YW5jZW9mIGEgJiYgbihpW3JdKTsgZWxzZSBpIGluc3RhbmNlb2YgYSAmJiBzICE9PSBpICYmIG4oaSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9LCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGxldCB7c3dpcGVyOiB0LCBleHRlbmRQYXJhbXM6IHMsIG9uOiBhfSA9IGU7XHJcbiAgICAgICAgcyh7XHJcbiAgICAgICAgICAgIGExMXk6IHtcclxuICAgICAgICAgICAgICAgIGVuYWJsZWQ6ICEwLFxyXG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uQ2xhc3M6IFwic3dpcGVyLW5vdGlmaWNhdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgcHJldlNsaWRlTWVzc2FnZTogXCJQcmV2aW91cyBzbGlkZVwiLFxyXG4gICAgICAgICAgICAgICAgbmV4dFNsaWRlTWVzc2FnZTogXCJOZXh0IHNsaWRlXCIsXHJcbiAgICAgICAgICAgICAgICBmaXJzdFNsaWRlTWVzc2FnZTogXCJUaGlzIGlzIHRoZSBmaXJzdCBzbGlkZVwiLFxyXG4gICAgICAgICAgICAgICAgbGFzdFNsaWRlTWVzc2FnZTogXCJUaGlzIGlzIHRoZSBsYXN0IHNsaWRlXCIsXHJcbiAgICAgICAgICAgICAgICBwYWdpbmF0aW9uQnVsbGV0TWVzc2FnZTogXCJHbyB0byBzbGlkZSB7e2luZGV4fX1cIixcclxuICAgICAgICAgICAgICAgIHNsaWRlTGFiZWxNZXNzYWdlOiBcInt7aW5kZXh9fSAvIHt7c2xpZGVzTGVuZ3RofX1cIixcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lck1lc3NhZ2U6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJSb2xlRGVzY3JpcHRpb25NZXNzYWdlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgaXRlbVJvbGVEZXNjcmlwdGlvbk1lc3NhZ2U6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBzbGlkZVJvbGU6IFwiZ3JvdXBcIixcclxuICAgICAgICAgICAgICAgIGlkOiBudWxsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSwgdC5hMTF5ID0ge2NsaWNrZWQ6ICExfTtcclxuICAgICAgICBsZXQgaSA9IG51bGw7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHIoZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gaTtcclxuICAgICAgICAgICAgMCAhPT0gdC5sZW5ndGggJiYgKHQuaHRtbChcIlwiKSwgdC5odG1sKGUpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbihlKSB7XHJcbiAgICAgICAgICAgIGUuYXR0cihcInRhYkluZGV4XCIsIFwiMFwiKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbChlKSB7XHJcbiAgICAgICAgICAgIGUuYXR0cihcInRhYkluZGV4XCIsIFwiLTFcIilcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG8oZSwgdCkge1xyXG4gICAgICAgICAgICBlLmF0dHIoXCJyb2xlXCIsIHQpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjKGUsIHQpIHtcclxuICAgICAgICAgICAgZS5hdHRyKFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIiwgdClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHAoZSwgdCkge1xyXG4gICAgICAgICAgICBlLmF0dHIoXCJhcmlhLWxhYmVsXCIsIHQpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB1KGUpIHtcclxuICAgICAgICAgICAgZS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLCAhMClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGgoZSkge1xyXG4gICAgICAgICAgICBlLmF0dHIoXCJhcmlhLWRpc2FibGVkXCIsICExKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbShlKSB7XHJcbiAgICAgICAgICAgIGlmICgxMyAhPT0gZS5rZXlDb2RlICYmIDMyICE9PSBlLmtleUNvZGUpIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgcyA9IHQucGFyYW1zLmExMXksIGEgPSBkKGUudGFyZ2V0KTtcclxuICAgICAgICAgICAgdC5uYXZpZ2F0aW9uICYmIHQubmF2aWdhdGlvbi4kbmV4dEVsICYmIGEuaXModC5uYXZpZ2F0aW9uLiRuZXh0RWwpICYmICh0LmlzRW5kICYmICF0LnBhcmFtcy5sb29wIHx8IHQuc2xpZGVOZXh0KCksIHQuaXNFbmQgPyByKHMubGFzdFNsaWRlTWVzc2FnZSkgOiByKHMubmV4dFNsaWRlTWVzc2FnZSkpLCB0Lm5hdmlnYXRpb24gJiYgdC5uYXZpZ2F0aW9uLiRwcmV2RWwgJiYgYS5pcyh0Lm5hdmlnYXRpb24uJHByZXZFbCkgJiYgKHQuaXNCZWdpbm5pbmcgJiYgIXQucGFyYW1zLmxvb3AgfHwgdC5zbGlkZVByZXYoKSwgdC5pc0JlZ2lubmluZyA/IHIocy5maXJzdFNsaWRlTWVzc2FnZSkgOiByKHMucHJldlNsaWRlTWVzc2FnZSkpLCB0LnBhZ2luYXRpb24gJiYgYS5pcyhVKHQucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0Q2xhc3MpKSAmJiBhWzBdLmNsaWNrKClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGYoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0LnBhZ2luYXRpb24gJiYgdC5wYWdpbmF0aW9uLmJ1bGxldHMgJiYgdC5wYWdpbmF0aW9uLmJ1bGxldHMubGVuZ3RoXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZigpICYmIHQucGFyYW1zLnBhZ2luYXRpb24uY2xpY2thYmxlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB2ID0gKGUsIHQsIHMpID0+IHtcclxuICAgICAgICAgICAgbihlKSwgXCJCVVRUT05cIiAhPT0gZVswXS50YWdOYW1lICYmIChvKGUsIFwiYnV0dG9uXCIpLCBlLm9uKFwia2V5ZG93blwiLCBtKSksIHAoZSwgcyksIGZ1bmN0aW9uIChlLCB0KSB7XHJcbiAgICAgICAgICAgICAgICBlLmF0dHIoXCJhcmlhLWNvbnRyb2xzXCIsIHQpXHJcbiAgICAgICAgICAgIH0oZSwgdClcclxuICAgICAgICB9LCB3ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0LmExMXkuY2xpY2tlZCA9ICEwXHJcbiAgICAgICAgfSwgYiA9ICgpID0+IHtcclxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0LmRlc3Ryb3llZCB8fCAodC5hMTF5LmNsaWNrZWQgPSAhMSlcclxuICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICB9KSlcclxuICAgICAgICB9LCB4ID0gZSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0LmExMXkuY2xpY2tlZCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCBzID0gZS50YXJnZXQuY2xvc2VzdChgLiR7dC5wYXJhbXMuc2xpZGVDbGFzc31gKTtcclxuICAgICAgICAgICAgaWYgKCFzIHx8ICF0LnNsaWRlcy5pbmNsdWRlcyhzKSkgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCBhID0gdC5zbGlkZXMuaW5kZXhPZihzKSA9PT0gdC5hY3RpdmVJbmRleCxcclxuICAgICAgICAgICAgICAgIGkgPSB0LnBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzICYmIHQudmlzaWJsZVNsaWRlcyAmJiB0LnZpc2libGVTbGlkZXMuaW5jbHVkZXMocyk7XHJcbiAgICAgICAgICAgIGEgfHwgaSB8fCBlLnNvdXJjZUNhcGFiaWxpdGllcyAmJiBlLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzIHx8ICh0LmlzSG9yaXpvbnRhbCgpID8gdC5lbC5zY3JvbGxMZWZ0ID0gMCA6IHQuZWwuc2Nyb2xsVG9wID0gMCwgdC5zbGlkZVRvKHQuc2xpZGVzLmluZGV4T2YocyksIDApKVxyXG4gICAgICAgIH0sIHkgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0LnBhcmFtcy5hMTF5O1xyXG4gICAgICAgICAgICBlLml0ZW1Sb2xlRGVzY3JpcHRpb25NZXNzYWdlICYmIGMoZCh0LnNsaWRlcyksIGUuaXRlbVJvbGVEZXNjcmlwdGlvbk1lc3NhZ2UpLCBlLnNsaWRlUm9sZSAmJiBvKGQodC5zbGlkZXMpLCBlLnNsaWRlUm9sZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0LnBhcmFtcy5sb29wID8gdC5zbGlkZXMuZmlsdGVyKChlID0+ICFlLmNsYXNzTGlzdC5jb250YWlucyh0LnBhcmFtcy5zbGlkZUR1cGxpY2F0ZUNsYXNzKSkpLmxlbmd0aCA6IHQuc2xpZGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZS5zbGlkZUxhYmVsTWVzc2FnZSAmJiB0LnNsaWRlcy5lYWNoKCgoYSwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgciA9IGQoYSksIG4gPSB0LnBhcmFtcy5sb29wID8gcGFyc2VJbnQoci5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIiksIDEwKSA6IGk7XHJcbiAgICAgICAgICAgICAgICBwKHIsIGUuc2xpZGVMYWJlbE1lc3NhZ2UucmVwbGFjZSgvXFx7XFx7aW5kZXhcXH1cXH0vLCBuICsgMSkucmVwbGFjZSgvXFx7XFx7c2xpZGVzTGVuZ3RoXFx9XFx9LywgcykpXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgIH0sIEUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0LnBhcmFtcy5hMTF5O1xyXG4gICAgICAgICAgICB0LiRlbC5hcHBlbmQoaSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0LiRlbDtcclxuICAgICAgICAgICAgZS5jb250YWluZXJSb2xlRGVzY3JpcHRpb25NZXNzYWdlICYmIGMocywgZS5jb250YWluZXJSb2xlRGVzY3JpcHRpb25NZXNzYWdlKSwgZS5jb250YWluZXJNZXNzYWdlICYmIHAocywgZS5jb250YWluZXJNZXNzYWdlKTtcclxuICAgICAgICAgICAgY29uc3QgYSA9IHQuJHdyYXBwZXJFbCxcclxuICAgICAgICAgICAgICAgIHIgPSBlLmlkIHx8IGEuYXR0cihcImlkXCIpIHx8IGBzd2lwZXItd3JhcHBlci0ke24gPSAxNiwgdm9pZCAwID09PSBuICYmIChuID0gMTYpLCBcInhcIi5yZXBlYXQobikucmVwbGFjZSgveC9nLCAoKCkgPT4gTWF0aC5yb3VuZCgxNiAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDE2KSkpfWA7XHJcbiAgICAgICAgICAgIHZhciBuO1xyXG4gICAgICAgICAgICBjb25zdCBsID0gdC5wYXJhbXMuYXV0b3BsYXkgJiYgdC5wYXJhbXMuYXV0b3BsYXkuZW5hYmxlZCA/IFwib2ZmXCIgOiBcInBvbGl0ZVwiO1xyXG4gICAgICAgICAgICB2YXIgbztcclxuICAgICAgICAgICAgbGV0IGQsIHU7XHJcbiAgICAgICAgICAgIG8gPSByLCBhLmF0dHIoXCJpZFwiLCBvKSwgZnVuY3Rpb24gKGUsIHQpIHtcclxuICAgICAgICAgICAgICAgIGUuYXR0cihcImFyaWEtbGl2ZVwiLCB0KVxyXG4gICAgICAgICAgICB9KGEsIGwpLCB5KCksIHQubmF2aWdhdGlvbiAmJiB0Lm5hdmlnYXRpb24uJG5leHRFbCAmJiAoZCA9IHQubmF2aWdhdGlvbi4kbmV4dEVsKSwgdC5uYXZpZ2F0aW9uICYmIHQubmF2aWdhdGlvbi4kcHJldkVsICYmICh1ID0gdC5uYXZpZ2F0aW9uLiRwcmV2RWwpLCBkICYmIGQubGVuZ3RoICYmIHYoZCwgciwgZS5uZXh0U2xpZGVNZXNzYWdlKSwgdSAmJiB1Lmxlbmd0aCAmJiB2KHUsIHIsIGUucHJldlNsaWRlTWVzc2FnZSksIGcoKSAmJiB0LnBhZ2luYXRpb24uJGVsLm9uKFwia2V5ZG93blwiLCBVKHQucGFyYW1zLnBhZ2luYXRpb24uYnVsbGV0Q2xhc3MpLCBtKSwgdC4kZWwub24oXCJmb2N1c1wiLCB4LCAhMCksIHQuJGVsLm9uKFwicG9pbnRlcmRvd25cIiwgdywgITApLCB0LiRlbC5vbihcInBvaW50ZXJ1cFwiLCBiLCAhMClcclxuICAgICAgICB9O1xyXG4gICAgICAgIGEoXCJiZWZvcmVJbml0XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGkgPSBkKGA8c3BhbiBjbGFzcz1cIiR7dC5wYXJhbXMuYTExeS5ub3RpZmljYXRpb25DbGFzc31cIiBhcmlhLWxpdmU9XCJhc3NlcnRpdmVcIiBhcmlhLWF0b21pYz1cInRydWVcIj48L3NwYW4+YClcclxuICAgICAgICB9KSksIGEoXCJhZnRlckluaXRcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC5wYXJhbXMuYTExeS5lbmFibGVkICYmIEUoKVxyXG4gICAgICAgIH0pKSwgYShcInNsaWRlc0xlbmd0aENoYW5nZSBzbmFwR3JpZExlbmd0aENoYW5nZSBzbGlkZXNHcmlkTGVuZ3RoQ2hhbmdlXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHQucGFyYW1zLmExMXkuZW5hYmxlZCAmJiB5KClcclxuICAgICAgICB9KSksIGEoXCJmcm9tRWRnZSB0b0VkZ2UgYWZ0ZXJJbml0IGxvY2sgdW5sb2NrXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHQucGFyYW1zLmExMXkuZW5hYmxlZCAmJiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodC5wYXJhbXMubG9vcCB8fCB0LnBhcmFtcy5yZXdpbmQgfHwgIXQubmF2aWdhdGlvbikgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyRuZXh0RWw6IGUsICRwcmV2RWw6IHN9ID0gdC5uYXZpZ2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgcyAmJiBzLmxlbmd0aCA+IDAgJiYgKHQuaXNCZWdpbm5pbmcgPyAodShzKSwgbChzKSkgOiAoaChzKSwgbihzKSkpLCBlICYmIGUubGVuZ3RoID4gMCAmJiAodC5pc0VuZCA/ICh1KGUpLCBsKGUpKSA6IChoKGUpLCBuKGUpKSlcclxuICAgICAgICAgICAgfSgpXHJcbiAgICAgICAgfSkpLCBhKFwicGFnaW5hdGlvblVwZGF0ZVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICB0LnBhcmFtcy5hMTF5LmVuYWJsZWQgJiYgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHQucGFyYW1zLmExMXk7XHJcbiAgICAgICAgICAgICAgICBmKCkgJiYgdC5wYWdpbmF0aW9uLmJ1bGxldHMuZWFjaCgocyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYSA9IGQocyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdC5wYXJhbXMucGFnaW5hdGlvbi5jbGlja2FibGUgJiYgKG4oYSksIHQucGFyYW1zLnBhZ2luYXRpb24ucmVuZGVyQnVsbGV0IHx8IChvKGEsIFwiYnV0dG9uXCIpLCBwKGEsIGUucGFnaW5hdGlvbkJ1bGxldE1lc3NhZ2UucmVwbGFjZSgvXFx7XFx7aW5kZXhcXH1cXH0vLCBhLmluZGV4KCkgKyAxKSkpKSwgYS5pcyhgLiR7dC5wYXJhbXMucGFnaW5hdGlvbi5idWxsZXRBY3RpdmVDbGFzc31gKSA/IGEuYXR0cihcImFyaWEtY3VycmVudFwiLCBcInRydWVcIikgOiBhLnJlbW92ZUF0dHIoXCJhcmlhLWN1cnJlbnRcIilcclxuICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICB9KClcclxuICAgICAgICB9KSksIGEoXCJkZXN0cm95XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHQucGFyYW1zLmExMXkuZW5hYmxlZCAmJiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZSwgcztcclxuICAgICAgICAgICAgICAgIGkgJiYgaS5sZW5ndGggPiAwICYmIGkucmVtb3ZlKCksIHQubmF2aWdhdGlvbiAmJiB0Lm5hdmlnYXRpb24uJG5leHRFbCAmJiAoZSA9IHQubmF2aWdhdGlvbi4kbmV4dEVsKSwgdC5uYXZpZ2F0aW9uICYmIHQubmF2aWdhdGlvbi4kcHJldkVsICYmIChzID0gdC5uYXZpZ2F0aW9uLiRwcmV2RWwpLCBlICYmIGUub2ZmKFwia2V5ZG93blwiLCBtKSwgcyAmJiBzLm9mZihcImtleWRvd25cIiwgbSksIGcoKSAmJiB0LnBhZ2luYXRpb24uJGVsLm9mZihcImtleWRvd25cIiwgVSh0LnBhcmFtcy5wYWdpbmF0aW9uLmJ1bGxldENsYXNzKSwgbSksIHQuJGVsLm9mZihcImZvY3VzXCIsIHgsICEwKSwgdC4kZWwub2ZmKFwicG9pbnRlcmRvd25cIiwgdywgITApLCB0LiRlbC5vZmYoXCJwb2ludGVydXBcIiwgYiwgITApXHJcbiAgICAgICAgICAgIH0oKVxyXG4gICAgICAgIH0pKVxyXG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBsZXQge3N3aXBlcjogdCwgZXh0ZW5kUGFyYW1zOiBzLCBvbjogYX0gPSBlO1xyXG4gICAgICAgIHMoe2hpc3Rvcnk6IHtlbmFibGVkOiAhMSwgcm9vdDogXCJcIiwgcmVwbGFjZVN0YXRlOiAhMSwga2V5OiBcInNsaWRlc1wiLCBrZWVwUXVlcnk6ICExfX0pO1xyXG4gICAgICAgIGxldCBpID0gITEsIG4gPSB7fTtcclxuICAgICAgICBjb25zdCBsID0gZSA9PiBlLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzKy9nLCBcIi1cIikucmVwbGFjZSgvW15cXHctXSsvZywgXCJcIikucmVwbGFjZSgvLS0rL2csIFwiLVwiKS5yZXBsYWNlKC9eLSsvLCBcIlwiKS5yZXBsYWNlKC8tKyQvLCBcIlwiKSxcclxuICAgICAgICAgICAgbyA9IGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHIoKTtcclxuICAgICAgICAgICAgICAgIGxldCBzO1xyXG4gICAgICAgICAgICAgICAgcyA9IGUgPyBuZXcgVVJMKGUpIDogdC5sb2NhdGlvbjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBzLnBhdGhuYW1lLnNsaWNlKDEpLnNwbGl0KFwiL1wiKS5maWx0ZXIoKGUgPT4gXCJcIiAhPT0gZSkpLCBpID0gYS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge2tleTogYVtpIC0gMl0sIHZhbHVlOiBhW2kgLSAxXX1cclxuICAgICAgICAgICAgfSwgZCA9IChlLCBzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpIHx8ICF0LnBhcmFtcy5oaXN0b3J5LmVuYWJsZWQpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGxldCBuO1xyXG4gICAgICAgICAgICAgICAgbiA9IHQucGFyYW1zLnVybCA/IG5ldyBVUkwodC5wYXJhbXMudXJsKSA6IGEubG9jYXRpb247XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvID0gdC5zbGlkZXMuZXEocyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZCA9IGwoby5hdHRyKFwiZGF0YS1oaXN0b3J5XCIpKTtcclxuICAgICAgICAgICAgICAgIGlmICh0LnBhcmFtcy5oaXN0b3J5LnJvb3QubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzID0gdC5wYXJhbXMuaGlzdG9yeS5yb290O1xyXG4gICAgICAgICAgICAgICAgICAgIFwiL1wiID09PSBzW3MubGVuZ3RoIC0gMV0gJiYgKHMgPSBzLnNsaWNlKDAsIHMubGVuZ3RoIC0gMSkpLCBkID0gYCR7c30vJHtlfS8ke2R9YFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIG4ucGF0aG5hbWUuaW5jbHVkZXMoZSkgfHwgKGQgPSBgJHtlfS8ke2R9YCk7XHJcbiAgICAgICAgICAgICAgICB0LnBhcmFtcy5oaXN0b3J5LmtlZXBRdWVyeSAmJiAoZCArPSBuLnNlYXJjaCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gYS5oaXN0b3J5LnN0YXRlO1xyXG4gICAgICAgICAgICAgICAgYyAmJiBjLnZhbHVlID09PSBkIHx8ICh0LnBhcmFtcy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSA/IGEuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe3ZhbHVlOiBkfSwgbnVsbCwgZCkgOiBhLmhpc3RvcnkucHVzaFN0YXRlKHt2YWx1ZTogZH0sIG51bGwsIGQpKVxyXG4gICAgICAgICAgICB9LCBjID0gKGUsIHMsIGEpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChzKSBmb3IgKGxldCBpID0gMCwgciA9IHQuc2xpZGVzLmxlbmd0aDsgaSA8IHI7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSB0LnNsaWRlcy5lcShpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobChyLmF0dHIoXCJkYXRhLWhpc3RvcnlcIikpID09PSBzICYmICFyLmhhc0NsYXNzKHQucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSByLmluZGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuc2xpZGVUbyhzLCBlLCBhKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB0LnNsaWRlVG8oMCwgZSwgYSlcclxuICAgICAgICAgICAgfSwgcCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIG4gPSBvKHQucGFyYW1zLnVybCksIGModC5wYXJhbXMuc3BlZWQsIG4udmFsdWUsICExKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIGEoXCJpbml0XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHQucGFyYW1zLmhpc3RvcnkuZW5hYmxlZCAmJiAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHIoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0LnBhcmFtcy5oaXN0b3J5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlLmhpc3RvcnkgfHwgIWUuaGlzdG9yeS5wdXNoU3RhdGUpIHJldHVybiB0LnBhcmFtcy5oaXN0b3J5LmVuYWJsZWQgPSAhMSwgdm9pZCAodC5wYXJhbXMuaGFzaE5hdmlnYXRpb24uZW5hYmxlZCA9ICEwKTtcclxuICAgICAgICAgICAgICAgICAgICBpID0gITAsIG4gPSBvKHQucGFyYW1zLnVybCksIChuLmtleSB8fCBuLnZhbHVlKSAmJiAoYygwLCBuLnZhbHVlLCB0LnBhcmFtcy5ydW5DYWxsYmFja3NPbkluaXQpLCB0LnBhcmFtcy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSB8fCBlLmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCBwKSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkoKVxyXG4gICAgICAgIH0pKSwgYShcImRlc3Ryb3lcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgdC5wYXJhbXMuaGlzdG9yeS5lbmFibGVkICYmICgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gcigpO1xyXG4gICAgICAgICAgICAgICAgdC5wYXJhbXMuaGlzdG9yeS5yZXBsYWNlU3RhdGUgfHwgZS5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgcClcclxuICAgICAgICAgICAgfSkoKVxyXG4gICAgICAgIH0pKSwgYShcInRyYW5zaXRpb25FbmQgX2ZyZWVNb2RlTm9Nb21lbnR1bVJlbGVhc2VcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgaSAmJiBkKHQucGFyYW1zLmhpc3Rvcnkua2V5LCB0LmFjdGl2ZUluZGV4KVxyXG4gICAgICAgIH0pKSwgYShcInNsaWRlQ2hhbmdlXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGkgJiYgdC5wYXJhbXMuY3NzTW9kZSAmJiBkKHQucGFyYW1zLmhpc3Rvcnkua2V5LCB0LmFjdGl2ZUluZGV4KVxyXG4gICAgICAgIH0pKVxyXG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBsZXQge3N3aXBlcjogdCwgZXh0ZW5kUGFyYW1zOiBzLCBlbWl0OiBpLCBvbjogbn0gPSBlLCBsID0gITE7XHJcbiAgICAgICAgY29uc3QgbyA9IGEoKSwgYyA9IHIoKTtcclxuICAgICAgICBzKHtoYXNoTmF2aWdhdGlvbjoge2VuYWJsZWQ6ICExLCByZXBsYWNlU3RhdGU6ICExLCB3YXRjaFN0YXRlOiAhMX19KTtcclxuICAgICAgICBjb25zdCBwID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpKFwiaGFzaENoYW5nZVwiKTtcclxuICAgICAgICAgICAgY29uc3QgZSA9IG8ubG9jYXRpb24uaGFzaC5yZXBsYWNlKFwiI1wiLCBcIlwiKTtcclxuICAgICAgICAgICAgaWYgKGUgIT09IHQuc2xpZGVzLmVxKHQuYWN0aXZlSW5kZXgpLmF0dHIoXCJkYXRhLWhhc2hcIikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSB0LiR3cmFwcGVyRWwuY2hpbGRyZW4oYC4ke3QucGFyYW1zLnNsaWRlQ2xhc3N9W2RhdGEtaGFzaD1cIiR7ZX1cIl1gKS5pbmRleCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gcykgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgdC5zbGlkZVRvKHMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB1ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAobCAmJiB0LnBhcmFtcy5oYXNoTmF2aWdhdGlvbi5lbmFibGVkKSBpZiAodC5wYXJhbXMuaGFzaE5hdmlnYXRpb24ucmVwbGFjZVN0YXRlICYmIGMuaGlzdG9yeSAmJiBjLmhpc3RvcnkucmVwbGFjZVN0YXRlKSBjLmhpc3RvcnkucmVwbGFjZVN0YXRlKG51bGwsIG51bGwsIGAjJHt0LnNsaWRlcy5lcSh0LmFjdGl2ZUluZGV4KS5hdHRyKFwiZGF0YS1oYXNoXCIpfWAgfHwgXCJcIiksIGkoXCJoYXNoU2V0XCIpOyBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSB0LnNsaWRlcy5lcSh0LmFjdGl2ZUluZGV4KSwgcyA9IGUuYXR0cihcImRhdGEtaGFzaFwiKSB8fCBlLmF0dHIoXCJkYXRhLWhpc3RvcnlcIik7XHJcbiAgICAgICAgICAgICAgICBvLmxvY2F0aW9uLmhhc2ggPSBzIHx8IFwiXCIsIGkoXCJoYXNoU2V0XCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIG4oXCJpbml0XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHQucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWQgJiYgKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdC5wYXJhbXMuaGFzaE5hdmlnYXRpb24uZW5hYmxlZCB8fCB0LnBhcmFtcy5oaXN0b3J5ICYmIHQucGFyYW1zLmhpc3RvcnkuZW5hYmxlZCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgbCA9ICEwO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IG8ubG9jYXRpb24uaGFzaC5yZXBsYWNlKFwiI1wiLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgYSA9IDAsIGkgPSB0LnNsaWRlcy5sZW5ndGg7IGEgPCBpOyBhICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaSA9IHQuc2xpZGVzLmVxKGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGkuYXR0cihcImRhdGEtaGFzaFwiKSB8fCBpLmF0dHIoXCJkYXRhLWhpc3RvcnlcIikpID09PSBlICYmICFpLmhhc0NsYXNzKHQucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gaS5pbmRleCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5zbGlkZVRvKGUsIHMsIHQucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCwgITApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0LnBhcmFtcy5oYXNoTmF2aWdhdGlvbi53YXRjaFN0YXRlICYmIGQoYykub24oXCJoYXNoY2hhbmdlXCIsIHApXHJcbiAgICAgICAgICAgIH0pKClcclxuICAgICAgICB9KSksIG4oXCJkZXN0cm95XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHQucGFyYW1zLmhhc2hOYXZpZ2F0aW9uLmVuYWJsZWQgJiYgdC5wYXJhbXMuaGFzaE5hdmlnYXRpb24ud2F0Y2hTdGF0ZSAmJiBkKGMpLm9mZihcImhhc2hjaGFuZ2VcIiwgcClcclxuICAgICAgICB9KSksIG4oXCJ0cmFuc2l0aW9uRW5kIF9mcmVlTW9kZU5vTW9tZW50dW1SZWxlYXNlXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGwgJiYgdSgpXHJcbiAgICAgICAgfSkpLCBuKFwic2xpZGVDaGFuZ2VcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgbCAmJiB0LnBhcmFtcy5jc3NNb2RlICYmIHUoKVxyXG4gICAgICAgIH0pKVxyXG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBsZXQgdCwge3N3aXBlcjogcywgZXh0ZW5kUGFyYW1zOiBpLCBvbjogciwgZW1pdDogbn0gPSBlO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBsKCkge1xyXG4gICAgICAgICAgICBpZiAoIXMuc2l6ZSkgcmV0dXJuIHMuYXV0b3BsYXkucnVubmluZyA9ICExLCB2b2lkIChzLmF1dG9wbGF5LnBhdXNlZCA9ICExKTtcclxuICAgICAgICAgICAgY29uc3QgZSA9IHMuc2xpZGVzLmVxKHMuYWN0aXZlSW5kZXgpO1xyXG4gICAgICAgICAgICBsZXQgYSA9IHMucGFyYW1zLmF1dG9wbGF5LmRlbGF5O1xyXG4gICAgICAgICAgICBlLmF0dHIoXCJkYXRhLXN3aXBlci1hdXRvcGxheVwiKSAmJiAoYSA9IGUuYXR0cihcImRhdGEtc3dpcGVyLWF1dG9wbGF5XCIpIHx8IHMucGFyYW1zLmF1dG9wbGF5LmRlbGF5KSwgY2xlYXJUaW1lb3V0KHQpLCB0ID0gcCgoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGU7XHJcbiAgICAgICAgICAgICAgICBzLnBhcmFtcy5hdXRvcGxheS5yZXZlcnNlRGlyZWN0aW9uID8gcy5wYXJhbXMubG9vcCA/IChzLmxvb3BGaXgoKSwgZSA9IHMuc2xpZGVQcmV2KHMucGFyYW1zLnNwZWVkLCAhMCwgITApLCBuKFwiYXV0b3BsYXlcIikpIDogcy5pc0JlZ2lubmluZyA/IHMucGFyYW1zLmF1dG9wbGF5LnN0b3BPbkxhc3RTbGlkZSA/IGQoKSA6IChlID0gcy5zbGlkZVRvKHMuc2xpZGVzLmxlbmd0aCAtIDEsIHMucGFyYW1zLnNwZWVkLCAhMCwgITApLCBuKFwiYXV0b3BsYXlcIikpIDogKGUgPSBzLnNsaWRlUHJldihzLnBhcmFtcy5zcGVlZCwgITAsICEwKSwgbihcImF1dG9wbGF5XCIpKSA6IHMucGFyYW1zLmxvb3AgPyAocy5sb29wRml4KCksIGUgPSBzLnNsaWRlTmV4dChzLnBhcmFtcy5zcGVlZCwgITAsICEwKSwgbihcImF1dG9wbGF5XCIpKSA6IHMuaXNFbmQgPyBzLnBhcmFtcy5hdXRvcGxheS5zdG9wT25MYXN0U2xpZGUgPyBkKCkgOiAoZSA9IHMuc2xpZGVUbygwLCBzLnBhcmFtcy5zcGVlZCwgITAsICEwKSwgbihcImF1dG9wbGF5XCIpKSA6IChlID0gcy5zbGlkZU5leHQocy5wYXJhbXMuc3BlZWQsICEwLCAhMCksIG4oXCJhdXRvcGxheVwiKSksIChzLnBhcmFtcy5jc3NNb2RlICYmIHMuYXV0b3BsYXkucnVubmluZyB8fCAhMSA9PT0gZSkgJiYgbCgpXHJcbiAgICAgICAgICAgIH0pLCBhKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gdCAmJiAoIXMuYXV0b3BsYXkucnVubmluZyAmJiAocy5hdXRvcGxheS5ydW5uaW5nID0gITAsIG4oXCJhdXRvcGxheVN0YXJ0XCIpLCBsKCksICEwKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIXMuYXV0b3BsYXkucnVubmluZyAmJiAodm9pZCAwICE9PSB0ICYmICh0ICYmIChjbGVhclRpbWVvdXQodCksIHQgPSB2b2lkIDApLCBzLmF1dG9wbGF5LnJ1bm5pbmcgPSAhMSwgbihcImF1dG9wbGF5U3RvcFwiKSwgITApKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYyhlKSB7XHJcbiAgICAgICAgICAgIHMuYXV0b3BsYXkucnVubmluZyAmJiAocy5hdXRvcGxheS5wYXVzZWQgfHwgKHQgJiYgY2xlYXJUaW1lb3V0KHQpLCBzLmF1dG9wbGF5LnBhdXNlZCA9ICEwLCAwICE9PSBlICYmIHMucGFyYW1zLmF1dG9wbGF5LndhaXRGb3JUcmFuc2l0aW9uID8gW1widHJhbnNpdGlvbmVuZFwiLCBcIndlYmtpdFRyYW5zaXRpb25FbmRcIl0uZm9yRWFjaCgoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzLiR3cmFwcGVyRWxbMF0uYWRkRXZlbnRMaXN0ZW5lcihlLCBoKVxyXG4gICAgICAgICAgICB9KSkgOiAocy5hdXRvcGxheS5wYXVzZWQgPSAhMSwgbCgpKSkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB1KCkge1xyXG4gICAgICAgICAgICBjb25zdCBlID0gYSgpO1xyXG4gICAgICAgICAgICBcImhpZGRlblwiID09PSBlLnZpc2liaWxpdHlTdGF0ZSAmJiBzLmF1dG9wbGF5LnJ1bm5pbmcgJiYgYygpLCBcInZpc2libGVcIiA9PT0gZS52aXNpYmlsaXR5U3RhdGUgJiYgcy5hdXRvcGxheS5wYXVzZWQgJiYgKGwoKSwgcy5hdXRvcGxheS5wYXVzZWQgPSAhMSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGgoZSkge1xyXG4gICAgICAgICAgICBzICYmICFzLmRlc3Ryb3llZCAmJiBzLiR3cmFwcGVyRWwgJiYgZS50YXJnZXQgPT09IHMuJHdyYXBwZXJFbFswXSAmJiAoW1widHJhbnNpdGlvbmVuZFwiLCBcIndlYmtpdFRyYW5zaXRpb25FbmRcIl0uZm9yRWFjaCgoZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzLiR3cmFwcGVyRWxbMF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCBoKVxyXG4gICAgICAgICAgICB9KSksIHMuYXV0b3BsYXkucGF1c2VkID0gITEsIHMuYXV0b3BsYXkucnVubmluZyA/IGwoKSA6IGQoKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG0oKSB7XHJcbiAgICAgICAgICAgIHMucGFyYW1zLmF1dG9wbGF5LmRpc2FibGVPbkludGVyYWN0aW9uID8gZCgpIDogKG4oXCJhdXRvcGxheVBhdXNlXCIpLCBjKCkpLCBbXCJ0cmFuc2l0aW9uZW5kXCIsIFwid2Via2l0VHJhbnNpdGlvbkVuZFwiXS5mb3JFYWNoKChlID0+IHtcclxuICAgICAgICAgICAgICAgIHMuJHdyYXBwZXJFbFswXS5yZW1vdmVFdmVudExpc3RlbmVyKGUsIGgpXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZigpIHtcclxuICAgICAgICAgICAgcy5wYXJhbXMuYXV0b3BsYXkuZGlzYWJsZU9uSW50ZXJhY3Rpb24gfHwgKHMuYXV0b3BsYXkucGF1c2VkID0gITEsIG4oXCJhdXRvcGxheVJlc3VtZVwiKSwgbCgpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcy5hdXRvcGxheSA9IHtydW5uaW5nOiAhMSwgcGF1c2VkOiAhMX0sIGkoe1xyXG4gICAgICAgICAgICBhdXRvcGxheToge1xyXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogITEsXHJcbiAgICAgICAgICAgICAgICBkZWxheTogM2UzLFxyXG4gICAgICAgICAgICAgICAgd2FpdEZvclRyYW5zaXRpb246ICEwLFxyXG4gICAgICAgICAgICAgICAgZGlzYWJsZU9uSW50ZXJhY3Rpb246ICEwLFxyXG4gICAgICAgICAgICAgICAgc3RvcE9uTGFzdFNsaWRlOiAhMSxcclxuICAgICAgICAgICAgICAgIHJldmVyc2VEaXJlY3Rpb246ICExLFxyXG4gICAgICAgICAgICAgICAgcGF1c2VPbk1vdXNlRW50ZXI6ICExXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSwgcihcImluaXRcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHMucGFyYW1zLmF1dG9wbGF5LmVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIG8oKTtcclxuICAgICAgICAgICAgICAgIGEoKS5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB1KSwgcy5wYXJhbXMuYXV0b3BsYXkucGF1c2VPbk1vdXNlRW50ZXIgJiYgKHMuJGVsLm9uKFwibW91c2VlbnRlclwiLCBtKSwgcy4kZWwub24oXCJtb3VzZWxlYXZlXCIsIGYpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpLCByKFwiYmVmb3JlVHJhbnNpdGlvblN0YXJ0XCIsICgoZSwgdCwgYSkgPT4ge1xyXG4gICAgICAgICAgICBzLmF1dG9wbGF5LnJ1bm5pbmcgJiYgKGEgfHwgIXMucGFyYW1zLmF1dG9wbGF5LmRpc2FibGVPbkludGVyYWN0aW9uID8gcy5hdXRvcGxheS5wYXVzZSh0KSA6IGQoKSlcclxuICAgICAgICB9KSksIHIoXCJzbGlkZXJGaXJzdE1vdmVcIiwgKCgpID0+IHtcclxuICAgICAgICAgICAgcy5hdXRvcGxheS5ydW5uaW5nICYmIChzLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbiA/IGQoKSA6IGMoKSlcclxuICAgICAgICB9KSksIHIoXCJ0b3VjaEVuZFwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBzLnBhcmFtcy5jc3NNb2RlICYmIHMuYXV0b3BsYXkucGF1c2VkICYmICFzLnBhcmFtcy5hdXRvcGxheS5kaXNhYmxlT25JbnRlcmFjdGlvbiAmJiBsKClcclxuICAgICAgICB9KSksIHIoXCJkZXN0cm95XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIHMuJGVsLm9mZihcIm1vdXNlZW50ZXJcIiwgbSksIHMuJGVsLm9mZihcIm1vdXNlbGVhdmVcIiwgZiksIHMuYXV0b3BsYXkucnVubmluZyAmJiBkKCk7XHJcbiAgICAgICAgICAgIGEoKS5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB1KVxyXG4gICAgICAgIH0pKSwgT2JqZWN0LmFzc2lnbihzLmF1dG9wbGF5LCB7cGF1c2U6IGMsIHJ1bjogbCwgc3RhcnQ6IG8sIHN0b3A6IGR9KVxyXG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBsZXQge3N3aXBlcjogdCwgZXh0ZW5kUGFyYW1zOiBzLCBvbjogYX0gPSBlO1xyXG4gICAgICAgIHMoe1xyXG4gICAgICAgICAgICB0aHVtYnM6IHtcclxuICAgICAgICAgICAgICAgIHN3aXBlcjogbnVsbCxcclxuICAgICAgICAgICAgICAgIG11bHRpcGxlQWN0aXZlVGh1bWJzOiAhMCxcclxuICAgICAgICAgICAgICAgIGF1dG9TY3JvbGxPZmZzZXQ6IDAsXHJcbiAgICAgICAgICAgICAgICBzbGlkZVRodW1iQWN0aXZlQ2xhc3M6IFwic3dpcGVyLXNsaWRlLXRodW1iLWFjdGl2ZVwiLFxyXG4gICAgICAgICAgICAgICAgdGh1bWJzQ29udGFpbmVyQ2xhc3M6IFwic3dpcGVyLXRodW1ic1wiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgaSA9ICExLCByID0gITE7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG4oKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0LnRodW1icy5zd2lwZXI7XHJcbiAgICAgICAgICAgIGlmICghZSB8fCBlLmRlc3Ryb3llZCkgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCBzID0gZS5jbGlja2VkSW5kZXgsIGEgPSBlLmNsaWNrZWRTbGlkZTtcclxuICAgICAgICAgICAgaWYgKGEgJiYgZChhKS5oYXNDbGFzcyh0LnBhcmFtcy50aHVtYnMuc2xpZGVUaHVtYkFjdGl2ZUNsYXNzKSkgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAobnVsbCA9PSBzKSByZXR1cm47XHJcbiAgICAgICAgICAgIGxldCBpO1xyXG4gICAgICAgICAgICBpZiAoaSA9IGUucGFyYW1zLmxvb3AgPyBwYXJzZUludChkKGUuY2xpY2tlZFNsaWRlKS5hdHRyKFwiZGF0YS1zd2lwZXItc2xpZGUtaW5kZXhcIiksIDEwKSA6IHMsIHQucGFyYW1zLmxvb3ApIHtcclxuICAgICAgICAgICAgICAgIGxldCBlID0gdC5hY3RpdmVJbmRleDtcclxuICAgICAgICAgICAgICAgIHQuc2xpZGVzLmVxKGUpLmhhc0NsYXNzKHQucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpICYmICh0Lmxvb3BGaXgoKSwgdC5fY2xpZW50TGVmdCA9IHQuJHdyYXBwZXJFbFswXS5jbGllbnRMZWZ0LCBlID0gdC5hY3RpdmVJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gdC5zbGlkZXMuZXEoZSkucHJldkFsbChgW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtpfVwiXWApLmVxKDApLmluZGV4KCksXHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IHQuc2xpZGVzLmVxKGUpLm5leHRBbGwoYFtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7aX1cIl1gKS5lcSgwKS5pbmRleCgpO1xyXG4gICAgICAgICAgICAgICAgaSA9IHZvaWQgMCA9PT0gcyA/IGEgOiB2b2lkIDAgPT09IGEgPyBzIDogYSAtIGUgPCBlIC0gcyA/IGEgOiBzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdC5zbGlkZVRvKGkpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBsKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7dGh1bWJzOiBlfSA9IHQucGFyYW1zO1xyXG4gICAgICAgICAgICBpZiAoaSkgcmV0dXJuICExO1xyXG4gICAgICAgICAgICBpID0gITA7XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0LmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICBpZiAoZS5zd2lwZXIgaW5zdGFuY2VvZiBzKSB0LnRodW1icy5zd2lwZXIgPSBlLnN3aXBlciwgT2JqZWN0LmFzc2lnbih0LnRodW1icy5zd2lwZXIub3JpZ2luYWxQYXJhbXMsIHtcclxuICAgICAgICAgICAgICAgIHdhdGNoU2xpZGVzUHJvZ3Jlc3M6ICEwLFxyXG4gICAgICAgICAgICAgICAgc2xpZGVUb0NsaWNrZWRTbGlkZTogITFcclxuICAgICAgICAgICAgfSksIE9iamVjdC5hc3NpZ24odC50aHVtYnMuc3dpcGVyLnBhcmFtcywge1xyXG4gICAgICAgICAgICAgICAgd2F0Y2hTbGlkZXNQcm9ncmVzczogITAsXHJcbiAgICAgICAgICAgICAgICBzbGlkZVRvQ2xpY2tlZFNsaWRlOiAhMVxyXG4gICAgICAgICAgICB9KTsgZWxzZSBpZiAobShlLnN3aXBlcikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBPYmplY3QuYXNzaWduKHt9LCBlLnN3aXBlcik7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGEsIHt3YXRjaFNsaWRlc1Byb2dyZXNzOiAhMCwgc2xpZGVUb0NsaWNrZWRTbGlkZTogITF9KSwgdC50aHVtYnMuc3dpcGVyID0gbmV3IHMoYSksIHIgPSAhMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0LnRodW1icy5zd2lwZXIuJGVsLmFkZENsYXNzKHQucGFyYW1zLnRodW1icy50aHVtYnNDb250YWluZXJDbGFzcyksIHQudGh1bWJzLnN3aXBlci5vbihcInRhcFwiLCBuKSwgITBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG8oZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzID0gdC50aHVtYnMuc3dpcGVyO1xyXG4gICAgICAgICAgICBpZiAoIXMgfHwgcy5kZXN0cm95ZWQpIHJldHVybjtcclxuICAgICAgICAgICAgY29uc3QgYSA9IFwiYXV0b1wiID09PSBzLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID8gcy5zbGlkZXNQZXJWaWV3RHluYW1pYygpIDogcy5wYXJhbXMuc2xpZGVzUGVyVmlldztcclxuICAgICAgICAgICAgbGV0IGkgPSAxO1xyXG4gICAgICAgICAgICBjb25zdCByID0gdC5wYXJhbXMudGh1bWJzLnNsaWRlVGh1bWJBY3RpdmVDbGFzcztcclxuICAgICAgICAgICAgaWYgKHQucGFyYW1zLnNsaWRlc1BlclZpZXcgPiAxICYmICF0LnBhcmFtcy5jZW50ZXJlZFNsaWRlcyAmJiAoaSA9IHQucGFyYW1zLnNsaWRlc1BlclZpZXcpLCB0LnBhcmFtcy50aHVtYnMubXVsdGlwbGVBY3RpdmVUaHVtYnMgfHwgKGkgPSAxKSwgaSA9IE1hdGguZmxvb3IoaSksIHMuc2xpZGVzLnJlbW92ZUNsYXNzKHIpLCBzLnBhcmFtcy5sb29wIHx8IHMucGFyYW1zLnZpcnR1YWwgJiYgcy5wYXJhbXMudmlydHVhbC5lbmFibGVkKSBmb3IgKGxldCBlID0gMDsgZSA8IGk7IGUgKz0gMSkgcy4kd3JhcHBlckVsLmNoaWxkcmVuKGBbZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3QucmVhbEluZGV4ICsgZX1cIl1gKS5hZGRDbGFzcyhyKTsgZWxzZSBmb3IgKGxldCBlID0gMDsgZSA8IGk7IGUgKz0gMSkgcy5zbGlkZXMuZXEodC5yZWFsSW5kZXggKyBlKS5hZGRDbGFzcyhyKTtcclxuICAgICAgICAgICAgY29uc3QgbiA9IHQucGFyYW1zLnRodW1icy5hdXRvU2Nyb2xsT2Zmc2V0LCBsID0gbiAmJiAhcy5wYXJhbXMubG9vcDtcclxuICAgICAgICAgICAgaWYgKHQucmVhbEluZGV4ICE9PSBzLnJlYWxJbmRleCB8fCBsKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSwgciwgbyA9IHMuYWN0aXZlSW5kZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAocy5wYXJhbXMubG9vcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHMuc2xpZGVzLmVxKG8pLmhhc0NsYXNzKHMucGFyYW1zLnNsaWRlRHVwbGljYXRlQ2xhc3MpICYmIChzLmxvb3BGaXgoKSwgcy5fY2xpZW50TGVmdCA9IHMuJHdyYXBwZXJFbFswXS5jbGllbnRMZWZ0LCBvID0gcy5hY3RpdmVJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IHMuc2xpZGVzLmVxKG8pLnByZXZBbGwoYFtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7dC5yZWFsSW5kZXh9XCJdYCkuZXEoMCkuaW5kZXgoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHMuc2xpZGVzLmVxKG8pLm5leHRBbGwoYFtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7dC5yZWFsSW5kZXh9XCJdYCkuZXEoMCkuaW5kZXgoKTtcclxuICAgICAgICAgICAgICAgICAgICBpID0gdm9pZCAwID09PSBlID8gYSA6IHZvaWQgMCA9PT0gYSA/IGUgOiBhIC0gbyA9PSBvIC0gZSA/IHMucGFyYW1zLnNsaWRlc1Blckdyb3VwID4gMSA/IGEgOiBvIDogYSAtIG8gPCBvIC0gZSA/IGEgOiBlLCByID0gdC5hY3RpdmVJbmRleCA+IHQucHJldmlvdXNJbmRleCA/IFwibmV4dFwiIDogXCJwcmV2XCJcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpID0gdC5yZWFsSW5kZXgsIHIgPSBpID4gdC5wcmV2aW91c0luZGV4ID8gXCJuZXh0XCIgOiBcInByZXZcIjtcclxuICAgICAgICAgICAgICAgIGwgJiYgKGkgKz0gXCJuZXh0XCIgPT09IHIgPyBuIDogLTEgKiBuKSwgcy52aXNpYmxlU2xpZGVzSW5kZXhlcyAmJiBzLnZpc2libGVTbGlkZXNJbmRleGVzLmluZGV4T2YoaSkgPCAwICYmIChzLnBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IGkgPSBpID4gbyA/IGkgLSBNYXRoLmZsb29yKGEgLyAyKSArIDEgOiBpICsgTWF0aC5mbG9vcihhIC8gMikgLSAxIDogaSA+IG8gJiYgcy5wYXJhbXMuc2xpZGVzUGVyR3JvdXAsIHMuc2xpZGVUbyhpLCBlID8gMCA6IHZvaWQgMCkpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHQudGh1bWJzID0ge3N3aXBlcjogbnVsbH0sIGEoXCJiZWZvcmVJbml0XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHt0aHVtYnM6IGV9ID0gdC5wYXJhbXM7XHJcbiAgICAgICAgICAgIGUgJiYgZS5zd2lwZXIgJiYgKGwoKSwgbyghMCkpXHJcbiAgICAgICAgfSkpLCBhKFwic2xpZGVDaGFuZ2UgdXBkYXRlIHJlc2l6ZSBvYnNlcnZlclVwZGF0ZVwiLCAoKCkgPT4ge1xyXG4gICAgICAgICAgICBvKClcclxuICAgICAgICB9KSksIGEoXCJzZXRUcmFuc2l0aW9uXCIsICgoZSwgcykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhID0gdC50aHVtYnMuc3dpcGVyO1xyXG4gICAgICAgICAgICBhICYmICFhLmRlc3Ryb3llZCAmJiBhLnNldFRyYW5zaXRpb24ocylcclxuICAgICAgICB9KSksIGEoXCJiZWZvcmVEZXN0cm95XCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSB0LnRodW1icy5zd2lwZXI7XHJcbiAgICAgICAgICAgIGUgJiYgIWUuZGVzdHJveWVkICYmIHIgJiYgZS5kZXN0cm95KClcclxuICAgICAgICB9KSksIE9iamVjdC5hc3NpZ24odC50aHVtYnMsIHtpbml0OiBsLCB1cGRhdGU6IG99KVxyXG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBsZXQge3N3aXBlcjogdCwgZXh0ZW5kUGFyYW1zOiBzLCBlbWl0OiBhLCBvbmNlOiBpfSA9IGU7XHJcbiAgICAgICAgcyh7XHJcbiAgICAgICAgICAgIGZyZWVNb2RlOiB7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiAhMSxcclxuICAgICAgICAgICAgICAgIG1vbWVudHVtOiAhMCxcclxuICAgICAgICAgICAgICAgIG1vbWVudHVtUmF0aW86IDEsXHJcbiAgICAgICAgICAgICAgICBtb21lbnR1bUJvdW5jZTogITAsXHJcbiAgICAgICAgICAgICAgICBtb21lbnR1bUJvdW5jZVJhdGlvOiAxLFxyXG4gICAgICAgICAgICAgICAgbW9tZW50dW1WZWxvY2l0eVJhdGlvOiAxLFxyXG4gICAgICAgICAgICAgICAgc3RpY2t5OiAhMSxcclxuICAgICAgICAgICAgICAgIG1pbmltdW1WZWxvY2l0eTogLjAyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSwgT2JqZWN0LmFzc2lnbih0LCB7XHJcbiAgICAgICAgICAgIGZyZWVNb2RlOiB7XHJcbiAgICAgICAgICAgICAgICBvblRvdWNoU3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gdC5nZXRUcmFuc2xhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB0LnNldFRyYW5zbGF0ZShlKSwgdC5zZXRUcmFuc2l0aW9uKDApLCB0LnRvdWNoRXZlbnRzRGF0YS52ZWxvY2l0aWVzLmxlbmd0aCA9IDAsIHQuZnJlZU1vZGUub25Ub3VjaEVuZCh7Y3VycmVudFBvczogdC5ydGwgPyB0LnRyYW5zbGF0ZSA6IC10LnRyYW5zbGF0ZX0pXHJcbiAgICAgICAgICAgICAgICB9LCBvblRvdWNoTW92ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHt0b3VjaEV2ZW50c0RhdGE6IGUsIHRvdWNoZXM6IHN9ID0gdDtcclxuICAgICAgICAgICAgICAgICAgICAwID09PSBlLnZlbG9jaXRpZXMubGVuZ3RoICYmIGUudmVsb2NpdGllcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHNbdC5pc0hvcml6b250YWwoKSA/IFwic3RhcnRYXCIgOiBcInN0YXJ0WVwiXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogZS50b3VjaFN0YXJ0VGltZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pLCBlLnZlbG9jaXRpZXMucHVzaCh7cG9zaXRpb246IHNbdC5pc0hvcml6b250YWwoKSA/IFwiY3VycmVudFhcIiA6IFwiY3VycmVudFlcIl0sIHRpbWU6IHUoKX0pXHJcbiAgICAgICAgICAgICAgICB9LCBvblRvdWNoRW5kOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB7Y3VycmVudFBvczogc30gPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHtwYXJhbXM6IHIsICR3cmFwcGVyRWw6IG4sIHJ0bFRyYW5zbGF0ZTogbCwgc25hcEdyaWQ6IG8sIHRvdWNoRXZlbnRzRGF0YTogZH0gPSB0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gdSgpIC0gZC50b3VjaFN0YXJ0VGltZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocyA8IC10Lm1pblRyYW5zbGF0ZSgpKSB0LnNsaWRlVG8odC5hY3RpdmVJbmRleCk7IGVsc2UgaWYgKHMgPiAtdC5tYXhUcmFuc2xhdGUoKSkgdC5zbGlkZXMubGVuZ3RoIDwgby5sZW5ndGggPyB0LnNsaWRlVG8oby5sZW5ndGggLSAxKSA6IHQuc2xpZGVUbyh0LnNsaWRlcy5sZW5ndGggLSAxKTsgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmZyZWVNb2RlLm1vbWVudHVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZC52ZWxvY2l0aWVzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gZC52ZWxvY2l0aWVzLnBvcCgpLCBzID0gZC52ZWxvY2l0aWVzLnBvcCgpLCBhID0gZS5wb3NpdGlvbiAtIHMucG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBlLnRpbWUgLSBzLnRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC52ZWxvY2l0eSA9IGEgLyBpLCB0LnZlbG9jaXR5IC89IDIsIE1hdGguYWJzKHQudmVsb2NpdHkpIDwgci5mcmVlTW9kZS5taW5pbXVtVmVsb2NpdHkgJiYgKHQudmVsb2NpdHkgPSAwKSwgKGkgPiAxNTAgfHwgdSgpIC0gZS50aW1lID4gMzAwKSAmJiAodC52ZWxvY2l0eSA9IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgdC52ZWxvY2l0eSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnZlbG9jaXR5ICo9IHIuZnJlZU1vZGUubW9tZW50dW1WZWxvY2l0eVJhdGlvLCBkLnZlbG9jaXRpZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlID0gMWUzICogci5mcmVlTW9kZS5tb21lbnR1bVJhdGlvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IHQudmVsb2NpdHkgKiBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGMgPSB0LnRyYW5zbGF0ZSArIHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsICYmIChjID0gLWMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHAsIGggPSAhMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG0gPSAyMCAqIE1hdGguYWJzKHQudmVsb2NpdHkpICogci5mcmVlTW9kZS5tb21lbnR1bUJvdW5jZVJhdGlvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA8IHQubWF4VHJhbnNsYXRlKCkpIHIuZnJlZU1vZGUubW9tZW50dW1Cb3VuY2UgPyAoYyArIHQubWF4VHJhbnNsYXRlKCkgPCAtbSAmJiAoYyA9IHQubWF4VHJhbnNsYXRlKCkgLSBtKSwgcCA9IHQubWF4VHJhbnNsYXRlKCksIGggPSAhMCwgZC5hbGxvd01vbWVudHVtQm91bmNlID0gITApIDogYyA9IHQubWF4VHJhbnNsYXRlKCksIHIubG9vcCAmJiByLmNlbnRlcmVkU2xpZGVzICYmIChmID0gITApOyBlbHNlIGlmIChjID4gdC5taW5UcmFuc2xhdGUoKSkgci5mcmVlTW9kZS5tb21lbnR1bUJvdW5jZSA/IChjIC0gdC5taW5UcmFuc2xhdGUoKSA+IG0gJiYgKGMgPSB0Lm1pblRyYW5zbGF0ZSgpICsgbSksIHAgPSB0Lm1pblRyYW5zbGF0ZSgpLCBoID0gITAsIGQuYWxsb3dNb21lbnR1bUJvdW5jZSA9ICEwKSA6IGMgPSB0Lm1pblRyYW5zbGF0ZSgpLCByLmxvb3AgJiYgci5jZW50ZXJlZFNsaWRlcyAmJiAoZiA9ICEwKTsgZWxzZSBpZiAoci5mcmVlTW9kZS5zdGlja3kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IG8ubGVuZ3RoOyB0ICs9IDEpIGlmIChvW3RdID4gLWMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBNYXRoLmFicyhvW2VdIC0gYykgPCBNYXRoLmFicyhvW2UgLSAxXSAtIGMpIHx8IFwibmV4dFwiID09PSB0LnN3aXBlRGlyZWN0aW9uID8gb1tlXSA6IG9bZSAtIDFdLCBjID0gLWNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmICYmIGkoXCJ0cmFuc2l0aW9uRW5kXCIsICgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5sb29wRml4KClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSwgMCAhPT0gdC52ZWxvY2l0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlID0gbCA/IE1hdGguYWJzKCgtYyAtIHQudHJhbnNsYXRlKSAvIHQudmVsb2NpdHkpIDogTWF0aC5hYnMoKGMgLSB0LnRyYW5zbGF0ZSkgLyB0LnZlbG9jaXR5KSwgci5mcmVlTW9kZS5zdGlja3kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IE1hdGguYWJzKChsID8gLWMgOiBjKSAtIHQudHJhbnNsYXRlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSB0LnNsaWRlc1NpemVzR3JpZFt0LmFjdGl2ZUluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHMgPCBhID8gci5zcGVlZCA6IHMgPCAyICogYSA/IDEuNSAqIHIuc3BlZWQgOiAyLjUgKiByLnNwZWVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyLmZyZWVNb2RlLnN0aWNreSkgcmV0dXJuIHZvaWQgdC5zbGlkZVRvQ2xvc2VzdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5mcmVlTW9kZS5tb21lbnR1bUJvdW5jZSAmJiBoID8gKHQudXBkYXRlUHJvZ3Jlc3MocCksIHQuc2V0VHJhbnNpdGlvbihlKSwgdC5zZXRUcmFuc2xhdGUoYyksIHQudHJhbnNpdGlvblN0YXJ0KCEwLCB0LnN3aXBlRGlyZWN0aW9uKSwgdC5hbmltYXRpbmcgPSAhMCwgbi50cmFuc2l0aW9uRW5kKCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCAmJiAhdC5kZXN0cm95ZWQgJiYgZC5hbGxvd01vbWVudHVtQm91bmNlICYmIChhKFwibW9tZW50dW1Cb3VuY2VcIiksIHQuc2V0VHJhbnNpdGlvbihyLnNwZWVkKSwgc2V0VGltZW91dCgoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnNldFRyYW5zbGF0ZShwKSwgbi50cmFuc2l0aW9uRW5kKCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICYmICF0LmRlc3Ryb3llZCAmJiB0LnRyYW5zaXRpb25FbmQoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpIDogdC52ZWxvY2l0eSA/IChhKFwiX2ZyZWVNb2RlTm9Nb21lbnR1bVJlbGVhc2VcIiksIHQudXBkYXRlUHJvZ3Jlc3MoYyksIHQuc2V0VHJhbnNpdGlvbihlKSwgdC5zZXRUcmFuc2xhdGUoYyksIHQudHJhbnNpdGlvblN0YXJ0KCEwLCB0LnN3aXBlRGlyZWN0aW9uKSwgdC5hbmltYXRpbmcgfHwgKHQuYW5pbWF0aW5nID0gITAsIG4udHJhbnNpdGlvbkVuZCgoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgJiYgIXQuZGVzdHJveWVkICYmIHQudHJhbnNpdGlvbkVuZCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpKSA6IHQudXBkYXRlUHJvZ3Jlc3MoYyksIHQudXBkYXRlQWN0aXZlSW5kZXgoKSwgdC51cGRhdGVTbGlkZXNDbGFzc2VzKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmZyZWVNb2RlLnN0aWNreSkgcmV0dXJuIHZvaWQgdC5zbGlkZVRvQ2xvc2VzdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5mcmVlTW9kZSAmJiBhKFwiX2ZyZWVNb2RlTm9Nb21lbnR1bVJlbGVhc2VcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoIXIuZnJlZU1vZGUubW9tZW50dW0gfHwgYyA+PSByLmxvbmdTd2lwZXNNcykgJiYgKHQudXBkYXRlUHJvZ3Jlc3MoKSwgdC51cGRhdGVBY3RpdmVJbmRleCgpLCB0LnVwZGF0ZVNsaWRlc0NsYXNzZXMoKSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBsZXQgdCwgcywgYSwge3N3aXBlcjogaSwgZXh0ZW5kUGFyYW1zOiByfSA9IGU7XHJcbiAgICAgICAgcih7Z3JpZDoge3Jvd3M6IDEsIGZpbGw6IFwiY29sdW1uXCJ9fSksIGkuZ3JpZCA9IHtcclxuICAgICAgICAgICAgaW5pdFNsaWRlczogZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7c2xpZGVzUGVyVmlldzogcn0gPSBpLnBhcmFtcywge3Jvd3M6IG4sIGZpbGw6IGx9ID0gaS5wYXJhbXMuZ3JpZDtcclxuICAgICAgICAgICAgICAgIHMgPSB0IC8gbiwgYSA9IE1hdGguZmxvb3IoZSAvIG4pLCB0ID0gTWF0aC5mbG9vcihlIC8gbikgPT09IGUgLyBuID8gZSA6IE1hdGguY2VpbChlIC8gbikgKiBuLCBcImF1dG9cIiAhPT0gciAmJiBcInJvd1wiID09PSBsICYmICh0ID0gTWF0aC5tYXgodCwgciAqIG4pKVxyXG4gICAgICAgICAgICB9LCB1cGRhdGVTbGlkZTogKGUsIHIsIG4sIGwpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHtzbGlkZXNQZXJHcm91cDogbywgc3BhY2VCZXR3ZWVuOiBkfSA9IGkucGFyYW1zLCB7cm93czogYywgZmlsbDogcH0gPSBpLnBhcmFtcy5ncmlkO1xyXG4gICAgICAgICAgICAgICAgbGV0IHUsIGgsIG07XHJcbiAgICAgICAgICAgICAgICBpZiAoXCJyb3dcIiA9PT0gcCAmJiBvID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBNYXRoLmZsb29yKGUgLyAobyAqIGMpKSwgYSA9IGUgLSBjICogbyAqIHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwID09PSBzID8gbyA6IE1hdGgubWluKE1hdGguY2VpbCgobiAtIHMgKiBjICogbykgLyBjKSwgbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IE1hdGguZmxvb3IoYSAvIGkpLCBoID0gYSAtIG0gKiBpICsgcyAqIG8sIHUgPSBoICsgbSAqIHQgLyBjLCByLmNzcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiLXdlYmtpdC1vcmRlclwiOiB1LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcjogdVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgXCJjb2x1bW5cIiA9PT0gcCA/IChoID0gTWF0aC5mbG9vcihlIC8gYyksIG0gPSBlIC0gaCAqIGMsIChoID4gYSB8fCBoID09PSBhICYmIG0gPT09IGMgLSAxKSAmJiAobSArPSAxLCBtID49IGMgJiYgKG0gPSAwLCBoICs9IDEpKSkgOiAobSA9IE1hdGguZmxvb3IoZSAvIHMpLCBoID0gZSAtIG0gKiBzKTtcclxuICAgICAgICAgICAgICAgIHIuY3NzKGwoXCJtYXJnaW4tdG9wXCIpLCAwICE9PSBtID8gZCAmJiBgJHtkfXB4YCA6IFwiXCIpXHJcbiAgICAgICAgICAgIH0sIHVwZGF0ZVdyYXBwZXJTaXplOiAoZSwgcywgYSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qge3NwYWNlQmV0d2VlbjogciwgY2VudGVyZWRTbGlkZXM6IG4sIHJvdW5kTGVuZ3RoczogbH0gPSBpLnBhcmFtcywge3Jvd3M6IG99ID0gaS5wYXJhbXMuZ3JpZDtcclxuICAgICAgICAgICAgICAgIGlmIChpLnZpcnR1YWxTaXplID0gKGUgKyByKSAqIHQsIGkudmlydHVhbFNpemUgPSBNYXRoLmNlaWwoaS52aXJ0dWFsU2l6ZSAvIG8pIC0gciwgaS4kd3JhcHBlckVsLmNzcyh7W2EoXCJ3aWR0aFwiKV06IGAke2kudmlydHVhbFNpemUgKyByfXB4YH0pLCBuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcy5zcGxpY2UoMCwgcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHMubGVuZ3RoOyB0ICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGEgPSBzW3RdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsICYmIChhID0gTWF0aC5mbG9vcihhKSksIHNbdF0gPCBpLnZpcnR1YWxTaXplICsgc1swXSAmJiBlLnB1c2goYSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcy5wdXNoKC4uLmUpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGxldCB7c3dpcGVyOiB0fSA9IGU7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0LCB7XHJcbiAgICAgICAgICAgIGFwcGVuZFNsaWRlOiBLLmJpbmQodCksXHJcbiAgICAgICAgICAgIHByZXBlbmRTbGlkZTogWi5iaW5kKHQpLFxyXG4gICAgICAgICAgICBhZGRTbGlkZTogUS5iaW5kKHQpLFxyXG4gICAgICAgICAgICByZW1vdmVTbGlkZTogSi5iaW5kKHQpLFxyXG4gICAgICAgICAgICByZW1vdmVBbGxTbGlkZXM6IGVlLmJpbmQodClcclxuICAgICAgICB9KVxyXG4gICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBsZXQge3N3aXBlcjogdCwgZXh0ZW5kUGFyYW1zOiBzLCBvbjogYX0gPSBlO1xyXG4gICAgICAgIHMoe2ZhZGVFZmZlY3Q6IHtjcm9zc0ZhZGU6ICExLCB0cmFuc2Zvcm1FbDogbnVsbH19KSwgdGUoe1xyXG4gICAgICAgICAgICBlZmZlY3Q6IFwiZmFkZVwiLFxyXG4gICAgICAgICAgICBzd2lwZXI6IHQsXHJcbiAgICAgICAgICAgIG9uOiBhLFxyXG4gICAgICAgICAgICBzZXRUcmFuc2xhdGU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHtzbGlkZXM6IGV9ID0gdCwgcyA9IHQucGFyYW1zLmZhZGVFZmZlY3Q7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGUubGVuZ3RoOyBhICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gdC5zbGlkZXMuZXEoYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAtZVswXS5zd2lwZXJTbGlkZU9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICB0LnBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlIHx8IChpIC09IHQudHJhbnNsYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgciA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdC5pc0hvcml6b250YWwoKSB8fCAociA9IGksIGkgPSAwKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuID0gdC5wYXJhbXMuZmFkZUVmZmVjdC5jcm9zc0ZhZGUgPyBNYXRoLm1heCgxIC0gTWF0aC5hYnMoZVswXS5wcm9ncmVzcyksIDApIDogMSArIE1hdGgubWluKE1hdGgubWF4KGVbMF0ucHJvZ3Jlc3MsIC0xKSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2UocywgZSkuY3NzKHtvcGFjaXR5OiBufSkudHJhbnNmb3JtKGB0cmFuc2xhdGUzZCgke2l9cHgsICR7cn1weCwgMHB4KWApXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb246IGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qge3RyYW5zZm9ybUVsOiBzfSA9IHQucGFyYW1zLmZhZGVFZmZlY3Q7XHJcbiAgICAgICAgICAgICAgICAocyA/IHQuc2xpZGVzLmZpbmQocykgOiB0LnNsaWRlcykudHJhbnNpdGlvbihlKSwgYWUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXBlcjogdCxcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogZSxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1FbDogcyxcclxuICAgICAgICAgICAgICAgICAgICBhbGxTbGlkZXM6ICEwXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvdmVyd3JpdGVQYXJhbXM6ICgpID0+ICh7XHJcbiAgICAgICAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAxLFxyXG4gICAgICAgICAgICAgICAgc2xpZGVzUGVyR3JvdXA6IDEsXHJcbiAgICAgICAgICAgICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiAhMCxcclxuICAgICAgICAgICAgICAgIHNwYWNlQmV0d2VlbjogMCxcclxuICAgICAgICAgICAgICAgIHZpcnR1YWxUcmFuc2xhdGU6ICF0LnBhcmFtcy5jc3NNb2RlXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgbGV0IHtzd2lwZXI6IHQsIGV4dGVuZFBhcmFtczogcywgb246IGF9ID0gZTtcclxuICAgICAgICBzKHtjdWJlRWZmZWN0OiB7c2xpZGVTaGFkb3dzOiAhMCwgc2hhZG93OiAhMCwgc2hhZG93T2Zmc2V0OiAyMCwgc2hhZG93U2NhbGU6IC45NH19KTtcclxuICAgICAgICBjb25zdCBpID0gKGUsIHQsIHMpID0+IHtcclxuICAgICAgICAgICAgbGV0IGEgPSBzID8gZS5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdFwiKSA6IGUuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXRvcFwiKSxcclxuICAgICAgICAgICAgICAgIGkgPSBzID8gZS5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHRcIikgOiBlLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b21cIik7XHJcbiAgICAgICAgICAgIDAgPT09IGEubGVuZ3RoICYmIChhID0gZChgPGRpdiBjbGFzcz1cInN3aXBlci1zbGlkZS1zaGFkb3ctJHtzID8gXCJsZWZ0XCIgOiBcInRvcFwifVwiPjwvZGl2PmApLCBlLmFwcGVuZChhKSksIDAgPT09IGkubGVuZ3RoICYmIChpID0gZChgPGRpdiBjbGFzcz1cInN3aXBlci1zbGlkZS1zaGFkb3ctJHtzID8gXCJyaWdodFwiIDogXCJib3R0b21cIn1cIj48L2Rpdj5gKSwgZS5hcHBlbmQoaSkpLCBhLmxlbmd0aCAmJiAoYVswXS5zdHlsZS5vcGFjaXR5ID0gTWF0aC5tYXgoLXQsIDApKSwgaS5sZW5ndGggJiYgKGlbMF0uc3R5bGUub3BhY2l0eSA9IE1hdGgubWF4KHQsIDApKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGUoe1xyXG4gICAgICAgICAgICBlZmZlY3Q6IFwiY3ViZVwiLFxyXG4gICAgICAgICAgICBzd2lwZXI6IHQsXHJcbiAgICAgICAgICAgIG9uOiBhLFxyXG4gICAgICAgICAgICBzZXRUcmFuc2xhdGU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHskZWw6IGUsICR3cmFwcGVyRWw6IHMsIHNsaWRlczogYSwgd2lkdGg6IHIsIGhlaWdodDogbiwgcnRsVHJhbnNsYXRlOiBsLCBzaXplOiBvLCBicm93c2VyOiBjfSA9IHQsXHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IHQucGFyYW1zLmN1YmVFZmZlY3QsIHUgPSB0LmlzSG9yaXpvbnRhbCgpLCBoID0gdC52aXJ0dWFsICYmIHQucGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcclxuICAgICAgICAgICAgICAgIGxldCBtLCBmID0gMDtcclxuICAgICAgICAgICAgICAgIHAuc2hhZG93ICYmICh1ID8gKG0gPSBzLmZpbmQoXCIuc3dpcGVyLWN1YmUtc2hhZG93XCIpLCAwID09PSBtLmxlbmd0aCAmJiAobSA9IGQoJzxkaXYgY2xhc3M9XCJzd2lwZXItY3ViZS1zaGFkb3dcIj48L2Rpdj4nKSwgcy5hcHBlbmQobSkpLCBtLmNzcyh7aGVpZ2h0OiBgJHtyfXB4YH0pKSA6IChtID0gZS5maW5kKFwiLnN3aXBlci1jdWJlLXNoYWRvd1wiKSwgMCA9PT0gbS5sZW5ndGggJiYgKG0gPSBkKCc8ZGl2IGNsYXNzPVwic3dpcGVyLWN1YmUtc2hhZG93XCI+PC9kaXY+JyksIGUuYXBwZW5kKG0pKSkpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZSA9IDA7IGUgPCBhLmxlbmd0aDsgZSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGEuZXEoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHMgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgIGggJiYgKHMgPSBwYXJzZUludCh0LmF0dHIoXCJkYXRhLXN3aXBlci1zbGlkZS1pbmRleFwiKSwgMTApKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgciA9IDkwICogcywgbiA9IE1hdGguZmxvb3IociAvIDM2MCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbCAmJiAociA9IC1yLCBuID0gTWF0aC5mbG9vcigtciAvIDM2MCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBNYXRoLm1heChNYXRoLm1pbih0WzBdLnByb2dyZXNzLCAxKSwgLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjID0gMCwgbSA9IDAsIGcgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHMgJSA0ID09IDAgPyAoYyA9IDQgKiAtbiAqIG8sIGcgPSAwKSA6IChzIC0gMSkgJSA0ID09IDAgPyAoYyA9IDAsIGcgPSA0ICogLW4gKiBvKSA6IChzIC0gMikgJSA0ID09IDAgPyAoYyA9IG8gKyA0ICogbiAqIG8sIGcgPSBvKSA6IChzIC0gMykgJSA0ID09IDAgJiYgKGMgPSAtbywgZyA9IDMgKiBvICsgNCAqIG8gKiBuKSwgbCAmJiAoYyA9IC1jKSwgdSB8fCAobSA9IGMsIGMgPSAwKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gYHJvdGF0ZVgoJHt1ID8gMCA6IC1yfWRlZykgcm90YXRlWSgke3UgPyByIDogMH1kZWcpIHRyYW5zbGF0ZTNkKCR7Y31weCwgJHttfXB4LCAke2d9cHgpYDtcclxuICAgICAgICAgICAgICAgICAgICBkIDw9IDEgJiYgZCA+IC0xICYmIChmID0gOTAgKiBzICsgOTAgKiBkLCBsICYmIChmID0gOTAgKiAtcyAtIDkwICogZCkpLCB0LnRyYW5zZm9ybSh2KSwgcC5zbGlkZVNoYWRvd3MgJiYgaSh0LCBkLCB1KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHMuY3NzKHtcclxuICAgICAgICAgICAgICAgICAgICBcIi13ZWJraXQtdHJhbnNmb3JtLW9yaWdpblwiOiBgNTAlIDUwJSAtJHtvIC8gMn1weGAsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGA1MCUgNTAlIC0ke28gLyAyfXB4YFxyXG4gICAgICAgICAgICAgICAgfSksIHAuc2hhZG93KSBpZiAodSkgbS50cmFuc2Zvcm0oYHRyYW5zbGF0ZTNkKDBweCwgJHtyIC8gMiArIHAuc2hhZG93T2Zmc2V0fXB4LCAkey1yIC8gMn1weCkgcm90YXRlWCg5MGRlZykgcm90YXRlWigwZGVnKSBzY2FsZSgke3Auc2hhZG93U2NhbGV9KWApOyBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gTWF0aC5hYnMoZikgLSA5MCAqIE1hdGguZmxvb3IoTWF0aC5hYnMoZikgLyA5MCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAxLjUgLSAoTWF0aC5zaW4oMiAqIGUgKiBNYXRoLlBJIC8gMzYwKSAvIDIgKyBNYXRoLmNvcygyICogZSAqIE1hdGguUEkgLyAzNjApIC8gMiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBwLnNoYWRvd1NjYWxlLCBhID0gcC5zaGFkb3dTY2FsZSAvIHQsIGkgPSBwLnNoYWRvd09mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICBtLnRyYW5zZm9ybShgc2NhbGUzZCgke3N9LCAxLCAke2F9KSB0cmFuc2xhdGUzZCgwcHgsICR7biAvIDIgKyBpfXB4LCAkey1uIC8gMiAvIGF9cHgpIHJvdGF0ZVgoLTkwZGVnKWApXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBnID0gYy5pc1NhZmFyaSB8fCBjLmlzV2ViVmlldyA/IC1vIC8gMiA6IDA7XHJcbiAgICAgICAgICAgICAgICBzLnRyYW5zZm9ybShgdHJhbnNsYXRlM2QoMHB4LDAsJHtnfXB4KSByb3RhdGVYKCR7dC5pc0hvcml6b250YWwoKSA/IDAgOiBmfWRlZykgcm90YXRlWSgke3QuaXNIb3Jpem9udGFsKCkgPyAtZiA6IDB9ZGVnKWApLCBzWzBdLnN0eWxlLnNldFByb3BlcnR5KFwiLS1zd2lwZXItY3ViZS10cmFuc2xhdGUtelwiLCBgJHtnfXB4YClcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbjogZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7JGVsOiBzLCBzbGlkZXM6IGF9ID0gdDtcclxuICAgICAgICAgICAgICAgIGEudHJhbnNpdGlvbihlKS5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodCwgLnN3aXBlci1zbGlkZS1zaGFkb3ctYm90dG9tLCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0XCIpLnRyYW5zaXRpb24oZSksIHQucGFyYW1zLmN1YmVFZmZlY3Quc2hhZG93ICYmICF0LmlzSG9yaXpvbnRhbCgpICYmIHMuZmluZChcIi5zd2lwZXItY3ViZS1zaGFkb3dcIikudHJhbnNpdGlvbihlKVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZWNyZWF0ZVNoYWRvd3M6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSB0LmlzSG9yaXpvbnRhbCgpO1xyXG4gICAgICAgICAgICAgICAgdC5zbGlkZXMuZWFjaCgodCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IE1hdGgubWF4KE1hdGgubWluKHQucHJvZ3Jlc3MsIDEpLCAtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaShkKHQpLCBzLCBlKVxyXG4gICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldEVmZmVjdFBhcmFtczogKCkgPT4gdC5wYXJhbXMuY3ViZUVmZmVjdCxcclxuICAgICAgICAgICAgcGVyc3BlY3RpdmU6ICgpID0+ICEwLFxyXG4gICAgICAgICAgICBvdmVyd3JpdGVQYXJhbXM6ICgpID0+ICh7XHJcbiAgICAgICAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAxLFxyXG4gICAgICAgICAgICAgICAgc2xpZGVzUGVyR3JvdXA6IDEsXHJcbiAgICAgICAgICAgICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiAhMCxcclxuICAgICAgICAgICAgICAgIHJlc2lzdGFuY2VSYXRpbzogMCxcclxuICAgICAgICAgICAgICAgIHNwYWNlQmV0d2VlbjogMCxcclxuICAgICAgICAgICAgICAgIGNlbnRlcmVkU2xpZGVzOiAhMSxcclxuICAgICAgICAgICAgICAgIHZpcnR1YWxUcmFuc2xhdGU6ICEwXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgbGV0IHtzd2lwZXI6IHQsIGV4dGVuZFBhcmFtczogcywgb246IGF9ID0gZTtcclxuICAgICAgICBzKHtmbGlwRWZmZWN0OiB7c2xpZGVTaGFkb3dzOiAhMCwgbGltaXRSb3RhdGlvbjogITAsIHRyYW5zZm9ybUVsOiBudWxsfX0pO1xyXG4gICAgICAgIGNvbnN0IGkgPSAoZSwgcywgYSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaSA9IHQuaXNIb3Jpem9udGFsKCkgPyBlLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1sZWZ0XCIpIDogZS5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctdG9wXCIpLFxyXG4gICAgICAgICAgICAgICAgciA9IHQuaXNIb3Jpem9udGFsKCkgPyBlLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1yaWdodFwiKSA6IGUuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LWJvdHRvbVwiKTtcclxuICAgICAgICAgICAgMCA9PT0gaS5sZW5ndGggJiYgKGkgPSBpZShhLCBlLCB0LmlzSG9yaXpvbnRhbCgpID8gXCJsZWZ0XCIgOiBcInRvcFwiKSksIDAgPT09IHIubGVuZ3RoICYmIChyID0gaWUoYSwgZSwgdC5pc0hvcml6b250YWwoKSA/IFwicmlnaHRcIiA6IFwiYm90dG9tXCIpKSwgaS5sZW5ndGggJiYgKGlbMF0uc3R5bGUub3BhY2l0eSA9IE1hdGgubWF4KC1zLCAwKSksIHIubGVuZ3RoICYmIChyWzBdLnN0eWxlLm9wYWNpdHkgPSBNYXRoLm1heChzLCAwKSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRlKHtcclxuICAgICAgICAgICAgZWZmZWN0OiBcImZsaXBcIixcclxuICAgICAgICAgICAgc3dpcGVyOiB0LFxyXG4gICAgICAgICAgICBvbjogYSxcclxuICAgICAgICAgICAgc2V0VHJhbnNsYXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7c2xpZGVzOiBlLCBydGxUcmFuc2xhdGU6IHN9ID0gdCwgYSA9IHQucGFyYW1zLmZsaXBFZmZlY3Q7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByID0gMDsgciA8IGUubGVuZ3RoOyByICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuID0gZS5lcShyKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbCA9IG5bMF0ucHJvZ3Jlc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgdC5wYXJhbXMuZmxpcEVmZmVjdC5saW1pdFJvdGF0aW9uICYmIChsID0gTWF0aC5tYXgoTWF0aC5taW4oblswXS5wcm9ncmVzcywgMSksIC0xKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbyA9IG5bMF0uc3dpcGVyU2xpZGVPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGQgPSAtMTgwICogbCwgYyA9IDAsIHAgPSB0LnBhcmFtcy5jc3NNb2RlID8gLW8gLSB0LnRyYW5zbGF0ZSA6IC1vLCB1ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB0LmlzSG9yaXpvbnRhbCgpID8gcyAmJiAoZCA9IC1kKSA6ICh1ID0gcCwgcCA9IDAsIGMgPSAtZCwgZCA9IDApLCBuWzBdLnN0eWxlLnpJbmRleCA9IC1NYXRoLmFicyhNYXRoLnJvdW5kKGwpKSArIGUubGVuZ3RoLCBhLnNsaWRlU2hhZG93cyAmJiBpKG4sIGwsIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGggPSBgdHJhbnNsYXRlM2QoJHtwfXB4LCAke3V9cHgsIDBweCkgcm90YXRlWCgke2N9ZGVnKSByb3RhdGVZKCR7ZH1kZWcpYDtcclxuICAgICAgICAgICAgICAgICAgICBzZShhLCBuKS50cmFuc2Zvcm0oaClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbjogZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7dHJhbnNmb3JtRWw6IHN9ID0gdC5wYXJhbXMuZmxpcEVmZmVjdDtcclxuICAgICAgICAgICAgICAgIChzID8gdC5zbGlkZXMuZmluZChzKSA6IHQuc2xpZGVzKS50cmFuc2l0aW9uKGUpLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3AsIC5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0LCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20sIC5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnRcIikudHJhbnNpdGlvbihlKSwgYWUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXBlcjogdCxcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogZSxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1FbDogc1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVjcmVhdGVTaGFkb3dzOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gdC5wYXJhbXMuZmxpcEVmZmVjdDtcclxuICAgICAgICAgICAgICAgIHQuc2xpZGVzLmVhY2goKHMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBkKHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByID0gYVswXS5wcm9ncmVzcztcclxuICAgICAgICAgICAgICAgICAgICB0LnBhcmFtcy5mbGlwRWZmZWN0LmxpbWl0Um90YXRpb24gJiYgKHIgPSBNYXRoLm1heChNYXRoLm1pbihzLnByb2dyZXNzLCAxKSwgLTEpKSwgaShhLCByLCBlKVxyXG4gICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldEVmZmVjdFBhcmFtczogKCkgPT4gdC5wYXJhbXMuZmxpcEVmZmVjdCxcclxuICAgICAgICAgICAgcGVyc3BlY3RpdmU6ICgpID0+ICEwLFxyXG4gICAgICAgICAgICBvdmVyd3JpdGVQYXJhbXM6ICgpID0+ICh7XHJcbiAgICAgICAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAxLFxyXG4gICAgICAgICAgICAgICAgc2xpZGVzUGVyR3JvdXA6IDEsXHJcbiAgICAgICAgICAgICAgICB3YXRjaFNsaWRlc1Byb2dyZXNzOiAhMCxcclxuICAgICAgICAgICAgICAgIHNwYWNlQmV0d2VlbjogMCxcclxuICAgICAgICAgICAgICAgIHZpcnR1YWxUcmFuc2xhdGU6ICF0LnBhcmFtcy5jc3NNb2RlXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgbGV0IHtzd2lwZXI6IHQsIGV4dGVuZFBhcmFtczogcywgb246IGF9ID0gZTtcclxuICAgICAgICBzKHtcclxuICAgICAgICAgICAgY292ZXJmbG93RWZmZWN0OiB7XHJcbiAgICAgICAgICAgICAgICByb3RhdGU6IDUwLFxyXG4gICAgICAgICAgICAgICAgc3RyZXRjaDogMCxcclxuICAgICAgICAgICAgICAgIGRlcHRoOiAxMDAsXHJcbiAgICAgICAgICAgICAgICBzY2FsZTogMSxcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVyOiAxLFxyXG4gICAgICAgICAgICAgICAgc2xpZGVTaGFkb3dzOiAhMCxcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUVsOiBudWxsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSwgdGUoe1xyXG4gICAgICAgICAgICBlZmZlY3Q6IFwiY292ZXJmbG93XCIsIHN3aXBlcjogdCwgb246IGEsIHNldFRyYW5zbGF0ZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qge3dpZHRoOiBlLCBoZWlnaHQ6IHMsIHNsaWRlczogYSwgc2xpZGVzU2l6ZXNHcmlkOiBpfSA9IHQsIHIgPSB0LnBhcmFtcy5jb3ZlcmZsb3dFZmZlY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IHQuaXNIb3Jpem9udGFsKCksIGwgPSB0LnRyYW5zbGF0ZSwgbyA9IG4gPyBlIC8gMiAtIGwgOiBzIC8gMiAtIGwsIGQgPSBuID8gci5yb3RhdGUgOiAtci5yb3RhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IHIuZGVwdGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlID0gMCwgdCA9IGEubGVuZ3RoOyBlIDwgdDsgZSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGEuZXEoZSksIHMgPSBpW2VdLCBsID0gKG8gLSB0WzBdLnN3aXBlclNsaWRlT2Zmc2V0IC0gcyAvIDIpIC8gcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygci5tb2RpZmllciA/IHIubW9kaWZpZXIobCkgOiBsICogci5tb2RpZmllcjtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IG4gPyBkICogcCA6IDAsIGggPSBuID8gMCA6IGQgKiBwLCBtID0gLWMgKiBNYXRoLmFicyhwKSwgZiA9IHIuc3RyZXRjaDtcclxuICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09IHR5cGVvZiBmICYmIC0xICE9PSBmLmluZGV4T2YoXCIlXCIpICYmIChmID0gcGFyc2VGbG9hdChyLnN0cmV0Y2gpIC8gMTAwICogcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGcgPSBuID8gMCA6IGYgKiBwLCB2ID0gbiA/IGYgKiBwIDogMCwgdyA9IDEgLSAoMSAtIHIuc2NhbGUpICogTWF0aC5hYnMocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnModikgPCAuMDAxICYmICh2ID0gMCksIE1hdGguYWJzKGcpIDwgLjAwMSAmJiAoZyA9IDApLCBNYXRoLmFicyhtKSA8IC4wMDEgJiYgKG0gPSAwKSwgTWF0aC5hYnModSkgPCAuMDAxICYmICh1ID0gMCksIE1hdGguYWJzKGgpIDwgLjAwMSAmJiAoaCA9IDApLCBNYXRoLmFicyh3KSA8IC4wMDEgJiYgKHcgPSAwKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gYHRyYW5zbGF0ZTNkKCR7dn1weCwke2d9cHgsJHttfXB4KSAgcm90YXRlWCgke2h9ZGVnKSByb3RhdGVZKCR7dX1kZWcpIHNjYWxlKCR7d30pYDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2UociwgdCkudHJhbnNmb3JtKGIpLCB0WzBdLnN0eWxlLnpJbmRleCA9IDEgLSBNYXRoLmFicyhNYXRoLnJvdW5kKHApKSwgci5zbGlkZVNoYWRvd3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGUgPSBuID8gdC5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctbGVmdFwiKSA6IHQuZmluZChcIi5zd2lwZXItc2xpZGUtc2hhZG93LXRvcFwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBuID8gdC5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3ctcmlnaHRcIikgOiB0LmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b21cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDAgPT09IGUubGVuZ3RoICYmIChlID0gaWUociwgdCwgbiA/IFwibGVmdFwiIDogXCJ0b3BcIikpLCAwID09PSBzLmxlbmd0aCAmJiAocyA9IGllKHIsIHQsIG4gPyBcInJpZ2h0XCIgOiBcImJvdHRvbVwiKSksIGUubGVuZ3RoICYmIChlWzBdLnN0eWxlLm9wYWNpdHkgPSBwID4gMCA/IHAgOiAwKSwgcy5sZW5ndGggJiYgKHNbMF0uc3R5bGUub3BhY2l0eSA9IC1wID4gMCA/IC1wIDogMClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHNldFRyYW5zaXRpb246IGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qge3RyYW5zZm9ybUVsOiBzfSA9IHQucGFyYW1zLmNvdmVyZmxvd0VmZmVjdDtcclxuICAgICAgICAgICAgICAgIChzID8gdC5zbGlkZXMuZmluZChzKSA6IHQuc2xpZGVzKS50cmFuc2l0aW9uKGUpLmZpbmQoXCIuc3dpcGVyLXNsaWRlLXNoYWRvdy10b3AsIC5zd2lwZXItc2xpZGUtc2hhZG93LXJpZ2h0LCAuc3dpcGVyLXNsaWRlLXNoYWRvdy1ib3R0b20sIC5zd2lwZXItc2xpZGUtc2hhZG93LWxlZnRcIikudHJhbnNpdGlvbihlKVxyXG4gICAgICAgICAgICB9LCBwZXJzcGVjdGl2ZTogKCkgPT4gITAsIG92ZXJ3cml0ZVBhcmFtczogKCkgPT4gKHt3YXRjaFNsaWRlc1Byb2dyZXNzOiAhMH0pXHJcbiAgICAgICAgfSlcclxuICAgIH0sIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgbGV0IHtzd2lwZXI6IHQsIGV4dGVuZFBhcmFtczogcywgb246IGF9ID0gZTtcclxuICAgICAgICBzKHtcclxuICAgICAgICAgICAgY3JlYXRpdmVFZmZlY3Q6IHtcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUVsOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgbGltaXRQcm9ncmVzczogMSxcclxuICAgICAgICAgICAgICAgIHNoYWRvd1BlclByb2dyZXNzOiAhMSxcclxuICAgICAgICAgICAgICAgIHByb2dyZXNzTXVsdGlwbGllcjogMSxcclxuICAgICAgICAgICAgICAgIHBlcnNwZWN0aXZlOiAhMCxcclxuICAgICAgICAgICAgICAgIHByZXY6IHt0cmFuc2xhdGU6IFswLCAwLCAwXSwgcm90YXRlOiBbMCwgMCwgMF0sIG9wYWNpdHk6IDEsIHNjYWxlOiAxfSxcclxuICAgICAgICAgICAgICAgIG5leHQ6IHt0cmFuc2xhdGU6IFswLCAwLCAwXSwgcm90YXRlOiBbMCwgMCwgMF0sIG9wYWNpdHk6IDEsIHNjYWxlOiAxfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgaSA9IGUgPT4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IGUgOiBgJHtlfXB4YDtcclxuICAgICAgICB0ZSh7XHJcbiAgICAgICAgICAgIGVmZmVjdDogXCJjcmVhdGl2ZVwiLFxyXG4gICAgICAgICAgICBzd2lwZXI6IHQsXHJcbiAgICAgICAgICAgIG9uOiBhLFxyXG4gICAgICAgICAgICBzZXRUcmFuc2xhdGU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHtzbGlkZXM6IGUsICR3cmFwcGVyRWw6IHMsIHNsaWRlc1NpemVzR3JpZDogYX0gPSB0LFxyXG4gICAgICAgICAgICAgICAgICAgIHIgPSB0LnBhcmFtcy5jcmVhdGl2ZUVmZmVjdCwge3Byb2dyZXNzTXVsdGlwbGllcjogbn0gPSByLCBsID0gdC5wYXJhbXMuY2VudGVyZWRTbGlkZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAobCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBhWzBdIC8gMiAtIHQucGFyYW1zLnNsaWRlc09mZnNldEJlZm9yZSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHMudHJhbnNmb3JtKGB0cmFuc2xhdGVYKGNhbGMoNTAlIC0gJHtlfXB4KSlgKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBlLmxlbmd0aDsgcyArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYSA9IGUuZXEocyksIG8gPSBhWzBdLnByb2dyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gTWF0aC5taW4oTWF0aC5tYXgoYVswXS5wcm9ncmVzcywgLXIubGltaXRQcm9ncmVzcyksIHIubGltaXRQcm9ncmVzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGMgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgIGwgfHwgKGMgPSBNYXRoLm1pbihNYXRoLm1heChhWzBdLm9yaWdpbmFsUHJvZ3Jlc3MsIC1yLmxpbWl0UHJvZ3Jlc3MpLCByLmxpbWl0UHJvZ3Jlc3MpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gYVswXS5zd2lwZXJTbGlkZU9mZnNldCwgdSA9IFt0LnBhcmFtcy5jc3NNb2RlID8gLXAgLSB0LnRyYW5zbGF0ZSA6IC1wLCAwLCAwXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IFswLCAwLCAwXTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbSA9ICExO1xyXG4gICAgICAgICAgICAgICAgICAgIHQuaXNIb3Jpem9udGFsKCkgfHwgKHVbMV0gPSB1WzBdLCB1WzBdID0gMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGYgPSB7dHJhbnNsYXRlOiBbMCwgMCwgMF0sIHJvdGF0ZTogWzAsIDAsIDBdLCBzY2FsZTogMSwgb3BhY2l0eTogMX07XHJcbiAgICAgICAgICAgICAgICAgICAgZCA8IDAgPyAoZiA9IHIubmV4dCwgbSA9ICEwKSA6IGQgPiAwICYmIChmID0gci5wcmV2LCBtID0gITApLCB1LmZvckVhY2goKChlLCB0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVbdF0gPSBgY2FsYygke2V9cHggKyAoJHtpKGYudHJhbnNsYXRlW3RdKX0gKiAke01hdGguYWJzKGQgKiBuKX0pKWBcclxuICAgICAgICAgICAgICAgICAgICB9KSksIGguZm9yRWFjaCgoKGUsIHQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaFt0XSA9IGYucm90YXRlW3RdICogTWF0aC5hYnMoZCAqIG4pXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpLCBhWzBdLnN0eWxlLnpJbmRleCA9IC1NYXRoLmFicyhNYXRoLnJvdW5kKG8pKSArIGUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGcgPSB1LmpvaW4oXCIsIFwiKSwgdiA9IGByb3RhdGVYKCR7aFswXX1kZWcpIHJvdGF0ZVkoJHtoWzFdfWRlZykgcm90YXRlWigke2hbMl19ZGVnKWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgPSBjIDwgMCA/IGBzY2FsZSgkezEgKyAoMSAtIGYuc2NhbGUpICogYyAqIG59KWAgOiBgc2NhbGUoJHsxIC0gKDEgLSBmLnNjYWxlKSAqIGMgKiBufSlgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gYyA8IDAgPyAxICsgKDEgLSBmLm9wYWNpdHkpICogYyAqIG4gOiAxIC0gKDEgLSBmLm9wYWNpdHkpICogYyAqIG4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBgdHJhbnNsYXRlM2QoJHtnfSkgJHt2fSAke3d9YDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobSAmJiBmLnNoYWRvdyB8fCAhbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZSA9IGEuY2hpbGRyZW4oXCIuc3dpcGVyLXNsaWRlLXNoYWRvd1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IGUubGVuZ3RoICYmIGYuc2hhZG93ICYmIChlID0gaWUociwgYSkpLCBlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IHIuc2hhZG93UGVyUHJvZ3Jlc3MgPyBkICogKDEgLyByLmxpbWl0UHJvZ3Jlc3MpIDogZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVbMF0uc3R5bGUub3BhY2l0eSA9IE1hdGgubWluKE1hdGgubWF4KE1hdGguYWJzKHQpLCAwKSwgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB5ID0gc2UociwgYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeS50cmFuc2Zvcm0oeCkuY3NzKHtvcGFjaXR5OiBifSksIGYub3JpZ2luICYmIHkuY3NzKFwidHJhbnNmb3JtLW9yaWdpblwiLCBmLm9yaWdpbilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbjogZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7dHJhbnNmb3JtRWw6IHN9ID0gdC5wYXJhbXMuY3JlYXRpdmVFZmZlY3Q7XHJcbiAgICAgICAgICAgICAgICAocyA/IHQuc2xpZGVzLmZpbmQocykgOiB0LnNsaWRlcykudHJhbnNpdGlvbihlKS5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3dcIikudHJhbnNpdGlvbihlKSwgYWUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXBlcjogdCxcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogZSxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1FbDogcyxcclxuICAgICAgICAgICAgICAgICAgICBhbGxTbGlkZXM6ICEwXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwZXJzcGVjdGl2ZTogKCkgPT4gdC5wYXJhbXMuY3JlYXRpdmVFZmZlY3QucGVyc3BlY3RpdmUsXHJcbiAgICAgICAgICAgIG92ZXJ3cml0ZVBhcmFtczogKCkgPT4gKHt3YXRjaFNsaWRlc1Byb2dyZXNzOiAhMCwgdmlydHVhbFRyYW5zbGF0ZTogIXQucGFyYW1zLmNzc01vZGV9KVxyXG4gICAgICAgIH0pXHJcbiAgICB9LCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGxldCB7c3dpcGVyOiB0LCBleHRlbmRQYXJhbXM6IHMsIG9uOiBhfSA9IGU7XHJcbiAgICAgICAgcyh7Y2FyZHNFZmZlY3Q6IHtzbGlkZVNoYWRvd3M6ICEwLCB0cmFuc2Zvcm1FbDogbnVsbCwgcm90YXRlOiAhMCwgcGVyU2xpZGVSb3RhdGU6IDIsIHBlclNsaWRlT2Zmc2V0OiA4fX0pLCB0ZSh7XHJcbiAgICAgICAgICAgIGVmZmVjdDogXCJjYXJkc1wiLFxyXG4gICAgICAgICAgICBzd2lwZXI6IHQsXHJcbiAgICAgICAgICAgIG9uOiBhLFxyXG4gICAgICAgICAgICBzZXRUcmFuc2xhdGU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHtzbGlkZXM6IGUsIGFjdGl2ZUluZGV4OiBzfSA9IHQsIGEgPSB0LnBhcmFtcy5jYXJkc0VmZmVjdCwge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VHJhbnNsYXRlOiBpLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzVG91Y2hlZDogclxyXG4gICAgICAgICAgICAgICAgfSA9IHQudG91Y2hFdmVudHNEYXRhLCBuID0gdC50cmFuc2xhdGU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBsID0gMDsgbCA8IGUubGVuZ3RoOyBsICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvID0gZS5lcShsKSwgZCA9IG9bMF0ucHJvZ3Jlc3MsIGMgPSBNYXRoLm1pbihNYXRoLm1heChkLCAtNCksIDQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwID0gb1swXS5zd2lwZXJTbGlkZU9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICB0LnBhcmFtcy5jZW50ZXJlZFNsaWRlcyAmJiAhdC5wYXJhbXMuY3NzTW9kZSAmJiB0LiR3cmFwcGVyRWwudHJhbnNmb3JtKGB0cmFuc2xhdGVYKCR7dC5taW5UcmFuc2xhdGUoKX1weClgKSwgdC5wYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgdC5wYXJhbXMuY3NzTW9kZSAmJiAocCAtPSBlWzBdLnN3aXBlclNsaWRlT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdSA9IHQucGFyYW1zLmNzc01vZGUgPyAtcCAtIHQudHJhbnNsYXRlIDogLXAsIGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG0gPSAtMTAwICogTWF0aC5hYnMoYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGYgPSAxLCBnID0gLWEucGVyU2xpZGVSb3RhdGUgKiBjLCB2ID0gYS5wZXJTbGlkZU9mZnNldCAtIC43NSAqIE1hdGguYWJzKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHcgPSB0LnZpcnR1YWwgJiYgdC5wYXJhbXMudmlydHVhbC5lbmFibGVkID8gdC52aXJ0dWFsLmZyb20gKyBsIDogbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9ICh3ID09PSBzIHx8IHcgPT09IHMgLSAxKSAmJiBjID4gMCAmJiBjIDwgMSAmJiAociB8fCB0LnBhcmFtcy5jc3NNb2RlKSAmJiBuIDwgaSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9ICh3ID09PSBzIHx8IHcgPT09IHMgKyAxKSAmJiBjIDwgMCAmJiBjID4gLTEgJiYgKHIgfHwgdC5wYXJhbXMuY3NzTW9kZSkgJiYgbiA+IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIgfHwgeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gKDEgLSBNYXRoLmFicygoTWF0aC5hYnMoYykgLSAuNSkgLyAuNSkpICoqIC41O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnICs9IC0yOCAqIGMgKiBlLCBmICs9IC0uNSAqIGUsIHYgKz0gOTYgKiBlLCBoID0gLTI1ICogZSAqIE1hdGguYWJzKGMpICsgXCIlXCJcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPSBjIDwgMCA/IGBjYWxjKCR7dX1weCArICgke3YgKiBNYXRoLmFicyhjKX0lKSlgIDogYyA+IDAgPyBgY2FsYygke3V9cHggKyAoLSR7diAqIE1hdGguYWJzKGMpfSUpKWAgOiBgJHt1fXB4YCwgIXQuaXNIb3Jpem9udGFsKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSB1LCB1ID0gZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB5ID0gYyA8IDAgPyBcIlwiICsgKDEgKyAoMSAtIGYpICogYykgOiBcIlwiICsgKDEgLSAoMSAtIGYpICogYyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEUgPSBgXFxuICAgICAgICB0cmFuc2xhdGUzZCgke3V9LCAke2h9LCAke219cHgpXFxuICAgICAgICByb3RhdGVaKCR7YS5yb3RhdGUgPyBnIDogMH1kZWcpXFxuICAgICAgICBzY2FsZSgke3l9KVxcbiAgICAgIGA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEuc2xpZGVTaGFkb3dzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlID0gby5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3dcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDAgPT09IGUubGVuZ3RoICYmIChlID0gaWUoYSwgbykpLCBlLmxlbmd0aCAmJiAoZVswXS5zdHlsZS5vcGFjaXR5ID0gTWF0aC5taW4oTWF0aC5tYXgoKE1hdGguYWJzKGMpIC0gLjUpIC8gLjUsIDApLCAxKSlcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgb1swXS5zdHlsZS56SW5kZXggPSAtTWF0aC5hYnMoTWF0aC5yb3VuZChkKSkgKyBlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBzZShhLCBvKS50cmFuc2Zvcm0oRSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbjogZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7dHJhbnNmb3JtRWw6IHN9ID0gdC5wYXJhbXMuY2FyZHNFZmZlY3Q7XHJcbiAgICAgICAgICAgICAgICAocyA/IHQuc2xpZGVzLmZpbmQocykgOiB0LnNsaWRlcykudHJhbnNpdGlvbihlKS5maW5kKFwiLnN3aXBlci1zbGlkZS1zaGFkb3dcIikudHJhbnNpdGlvbihlKSwgYWUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXBlcjogdCxcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogZSxcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1FbDogc1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcGVyc3BlY3RpdmU6ICgpID0+ICEwLFxyXG4gICAgICAgICAgICBvdmVyd3JpdGVQYXJhbXM6ICgpID0+ICh7d2F0Y2hTbGlkZXNQcm9ncmVzczogITAsIHZpcnR1YWxUcmFuc2xhdGU6ICF0LnBhcmFtcy5jc3NNb2RlfSlcclxuICAgICAgICB9KVxyXG4gICAgfV07XHJcbiAgICByZXR1cm4gVi51c2UocmUpLCBWXHJcbn0pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpcGVyLWJ1bmRsZS5taW4uanMubWFwIiwiLyohXG4gKiBiYWd1ZXR0ZUJveC5qc1xuICogQGF1dGhvciAgZmVpbW9zaVxuICogQHZlcnNpb24gMS4xMS4xXG4gKiBAdXJsIGh0dHBzOi8vZ2l0aHViLmNvbS9mZWltb3NpL2JhZ3VldHRlQm94LmpzXG4gKi9cbiFmdW5jdGlvbihlLHQpe1widXNlIHN0cmljdFwiO1wiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUodCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9dCgpOmUuYmFndWV0dGVCb3g9dCgpfSh0aGlzLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHIsbCx1LGMsZCxmPSc8c3ZnIHdpZHRoPVwiNDRcIiBoZWlnaHQ9XCI2MFwiPjxwb2x5bGluZSBwb2ludHM9XCIzMCAxMCAxMCAzMCAzMCA1MFwiIHN0cm9rZT1cInJnYmEoMjU1LDI1NSwyNTUsMC41KVwiIHN0cm9rZS13aWR0aD1cIjRcInN0cm9rZS1saW5lY2FwPVwiYnV0dFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIi8+PC9zdmc+JyxnPSc8c3ZnIHdpZHRoPVwiNDRcIiBoZWlnaHQ9XCI2MFwiPjxwb2x5bGluZSBwb2ludHM9XCIxNCAxMCAzNCAzMCAxNCA1MFwiIHN0cm9rZT1cInJnYmEoMjU1LDI1NSwyNTUsMC41KVwiIHN0cm9rZS13aWR0aD1cIjRcInN0cm9rZS1saW5lY2FwPVwiYnV0dFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIi8+PC9zdmc+JyxwPSc8c3ZnIHdpZHRoPVwiMzBcIiBoZWlnaHQ9XCIzMFwiPjxnIHN0cm9rZT1cInJnYigxNjAsMTYwLDE2MClcIiBzdHJva2Utd2lkdGg9XCI0XCI+PGxpbmUgeDE9XCI1XCIgeTE9XCI1XCIgeDI9XCIyNVwiIHkyPVwiMjVcIi8+PGxpbmUgeDE9XCI1XCIgeTE9XCIyNVwiIHgyPVwiMjVcIiB5Mj1cIjVcIi8+PC9nPjwvc3ZnPicsYj17fSx2PXtjYXB0aW9uczohMCxidXR0b25zOlwiYXV0b1wiLGZ1bGxTY3JlZW46ITEsbm9TY3JvbGxiYXJzOiExLGJvZHlDbGFzczpcImJhZ3VldHRlQm94LW9wZW5cIix0aXRsZVRhZzohMSxhc3luYzohMSxwcmVsb2FkOjIsYW5pbWF0aW9uOlwic2xpZGVJblwiLGFmdGVyU2hvdzpudWxsLGFmdGVySGlkZTpudWxsLG9uQ2hhbmdlOm51bGwsb3ZlcmxheUJhY2tncm91bmRDb2xvcjpcInJnYmEoMCwwLDAsLjgpXCJ9LG09e30saD1bXSxvPTAsbj0hMSxpPXt9LGE9ITEseT0vLitcXC4oZ2lmfGpwZT9nfHBuZ3x3ZWJwKS9pLHc9e30saz1bXSxzPW51bGwseD1mdW5jdGlvbihlKXstMSE9PWUudGFyZ2V0LmlkLmluZGV4T2YoXCJiYWd1ZXR0ZS1pbWdcIikmJmooKX0sRT1mdW5jdGlvbihlKXtlLnN0b3BQcm9wYWdhdGlvbj9lLnN0b3BQcm9wYWdhdGlvbigpOmUuY2FuY2VsQnViYmxlPSEwLEQoKX0sQz1mdW5jdGlvbihlKXtlLnN0b3BQcm9wYWdhdGlvbj9lLnN0b3BQcm9wYWdhdGlvbigpOmUuY2FuY2VsQnViYmxlPSEwLFgoKX0sQj1mdW5jdGlvbihlKXtlLnN0b3BQcm9wYWdhdGlvbj9lLnN0b3BQcm9wYWdhdGlvbigpOmUuY2FuY2VsQnViYmxlPSEwLGooKX0sVD1mdW5jdGlvbihlKXtpLmNvdW50KyssMTxpLmNvdW50JiYoaS5tdWx0aXRvdWNoPSEwKSxpLnN0YXJ0WD1lLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYLGkuc3RhcnRZPWUuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVl9LE49ZnVuY3Rpb24oZSl7aWYoIWEmJiFpLm11bHRpdG91Y2gpe2UucHJldmVudERlZmF1bHQ/ZS5wcmV2ZW50RGVmYXVsdCgpOmUucmV0dXJuVmFsdWU9ITE7dmFyIHQ9ZS50b3VjaGVzWzBdfHxlLmNoYW5nZWRUb3VjaGVzWzBdOzQwPHQucGFnZVgtaS5zdGFydFg/KGE9ITAsRCgpKTp0LnBhZ2VYLWkuc3RhcnRYPC00MD8oYT0hMCxYKCkpOjEwMDxpLnN0YXJ0WS10LnBhZ2VZJiZqKCl9fSxMPWZ1bmN0aW9uKCl7aS5jb3VudC0tLGkuY291bnQ8PTAmJihpLm11bHRpdG91Y2g9ITEpLGE9ITF9LEE9ZnVuY3Rpb24oKXtMKCl9LFA9ZnVuY3Rpb24oZSl7XCJibG9ja1wiPT09ci5zdHlsZS5kaXNwbGF5JiZyLmNvbnRhaW5zJiYhci5jb250YWlucyhlLnRhcmdldCkmJihlLnN0b3BQcm9wYWdhdGlvbigpLFkoKSl9O2Z1bmN0aW9uIFMoZSl7aWYody5oYXNPd25Qcm9wZXJ0eShlKSl7dmFyIHQ9d1tlXS5nYWxsZXJpZXM7W10uZm9yRWFjaC5jYWxsKHQsZnVuY3Rpb24oZSl7W10uZm9yRWFjaC5jYWxsKGUsZnVuY3Rpb24oZSl7VyhlLmltYWdlRWxlbWVudCxcImNsaWNrXCIsZS5ldmVudEhhbmRsZXIpfSksaD09PWUmJihoPVtdKX0pLGRlbGV0ZSB3W2VdfX1mdW5jdGlvbiBGKGUpe3N3aXRjaChlLmtleUNvZGUpe2Nhc2UgMzc6RCgpO2JyZWFrO2Nhc2UgMzk6WCgpO2JyZWFrO2Nhc2UgMjc6aigpO2JyZWFrO2Nhc2UgMzY6IWZ1bmN0aW9uIHQoZSl7ZSYmZS5wcmV2ZW50RGVmYXVsdCgpO3JldHVybiBNKDApfShlKTticmVhaztjYXNlIDM1OiFmdW5jdGlvbiBuKGUpe2UmJmUucHJldmVudERlZmF1bHQoKTtyZXR1cm4gTShoLmxlbmd0aC0xKX0oZSl9fWZ1bmN0aW9uIEgoZSx0KXtpZihoIT09ZSl7Zm9yKGg9ZSxmdW5jdGlvbiBzKGUpe2U9ZXx8e307Zm9yKHZhciB0IGluIHYpYlt0XT12W3RdLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBlW3RdJiYoYlt0XT1lW3RdKTtsLnN0eWxlLnRyYW5zaXRpb249bC5zdHlsZS53ZWJraXRUcmFuc2l0aW9uPVwiZmFkZUluXCI9PT1iLmFuaW1hdGlvbj9cIm9wYWNpdHkgLjRzIGVhc2VcIjpcInNsaWRlSW5cIj09PWIuYW5pbWF0aW9uP1wiXCI6XCJub25lXCIsXCJhdXRvXCI9PT1iLmJ1dHRvbnMmJihcIm9udG91Y2hzdGFydFwiaW4gd2luZG93fHwxPT09aC5sZW5ndGgpJiYoYi5idXR0b25zPSExKTt1LnN0eWxlLmRpc3BsYXk9Yy5zdHlsZS5kaXNwbGF5PWIuYnV0dG9ucz9cIlwiOlwibm9uZVwiO3RyeXtyLnN0eWxlLmJhY2tncm91bmRDb2xvcj1iLm92ZXJsYXlCYWNrZ3JvdW5kQ29sb3J9Y2F0Y2gobil7fX0odCk7bC5maXJzdENoaWxkOylsLnJlbW92ZUNoaWxkKGwuZmlyc3RDaGlsZCk7Zm9yKHZhciBuLG89W10saT1bXSxhPWsubGVuZ3RoPTA7YTxlLmxlbmd0aDthKyspKG49SihcImRpdlwiKSkuY2xhc3NOYW1lPVwiZnVsbC1pbWFnZVwiLG4uaWQ9XCJiYWd1ZXR0ZS1pbWctXCIrYSxrLnB1c2gobiksby5wdXNoKFwiYmFndWV0dGVCb3gtZmlndXJlLVwiK2EpLGkucHVzaChcImJhZ3VldHRlQm94LWZpZ2NhcHRpb24tXCIrYSksbC5hcHBlbmRDaGlsZChrW2FdKTtyLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiLG8uam9pbihcIiBcIikpLHIuc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLGkuam9pbihcIiBcIikpfX1mdW5jdGlvbiBJKGUpe2Iubm9TY3JvbGxiYXJzJiYoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLm92ZXJmbG93WT1cImhpZGRlblwiLGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3dZPVwic2Nyb2xsXCIpLFwiYmxvY2tcIiE9PXIuc3R5bGUuZGlzcGxheSYmKFUoZG9jdW1lbnQsXCJrZXlkb3duXCIsRiksaT17Y291bnQ6MCxzdGFydFg6bnVsbCxzdGFydFk6bnVsbH0scShvPWUsZnVuY3Rpb24oKXt6KG8pLFYobyl9KSxSKCksci5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIixiLmZ1bGxTY3JlZW4mJmZ1bmN0aW9uIHQoKXtyLnJlcXVlc3RGdWxsc2NyZWVuP3IucmVxdWVzdEZ1bGxzY3JlZW4oKTpyLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuP3Iud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oKTpyLm1velJlcXVlc3RGdWxsU2NyZWVuJiZyLm1velJlcXVlc3RGdWxsU2NyZWVuKCl9KCksc2V0VGltZW91dChmdW5jdGlvbigpe3IuY2xhc3NOYW1lPVwidmlzaWJsZVwiLGIuYm9keUNsYXNzJiZkb2N1bWVudC5ib2R5LmNsYXNzTGlzdCYmZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKGIuYm9keUNsYXNzKSxiLmFmdGVyU2hvdyYmYi5hZnRlclNob3coKX0sNTApLGIub25DaGFuZ2UmJmIub25DaGFuZ2UobyxrLmxlbmd0aCkscz1kb2N1bWVudC5hY3RpdmVFbGVtZW50LFkoKSxuPSEwKX1mdW5jdGlvbiBZKCl7Yi5idXR0b25zP3UuZm9jdXMoKTpkLmZvY3VzKCl9ZnVuY3Rpb24gaigpe2Iubm9TY3JvbGxiYXJzJiYoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLm92ZXJmbG93WT1cImF1dG9cIixkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93WT1cImF1dG9cIiksXCJub25lXCIhPT1yLnN0eWxlLmRpc3BsYXkmJihXKGRvY3VtZW50LFwia2V5ZG93blwiLEYpLHIuY2xhc3NOYW1lPVwiXCIsc2V0VGltZW91dChmdW5jdGlvbigpe3Iuc3R5bGUuZGlzcGxheT1cIm5vbmVcIixkb2N1bWVudC5mdWxsc2NyZWVuJiZmdW5jdGlvbiBlKCl7ZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4/ZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKTpkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuP2RvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4oKTpkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbiYmZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4oKX0oKSxiLmJvZHlDbGFzcyYmZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QmJmRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShiLmJvZHlDbGFzcyksYi5hZnRlckhpZGUmJmIuYWZ0ZXJIaWRlKCkscyYmcy5mb2N1cygpLG49ITF9LDUwMCkpfWZ1bmN0aW9uIHEodCxuKXt2YXIgZT1rW3RdLG89aFt0XTtpZih2b2lkIDAhPT1lJiZ2b2lkIDAhPT1vKWlmKGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbWdcIilbMF0pbiYmbigpO2Vsc2V7dmFyIGk9by5pbWFnZUVsZW1lbnQsYT1pLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW1nXCIpWzBdLHM9XCJmdW5jdGlvblwiPT10eXBlb2YgYi5jYXB0aW9ucz9iLmNhcHRpb25zLmNhbGwoaCxpKTppLmdldEF0dHJpYnV0ZShcImRhdGEtY2FwdGlvblwiKXx8aS50aXRsZSxyPWZ1bmN0aW9uIGQoZSl7dmFyIHQ9ZS5ocmVmO2lmKGUuZGF0YXNldCl7dmFyIG49W107Zm9yKHZhciBvIGluIGUuZGF0YXNldClcImF0LVwiIT09by5zdWJzdHJpbmcoMCwzKXx8aXNOYU4oby5zdWJzdHJpbmcoMykpfHwobltvLnJlcGxhY2UoXCJhdC1cIixcIlwiKV09ZS5kYXRhc2V0W29dKTtmb3IodmFyIGk9T2JqZWN0LmtleXMobikuc29ydChmdW5jdGlvbihlLHQpe3JldHVybiBwYXJzZUludChlLDEwKTxwYXJzZUludCh0LDEwKT8tMToxfSksYT13aW5kb3cuaW5uZXJXaWR0aCp3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyxzPTA7czxpLmxlbmd0aC0xJiZpW3NdPGE7KXMrKzt0PW5baVtzXV18fHR9cmV0dXJuIHR9KGkpLGw9SihcImZpZ3VyZVwiKTtpZihsLmlkPVwiYmFndWV0dGVCb3gtZmlndXJlLVwiK3QsbC5pbm5lckhUTUw9JzxkaXYgY2xhc3M9XCJiYWd1ZXR0ZUJveC1zcGlubmVyXCI+PGRpdiBjbGFzcz1cImJhZ3VldHRlQm94LWRvdWJsZS1ib3VuY2UxXCI+PC9kaXY+PGRpdiBjbGFzcz1cImJhZ3VldHRlQm94LWRvdWJsZS1ib3VuY2UyXCI+PC9kaXY+PC9kaXY+JyxiLmNhcHRpb25zJiZzKXt2YXIgdT1KKFwiZmlnY2FwdGlvblwiKTt1LmlkPVwiYmFndWV0dGVCb3gtZmlnY2FwdGlvbi1cIit0LHUuaW5uZXJIVE1MPXMsbC5hcHBlbmRDaGlsZCh1KX1lLmFwcGVuZENoaWxkKGwpO3ZhciBjPUooXCJpbWdcIik7Yy5vbmxvYWQ9ZnVuY3Rpb24oKXt2YXIgZT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2JhZ3VldHRlLWltZy1cIit0K1wiIC5iYWd1ZXR0ZUJveC1zcGlubmVyXCIpO2wucmVtb3ZlQ2hpbGQoZSksIWIuYXN5bmMmJm4mJm4oKX0sYy5zZXRBdHRyaWJ1dGUoXCJzcmNcIixyKSxjLmFsdD1hJiZhLmFsdHx8XCJcIixiLnRpdGxlVGFnJiZzJiYoYy50aXRsZT1zKSxsLmFwcGVuZENoaWxkKGMpLGIuYXN5bmMmJm4mJm4oKX19ZnVuY3Rpb24gWCgpe3JldHVybiBNKG8rMSl9ZnVuY3Rpb24gRCgpe3JldHVybiBNKG8tMSl9ZnVuY3Rpb24gTShlLHQpe3JldHVybiFuJiYwPD1lJiZlPHQubGVuZ3RoPyhIKHQsYiksSShlKSwhMCk6ZTwwPyhiLmFuaW1hdGlvbiYmTyhcImxlZnRcIiksITEpOmU+PWsubGVuZ3RoPyhiLmFuaW1hdGlvbiYmTyhcInJpZ2h0XCIpLCExKToocShvPWUsZnVuY3Rpb24oKXt6KG8pLFYobyl9KSxSKCksYi5vbkNoYW5nZSYmYi5vbkNoYW5nZShvLGsubGVuZ3RoKSwhMCl9ZnVuY3Rpb24gTyhlKXtsLmNsYXNzTmFtZT1cImJvdW5jZS1mcm9tLVwiK2Usc2V0VGltZW91dChmdW5jdGlvbigpe2wuY2xhc3NOYW1lPVwiXCJ9LDQwMCl9ZnVuY3Rpb24gUigpe3ZhciBlPTEwMCotbytcIiVcIjtcImZhZGVJblwiPT09Yi5hbmltYXRpb24/KGwuc3R5bGUub3BhY2l0eT0wLHNldFRpbWVvdXQoZnVuY3Rpb24oKXttLnRyYW5zZm9ybXM/bC5zdHlsZS50cmFuc2Zvcm09bC5zdHlsZS53ZWJraXRUcmFuc2Zvcm09XCJ0cmFuc2xhdGUzZChcIitlK1wiLDAsMClcIjpsLnN0eWxlLmxlZnQ9ZSxsLnN0eWxlLm9wYWNpdHk9MX0sNDAwKSk6bS50cmFuc2Zvcm1zP2wuc3R5bGUudHJhbnNmb3JtPWwuc3R5bGUud2Via2l0VHJhbnNmb3JtPVwidHJhbnNsYXRlM2QoXCIrZStcIiwwLDApXCI6bC5zdHlsZS5sZWZ0PWV9ZnVuY3Rpb24geihlKXtlLW8+PWIucHJlbG9hZHx8cShlKzEsZnVuY3Rpb24oKXt6KGUrMSl9KX1mdW5jdGlvbiBWKGUpe28tZT49Yi5wcmVsb2FkfHxxKGUtMSxmdW5jdGlvbigpe1YoZS0xKX0pfWZ1bmN0aW9uIFUoZSx0LG4sbyl7ZS5hZGRFdmVudExpc3RlbmVyP2UuYWRkRXZlbnRMaXN0ZW5lcih0LG4sbyk6ZS5hdHRhY2hFdmVudChcIm9uXCIrdCxmdW5jdGlvbihlKXsoZT1lfHx3aW5kb3cuZXZlbnQpLnRhcmdldD1lLnRhcmdldHx8ZS5zcmNFbGVtZW50LG4oZSl9KX1mdW5jdGlvbiBXKGUsdCxuLG8pe2UucmVtb3ZlRXZlbnRMaXN0ZW5lcj9lLnJlbW92ZUV2ZW50TGlzdGVuZXIodCxuLG8pOmUuZGV0YWNoRXZlbnQoXCJvblwiK3Qsbil9ZnVuY3Rpb24gRyhlKXtyZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZSl9ZnVuY3Rpb24gSihlKXtyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlKX1yZXR1cm5bXS5mb3JFYWNofHwoQXJyYXkucHJvdG90eXBlLmZvckVhY2g9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49MDtuPHRoaXMubGVuZ3RoO24rKyllLmNhbGwodCx0aGlzW25dLG4sdGhpcyl9KSxbXS5maWx0ZXJ8fChBcnJheS5wcm90b3R5cGUuZmlsdGVyPWZ1bmN0aW9uKGUsdCxuLG8saSl7Zm9yKG49dGhpcyxvPVtdLGk9MDtpPG4ubGVuZ3RoO2krKyllLmNhbGwodCxuW2ldLGksbikmJm8ucHVzaChuW2ldKTtyZXR1cm4gb30pLHtydW46ZnVuY3Rpb24gSyhlLHQpe3JldHVybiBtLnRyYW5zZm9ybXM9ZnVuY3Rpb24gbigpe3ZhciBlPUooXCJkaXZcIik7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGUuc3R5bGUucGVyc3BlY3RpdmV8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBlLnN0eWxlLndlYmtpdFBlcnNwZWN0aXZlfSgpLG0uc3ZnPWZ1bmN0aW9uIG8oKXt2YXIgZT1KKFwiZGl2XCIpO3JldHVybiBlLmlubmVySFRNTD1cIjxzdmcvPlwiLFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj09PShlLmZpcnN0Q2hpbGQmJmUuZmlyc3RDaGlsZC5uYW1lc3BhY2VVUkkpfSgpLG0ucGFzc2l2ZUV2ZW50cz1mdW5jdGlvbiBpKCl7dmFyIGU9ITE7dHJ5e3ZhciB0PU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSxcInBhc3NpdmVcIix7Z2V0OmZ1bmN0aW9uKCl7ZT0hMH19KTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRlc3RcIixudWxsLHQpfWNhdGNoKG4pe31yZXR1cm4gZX0oKSxmdW5jdGlvbiBhKCl7aWYocj1HKFwiYmFndWV0dGVCb3gtb3ZlcmxheVwiKSlyZXR1cm4gbD1HKFwiYmFndWV0dGVCb3gtc2xpZGVyXCIpLHU9RyhcInByZXZpb3VzLWJ1dHRvblwiKSxjPUcoXCJuZXh0LWJ1dHRvblwiKSx2b2lkKGQ9RyhcImNsb3NlLWJ1dHRvblwiKSk7KHI9SihcImRpdlwiKSkuc2V0QXR0cmlidXRlKFwicm9sZVwiLFwiZGlhbG9nXCIpLHIuaWQ9XCJiYWd1ZXR0ZUJveC1vdmVybGF5XCIsZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdLmFwcGVuZENoaWxkKHIpLChsPUooXCJkaXZcIikpLmlkPVwiYmFndWV0dGVCb3gtc2xpZGVyXCIsci5hcHBlbmRDaGlsZChsKSwodT1KKFwiYnV0dG9uXCIpKS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJidXR0b25cIiksdS5pZD1cInByZXZpb3VzLWJ1dHRvblwiLHUuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLFwiUHJldmlvdXNcIiksdS5pbm5lckhUTUw9bS5zdmc/ZjpcIiZsdDtcIixyLmFwcGVuZENoaWxkKHUpLChjPUooXCJidXR0b25cIikpLnNldEF0dHJpYnV0ZShcInR5cGVcIixcImJ1dHRvblwiKSxjLmlkPVwibmV4dC1idXR0b25cIixjLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIixcIk5leHRcIiksYy5pbm5lckhUTUw9bS5zdmc/ZzpcIiZndDtcIixyLmFwcGVuZENoaWxkKGMpLChkPUooXCJidXR0b25cIikpLnNldEF0dHJpYnV0ZShcInR5cGVcIixcImJ1dHRvblwiKSxkLmlkPVwiY2xvc2UtYnV0dG9uXCIsZC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsXCJDbG9zZVwiKSxkLmlubmVySFRNTD1tLnN2Zz9wOlwiJnRpbWVzO1wiLHIuYXBwZW5kQ2hpbGQoZCksdS5jbGFzc05hbWU9Yy5jbGFzc05hbWU9ZC5jbGFzc05hbWU9XCJiYWd1ZXR0ZUJveC1idXR0b25cIixmdW5jdGlvbiBuKCl7dmFyIGU9bS5wYXNzaXZlRXZlbnRzP3twYXNzaXZlOiExfTpudWxsLHQ9bS5wYXNzaXZlRXZlbnRzP3twYXNzaXZlOiEwfTpudWxsO1UocixcImNsaWNrXCIseCksVSh1LFwiY2xpY2tcIixFKSxVKGMsXCJjbGlja1wiLEMpLFUoZCxcImNsaWNrXCIsQiksVShsLFwiY29udGV4dG1lbnVcIixBKSxVKHIsXCJ0b3VjaHN0YXJ0XCIsVCx0KSxVKHIsXCJ0b3VjaG1vdmVcIixOLGUpLFUocixcInRvdWNoZW5kXCIsTCksVShkb2N1bWVudCxcImZvY3VzXCIsUCwhMCl9KCl9KCksUyhlKSxmdW5jdGlvbiBzKGUsYSl7dmFyIHQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlKSxuPXtnYWxsZXJpZXM6W10sbm9kZUxpc3Q6dH07cmV0dXJuIHdbZV09bixbXS5mb3JFYWNoLmNhbGwodCxmdW5jdGlvbihlKXthJiZhLmZpbHRlciYmKHk9YS5maWx0ZXIpO3ZhciB0PVtdO2lmKHQ9XCJBXCI9PT1lLnRhZ05hbWU/W2VdOmUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJhXCIpLDAhPT0odD1bXS5maWx0ZXIuY2FsbCh0LGZ1bmN0aW9uKGUpe2lmKC0xPT09ZS5jbGFzc05hbWUuaW5kZXhPZihhJiZhLmlnbm9yZUNsYXNzKSlyZXR1cm4geS50ZXN0KGUuaHJlZil9KSkubGVuZ3RoKXt2YXIgaT1bXTtbXS5mb3JFYWNoLmNhbGwodCxmdW5jdGlvbihlLHQpe3ZhciBuPWZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQ/ZS5wcmV2ZW50RGVmYXVsdCgpOmUucmV0dXJuVmFsdWU9ITEsSChpLGEpLEkodCl9LG89e2V2ZW50SGFuZGxlcjpuLGltYWdlRWxlbWVudDplfTtVKGUsXCJjbGlja1wiLG4pLGkucHVzaChvKX0pLG4uZ2FsbGVyaWVzLnB1c2goaSl9fSksbi5nYWxsZXJpZXN9KGUsdCl9LHNob3c6TSxzaG93TmV4dDpYLHNob3dQcmV2aW91czpELGhpZGU6aixkZXN0cm95OmZ1bmN0aW9uIGUoKXshZnVuY3Rpb24gbigpe3ZhciBlPW0ucGFzc2l2ZUV2ZW50cz97cGFzc2l2ZTohMX06bnVsbCx0PW0ucGFzc2l2ZUV2ZW50cz97cGFzc2l2ZTohMH06bnVsbDtXKHIsXCJjbGlja1wiLHgpLFcodSxcImNsaWNrXCIsRSksVyhjLFwiY2xpY2tcIixDKSxXKGQsXCJjbGlja1wiLEIpLFcobCxcImNvbnRleHRtZW51XCIsQSksVyhyLFwidG91Y2hzdGFydFwiLFQsdCksVyhyLFwidG91Y2htb3ZlXCIsTixlKSxXKHIsXCJ0b3VjaGVuZFwiLEwpLFcoZG9jdW1lbnQsXCJmb2N1c1wiLFAsITApfSgpLGZ1bmN0aW9uIHQoKXtmb3IodmFyIGUgaW4gdyl3Lmhhc093blByb3BlcnR5KGUpJiZTKGUpfSgpLFcoZG9jdW1lbnQsXCJrZXlkb3duXCIsRiksZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdLnJlbW92ZUNoaWxkKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYmFndWV0dGVCb3gtb3ZlcmxheVwiKSksdz17fSxoPVtdLG89MH19fSk7Il19
